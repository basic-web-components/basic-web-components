{"version":3,"sources":["node_modules/browser-pack/_prelude.js","packages/basic-component-mixins/src/AttributeMarshallingMixin.js","packages/basic-component-mixins/src/ComposableMixin.js","packages/basic-component-mixins/src/DistributedChildrenMixin.js","packages/basic-component-mixins/src/ShadowElementReferencesMixin.js","packages/basic-component-mixins/src/ShadowTemplateMixin.js","packages/basic-component-mixins/src/createSymbol.js","packages/basic-component-mixins/src/safeAttributes.js","packages/basic-component-mixins/src/symbols.js","packages/basic-component-mixins/src/toggleClass.js","packages/basic-element-base/src/ElementBase.js","packages/basic-wrapped-standard-element/globals.js","packages/basic-wrapped-standard-element/src/WrappedStandardElement.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","attributeToPropertyName","attributeName","propertyName","attributeToPropertyNames","hypenRegEx","replace","match","toUpperCase","attributesForClass","classFn","HTMLElement","Object","baseClass","getPrototypeOf","prototype","constructor","baseAttributes","propertyNames","getOwnPropertyNames","setterNames","filter","getOwnPropertyDescriptor","set","attributes","map","setterName","propertyNameToAttribute","diff","attribute","indexOf","concat","propertyNamesToAttributes","uppercaseRegEx","toLowerCase","_safeAttributes","base","AttributeMarshalling","_base","_classCallCheck","this","_possibleConstructorReturn","__proto__","apply","arguments","_inherits","_createClass","key","value","oldValue","newValue","_get","_safeAttributes2","default","connected","setAttribute","className","toggleClass","get","composeClass","mixin","Subclass","_base2","copyOwnProperties","NON_MIXABLE_OBJECT_PROPERTIES","source","target","ignorePropertyNames","undefined","forEach","name","descriptor","defineProperty","Composable","_len","mixins","Array","_key","reduce","expandContentElements","nodes","includeTextNodes","_ref","expanded","node","isSlot","HTMLSlotElement","localName","assignedNodes","flatten","Text","flattened","_toConsumableArray","DistributedChildren","children","childNodes","strings","distributedChildNodes","child","textContent","join","ShadowElementReferences","_this","shadowRoot","$","nodesWithIds","querySelectorAll","id","getAttribute","createTemplateWithInnerHTML","innerHTML","template","document","createElement","div","content","appendChild","shimTemplateStyles","tag","window","WebComponents","ShadowCSS","shimStyling","_symbols","ShadowTemplate","_symbols2","ShadowDOMPolyfill","root","attachShadow","mode","clone","importNode","createSymbol","description","Symbol","setAttributeToElement","element","removeAttribute","text","String","_createSymbol","_toggleClass2","safeToSetAttributesSymbol","_createSymbol2","pendingAttributesSymbol","pendingClassesSymbol","_value","_toggleClass3","symbols","defaults","dragging","goDown","goEnd","goLeft","goRight","goStart","goUp","itemAdded","itemsChanged","itemSelected","keydown","force","classList","addClass","contains","add","remove","_AttributeMarshallingMixin","_ComposableMixin","_DistributedChildrenMixin","_ShadowElementReferencesMixin","_ShadowTemplateMixin","ElementBase","_ComposableMixin2","compose","_ShadowTemplateMixin2","_ShadowElementReferencesMixin2","_AttributeMarshallingMixin2","_DistributedChildrenMixin2","_WrappedStandardElement","Basic","WrappedStandardElement","_WrappedStandardElement2","createPropertyDelegate","delegate","configurable","enumerable","inner","writable","_ElementBase2","reraiseEvents","address","blockquote","caption","center","dd","dir","dl","dt","fieldset","form","frame","h1","h2","h3","h4","h5","h6","iframe","img","input","keygen","li","link","menu","object","ol","p","script","select","tbody","tfoot","thead","textarea","eventBubbles","abort","change","reset","blockElements","eventNames","extends","eventName","addEventListener","realEvent","event","Event","bubbles","dispatchEvent","label","display","extendsTag","Wrapped","_WrappedStandardEleme","extendsPrototype","names"],"mappings":"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","file":"basic-wrapped-standard-element.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import safeAttributes from './safeAttributes';\n\n\n// Memoized maps of attribute to property names and vice versa.\nconst attributeToPropertyNames = {};\nconst propertyNamesToAttributes = {};\n\n\n/* Exported function extends a base class with AttributeMarshalling. */\nexport default (base) => {\n\n  /**\n   * Mixin which marshalls attributes to properties and vice versa.\n   *\n   * If your component exposes a setter for a property, it's generally a good\n   * idea to let devs using your component be able to set that property in HTML\n   * via an element attribute. You can code that yourself by writing an\n   * `attributeChangedCallback`, or you can use this mixin to get a degree of\n   * automatic support.\n   *\n   * This mixin implements an `attributeChangedCallback` that will attempt to\n   * convert a change in an element attribute into a call to the corresponding\n   * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n   * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n   * respects that convention, automatically mapping the hyphenated attribute\n   * name to the corresponding camelCase property name.\n   *\n   * Example: You define a component using this mixin:\n   *\n   *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n   *       get fooBar() { return this._fooBar; }\n   *       set fooBar(value) { this._fooBar = value; }\n   *     }\n   *     customElements.define('my-element', MyElement);\n   *\n   * If someone then instantiates your component in HTML:\n   *\n   *     <my-element foo-bar=\"Hello\"></my-element>\n   *\n   * Then, after the element has been upgraded, the `fooBar` setter will\n   * automatically be invoked with the initial value \"Hello\".\n   *\n   * For the time being, this mixin only supports string-valued properties.\n   * If you'd like to convert string attributes to other types (numbers,\n   * booleans), you need to implement `attributeChangedCallback` yourself.\n   */\n  class AttributeMarshalling extends base {\n\n    /*\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n      const propertyName = attributeToPropertyName(attributeName);\n      // If the attribute name corresponds to a property name, set the property.\n      // Ignore standard HTMLElement properties handled by the DOM.\n      if (propertyName in this && !(propertyName in HTMLElement.prototype)) {\n        this[propertyName] = newValue;\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    static get observedAttributes() {\n      return attributesForClass(this);\n    }\n\n    /**\n     * Set/unset the attribute with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as an attribute. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes. A call to `reflectAttribute` during the constructor will\n     * be deferred until the element is connected to the document.\n     *\n     * @param {string} attribute - The name of the *attribute* (not property) to set.\n     * @param {object} value - The value to set. If null, the attribute will be removed.\n     */\n    reflectAttribute(attribute, value) {\n      return safeAttributes.setAttribute(this, attribute, value);\n    }\n\n    /**\n     * Set/unset the class with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as as class. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes, including the `class` attribute. A call to\n     * `reflectClass` during the constructor will be deferred until the element\n     * is connected to the document.\n     *\n     * @param {string} className - The name of the class to set.\n     * @param {object} value - True to set the class, false to remove it.\n     */\n    reflectClass(className, value) {\n      return safeAttributes.toggleClass(this, className, value);\n    }\n\n  }\n\n  return AttributeMarshalling;\n};\n\n\n// Convert hyphenated foo-bar attribute name to camel case fooBar property name.\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hypenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hypenRegEx,\n        match => match[1].toUpperCase());\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\nfunction attributesForClass(classFn) {\n\n  // We treat the element base classes as if they have no attributes, since we\n  // don't want to receive attributeChangedCallback for them.\n  if (classFn === HTMLElement || classFn === Object) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n  const baseAttributes = attributesForClass(baseClass);\n\n  // Get attributes for this class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter(propertyName =>\n    typeof Object.getOwnPropertyDescriptor(\n        classFn.prototype, propertyName).set === 'function');\n  const attributes = setterNames.map(setterName =>\n      propertyNameToAttribute(setterName));\n\n  // Merge.\n  const diff = attributes.filter(attribute =>\n      baseAttributes.indexOf(attribute) < 0);\n  return baseAttributes.concat(diff);\n}\n\n// Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, '-$1').toLowerCase();\n  }\n  return attribute;\n}\n","/* Exported function extends a base class with Composable. */\nexport default (base) => {\n\n  /**\n   * Mixin to make a class more easily composable with other mixins.\n   *\n   * This mixin contributes a `compose` method that applies a set of mixin\n   * functions and returns the resulting new class. This sugar can make the\n   * application of many mixins at once easier to read.\n   */\n  class Composable extends base {\n\n    /**\n     * Apply a set of mixin functions or mixin objects to the present class and\n     * return the new class.\n     *\n     * Instead of writing:\n     *\n     *     let MyClass = Mixin1(Mixin2(Mixin3(Mixin4(Mixin5(BaseClass)))));\n     *\n     * You can write:\n     *\n     *     let MyClass = ComposableMixin(BaseClass).compose(\n     *       Mixin1,\n     *       Mixin2,\n     *       Mixin3,\n     *       Mixin4,\n     *       Mixin5\n     *     );\n     *\n     * This function can also take mixin objects. A mixin object is just a\n     * shorthand for a mixin function that creates a new subclass with the given\n     * members. The mixin object's members are *not* copied directly onto the\n     * prototype of the base class, as with traditional mixins.\n     *\n     * In addition to providing syntactic sugar, this mixin can be used to\n     * define a class in ES5, which lacks ES6's `class` keyword.\n     *\n     * @param {...mixins} mixins - A set of mixin functions or objects to apply.\n     */\n    static compose(...mixins) {\n      // We create a new subclass for each mixin in turn. The result becomes\n      // the base class extended by any subsequent mixins. It turns out that\n      // we can use Array.reduce() to concisely express this, using the current\n      // object as the seed for reduce().\n      return mixins.reduce(composeClass, this);\n    }\n\n  }\n\n  return Composable;\n};\n\n\n// Properties defined by Object that we don't want to mixin.\nconst NON_MIXABLE_OBJECT_PROPERTIES = [\n  'constructor'\n];\n\n/*\n * Apply the mixin to the given base class to return a new class.\n * The mixin can either be a function that returns the modified class, or a\n * plain object whose members will be copied to the new class' prototype.\n */\nfunction composeClass(base, mixin) {\n  if (typeof mixin === 'function') {\n    // Mixin function\n    return mixin(base);\n  } else {\n    // Mixin object\n    class Subclass extends base {}\n    copyOwnProperties(mixin, Subclass.prototype, NON_MIXABLE_OBJECT_PROPERTIES);\n    return Subclass;\n  }\n}\n\n\n/*\n * Copy the given properties/methods to the target.\n * Return the updated target.\n */\nfunction copyOwnProperties(source, target, ignorePropertyNames = []) {\n  Object.getOwnPropertyNames(source).forEach(name => {\n    if (ignorePropertyNames.indexOf(name) < 0) {\n      const descriptor = Object.getOwnPropertyDescriptor(source, name);\n      Object.defineProperty(target, name, descriptor);\n    }\n  });\n  return target;\n}\n","/* Exported function extends a base class with DistributedChildren. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines helpers for accessing a component's distributed\n   * children as a flattened array or string.\n   *\n   * The standard DOM API provides several ways of accessing child content:\n   * `children`, `childNodes`, and `textContent`. None of these functions are\n   * Shadow DOM aware. This mixin defines variations of those functions that\n   * *are* Shadow DOM aware.\n   *\n   * Example: you create a component `<count-children>` that displays a number\n   * equal to the number of children placed inside that component. If someone\n   * instantiates your component like:\n   *\n   *     <count-children>\n   *       <div></div>\n   *       <div></div>\n   *       <div></div>\n   *     </count-children>\n   *\n   * Then the component should show \"3\", because there are three children. To\n   * calculate the number of children, the component can just calculate\n   * `this.children.length`. However, suppose someone instantiates your\n   * component inside one of their own components, and puts a `<slot>` element\n   * inside your component:\n   *\n   *     <count-children>\n   *       <slot></slot>\n   *     </count-children>\n   *\n   * If your component only looks at `this.children`, it will always see exactly\n   * one child — the `<slot>` element. But the user looking at the page will\n   * *see* any nodes distributed to that slot. To match what the user sees, your\n   * component should expand any `<slot>` elements it contains.\n   *\n   * That is the problem this mixin solves. After applying this mixin, your\n   * component code has access to `this.distributedChildren`, whose `length`\n   * will return the total number of all children distributed to your component\n   * in the composed tree.\n   *\n   * Note: The latest Custom Elements API design calls for a new function,\n   * `getAssignedNodes` that takes an optional `deep` parameter, that will solve\n   * this problem at the API level.\n   */\n  class DistributedChildren extends base {\n\n    /**\n     * An in-order collection of distributed children, expanding any slot\n     * elements. Like the standard children property, this skips text nodes.\n     *\n     * @type {HTMLElement[]}\n     */\n    get distributedChildren() {\n      return expandContentElements(this.children, false);\n    }\n\n    /**\n     * An in-order collection of distributed child nodes, expanding any slot\n     * elements. Like the standard childNodes property, this includes text\n     * nodes.\n     *\n     * @type {Node[]}\n     */\n    get distributedChildNodes() {\n      return expandContentElements(this.childNodes, true);\n    }\n\n    /**\n     * The concatenated text content of all distributed child nodes, expanding\n     * any slot elements.\n     *\n     * @type {string}\n     */\n    get distributedTextContent() {\n      const strings = this.distributedChildNodes.map(function(child) {\n        return child.textContent;\n      });\n      return strings.join('');\n    }\n\n  }\n\n  return DistributedChildren;\n};\n\n\n/*\n * Given a array of nodes, return a new array with any content elements expanded\n * to the nodes distributed to that content element. This rule is applied\n * recursively.\n *\n * If includeTextNodes is true, text nodes will be included, as in the\n * standard childNodes property; by default, this skips text nodes, like the\n * standard children property.\n */\nfunction expandContentElements(nodes, includeTextNodes) {\n  const expanded = Array.prototype.map.call(nodes, node => {\n    // We want to see if the node is an instanceof HTMLSlotELement, but\n    // that class won't exist if the browser that doesn't support native\n    // Shadow DOM and if the Shadow DOM polyfill hasn't been loaded. Instead,\n    // we do a simplistic check to see if the tag name is \"slot\".\n    const isSlot = typeof HTMLSlotElement !== 'undefined' ?\n      node instanceof HTMLSlotElement :\n      node.localName === 'slot';\n    if (isSlot) {\n      // Use the nodes assigned to this node instead.\n      const assignedNodes = node.assignedNodes({ flatten: true });\n      return assignedNodes ?\n        expandContentElements(assignedNodes, includeTextNodes) :\n        [];\n    } else if (node instanceof HTMLElement) {\n      // Plain element; use as is.\n      return [node];\n    } else if (node instanceof Text && includeTextNodes) {\n      // Text node.\n      return [node];\n    } else {\n      // Comment, processing instruction, etc.; skip.\n      return [];\n    }\n  });\n  const flattened = [].concat(...expanded);\n  return flattened;\n}\n","/* Exported function extends a base class with ShadowElementReferences. */\nexport default (base) => {\n\n  /**\n   * Mixin to create references to elements in a component's Shadow DOM subtree.\n   *\n   * This adds a member on the component called `this.$` that can be used to\n   * reference shadow elements with IDs. E.g., if component's shadow contains an\n   * element `<button id=\"foo\">`, then this mixin will create a member\n   * `this.$.foo` that points to that button.\n   *\n   * Such references simplify a component's access to its own elements. In\n   * exchange, this mixin trades off a one-time cost of querying all elements in\n   * the shadow tree instead of paying an ongoing cost to query for an element\n   * each time the component wants to inspect or manipulate it.\n   *\n   * This mixin expects the component to define a Shadow DOM subtree. You can\n   * create that tree yourself, or make use of\n   * [ShadowTemplateMixin](ShadowTemplateMixin.md).\n   *\n   * This mixin is inspired by Polymer's [automatic\n   * node finding](https://www.polymer-project.org/1.0/docs/devguide/local-dom.html#node-finding)\n   * feature.\n   */\n  class ShadowElementReferences extends base {\n\n    constructor() {\n      super();\n      if (this.shadowRoot) {\n        // Look for elements in the shadow subtree that have id attributes.\n        // An alternatively implementation of this mixin would be to just define\n        // a this.$ getter that lazily does this search the first time someone\n        // tries to access this.$. That might introduce some complexity – if the\n        // the tree changed after it was first populated, the result of\n        // searching for a node might be somewhat unpredictable.\n        this.$ = {};\n        const nodesWithIds = this.shadowRoot.querySelectorAll('[id]');\n        [].forEach.call(nodesWithIds, node => {\n          const id = node.getAttribute('id');\n          this.$[id] = node;\n        });\n      }\n    }\n\n    /**\n     * The collection of references to the elements with IDs in a component's\n     * Shadow DOM subtree.\n     *\n     * @type {object}\n     * @member $\n     */\n  }\n\n  return ShadowElementReferences;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with ShadowTemplate. */\nexport default (base) => {\n\n  /**\n   * Mixin for stamping a template into a Shadow DOM subtree upon component\n   * instantiation.\n   *\n   * To use this mixin, define a `template` property as a string or HTML\n   * `<template>` element:\n   *\n   *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n   *       get [symbols.template]() {\n   *         return `Hello, <em>world</em>.`;\n   *       }\n   *     }\n   *\n   * When your component class is instantiated, a shadow root will be created on\n   * the instance, and the contents of the template will be cloned into the\n   * shadow root. If your component does not define a `template` property, this\n   * mixin has no effect.\n   *\n   * For the time being, this extension retains support for Shadow DOM v0. That\n   * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n   * implement Shadow DOM v1.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n      let template = this[symbols.template];\n      // TODO: Save the processed template with the component's class prototype\n      // so it doesn't need to be processed with every instantiation.\n      if (template) {\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          template = createTemplateWithInnerHTML(template);\n        }\n\n        if (window.ShadowDOMPolyfill) {\n          shimTemplateStyles(template, this.localName);\n        }\n\n        const root = this.attachShadow({ mode: 'open' });\n        const clone = document.importNode(template.content, true);\n        root.appendChild(clone);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n};\n\n\n// Convert a plain string of HTML into a real template element.\nfunction createTemplateWithInnerHTML(innerHTML) {\n  const template = document.createElement('template');\n  // REVIEW: Is there an easier way to do this?\n  // We'd like to just set innerHTML on the template content, but since it's\n  // a DocumentFragment, that doesn't work.\n  const div = document.createElement('div');\n  div.innerHTML = innerHTML;\n  while (div.childNodes.length > 0) {\n    template.content.appendChild(div.childNodes[0]);\n  }\n  return template;\n}\n\n// Invoke basic style shimming with ShadowCSS.\nfunction shimTemplateStyles(template, tag) {\n  window.WebComponents.ShadowCSS.shimStyling(template.content, tag);\n}\n","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\n\n\n// Symbols for private data members on an element.\nconst safeToSetAttributesSymbol = createSymbol('safeToSetAttributes');\nconst pendingAttributesSymbol = createSymbol('pendingAttributes');\nconst pendingClassesSymbol = createSymbol('pendingClasses');\n\n\n/**\n * Helper functions for updating attributes, including the `class` attribute.\n */\nexport default {\n\n  /**\n   * Perform any pending updates to attributes and classes.\n   *\n   * This writes any `setAttribute` or `toggleClass` values that were performed\n   * before an element was attached to the document for the first time.\n   *\n   * This method should be called by mixins/components in their\n   * `connectedCallback`. If mulitple mixins/components invoke this during the\n   * same `connectedCallback`, only the first call will have any effect. The\n   * subsequent calls will be harmless.\n   *\n   * @param {HTMLElement} element - The element being added to the document.\n   */\n  connected(element) {\n    element[safeToSetAttributesSymbol] = true;\n\n    // Set any pending attributes.\n    if (element[pendingAttributesSymbol]) {\n      for (let attribute in element[pendingAttributesSymbol]) {\n        const value = element[pendingAttributesSymbol][attribute];\n        setAttributeToElement(element, attribute, value);\n      }\n      element[pendingAttributesSymbol] = null;\n    }\n\n    // Set any pending classes.\n    if (element[pendingClassesSymbol]) {\n      for (let className in element[pendingClassesSymbol]) {\n        const value = element[pendingClassesSymbol][className];\n        toggleClass(element, className, value);\n      }\n      element[pendingClassesSymbol] = null;\n    }\n  },\n\n  /**\n   * Set/unset the attribute with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as an attribute. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes. A call to `setAttribute` during the constructor will\n   * be deferred until the element is connected to the document.\n   *\n   * @param {string} attribute - The name of the *attribute* (not property) to set.\n   * @param {object} value - The value to set. If null, the attribute will be removed.\n   */\n  setAttribute(element, attribute, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set attributes immediately.\n      setAttributeToElement(element, attribute, value);\n    } else {\n      // Defer setting attributes until the first time we're connected.\n      if (!element[pendingAttributesSymbol]) {\n        element[pendingAttributesSymbol] = {};\n      }\n      element[pendingAttributesSymbol][attribute] = value;\n    }\n  },\n\n  /**\n   * Set/unset the class with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as as class. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes, including the `class` attribute. A call to\n   * `toggleClass` during the constructor will be deferred until the element\n   * is connected to the document.\n   *\n   * @param {string} className - The name of the class to set.\n   * @param {object} value - True to set the class, false to remove it.\n   */\n  toggleClass(element, className, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set class immediately.\n      toggleClass(element, className, value);\n    } else {\n      // Defer setting class until the first time we're connected.\n      if (!element[pendingClassesSymbol]) {\n        element[pendingClassesSymbol] = {};\n      }\n      element[pendingClassesSymbol][className] = value;\n    }\n  }\n\n};\n\n\n// Reflect the attribute to the given element.\n// If the value is null, remove the attribute.\nfunction setAttributeToElement(element, attributeName, value) {\n  if (value === null || typeof value === 'undefined') {\n    element.removeAttribute(attributeName);\n  } else {\n    const text = String(value);\n    // Avoid recursive attributeChangedCallback calls.\n    if (element.getAttribute(attributeName) !== text) {\n      element.setAttribute(attributeName, value);\n    }\n  }\n}\n","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'basic-component-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'basic-component-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `dragging` property.\n   *\n   * Components like carousels often define animated CSS transitions for\n   * sliding effects. Such a transition should usually *not* be applied while\n   * the user is dragging, because a CSS animation will introduce a lag that\n   * makes the swipe feel sluggish. Instead, as long as the user is dragging\n   * with their finger down, the transition should be suppressed. When the\n   * user releases their finger, the transition can be restored, allowing the\n   * animation to show the carousel sliding into its final position.\n   *\n   * @type {boolean} true if a drag is in progress, false if not.\n   */\n  dragging: createSymbol('dragging'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: createSymbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: createSymbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: createSymbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: createSymbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: createSymbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: createSymbol('goUp'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: createSymbol('keydown'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLElement}\n   */\n  template: createSymbol('template')\n};\n\nexport default symbols;\n","/**\n * Helper function for standard classList.toggle() behavior on old browsers,\n * namely IE 11.\n *\n * The standard\n * [classlist](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)\n * object has a `toggle()` function that supports a second Boolean parameter\n * that can be used to succinctly turn a class on or off. This feature is often\n * useful in designing custom elements, which may want to externally reflect\n * component state in a CSS class that can be used for styling purposes.\n *\n * Unfortunately, IE 11 does not support the Boolean parameter to\n * `classList.toggle()`. This helper function behaves like the standard\n * `toggle()`, including support for the Boolean parameter, so that it can be\n * used even on IE 11.\n *\n * @function toggleClass\n * @param {HTMLElement} element - The element to modify\n * @param {string} className - The class to add/remove\n * @param {boolean} [force] - Force the class to be added (if true) or removed\n *                            (if false)\n */\nexport default function toggleClass(element, className, force) {\n  const classList = element.classList;\n  const addClass = (typeof force === 'undefined') ?\n    !classList.contains(className) :\n    force;\n  if (addClass) {\n    classList.add(className);\n  } else {\n    classList.remove(className);\n  }\n  return addClass;\n}\n","import AttributeMarshallingMixin from '../../basic-component-mixins/src/AttributeMarshallingMixin';\nimport ComposableMixin from '../../basic-component-mixins/src/ComposableMixin';\nimport DistributedChildrenMixin from '../../basic-component-mixins/src/DistributedChildrenMixin';\nimport ShadowElementReferencesMixin from '../../basic-component-mixins/src/ShadowElementReferencesMixin';\nimport ShadowTemplateMixin from '../../basic-component-mixins/src/ShadowTemplateMixin';\n\n\n/**\n * A sample general-purpose base class for defining custom elements that mixes\n * in some common features: template stamping into a shadow root, shadow element\n * references, marshalling attributes to properties, and retrieving the children\n * distributed to a component.\n *\n * This base class is not special in any way, and is defined only as a\n * convenient shorthand for applying the mixins listed above. You can use this\n * class as a base class for your own elements, or easily create your own base\n * class by applying the same set of mixins.\n *\n * The ElementBase base class does not register itself as a custom element with\n * the browser, and hence cannot be independently instantiated.\n *\n * @mixes AttributeMarshallingMixin\n * @mixes ComposableMixin\n * @mixes DistributedChildrenMixin\n * @mixes ShadowElementReferencesMixin\n * @mixes ShadowTemplateMixin\n */\nclass ElementBase extends ComposableMixin(HTMLElement).compose(\n  ShadowTemplateMixin,          // before node finding, so shadow root is populated\n  ShadowElementReferencesMixin, // before marshalling, so properties can use refs\n  AttributeMarshallingMixin,\n  DistributedChildrenMixin\n) {}\n\nexport default ElementBase;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport WrappedStandardElement from './src/WrappedStandardElement';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.WrappedStandardElement = WrappedStandardElement;\n","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/*\n * A set of events which, if fired by the inner standard element, should be\n * re-raised by the custom element. (We only need to do that under native\n * Shadow DOM, not the polyfill.)\n *\n * These are events which are spec'ed to NOT get retargetted across a Shadow DOM\n * boundary, organized by which element(s) raise the events. To properly\n * simulate these, we will need to listen for the real events, then re-raise a\n * simulation of the original event. For more information, see\n * https://www.w3.org/TR/shadow-dom/#h-events-that-are-not-leaked-into-ancestor-trees.\n *\n * It appears that we do *not* need to re-raise the non-bubbling \"focus\" and\n * \"blur\" events. These appear to be automatically re-raised as expected -- but\n * it's not clear why that happens.\n *\n * The list below is reasonably complete. It omits elements that cannot be\n * wrapped (see class notes above). Also, we haven't actually tried wrapping\n * every element in this list; some of the more obscure ones might not actually\n * work as expected, but it was easier to include them for completeness than\n * to actually verify whether or not the element can be wrapped.\n */\nconst reraiseEvents = {\n  address: ['scroll'],\n  blockquote: ['scroll'],\n  caption: ['scroll'],\n  center: ['scroll'],\n  dd: ['scroll'],\n  dir: ['scroll'],\n  div: ['scroll'],\n  dl: ['scroll'],\n  dt: ['scroll'],\n  fieldset: ['scroll'],\n  form: ['reset', 'scroll'],\n  frame: ['load'],\n  h1: ['scroll'],\n  h2: ['scroll'],\n  h3: ['scroll'],\n  h4: ['scroll'],\n  h5: ['scroll'],\n  h6: ['scroll'],\n  iframe: ['load'],\n  img: ['abort', 'error', 'load'],\n  input: ['abort', 'change', 'error', 'select', 'load'],\n  keygen: ['reset', 'select'],\n  li: ['scroll'],\n  link: ['load'],\n  menu: ['scroll'],\n  object: ['error', 'scroll'],\n  ol: ['scroll'],\n  p: ['scroll'],\n  script: ['error', 'load'],\n  select: ['change', 'scroll'],\n  tbody: ['scroll'],\n  tfoot: ['scroll'],\n  thead: ['scroll'],\n  textarea: ['change', 'select', 'scroll']\n};\n\n\n// Keep track of which re-raised events should bubble.\nconst eventBubbles = {\n  abort: true,\n  change: true,\n  reset: true\n};\n\n\n// Elements which are display: block by default.\n// Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nconst blockElements = [\n  'address',\n  'article',\n  'aside',\n  'blockquote',\n  'canvas',\n  'dd',\n  'div',\n  'dl',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'header',\n  'hgroup',\n  'hr',\n  'li',\n  'main',\n  'nav',\n  'noscript',\n  'ol',\n  'output',\n  'p',\n  'pre',\n  'section',\n  'table',\n  'tfoot',\n  'ul',\n  'video'\n];\n\n\n/**\n * Wraps a standard HTML element so that the standard behavior can then be\n * extended.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-wrapped-standard-element/)\n *\n * See also [basic-autosize-textarea](../basic-autosize-textarea) and\n * [basic-current-anchor](../basic-current-anchor). The former uses\n * WrappedStandardElement to wrap a standard `<textarea>` and `<a>`,\n * respectively.\n *\n * The Custom Elements spec does not currently (as of March 2016) allow you to\n * extend the behavior of a standard HTML element like `<a>` or `<button>`.\n * As a partial workaround, the WrappedStandardElement class can create a class\n * for you that wraps an instance of a standard HTML element. For example, the\n * code below creates a class that will wrap an instance of a standard `<a>`\n * element:\n *\n *     class WrappedA extends WrappedStandardElement.wrap('a') {\n *       customMethod() { ... }\n *     }\n *     customElements.define('wrapped-a', WrappedA);\n *\n * An instance of the resulting class will look to the user like an instance of\n * the standard element class it wraps. The resulting class will *not* be an\n * `instanceof` the standard class (here, HTMLAnchorElement). Another limitation\n * is that the resulting `<wrapped-a>` will not automatically pick up CSS styles\n * for standard `<a>` elements. However, the resulting class *can* be extended.\n * E.g., instances of the above class have a `customMethod()` available to them.\n *\n * Any properties defined by the original standard element will be exposed on\n * the resulting wrapper class, and calls to get or set those properties will be\n * delegated to the wrapped element instance. Continuing the above example:\n *\n *     let wrapped = document.createElement('wrapped-a');\n *     wrapped.href = 'http://example.com/';\n *     wrapped.textContent = 'Click here';\n *\n * Here, the created custom `<wrapped-a>` element will contain inside its\n * shadow tree an instance of a standard `<a>` element. The call to set the\n * wrapper's `href` property will ultimately set the `href` on the inner link.\n * Moreover, the text content of the `<wrapped-a>` element will appear inside\n * the inner link. The result of all this is that the user will see what *looks*\n * like a normal link, just as if you had written\n * `<a href=\"http://example.com/\">Click here</a>`. However, the actual element\n * will be an instance of your custom class, with whatever behavior you've\n * defined for it.\n *\n * Wrapped elements should raise the same events as the original standard\n * elements. E.g., if you wrap an `<img>` element, the wrapped result will raise\n * the standard `load` event as expected.\n *\n * Some elements, such as `<body>`, `<html>`, and `<style>` cannot be wrapped\n * and still achieve their standard behavior.\n *\n * @extends ElementBase\n */\nclass WrappedStandardElement extends ElementBase {\n\n  constructor() {\n    super();\n\n    // Listen for any events raised by the inner element which will not\n    // automatically be retargetted across the Shadow DOM boundary, and re-raise\n    // those events when they happen.\n    //\n    // Note: It's unclear why we need to do this in the Shadow DOM polyfill.\n    // In theory, events in the light DOM should bubble as normal. But this\n    // code appears to be required in the polyfill case as well.\n    const eventNames = reraiseEvents[this.extends] || [];\n    eventNames.forEach(eventName => {\n      this.inner.addEventListener(eventName, realEvent => {\n        const event = new Event(eventName, {\n          bubbles: eventBubbles[eventName] || false\n        });\n        this.dispatchEvent(event);\n      });\n    });\n  }\n\n  /**\n   * A description for the user of the element's purpose on the page. Setting\n   * this applies the label to the inner element, ensuring that screen readers\n   * and other assistive technologies will provide a meaningful description to\n   * the user.\n   *\n   * @type {string}\n   */\n  get ariaLabel() {\n    return this.inner.getAttribute('aria-label');\n  }\n  set ariaLabel(label) {\n    // Propagate the ARIA label to the inner textarea.\n    this.inner.setAttribute('aria-label', label);\n  }\n\n  /**\n   * Returns a reference to the inner standard HTML element.\n   *\n   * @type {HTMLElement}\n   */\n  get inner() {\n    return this.$.inner;\n  }\n\n  /**\n   * The template copied into the shadow tree of new instances of this element.\n   *\n   * The default value of this property is a template that includes an instance\n   * the standard element being wrapped, with a `<slot>` element inside that\n   * to pick up the element's light DOM content. For example, if you wrap an\n   * `<a>` element, then the default template will look like:\n   *\n   *     <template>\n   *       <style>\n   *       :host {\n   *         display: inline-block;\n   *       }\n   *       </style>\n   *       <a id=\"inner\">\n   *         <slot></slot>\n   *       </a>\n   *     </template>\n   *\n   * The `display` styling applied to the host will be `block` for elements that\n   * are block elements by default, and `inline-block` (not `inline`) for other\n   * elements.\n   *\n   * If you'd like the template to include other elements, then override this\n   * property and return a template of your own. The template should include an\n   * instance of the standard HTML element you are wrapping, and the ID of that\n   * element should be \"inner\".\n   *\n   * @type {(string|HTMLTemplateElement)}\n   */\n  get [symbols.template]() {\n    const display = blockElements.indexOf(this.extends) >= 0 ?\n      'block' :\n      'inline-block';\n    return `<style>:host { display: ${display}}</style><${this.extends} id=\"inner\"><slot></slot></${this.extends}`;\n  }\n\n  /**\n   * Creates a class that wraps a standard HTML element.\n   *\n   * Note that the resulting class is a subclass of WrappedStandardElement, not\n   * the standard class being wrapped. E.g., if you call\n   * `WrappedStandardElement.wrap('a')`, you will get a class whose shadow tree\n   * will include an anchor element, but the class will *not* inherit from\n   * HTMLAnchorElement.\n   *\n   * @param {string} extendsTag - the standard HTML element tag to extend\n   */\n  static wrap(extendsTag) {\n\n    // Create the new class.\n    class Wrapped extends WrappedStandardElement {}\n\n    // Indicate which tag it wraps.\n    Wrapped.prototype.extends = extendsTag;\n\n    // Create getter/setters that delegate to the wrapped element.\n    const element = document.createElement(extendsTag);\n    const extendsPrototype = element.constructor.prototype;\n    const names = Object.getOwnPropertyNames(extendsPrototype);\n    names.forEach(name => {\n        const descriptor = Object.getOwnPropertyDescriptor(extendsPrototype, name);\n        const delegate = createPropertyDelegate(name, descriptor);\n        Object.defineProperty(Wrapped.prototype, name, delegate);\n    });\n\n    return Wrapped;\n  }\n\n}\n\n\nfunction createPropertyDelegate(name, descriptor) {\n  const delegate = {\n    configurable: descriptor.configurable,\n    enumerable: descriptor.enumerable,\n  };\n  if (descriptor.get) {\n    delegate.get = function() {\n      return this.inner[name];\n    };\n  }\n  if (descriptor.set) {\n    delegate.set = function(value) {\n      this.inner[name] = value;\n    };\n  }\n  if (descriptor.writable) {\n    delegate.writable = descriptor.writable;\n  }\n  return delegate;\n}\n\n\nexport default WrappedStandardElement;\n"]}