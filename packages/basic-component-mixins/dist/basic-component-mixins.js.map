{"version":3,"sources":["node_modules/browser-pack/_prelude.js","packages/basic-component-mixins/globals.js","packages/basic-component-mixins/src/ArrowSelectionMixin.js","packages/basic-component-mixins/src/AttributeMarshallingMixin.js","packages/basic-component-mixins/src/ClickSelectionMixin.js","packages/basic-component-mixins/src/ComposableMixin.js","packages/basic-component-mixins/src/ContentItemsMixin.js","packages/basic-component-mixins/src/DirectionSelectionMixin.js","packages/basic-component-mixins/src/DistributedChildrenContentMixin.js","packages/basic-component-mixins/src/DistributedChildrenMixin.js","packages/basic-component-mixins/src/FractionalSelectionMixin.js","packages/basic-component-mixins/src/GenericMixin.js","packages/basic-component-mixins/src/KeyboardDirectionMixin.js","packages/basic-component-mixins/src/KeyboardMixin.js","packages/basic-component-mixins/src/KeyboardPagedSelectionMixin.js","packages/basic-component-mixins/src/KeyboardPrefixSelectionMixin.js","packages/basic-component-mixins/src/PageDotsMixin.js","packages/basic-component-mixins/src/PlayControlsMixin.js","packages/basic-component-mixins/src/SelectionAnimationMixin.js","packages/basic-component-mixins/src/SelectionAriaActiveMixin.js","packages/basic-component-mixins/src/SelectionHighlightMixin.js","packages/basic-component-mixins/src/SelectionInViewMixin.js","packages/basic-component-mixins/src/ShadowElementReferencesMixin.js","packages/basic-component-mixins/src/ShadowTemplateMixin.js","packages/basic-component-mixins/src/SingleSelectionMixin.js","packages/basic-component-mixins/src/SwipeDirectionMixin.js","packages/basic-component-mixins/src/TimerSelectionMixin.js","packages/basic-component-mixins/src/TrackpadDirectionMixin.js","packages/basic-component-mixins/src/createSymbol.js","packages/basic-component-mixins/src/microtask.js","packages/basic-component-mixins/src/renderArrayAsElements.js","packages/basic-component-mixins/src/safeAttributes.js","packages/basic-component-mixins/src/symbols.js","packages/basic-component-mixins/src/toggleClass.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","_ArrowSelectionMixin","_AttributeMarshallingMixin","_ClickSelectionMixin","_ComposableMixin","_ContentItemsMixin","_createSymbol","_DirectionSelectionMixin","_DistributedChildrenMixin","_DistributedChildrenContentMixin","_GenericMixin","_KeyboardMixin","_KeyboardDirectionMixin","_KeyboardPagedSelectionMixin","_KeyboardPrefixSelectionMixin","_microtask","_PageDotsMixin","_PlayControlsMixin","_safeAttributes","_SelectionAnimationMixin","_SelectionAriaActiveMixin","_SelectionHighlightMixin","_SelectionInViewMixin","_ShadowElementReferencesMixin","_ShadowTemplateMixin","_SingleSelectionMixin","_SwipeDirectionMixin","_symbols","_TimerSelectionMixin","_TrackpadDirectionMixin","window","Basic","ArrowSelectionMixin","_ArrowSelectionMixin2","default","AttributeMarshallingMixin","_AttributeMarshallingMixin2","ClickSelectionMixin","_ClickSelectionMixin2","ComposableMixin","_ComposableMixin2","ContentItemsMixin","_ContentItemsMixin2","createSymbol","_createSymbol2","DirectionSelectionMixin","_DirectionSelectionMixin2","DistributedChildrenMixin","_DistributedChildrenMixin2","DistributedChildrenContentMixin","_DistributedChildrenContentMixin2","generic","_GenericMixin2","KeyboardMixin","_KeyboardMixin2","KeyboardDirectionMixin","_KeyboardDirectionMixin2","KeyboardPagedSelectionMixin","_KeyboardPagedSelectionMixin2","KeyboardPrefixSelectionMixin","_KeyboardPrefixSelectionMixin2","microtask","_microtask2","PageDotsMixin","_PageDotsMixin2","PlayControlsMixin","_PlayControlsMixin2","safeAttributes","_safeAttributes2","SelectionAnimationMixin","_SelectionAnimationMixin2","SelectionAriaActiveMixin","_SelectionAriaActiveMixin2","SelectionHighlightMixin","_SelectionHighlightMixin2","SelectionInViewMixin","_SelectionInViewMixin2","ShadowElementReferencesMixin","_ShadowElementReferencesMixin2","ShadowTemplateMixin","_ShadowTemplateMixin2","SingleSelectionMixin","_SingleSelectionMixin2","SwipeDirectionMixin","_SwipeDirectionMixin2","symbols","_symbols2","TimerSelectionMixin","_TimerSelectionMixin2","TrackpadDirectionMixin","_TrackpadDirectionMixin2","assumeButtonFocus","element","button","addEventListener","event","focus","preventDefault","deviceSupportsTouch","DocumentTouch","document","listenForMouse","mousedownListenerSymbol","mouseTimeoutSymbol","clearTimeout","lastMouseXSymbol","pageX","lastMouseYSymbol","pageY","mousemoveListenerSymbol","setTimeout","mouseDetected","showArrows","removeEventListener","classList","add","base","ArrowSelection","_base","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","$","buttonLeft","handlingUserInteraction","selectPrevious","stopPropagation","buttonRight","selectNext","_inherits","_createClass","key","value","_get","prototype","contains","get","set","canSelectNext","_set","disabled","canSelectPrevious","defaults","navigationAxis","template","baseTemplate","attributeToPropertyName","attributeName","propertyName","attributeToPropertyNames","hypenRegEx","replace","match","toUpperCase","attributesForClass","classFn","HTMLElement","baseClass","constructor","baseAttributes","propertyNames","getOwnPropertyNames","setterNames","filter","getOwnPropertyDescriptor","attributes","map","setterName","propertyNameToAttribute","diff","attribute","indexOf","concat","propertyNamesToAttributes","uppercaseRegEx","toLowerCase","AttributeMarshalling","apply","arguments","oldValue","newValue","connected","setAttribute","className","toggleClass","indexOfContainingItem","target","items","itemCount","item","ClickSelection","path","index","selectedIndex","composeClass","mixin","Subclass","_base2","copyOwnProperties","NON_MIXABLE_OBJECT_PROPERTIES","source","ignorePropertyNames","undefined","forEach","name","descriptor","defineProperty","Composable","_len","mixins","Array","_key","reduce","filterAuxiliaryElements","auxiliaryTags","localName","_toggleClass","itemsSymbol","itemInitializedSymbol","ContentItems","itemsChanged","itemAdded","itemSelected","selected","_toggleClass2","_this2","dispatchEvent","CustomEvent","content","DirectionSelection","goDown","goEnd","selectLast","goLeft","goRight","goStart","selectFirst","goUp","selectedFraction","DistributedChildrenContent","shadowRoot","slots","querySelectorAll","slot","contentChanged","distributedChildren","console","warn","expandContentElements","nodes","includeTextNodes","_ref","expanded","node","isSlot","HTMLSlotElement","assignedNodes","flatten","Text","flattened","_toConsumableArray","DistributedChildren","children","childNodes","strings","distributedChildNodes","child","textContent","join","FractionalSelection","selectedFractionSymbol","helpers","dampedSelection","selection","bound","damped","damping","x","y","elementSelection","selectionParts","Math","ceil","floor","fraction","wrappedSelection","wrappedSelectionParts","wrap","genericSymbol","Generic","parsed","String","removeAttribute","navigationAxisSymbol","KeyboardDirection","keydown","handled","axis","horizontal","vertical","keyCode","metaKey","altKey","Keyboard","getAttribute","tabindex","getIndexOfItemAtY","downward","start","end","step","scrollTarget","topOfClientArea","offsetTop","clientTop","itemIndex","itemTop","found","itemBottom","offsetHeight","itemStyle","getComputedStyle","itemPaddingTop","parseFloat","paddingTop","itemPaddingBottom","paddingBottom","contentTop","contentBottom","clientHeight","scrollOnePage","edge","scrollTop","indexOfItemAtEdge","newIndex","delta","KeyboardPagedSelection","pageUp","pageDown","getIndexOfItemWithTextPrefix","prefix","itemTextContents","getItemTextContents","prefixLength","itemTextContent","substr","itemTextContentsSymbol","text","alt","handleBackspace","typedPrefixSymbol","selectItemWithTextPrefix","setPrefixTimeout","handlePlainCharacter","char","resetPrefixTimeout","prefixTimeoutSymbol","resetTypedPrefix","PREFIX_TIMEOUT_DURATION","KeyboardPrefixSelection","resetPrefix","ctrlKey","which","fromCharCode","keepIndexWithinBounds","renderTransition","dots","dotCount","opacityMinimum","opacityMaximum","opacityRange","fractionalIndex","leftIndex","rightIndex","selectionWraps","awayIndex","towardIndex","truncatedSelectedFraction","progress","opacityProgressThroughRange","abs","dot","dotOpacity","style","opacity","refreshDots","_renderArrayAsElements","PageDots","dotIndex","_renderArrayAsElements2","createElement","slice","PlayControls","previousButton","playButton","playing","nextButton","SelectionAnimation","selectionAnimationDuration","selectionAnimationEffect","selectionAnimationKeyframes","dragging","_resetAnimations","renderSelection","draggingSymbol","previousValue","resetAnimationsOnNextRenderSymbol","selectionAnimationDurationSymbol","selectionAnimationEffectSymbol","standardEffectKeyframes","selectionAnimationKeyframesSymbol","animateSelection","fromSelection","toSelection","keyframes","playingAnimationSymbol","timings","effectTimingsForSelectionAnimation","selectionIndex","_FractionalSelectionMixin2","totalSteps","stepsToIndex","forward","nextUpIndex","isItemIndexInBounds","lastAnimationDetails","timing","showItem","animation","animate","animationSymbol","endDelay","onfinish","selectionAnimationFinished","lastAnimationSymbol","getAnimationForItemIndex","duration","fill","pause","previousSelection","previousSelectionSymbol","renderSelectionInstantly","animationFractions","animationFractionsForSelection","animationFraction","setAnimationFraction","animations","cancel","details","currentTime","flag","visibility","allowWrap","steps","wrapSteps","_FractionalSelectionMixin","toIndex","direction","totalDuration","stepDuration","positionInSequence","delay","crossfade","reveal","transform","zIndex","revealWithFade","showAdjacent","slide","slideWithGap","idCount","SelectionAriaActive","role","id","baseId","itemId","SelectionHighlight","SelectionInView","selectedItem","scrollItemIntoView","elementTop","elementBottom","scrollBottom","ShadowElementReferences","nodesWithIds","createTemplateWithInnerHTML","innerHTML","div","appendChild","shimTemplateStyles","tag","WebComponents","ShadowCSS","shimStyling","ShadowTemplate","ShadowDOMPolyfill","root","attachShadow","mode","clone","importNode","selectIndex","count","boundedIndex","max","min","previousIndex","trackSelectedItem","previousSelectedItem","indexInCurrentItems","previousSelectedIndex","newSelectedIndex","selectionRequired","updatePossibleNavigations","canSelectNextSymbol","canSelectPreviousSymbol","selectionRequiredSymbol","selectionWrapsSymbol","externalSelectedIndexSymbol","externalSelectedItemSymbol","internalSelectedIndexSymbol","internalSelectedItemSymbol","SingleSelection","previousCanSelectNext","previousCanSelectPrevious","hasItems","detail","isEventForPenOrPrimaryTouch","pointerType","isPrimary","touchEnd","clientX","clientY","deltaXSymbol","trackTo","travelFraction","deltaYSymbol","touchMove","previousXSymbol","previousYSymbol","touchStart","startXSymbol","width","offsetWidth","dragDistance","multiTouchSymbol","travelFractionSymbol","SwipeDirection","PointerEvent","touches","changedTouches","touchAction","clearTimer","timerTimeoutSymbol","restartTimer","startTimer","selectNextWithWrap","selectionTimerDuration","playingSymbol","selectionTimerDurationSymbol","TimerSelection","previousPlaying","play","parseInt","postNavigate","wheelDistanceSymbol","postNavigateDelayCompleteSymbol","absorbDecelerationSymbol","POST_NAVIGATE_TIME","resetWheelTracking","lastDeltaXSymbol","lastWheelTimeoutSymbol","sign","wheel","wheelTimedOut","WHEEL_TIME","deltaX","deltaY","acceleration","TrackpadDirection","description","Symbol","callback","callbacks","push","counter","executeCallbacks","shift","createTextNode","observer","MutationObserver","observe","characterData","renderArrayAsElements","container","renderItem","oldElement","newElement","replaceChild","removeChild","setAttributeToElement","safeToSetAttributesSymbol","pendingAttributesSymbol","pendingClassesSymbol","_value","_toggleClass3","force","addClass","remove"],"mappings":"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","file":"basic-component-mixins.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport ArrowSelectionMixin from './src/ArrowSelectionMixin';\nimport AttributeMarshallingMixin from './src/AttributeMarshallingMixin';\nimport ClickSelectionMixin from './src/ClickSelectionMixin';\nimport ComposableMixin from './src/ComposableMixin';\nimport ContentItemsMixin from './src/ContentItemsMixin';\nimport createSymbol from './src/createSymbol';\nimport DirectionSelectionMixin from './src/DirectionSelectionMixin';\nimport DistributedChildrenMixin from './src/DistributedChildrenMixin';\nimport DistributedChildrenContentMixin from './src/DistributedChildrenContentMixin';\nimport GenericMixin from './src/GenericMixin';\nimport KeyboardMixin from './src/KeyboardMixin';\nimport KeyboardDirectionMixin from './src/KeyboardDirectionMixin';\nimport KeyboardPagedSelectionMixin from './src/KeyboardPagedSelectionMixin';\nimport KeyboardPrefixSelectionMixin from './src/KeyboardPrefixSelectionMixin';\nimport microtask from './src/microtask';\nimport PageDotsMixin from './src/PageDotsMixin';\nimport PlayControlsMixin from './src/PlayControlsMixin';\nimport safeAttributes from './src/safeAttributes';\nimport SelectionAnimationMixin from './src/SelectionAnimationMixin';\nimport SelectionAriaActiveMixin from './src/SelectionAriaActiveMixin';\nimport SelectionHighlightMixin from './src/SelectionHighlightMixin';\nimport SelectionInViewMixin from './src/SelectionInViewMixin';\nimport ShadowElementReferencesMixin from './src/ShadowElementReferencesMixin';\nimport ShadowTemplateMixin from './src/ShadowTemplateMixin';\nimport SingleSelectionMixin from './src/SingleSelectionMixin';\nimport SwipeDirectionMixin from './src/SwipeDirectionMixin';\nimport symbols from './src/symbols';\nimport TimerSelectionMixin from './src/TimerSelectionMixin';\nimport TrackpadDirectionMixin from './src/TrackpadDirectionMixin';\n\nwindow.Basic = window.Basic || {};\n\nwindow.Basic.ArrowSelectionMixin = ArrowSelectionMixin;\nwindow.Basic.AttributeMarshallingMixin = AttributeMarshallingMixin;\nwindow.Basic.ClickSelectionMixin = ClickSelectionMixin;\nwindow.Basic.ComposableMixin = ComposableMixin;\nwindow.Basic.ContentItemsMixin = ContentItemsMixin;\nwindow.Basic.createSymbol = createSymbol;\nwindow.Basic.DirectionSelectionMixin = DirectionSelectionMixin;\nwindow.Basic.DistributedChildrenMixin = DistributedChildrenMixin;\nwindow.Basic.DistributedChildrenContentMixin = DistributedChildrenContentMixin;\nwindow.Basic.generic = GenericMixin;\nwindow.Basic.KeyboardMixin = KeyboardMixin;\nwindow.Basic.KeyboardDirectionMixin = KeyboardDirectionMixin;\nwindow.Basic.KeyboardPagedSelectionMixin = KeyboardPagedSelectionMixin;\nwindow.Basic.KeyboardPrefixSelectionMixin = KeyboardPrefixSelectionMixin;\nwindow.Basic.microtask = microtask;\nwindow.Basic.PageDotsMixin = PageDotsMixin;\nwindow.Basic.PlayControlsMixin = PlayControlsMixin;\nwindow.Basic.safeAttributes = safeAttributes;\nwindow.Basic.SelectionAnimationMixin = SelectionAnimationMixin;\nwindow.Basic.SelectionAriaActiveMixin = SelectionAriaActiveMixin;\nwindow.Basic.SelectionHighlightMixin = SelectionHighlightMixin;\nwindow.Basic.SelectionInViewMixin = SelectionInViewMixin;\nwindow.Basic.ShadowElementReferencesMixin = ShadowElementReferencesMixin;\nwindow.Basic.ShadowTemplateMixin = ShadowTemplateMixin;\nwindow.Basic.SingleSelectionMixin = SingleSelectionMixin;\nwindow.Basic.SwipeDirectionMixin = SwipeDirectionMixin;\nwindow.Basic.symbols = symbols;\nwindow.Basic.TimerSelectionMixin = TimerSelectionMixin;\nwindow.Basic.TrackpadDirectionMixin = TrackpadDirectionMixin;\n","import createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n// Symbols for private data members on an element.\nconst mousedownListenerSymbol = createSymbol('mousedownListener');\nconst mousemoveListenerSymbol = createSymbol('mousemoveListener');\nconst lastMouseXSymbol = createSymbol('lastMouseX');\nconst lastMouseYSymbol = createSymbol('lastMouseY');\nconst mouseTimeoutSymbol = createSymbol('mouseTimeout');\n\n\n/* Exported function extends a base class with ArrowSelection. */\nexport default (base) => {\n\n  /**\n   * Template mixin which adds prominent left and right arrow buttons to a\n   * wrapped child such as a carousel.\n   *\n   * You can see a\n   * [live demo](http://basicwebcomponents.org/basic-web-components/packages/demos/carousel-with-arrows.html)\n   * of this mixin applied to a carousel.\n   *\n   * Clicking the left/right buttons selects the previous/next item.\n   *\n   * Typical usage:\n   *\n   *     class CarouselWithArrows extends ArrowSelectionMixin(Carousel) {}\n   *     customElements.define('carousel-with-arrows', CarouselWithArrows);\n   *\n   * By default, the arrow buttons are shown on devices with a mouse or mouse-like\n   * pointing device. They are not shown on a touch-capable device unless mouse\n   * movement is detected. To cause the buttons to always appear, apply the\n   * 'showArrows' CSS class.\n   */\n  class ArrowSelection extends base {\n\n    constructor() {\n      super();\n\n      this.$.buttonLeft.addEventListener('click', event => {\n        this[symbols.handlingUserInteraction] = true;\n        this.selectPrevious();\n        event.stopPropagation();\n        this[symbols.handlingUserInteraction] = false;\n      });\n      this.$.buttonRight.addEventListener('click', event => {\n        this[symbols.handlingUserInteraction] = true;\n        this.selectNext();\n        event.stopPropagation();\n        this[symbols.handlingUserInteraction] = false;\n      });\n      assumeButtonFocus(this, this.$.buttonLeft);\n      assumeButtonFocus(this, this.$.buttonRight);\n    }\n\n    get canSelectNext() {\n      return super.canSelectNext;\n    }\n    set canSelectNext(canSelectNext) {\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      this.$.buttonRight.disabled = !canSelectNext;\n    }\n\n    get canSelectPrevious() {\n      return super.canSelectPrevious;\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      this.$.buttonLeft.disabled = !canSelectPrevious;\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      if (!this.classList.contains('showArrows')) {\n        // Determine whether we should show arrow buttons or not.\n        if (deviceSupportsTouch()) {\n          // A touch device might also support a mouse, but we can't know whether\n          // there's actually a mouse until we hear from it.\n          listenForMouse(this);\n        } else {\n          // The device doesn't support touch, so assume it has a mouse.\n          showArrows(this);\n        }\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.navigationAxis = 'horizontal';\n      return defaults;\n    }\n\n    /*\n     * The template uses the chevron-left and chevron-right SVG icons from\n     * https://github.com/PolymerElements/iron-icons/blob/master/iron-icons.html.\n     */\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n        :host {\n          -webkit-align-items: stretch;\n          align-items: stretch;\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          -webkit-justify-content: center;\n          justify-content: center;\n        }\n\n        #arrowNavigationContainer {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          position: relative;\n        }\n\n        .navigationButton {\n          background: transparent;\n          border: 1px solid transparent;\n          box-sizing: border-box;\n          color: rgba(0, 0, 0, 0.7);\n          fill: currentColor;\n          margin: 0;\n          opacity: 1;\n          outline: none; /* REVIEW: Accessibility should be provided by other elements. */\n          padding: 0;\n          transition: opacity 1s;\n          z-index: 1;\n        }\n\n        .navigationButton:hover:not(:disabled) {\n          background: rgba(0, 0, 0, 0.5);\n          color: rgba(0, 0, 0, 0.8);\n          cursor: pointer;\n        }\n        .navigationButton:active:not(:disabled) {\n          background: rgba(0, 0, 0, 0.7);\n          color: rgba(0, 0, 0, 0.9);\n        }\n        .navigationButton:disabled {\n          color: rgba(0, 0, 0, 0.2);\n        }\n\n        :host(:not(.showArrows)) .navigationButton {\n          opacity: 0;\n          visibility: hidden;\n        }\n\n        .navigationButton .icon {\n          height: 48px;\n          width: 48px;\n        }\n\n        /* Overlay variant */\n        :host(.overlayArrows) {\n          position: relative;\n        }\n        :host(.overlayArrows) .navigationButton {\n          bottom: 0;\n          color: rgba(255, 255, 255, 0.7);\n          position: absolute;\n          top: 0;\n        }\n        :host(.overlayArrows) #buttonLeft {\n          left: 0;\n        }\n        :host(.overlayArrows) #buttonRight {\n          right: 0;\n        }\n        :host(.overlayArrows) .navigationButton:hover:not(:disabled) {\n          background: rgba(255, 255, 255, 0.2);\n          color: rgba(255, 255, 255, 0.8);\n        }\n        :host(.overlayArrows) .navigationButton:active:not(:disabled) {\n          background: rgba(255, 255, 255, 0.4);\n          color: rgba(255, 255, 255, 0.9);\n        }\n        :host(.overlayArrows) .navigationButton:disabled {\n          color: rgba(255, 255, 255, 0.3);\n        }\n        </style>\n\n        <!--\n        Accessibility note: since the navigation offered by the arrow buttons should\n        be redundant (that is, there should be other ways of navigating the list),\n        we mark the button as aria-hidden so that assistive devices ignore them.\n        -->\n        <button id=\"buttonLeft\" class=\"navigationButton\" disabled tabindex=\"-1\" aria-hidden=\"true\">\n          <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n            <g id=\"chevron-left\">\n              <path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"/>\n            </g>\n          </svg>\n        </button>\n        <div id=\"arrowNavigationContainer\" role=\"none\">\n          ${baseTemplate}\n        </div>\n        <button id=\"buttonRight\" class=\"navigationButton\" disabled tabindex=\"-1\" aria-hidden=\"true\">\n          <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n            <g id=\"chevron-right\">\n              <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"/>\n            </g>\n          </svg>\n        </button>\n      `;\n    }\n\n  }\n\n  return ArrowSelection;\n};\n\n\n/*\n * By default, a button will always take focus on mousedown. For this component,\n * we want to override that behavior, such that a mousedown on a button keeps\n * the focus on the outer component.\n */\nfunction assumeButtonFocus(element, button) {\n  button.addEventListener('mousedown', event => {\n    // Given the main element the focus if it doesn't already have it.\n    element.focus();\n    // Prevent the default focus-on-mousedown behavior.\n    event.preventDefault();\n  });\n}\n\nfunction deviceSupportsTouch() {\n  return 'ontouchstart' in window ||\n      (window.DocumentTouch && document instanceof window.DocumentTouch);\n}\n\n// We try to detect the presence of a mouse by listening for mousemove events\n// which are *not* the result of a mousedown. On a touch device, a tap on the\n// page will generate a fake mousemove, followed by a mousedown. We don't want\n// to respond to those fake mousemove events. To discriminate between fake and\n// real mousemove events, when we get a mousemove event, we wait for a bit to\n// see if the same location is reported as the location of a subsequent\n// mousedown.\nfunction listenForMouse(element) {\n\n  element[mousedownListenerSymbol] = event => {\n    if (element[mouseTimeoutSymbol]) {\n      clearTimeout(element[mouseTimeoutSymbol]);\n    }\n    element[lastMouseXSymbol] = event.pageX;\n    element[lastMouseYSymbol] = event.pageY;\n  };\n  window.addEventListener('mousedown', element[mousedownListenerSymbol]);\n\n  element[mousemoveListenerSymbol] = event => {\n    // Postpone checking the mousemove location to give the mousedown event a\n    // chance to fire. The 250 ms delay is just guesswork; a shorter delay\n    // doesn't seem to work.\n    element[mouseTimeoutSymbol] = setTimeout(() => {\n      if (element[lastMouseXSymbol] != null && event.pageX !== element[lastMouseXSymbol] ||\n          element[lastMouseYSymbol] != null && event.pageY !== element[lastMouseYSymbol]) {\n        // mousemove event was at a location other than the last mousedown,\n        // and hence most likely a real mousemove event.\n        mouseDetected(element);\n      } else {\n        element[lastMouseXSymbol] = event.pageX;\n        element[lastMouseYSymbol] = event.pageY;\n      }\n    }, 250);\n  };\n  window.addEventListener('mousemove', element[mousemoveListenerSymbol]);\n}\n\nfunction mouseDetected(element) {\n  showArrows(element);\n\n  // We can stop listening for mouse events now.\n  if (element[mouseTimeoutSymbol]) {\n    clearTimeout(element[mouseTimeoutSymbol]);\n  }\n  window.removeEventListener('mousedown', element[mousedownListenerSymbol]);\n  window.removeEventListener('mousemove', element[mousemoveListenerSymbol]);\n  element[mousedownListenerSymbol] = null;\n  element[mousemoveListenerSymbol] = null;\n}\n\nfunction showArrows(element) {\n  element.classList.add('showArrows');\n}\n","import safeAttributes from './safeAttributes';\n\n\n// Memoized maps of attribute to property names and vice versa.\nconst attributeToPropertyNames = {};\nconst propertyNamesToAttributes = {};\n\n\n/* Exported function extends a base class with AttributeMarshalling. */\nexport default (base) => {\n\n  /**\n   * Mixin which marshalls attributes to properties and vice versa.\n   *\n   * If your component exposes a setter for a property, it's generally a good\n   * idea to let devs using your component be able to set that property in HTML\n   * via an element attribute. You can code that yourself by writing an\n   * `attributeChangedCallback`, or you can use this mixin to get a degree of\n   * automatic support.\n   *\n   * This mixin implements an `attributeChangedCallback` that will attempt to\n   * convert a change in an element attribute into a call to the corresponding\n   * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n   * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n   * respects that convention, automatically mapping the hyphenated attribute\n   * name to the corresponding camelCase property name.\n   *\n   * Example: You define a component using this mixin:\n   *\n   *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n   *       get fooBar() { return this._fooBar; }\n   *       set fooBar(value) { this._fooBar = value; }\n   *     }\n   *     customElements.define('my-element', MyElement);\n   *\n   * If someone then instantiates your component in HTML:\n   *\n   *     <my-element foo-bar=\"Hello\"></my-element>\n   *\n   * Then, after the element has been upgraded, the `fooBar` setter will\n   * automatically be invoked with the initial value \"Hello\".\n   *\n   * For the time being, this mixin only supports string-valued properties.\n   * If you'd like to convert string attributes to other types (numbers,\n   * booleans), you need to implement `attributeChangedCallback` yourself.\n   */\n  class AttributeMarshalling extends base {\n\n    /*\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n      const propertyName = attributeToPropertyName(attributeName);\n      // If the attribute name corresponds to a property name, set the property.\n      // Ignore standard HTMLElement properties handled by the DOM.\n      if (propertyName in this && !(propertyName in HTMLElement.prototype)) {\n        this[propertyName] = newValue;\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    static get observedAttributes() {\n      return attributesForClass(this);\n    }\n\n    /**\n     * Set/unset the attribute with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as an attribute. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes. A call to `reflectAttribute` during the constructor will\n     * be deferred until the element is connected to the document.\n     *\n     * @param {string} attribute - The name of the *attribute* (not property) to set.\n     * @param {object} value - The value to set. If null, the attribute will be removed.\n     */\n    reflectAttribute(attribute, value) {\n      return safeAttributes.setAttribute(this, attribute, value);\n    }\n\n    /**\n     * Set/unset the class with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as as class. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes, including the `class` attribute. A call to\n     * `reflectClass` during the constructor will be deferred until the element\n     * is connected to the document.\n     *\n     * @param {string} className - The name of the class to set.\n     * @param {object} value - True to set the class, false to remove it.\n     */\n    reflectClass(className, value) {\n      return safeAttributes.toggleClass(this, className, value);\n    }\n\n  }\n\n  return AttributeMarshalling;\n};\n\n\n// Convert hyphenated foo-bar attribute name to camel case fooBar property name.\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hypenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hypenRegEx,\n        match => match[1].toUpperCase());\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\nfunction attributesForClass(classFn) {\n\n  // We treat the element base classes as if they have no attributes, since we\n  // don't want to receive attributeChangedCallback for them.\n  if (classFn === HTMLElement || classFn === Object) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n  const baseAttributes = attributesForClass(baseClass);\n\n  // Get attributes for this class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter(propertyName =>\n    typeof Object.getOwnPropertyDescriptor(\n        classFn.prototype, propertyName).set === 'function');\n  const attributes = setterNames.map(setterName =>\n      propertyNameToAttribute(setterName));\n\n  // Merge.\n  const diff = attributes.filter(attribute =>\n      baseAttributes.indexOf(attribute) < 0);\n  return baseAttributes.concat(diff);\n}\n\n// Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, '-$1').toLowerCase();\n  }\n  return attribute;\n}\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with ClickSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps a click (actually, a mousedown) to a selection.\n   *\n   * This simple mixin is useful in list box-like elements, where a click on a\n   * list item implicitly selects it.\n   *\n   * This mixin expects the component to provide an `items` property. You can\n   * provide that property yourself, or use\n   * [ContentItemsMixin](ContentItemsMixin.md). This mixin also expects the\n   * component to define a `selectedIndex` property. You can provide that\n   * yourself, or use [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class ClickSelection extends base {\n\n    constructor() {\n      super();\n      /*\n       * REVIEW: Which event should we listen to here?\n       *\n       * The standard use for this mixin is in list boxes. List boxes don't\n       * appear to be consistent with regard to whether they select on mousedown\n       * or click/mouseup.\n       */\n      this.addEventListener('mousedown', event => {\n        this[symbols.handlingUserInteraction] = true;\n        // HACK: If the item is a button, the event seems to be raised in\n        // phase 2 (AT_TARGET), but the target is the component, not item.\n        // Need to invesigate.\n        const target = event.target === this ?\n          event.path[0] :\n          event.target;\n        const index = indexOfContainingItem(this, target);\n        if (index >= 0) {\n          this.selectedIndex = index;\n          // Note: We don't call preventDefault here. The default behavior for\n          // mousedown includes setting keyboard focus if the element doesn't\n          // already have the focus, and we want to preserve that behavior.\n          event.stopPropagation();\n        }\n        this[symbols.handlingUserInteraction] = false;\n      });\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n    }\n\n  }\n\n  return ClickSelection;\n};\n\n\n/*\n * Return index of the element items that either is or contains the indicated\n * target. Return -1 if not found.\n */\nfunction indexOfContainingItem(element, target) {\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n  for (let i = 0; i < itemCount; i++) {\n    let item = items[i];\n    if (item === target || item.contains(target)) {\n      return i;\n    }\n  }\n  return -1;\n}\n","/* Exported function extends a base class with Composable. */\nexport default (base) => {\n\n  /**\n   * Mixin to make a class more easily composable with other mixins.\n   *\n   * This mixin contributes a `compose` method that applies a set of mixin\n   * functions and returns the resulting new class. This sugar can make the\n   * application of many mixins at once easier to read.\n   */\n  class Composable extends base {\n\n    /**\n     * Apply a set of mixin functions or mixin objects to the present class and\n     * return the new class.\n     *\n     * Instead of writing:\n     *\n     *     let MyClass = Mixin1(Mixin2(Mixin3(Mixin4(Mixin5(BaseClass)))));\n     *\n     * You can write:\n     *\n     *     let MyClass = ComposableMixin(BaseClass).compose(\n     *       Mixin1,\n     *       Mixin2,\n     *       Mixin3,\n     *       Mixin4,\n     *       Mixin5\n     *     );\n     *\n     * This function can also take mixin objects. A mixin object is just a\n     * shorthand for a mixin function that creates a new subclass with the given\n     * members. The mixin object's members are *not* copied directly onto the\n     * prototype of the base class, as with traditional mixins.\n     *\n     * In addition to providing syntactic sugar, this mixin can be used to\n     * define a class in ES5, which lacks ES6's `class` keyword.\n     *\n     * @param {...mixins} mixins - A set of mixin functions or objects to apply.\n     */\n    static compose(...mixins) {\n      // We create a new subclass for each mixin in turn. The result becomes\n      // the base class extended by any subsequent mixins. It turns out that\n      // we can use Array.reduce() to concisely express this, using the current\n      // object as the seed for reduce().\n      return mixins.reduce(composeClass, this);\n    }\n\n  }\n\n  return Composable;\n};\n\n\n// Properties defined by Object that we don't want to mixin.\nconst NON_MIXABLE_OBJECT_PROPERTIES = [\n  'constructor'\n];\n\n/*\n * Apply the mixin to the given base class to return a new class.\n * The mixin can either be a function that returns the modified class, or a\n * plain object whose members will be copied to the new class' prototype.\n */\nfunction composeClass(base, mixin) {\n  if (typeof mixin === 'function') {\n    // Mixin function\n    return mixin(base);\n  } else {\n    // Mixin object\n    class Subclass extends base {}\n    copyOwnProperties(mixin, Subclass.prototype, NON_MIXABLE_OBJECT_PROPERTIES);\n    return Subclass;\n  }\n}\n\n\n/*\n * Copy the given properties/methods to the target.\n * Return the updated target.\n */\nfunction copyOwnProperties(source, target, ignorePropertyNames = []) {\n  Object.getOwnPropertyNames(source).forEach(name => {\n    if (ignorePropertyNames.indexOf(name) < 0) {\n      const descriptor = Object.getOwnPropertyDescriptor(source, name);\n      Object.defineProperty(target, name, descriptor);\n    }\n  });\n  return target;\n}\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemsSymbol = createSymbol('items');\nconst itemInitializedSymbol = createSymbol('itemInitialized');\n\n\n/* Exported function extends a base class with ContentItems. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps content semantics (elements) to list item semantics.\n   *\n   * Items differ from element contents in several ways:\n   *\n   * * They are often referenced via index.\n   * * They may have a selection state.\n   * * It's common to do work to initialize the appearance or state of a new\n   *   item.\n   * * Auxiliary invisible child elements are filtered out and not counted as\n   *   items. Auxiliary elements include link, script, style, and template\n   *   elements. This filtering ensures that those auxiliary elements can be\n   *   used in markup inside of a list without being treated as list items.\n   *\n   * This mixin expects a component to provide a `content` property returning a\n   * raw set of elements. You can provide that yourself, or use\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md).\n   *\n   * The most commonly referenced property defined by this mixin is the `items`\n   * property. To avoid having to do work each time that property is requested,\n   * this mixin supports an optimized mode. If you invoke the `contentChanged`\n   * method when the set of items changes, the mixin concludes that you'll take\n   * care of notifying it of future changes, and turns on the optimization. With\n   * that on, the mixin saves a reference to the computed set of items, and will\n   * return that immediately on subsequent calls to the `items` property. If you\n   * use this mixin in conjunction with\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md), the\n   * `contentChanged` method will be invoked for you when the element's children\n   * change, turning on the optimization automatically.\n   */\n  class ContentItems extends base {\n\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n\n      // Since we got the contentChanged call, we'll assume we'll be notified if\n      // the set of items changes later. We turn on memoization of the items\n      // property by setting our internal property to null (instead of\n      // undefined).\n      this[itemsSymbol] = null;\n\n      this[symbols.itemsChanged]();\n    }\n\n    /**\n     * This method is invoked whenever a new item is added to the list.\n     *\n     * The default implementation of this method does nothing. You can override\n     * this to perform per-item initialization.\n     *\n     * @param {HTMLElement} item - The item that was added.\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n    }\n\n    /**\n     * The selection state for a single item has changed.\n     *\n     * Invoke this method to signal that the selected state of the indicated item\n     * has changed. By default, this applies a `selected` CSS class if the item\n     * is selected, and removed it if not selected.\n     *\n     * @param {HTMLElement} item - The item whose selection state has changed.\n     * @param {boolean} selected - True if the item is selected, false if not.\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      toggleClass(item, 'selected', selected);\n    }\n\n    /**\n     * The current set of items in the list. See the top-level documentation for\n     * mixin for a description of how items differ from plain content.\n     *\n     * @type {HTMLElement[]}\n     */\n    get items() {\n      let items;\n      if (this[itemsSymbol] == null) {\n        items = filterAuxiliaryElements(this.content);\n        // Note: test for *equality* with null; don't treat undefined as a match.\n        if (this[itemsSymbol] === null) {\n          // Memoize the set of items.\n          this[itemsSymbol] = items;\n        }\n      } else {\n        // Return the memoized items.\n        items = this[itemsSymbol];\n      }\n      return items;\n    }\n\n    /**\n     * This method is invoked when the underlying contents change. It is also\n     * invoked on component initialization – since the items have \"changed\" from\n     * being nothing.\n     */\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // Perform per-item initialization.\n      Array.prototype.forEach.call(this.items, item => {\n        if (!item[itemInitializedSymbol]) {\n          this[symbols.itemAdded](item);\n          item[itemInitializedSymbol] = true;\n        }\n      });\n\n      if (this[symbols.handlingUserInteraction]) {\n        this.dispatchEvent(new CustomEvent('items-changed'));\n      }\n    }\n\n    /**\n     * Fires when the items in the list change.\n     *\n     * @memberof ContentItems\n     * @event items-changed\n     */\n  }\n\n  return ContentItems;\n};\n\n\n// Return the given elements, filtering out auxiliary elements that aren't\n// typically visible. Items which are not elements are returned as is.\nfunction filterAuxiliaryElements(items) {\n  const auxiliaryTags = [\n    'link',\n    'script',\n    'style',\n    'template'\n  ];\n  return [].filter.call(items, function(item) {\n    return !item.localName || auxiliaryTags.indexOf(item.localName) < 0;\n  });\n}\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with DirectionSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps direction semantics (goLeft, goRight, etc.) to selection\n   * semantics (selectPrevious, selectNext, etc.).\n   *\n   * This mixin can be used in conjunction with\n   * [KeyboardDirectionMixin](KeyboardDirectionMixin.md) (which maps keyboard\n   * events to directions) and a mixin that handles selection like\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class DirectionSelection extends base {\n\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { super[symbols.goDown](); }\n      return this.selectNext();\n    }\n\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { super[symbols.goEnd](); }\n      return this.selectLast();\n    }\n\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { super[symbols.goLeft](); }\n      return this.selectPrevious();\n    }\n\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { super[symbols.goRight](); }\n      return this.selectNext();\n    }\n\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { super[symbols.goStart](); }\n      return this.selectFirst();\n    }\n\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { super[symbols.goUp](); }\n      return this.selectPrevious();\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    get selectedFraction() {\n      return super.selectedFraction;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectFirst() {\n      if (super.selectFirst) { return super.selectFirst(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectLast() {\n      if (super.selectLast) { return super.selectLast(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectNext() {\n      if (super.selectNext) { return super.selectNext(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectPrevious() {\n      if (super.selectPrevious) { return super.selectPrevious(); }\n    }\n\n    // Map drag travel fraction to selection fraction.\n    get travelFraction() {\n      return super.travelFraction;\n    }\n    set travelFraction(value) {\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n      this.selectedFraction = value;\n    }\n\n  }\n\n  return DirectionSelection;\n};\n","import microtask from './microtask';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/* Exported function extends a base class with DistributedChildrenContent. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines a component's content as its children, expanding any\n   * nodes distributed to the component's slots.\n   *\n   * This also provides notification of changes to a component's content. It\n   * will invoke a `contentChanged` method when the component is first\n   * instantiated, and whenever its distributed children change. This is an\n   * easy way to satisfy the Gold Standard checklist item for monitoring\n   * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n   *\n   * Example:\n   *\n   * ```\n   * let base = DistributedChildrenContentMixin(DistributedChildrenMixin(HTMLElement));\n   * class CountingElement extends base {\n   *\n   *   constructor() {\n   *     super();\n   *     let root = this.attachShadow({ mode: 'open' });\n   *     root.innerHTML = `<slot></slot>`;\n   *   }\n   *\n   *   contentChanged() {\n   *     // Count the component's children, both initially and when changed.\n   *     this.count = this.distributedChildren.length;\n   *   }\n   *\n   * }\n   * ```\n   *\n   * Note that content change detection depends upon the element having at least\n   * one `slot` element in its shadow subtree.\n   *\n   * This mixin is intended for use with the\n   * [DistributedChildrenMixin](DistributedChildrenMixin.md). See that mixin for\n   * a discussion of how that works. This DistributedChildrenContentMixin\n   * provides an easy way of defining the \"content\" of a component as the\n   * component's distributed children. That in turn lets mixins like\n   * [ContentItemsMixin](ContentItemsMixin.md) manipulate the children as list\n   * items.\n   */\n  class DistributedChildrenContent extends base {\n\n    constructor() {\n      super();\n\n      if (this.shadowRoot) {\n        // Listen to changes on all slots.\n        const slots = this.shadowRoot.querySelectorAll('slot');\n        slots.forEach(slot => slot.addEventListener('slotchange', event => {\n          this.contentChanged();\n        }));\n      }\n\n      // Make an initial call to contentChanged() so that the component can do\n      // initialization that it normally does when content changes.\n      //\n      // This will invoke contentChanged() handlers in other mixins. In order\n      // that those mixins have a chance to complete their own initialization,\n      // we add the contentChanged() call to the microtask queue.\n      microtask(() => this.contentChanged());\n    }\n\n    /**\n     * Invoked when the contents of the component (including distributed\n     * children) have changed.\n     *\n     * This method is also invoked when a component is first instantiated; the\n     * contents have essentially \"changed\" from being nothing. This allows the\n     * component to perform initial processing of its children.\n     */\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n      if (this[symbols.handlingUserInteraction]) {\n        const event = new CustomEvent('content-changed');\n        this.dispatchEvent(event);\n      }\n    }\n\n    /**\n     * The content of this component, defined to be the flattened array of\n     * children distributed to the component.\n     *\n     * @type {HTMLElement[]}\n     */\n    get content() {\n      const distributedChildren = this.distributedChildren;\n      if (typeof distributedChildren === 'undefined') {\n        console.warn(`DistributedChildrenContentMixin expects the component to define a \"distributedChildren\" property.`);\n      }\n      return distributedChildren;\n    }\n    set content(value) {\n      if ('content' in base.prototype) { super.content = value; }\n      // TODO: Set the children to the given value (which should be an array of\n      // elements)?\n    }\n\n    /**\n     * This event is raised when the component's contents (including distributed\n     * children) have changed.\n     *\n     * @memberof DistributedChildrenContent\n     * @event content-changed\n     */\n  }\n\n  return DistributedChildrenContent;\n};\n","/* Exported function extends a base class with DistributedChildren. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines helpers for accessing a component's distributed\n   * children as a flattened array or string.\n   *\n   * The standard DOM API provides several ways of accessing child content:\n   * `children`, `childNodes`, and `textContent`. None of these functions are\n   * Shadow DOM aware. This mixin defines variations of those functions that\n   * *are* Shadow DOM aware.\n   *\n   * Example: you create a component `<count-children>` that displays a number\n   * equal to the number of children placed inside that component. If someone\n   * instantiates your component like:\n   *\n   *     <count-children>\n   *       <div></div>\n   *       <div></div>\n   *       <div></div>\n   *     </count-children>\n   *\n   * Then the component should show \"3\", because there are three children. To\n   * calculate the number of children, the component can just calculate\n   * `this.children.length`. However, suppose someone instantiates your\n   * component inside one of their own components, and puts a `<slot>` element\n   * inside your component:\n   *\n   *     <count-children>\n   *       <slot></slot>\n   *     </count-children>\n   *\n   * If your component only looks at `this.children`, it will always see exactly\n   * one child — the `<slot>` element. But the user looking at the page will\n   * *see* any nodes distributed to that slot. To match what the user sees, your\n   * component should expand any `<slot>` elements it contains.\n   *\n   * That is the problem this mixin solves. After applying this mixin, your\n   * component code has access to `this.distributedChildren`, whose `length`\n   * will return the total number of all children distributed to your component\n   * in the composed tree.\n   *\n   * Note: The latest Custom Elements API design calls for a new function,\n   * `getAssignedNodes` that takes an optional `deep` parameter, that will solve\n   * this problem at the API level.\n   */\n  class DistributedChildren extends base {\n\n    /**\n     * An in-order collection of distributed children, expanding any slot\n     * elements. Like the standard children property, this skips text nodes.\n     *\n     * @type {HTMLElement[]}\n     */\n    get distributedChildren() {\n      return expandContentElements(this.children, false);\n    }\n\n    /**\n     * An in-order collection of distributed child nodes, expanding any slot\n     * elements. Like the standard childNodes property, this includes text\n     * nodes.\n     *\n     * @type {Node[]}\n     */\n    get distributedChildNodes() {\n      return expandContentElements(this.childNodes, true);\n    }\n\n    /**\n     * The concatenated text content of all distributed child nodes, expanding\n     * any slot elements.\n     *\n     * @type {string}\n     */\n    get distributedTextContent() {\n      const strings = this.distributedChildNodes.map(function(child) {\n        return child.textContent;\n      });\n      return strings.join('');\n    }\n\n  }\n\n  return DistributedChildren;\n};\n\n\n/*\n * Given a array of nodes, return a new array with any content elements expanded\n * to the nodes distributed to that content element. This rule is applied\n * recursively.\n *\n * If includeTextNodes is true, text nodes will be included, as in the\n * standard childNodes property; by default, this skips text nodes, like the\n * standard children property.\n */\nfunction expandContentElements(nodes, includeTextNodes) {\n  const expanded = Array.prototype.map.call(nodes, node => {\n    // We want to see if the node is an instanceof HTMLSlotELement, but\n    // that class won't exist if the browser that doesn't support native\n    // Shadow DOM and if the Shadow DOM polyfill hasn't been loaded. Instead,\n    // we do a simplistic check to see if the tag name is \"slot\".\n    const isSlot = typeof HTMLSlotElement !== 'undefined' ?\n      node instanceof HTMLSlotElement :\n      node.localName === 'slot';\n    if (isSlot) {\n      // Use the nodes assigned to this node instead.\n      const assignedNodes = node.assignedNodes({ flatten: true });\n      return assignedNodes ?\n        expandContentElements(assignedNodes, includeTextNodes) :\n        [];\n    } else if (node instanceof HTMLElement) {\n      // Plain element; use as is.\n      return [node];\n    } else if (node instanceof Text && includeTextNodes) {\n      // Text node.\n      return [node];\n    } else {\n      // Comment, processing instruction, etc.; skip.\n      return [];\n    }\n  });\n  const flattened = [].concat(...expanded);\n  return flattened;\n}\n","import createSymbol from './createSymbol';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n// Symbols for private data members on an element.\nconst selectedFractionSymbol = createSymbol('selectedFraction');\n\n\n/* Exported function extends a base class with FractionalSelection. */\nexport default function mixin(base) {\n\n  /**\n   * Adds support for fractional selection: treating a selection as a real\n   * number that combines an integer portion (an index into a list), and a\n   * fraction (indicating how far of the way we are to the next or previous\n   * item).\n   *\n   * This is useful in components that support incremental operations during\n   * dragging and swiping. Example: a carousel component has several items, and the\n   * currently selected item is item 3. The user begins swiping to the left,\n   * moving towards selecting item 4. Halfway through this operation, the\n   * fractional selection value is 3.5.\n   *\n   * This value permits communication between mixins like\n   * [SwipeDirectionMixin](./SwipeDirectionMixin.md) and\n   * [TrackpadDirectionMixin](./TrackpadDirectionMixin.md), which generate\n   * fractional selection values, and mixins like\n   * [SelectionAnimationMixin](./SelectionAnimationMixin.md), which can render\n   * selection at a fractional value.\n   */\n  class FractionalSelection extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      this.selectedFraction = 0;\n    }\n\n    /**\n     * A fractional value indicating how far the user has currently advanced to\n     * the next/previous item. E.g., a `selectedFraction` of 3.5 indicates the\n     * user is halfway between items 3 and 4.\n     *\n     * @type {number}\n     */\n    get selectedFraction() {\n      return this[selectedFractionSymbol];\n    }\n    set selectedFraction(value) {\n      this[selectedFractionSymbol] = value;\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      if (this[symbols.handlingUserInteraction]) {\n        const event = new CustomEvent('selected-fraction-changed');\n        this.dispatchEvent(event);\n      }\n    }\n\n  }\n\n  return FractionalSelection;\n}\n\n\nmixin.helpers = {\n\n  /*\n   * Dampen a selection that goes past the beginning or end of a list. This is\n   * generally used to produce a visual effect of tension as the user tries to\n   * go further in a direction that has no more items.\n   *\n   * Example: suppose `itemCount` is 5, indicating a list of 5 items. The index of\n   * the last item is 4. If the `selection` parameter is 4.5, the user is trying\n   * to go past this last item. When a damping function is applied, the resulting\n   * value will be less than 4.5 (the actual value will be 4.25). When this\n   * selection state is rendered, the user will see that, each unit distance the\n   * drag travels has less and less visible effect. This is perceived as tension.\n   *\n   * @param {number} selection - A real number indicating a selection position\n   * @param {number} itemCount - An integer for the number of items in the list\n   * @returns {number} A real number representing the damped selection value.\n   */\n  dampedSelection(selection, itemCount) {\n    const bound = itemCount - 1;\n    let damped;\n    if (selection < 0) {\n      // Trying to go past beginning of list. Apply tension from the left edge.\n      damped = -mixin.helpers.damping(-selection);\n    } else if (selection >= bound) {\n      // Trying to go past end of list. Apply tension from the right edge.\n      damped = bound + mixin.helpers.damping(selection - bound);\n    } else {\n      // No damping required.\n      damped = selection;\n    }\n    return damped;\n  },\n\n  /*\n   * Calculate damping as a function of the distance past the minimum/maximum\n   * values.\n   *\n   * We want to asymptotically approach an absolute minimum of 1 unit\n   * below/above the actual minimum/maximum. This requires calculating a\n   * hyperbolic function.\n   *\n   * See http://www.wolframalpha.com/input/?i=y+%3D+-1%2F%28x%2B1%29+%2B+1\n   * for the one we use. The only portion of that function we care about is when\n   * x is zero or greater. An important consideration is that the curve be\n   * tangent to the diagonal line x=y at (0, 0). This ensures smooth continuity\n   * with the normal drag behavior, in which the visible sliding is linear with\n   * the distance the touchpoint has been dragged.\n   */\n  damping(x) {\n    const y = (-1 / (x + 1)) + 1;\n    return y;\n  },\n\n  /*\n   * Return the current fractional selection value for the given element.\n   *\n   * This simply adds the element's `selectedIndex` and `selectedFraction`\n   * properties.\n   *\n   * @param {HTMLElement} element - An element that supports selection\n   */\n  elementSelection(element) {\n    const selectedIndex = element.selectedIndex;\n    if (selectedIndex < 0) {\n      // No selection\n      return;\n    }\n    const selectedFraction = element.selectedFraction || 0;\n    return selectedIndex + selectedFraction;\n  },\n\n  /*\n   * Breaks a fractional selection into its integer and fractional parts.\n   *\n   * Example: if passed 3.5, this returns { index: 3, fraction: 5 }.\n   *\n   * @param {number} selection – A real number representing a selection point\n   * @returns {object} - An object with an `index` property holding the\n   * selection's integer component, and a `fraction` property holding the\n   * selection's fractional component.\n   */\n  selectionParts(selection) {\n    // Stupid IE doesn't have Math.trunc.\n    // const index = Math.trunc(selection);\n    const index = selection < 0 ? Math.ceil(selection) : Math.floor(selection);\n    const fraction = selection - index;\n    return { index, fraction };\n  },\n\n  /*\n   * Returns a fractional selection point after accounting for wrapping, ensuring\n   * that the integer portion of the selection stays between 0 and `itemCount`-1.\n   * That is, the integer portion will always be a valid index into the list.\n   *\n   * Example of wrapping past the end of the list: if `selection` is 5.5 and\n   * `itemCount` is 5, this returns 0.5. Example of wrapping past the beginning of\n   * the list: if `selection` is 0.5 and `itemCount` is 5, this returns 4.5.\n   *\n   * @param {number} selection - A real number representing a selection point\n   * @param {number} itemCount - The number of items in the list\n   * @returns {number} - The result of wrapping the selection point\n   */\n  wrappedSelection(selection, itemCount) {\n    // Handles possibility of negative mod.\n    // See http://stackoverflow.com/a/18618250/76472\n    return ((selection % itemCount) + itemCount) % itemCount;\n  },\n\n  /*\n   * Return the parts of a selection, first wrapping if necessary.\n   *\n   * @param {number} selection – A real number representing a selection point\n   * @param {number} itemCount - The number of items in the list\n   * @param {boolean} wrap – True if the selection should wrap to stay within the\n   * list\n   * @returns {object} – The parts of the selection, using the same format as\n   * `selectionParts`.\n   */\n  wrappedSelectionParts(selection, itemCount, wrap) {\n    if (wrap) {\n      selection = mixin.helpers.wrappedSelection(selection, itemCount);\n    }\n    return mixin.helpers.selectionParts(selection);\n  }\n\n};\n","import createSymbol from './createSymbol';\nimport safeAttributes from './safeAttributes';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst genericSymbol = createSymbol('generic');\n\n\n/* Exported function extends a base class with Generic. */\nexport default (base) => {\n\n  /**\n   * Mixin which allows a component to support a \"generic\" style: a minimalist\n   * style that can easily be removed to reset its visual appearance to a\n   * baseline state.\n   *\n   * By default, a component should provide a minimal visual presentation that\n   * allows the component to function. However, the more styling the component\n   * provides by default, the harder it becomes to get the component to fit in\n   * in other settings. Each CSS rule has to be overridden. Worse, new CSS rules\n   * added to the default style won't be overridden by default, making it hard\n   * to know whether a new version of a component will still look okay.\n   *\n   * As a compromise, the mixin defines a `generic` attribute. This attribute is\n   * normally set by default, and styles can be written that apply only when the\n   * generic attribute is set. This allows the construction of CSS rules that\n   * will only apply to generic components like:\n   *\n   *     :host([generic=\"\"]) {\n   *       ... generic appearance defined here ...\n   *     }\n   *\n   * This makes it easy to remove all default styling — set the `GenericMixin`\n   * attribute to false, and all default styling will be removed.\n   */\n  class Generic extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.generic === 'undefined') {\n        this.generic = this[symbols.defaults].generic;\n      }\n    }\n\n    // This mixin doesn't actually respond to attribute changes, but relies\n    // on separately-defined behavior (e.g., in AttributeMarshallingMixin) for that.\n    // Still, we need define a baseline attributeChangedCallback that does\n    // nothing, in case this mixin gets used on its own.\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(name, oldValue, newValue); }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.generic = true;\n      return defaults;\n    }\n\n    /**\n     * True if the component would like to receive generic styling.\n     *\n     * This property is true by default — set it to false to turn off all\n     * generic styles. This makes it easier to apply custom styling; you won't\n     * have to explicitly override styling you don't want.\n     *\n     * @type Boolean\n     * @default true\n     */\n    get generic() {\n      return this[genericSymbol];\n    }\n    set generic(value) {\n      const parsed = typeof value === 'string' ?\n        String(value) !== 'false' :\n        value;\n      this[genericSymbol] = parsed;\n\n      if ('generic' in base.prototype) { super.generic = value; }\n\n      // We roll our own attribute setting so that an explicitly false value\n      // shows up as GenericMixin=\"false\".\n      if (parsed === false) {\n        // Explicitly use false string.\n        safeAttributes.setAttribute(this, 'generic', 'false');\n      } else if (parsed == null) {\n        // Explicitly remove attribute. (Always safe to do this.)\n        this.removeAttribute('generic');\n      } else {\n        // Use the empty string to get attribute to appear with no value.\n        safeAttributes.setAttribute(this, 'generic', '');\n      }\n    }\n\n  }\n\n  return Generic;\n};\n\n\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst navigationAxisSymbol = createSymbol('navigationAxis');\n\n\n/* Exported function extends a base class with KeyboardDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps direction keys (Left, Right, etc.) to direction semantics\n   * (go left, go right, etc.).\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   *\n   * This mixin calls methods such as `goLeft` and `goRight`. You can define\n   * what that means by implementing those methods yourself. If you want to use\n   * direction keys to navigate a selection, use this mixin with\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n   */\n  class KeyboardDirection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.navigationAxis === 'undefined') {\n        this.navigationAxis = this[symbols.defaults].navigationAxis;\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.navigationAxis = 'both';\n      return defaults;\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate down.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { return super[symbols.goDown](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the end (e.g., of a list).\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { return super[symbols.goEnd](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the start (e.g., of a\n     * list). The default implementation of this method does nothing.\n     */\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { return super[symbols.goStart](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate up.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { return super[symbols.goUp](); }\n    }\n\n    /**\n     * Indicates the direction of permitted navigation with the keyboard.\n     *\n     * Accepted values are \"horizontal\", \"vertical\", or \"both\" (the default).\n     * If this property is \"horizontal\", the Up Arrow and Down Arrow keys will\n     * be ignored. Conversely, if this is \"vertical\", the Left Arrow and Right\n     * Arrow keys will be ignored.\n     *\n     * @type {string}\n     */\n    get navigationAxis() {\n      return this[navigationAxisSymbol];\n    }\n    set navigationAxis(value) {\n      this[navigationAxisSymbol] = value;\n      if ('navigationAxis' in base.prototype) { super.navigationAxis = value; }\n    }\n\n    [symbols.keydown](event) {\n      let handled;\n\n      const axis = this.navigationAxis;\n      const horizontal = (axis === 'horizontal' || axis === 'both');\n      const vertical = (axis === 'vertical' || axis === 'both');\n\n      // Ignore Left/Right keys when metaKey or altKey modifier is also pressed,\n      // as the user may be trying to navigate back or forward in the browser.\n      switch (event.keyCode) {\n        case 35: // End\n          handled = this[symbols.goEnd]();\n          break;\n        case 36: // Home\n          handled = this[symbols.goStart]();\n          break;\n        case 37: // Left\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goLeft]();\n          }\n          break;\n        case 38: // Up\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goStart]() : this[symbols.goUp]();\n          }\n          break;\n        case 39: // Right\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goRight]();\n          }\n          break;\n        case 40: // Down\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goEnd]() : this[symbols.goDown]();\n          }\n          break;\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n  }\n\n  return KeyboardDirection;\n};\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with Keyboard. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages the keydown handling for a component.\n   *\n   * This mixin handles several keyboard-related features.\n   *\n   * First, it wires up a single keydown event handler that can be shared by\n   * multiple mixins on a component. The event handler will invoke a `keydown`\n   * method with the event object, and any mixin along the prototype chain that\n   * wants to handle that method can do so.\n   *\n   * If a mixin wants to indicate that keyboard event has been handled, and that\n   * other mixins should *not* handle it, the mixin's `keydown` handler should\n   * return a value of true. The convention that seems to work well is that a\n   * mixin should see if it wants to handle the event and, if not, then ask the\n   * superclass to see if it wants to handle the event. This has the effect of\n   * giving the mixin that was applied last the first chance at handling a\n   * keyboard event.\n   *\n   * Example:\n   *\n   *     [symbols.keydown](event) {\n   *       let handled;\n   *       switch (event.keyCode) {\n   *         // Handle the keys you want, setting handled = true if appropriate.\n   *       }\n   *       // Prefer mixin result if it's defined, otherwise use base result.\n   *       return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n   *     }\n   *\n   * A second feature provided by this mixin is that it implicitly makes the\n   * component a tab stop if it isn't already, by setting `tabIndex` to 0. This\n   * has the effect of adding the component to the tab order in document order.\n   */\n  class Keyboard extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('keydown', event => {\n        this[symbols.handlingUserInteraction] = true;\n        const handled = this[symbols.keydown](event);\n        if (handled) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n        this[symbols.handlingUserInteraction] = false;\n      });\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (this.getAttribute('tabindex') == null && this[symbols.defaults].tabindex !== null) {\n        this.setAttribute('tabindex', this[symbols.defaults].tabindex);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      // The default tab index is 0 (document order).\n      defaults.tabindex = 0;\n      return defaults;\n    }\n\n    /**\n     * Handle the indicated keyboard event.\n     *\n     * The default implementation of this method does nothing. This will\n     * typically be handled by other mixins.\n     *\n     * @param {KeyboardEvent} event - the keyboard event\n     * @return {boolean} true if the event was handled\n     */\n    [symbols.keydown](event) {\n      if (super[symbols.keydown]) { return super[symbols.keydown](event); }\n    }\n\n  }\n\n  return Keyboard;\n};\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with KeyboardPagedSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps page keys (Page Up, Page Down) into operations that move\n   * the selection by one page.\n   *\n   * The keyboard interaction model generally follows that of Microsoft Windows'\n   * list boxes instead of those in OS X:\n   *\n   * * The Page Up/Down and Home/End keys actually change the selection, rather\n   *   than just scrolling. The former behavior seems more generally useful for\n   *   keyboard users.\n   *\n   * * Pressing Page Up/Down will change the selection to the topmost/bottommost\n   *   visible item if the selection is not already there. Thereafter, the key\n   *   will move the selection up/down by a page, and (per the above point) make\n   *   the selected item visible.\n   *\n   * To ensure the selected item is in view following use of Page Up/Down, use\n   * the related [SelectionInViewMixin](SelectionInViewMixin.md).\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   */\n  class KeyboardPagedSelection extends base {\n\n    [symbols.keydown](event) {\n      let handled;\n      switch (event.keyCode) {\n        case 33: // Page Up\n          handled = this.pageUp();\n          break;\n        case 34: // Page Down\n          handled = this.pageDown();\n          break;\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    /**\n     * Scroll down one page.\n     */\n    pageDown() {\n      if (super.pageDown) { super.pageDown(); }\n      return scrollOnePage(this, true);\n    }\n\n    /**\n     * Scroll up one page.\n     */\n    pageUp() {\n      if (super.pageUp) { super.pageUp(); }\n      return scrollOnePage(this, false);\n    }\n\n    /**\n     * The element that should be scrolled with the Page Up/Down keys.\n     * Default is the current element.\n     *\n     * @type {HTMLElement}\n     */\n    get scrollTarget() {\n      // Prefer base result.\n      return 'scrollTarget' in base.prototype ? super.scrollTarget : this;\n    }\n    set scrollTarget(element) {\n      if ('scrollTarget' in base.prototype) { super.scrollTarget = element; }\n    }\n  }\n\n  return KeyboardPagedSelection;\n};\n\n\n// Return the item whose content spans the given y position (relative to the\n// top of the list's scrolling client area), or null if not found.\n//\n// If downward is true, move down the list of items to find the first item\n// found at the given y position; if downward is false, move up the list of\n// items to find the last item at that position.\nfunction getIndexOfItemAtY(element, y, downward) {\n  const items = element.items;\n  const start = downward ? 0 : items.length - 1;\n  const end = downward ? items.length : 0;\n  const step = downward ? 1 : -1;\n  const scrollTarget = element.scrollTarget;\n  const topOfClientArea = scrollTarget.offsetTop + scrollTarget.clientTop;\n\n  // Find the item spanning the indicated y coordinate.\n  let item;\n  let itemIndex = start;\n  let itemTop;\n  let found = false;\n  while (itemIndex !== end) {\n    item = items[itemIndex];\n    itemTop = item.offsetTop - topOfClientArea;\n    const itemBottom = itemTop + item.offsetHeight;\n    if (itemTop <= y && itemBottom >= y) {\n      // Item spans the indicated y coordinate.\n      found = true;\n      break;\n    }\n    itemIndex += step;\n  }\n\n  if (!found) {\n    return null;\n  }\n\n  // We may have found an item whose padding spans the given y coordinate,\n  // but whose content is actually above/below that point.\n  // TODO: If the item has a border, then padding should be included in\n  // considering a hit.\n  const itemStyle = getComputedStyle(item);\n  const itemPaddingTop = parseFloat(itemStyle.paddingTop);\n  const itemPaddingBottom = parseFloat(itemStyle.paddingBottom);\n  const contentTop = itemTop + item.clientTop + itemPaddingTop;\n  const contentBottom = contentTop + item.clientHeight - itemPaddingTop - itemPaddingBottom;\n  if (downward && contentTop <= y || !downward && contentBottom >= y) {\n    // The indicated coordinate hits the actual item content.\n    return itemIndex;\n  }\n  else {\n    // The indicated coordinate falls within the item's padding. Back up to\n    // the item below/above the item we found and return that.\n    return itemIndex - step;\n  }\n}\n\n// Move by one page downward (if downward is true), or upward (if false).\n// Return true if we ended up changing the selection, false if not.\n// TODO: Better support for horizontal lists.\nfunction scrollOnePage(element, downward) {\n\n  // Determine the item visible just at the edge of direction we're heading.\n  // We'll select that item if it's not already selected.\n  const scrollTarget = element.scrollTarget;\n  const edge = scrollTarget.scrollTop + (downward ? scrollTarget.clientHeight : 0);\n  const indexOfItemAtEdge = getIndexOfItemAtY(element, edge, downward);\n\n  const selectedIndex = element.selectedIndex;\n  let newIndex;\n  if (indexOfItemAtEdge && selectedIndex === indexOfItemAtEdge) {\n    // The item at the edge was already selected, so scroll in the indicated\n    // direction by one page. Leave the new item at that edge selected.\n    const delta = (downward ? 1 : -1) * scrollTarget.clientHeight;\n    newIndex = getIndexOfItemAtY(element, edge + delta, downward);\n  }\n  else {\n    // The item at the edge wasn't selected yet. Instead of scrolling, we'll\n    // just select that item. That is, the first attempt to page up/down\n    // usually just moves the selection to the edge in that direction.\n    newIndex = indexOfItemAtEdge;\n  }\n\n  if (!newIndex) {\n    // We can't find an item in the direction we want to travel. Select the\n    // last item (if moving downward) or first item (if moving upward).\n    newIndex = (downward ? element.items.length - 1 : 0);\n  }\n\n  if (newIndex !== selectedIndex) {\n    element.selectedIndex = newIndex;\n    return true; // We handled the page up/down ourselves.\n  }\n  else {\n    return false; // We didn't do anything.\n  }\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemTextContentsSymbol = createSymbol('itemTextContents');\nconst typedPrefixSymbol = createSymbol('typedPrefix');\nconst prefixTimeoutSymbol = createSymbol('prefixTimeout');\n\n\n/* Exported function extends a base class with KeyboardPrefixSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin that handles list box-style prefix typing, in which the user can type\n   * a string to select the first item that begins with that string.\n   *\n   * Example: suppose a component using this mixin has the following items:\n   *\n   *     <sample-list-component>\n   *       <div>Apple</div>\n   *       <div>Apricot</div>\n   *       <div>Banana</div>\n   *       <div>Blackberry</div>\n   *       <div>Blueberry</div>\n   *       <div>Cantaloupe</div>\n   *       <div>Cherry</div>\n   *       <div>Lemon</div>\n   *       <div>Lime</div>\n   *     </sample-list-component>\n   *\n   * If this component receives the focus, and the user presses the \"b\" or \"B\"\n   * key, the \"Banana\" item will be selected, because it's the first item that\n   * matches the prefix \"b\". (Matching is case-insensitive.) If the user now\n   * presses the \"l\" or \"L\" key quickly, the prefix to match becomes \"bl\", so\n   * \"Blackberry\" will be selected.\n   *\n   * The prefix typing feature has a one second timeout — the prefix to match\n   * will be reset after a second has passed since the user last typed a key.\n   * If, in the above example, the user waits a second between typing \"b\" and\n   * \"l\", the prefix will become \"l\", so \"Lemon\" would be selected.\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   *\n   * This mixin also expects the component to provide an `items` property. The\n   * `textContent` of those items will be used for purposes of prefix matching.\n   */\n  class KeyboardPrefixSelection extends base {\n\n    // TODO: If the set of items is changed, reset the prefix.\n    // [symbols.itemsChanged]() {\n    //   this[itemTextContentsSymbol] = null;\n    //   resetTypedPrefix(this);\n    // }\n\n    // TODO: If the selection is changed by some other means (e.g., arrow keys)\n    // other than prefix typing, then that act should reset the prefix.\n\n    [symbols.keydown](event) {\n      let handled;\n      let resetPrefix = true;\n\n      switch (event.keyCode) {\n        case 8: // Backspace\n          handleBackspace(this);\n          handled = true;\n          resetPrefix = false;\n          break;\n        case 27: // Escape\n          handled = true;\n          break;\n        default:\n          if (!event.ctrlKey && !event.metaKey && !event.altKey &&\n              event.which !== 32 /* Space */) {\n            handlePlainCharacter(this, String.fromCharCode(event.which));\n          }\n          resetPrefix = false;\n      }\n\n      if (resetPrefix) {\n        resetTypedPrefix(this);\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    /**\n     * Select the first item whose text content begins with the given prefix.\n     *\n     * @param prefix [String] The prefix string to search for\n     */\n    selectItemWithTextPrefix(prefix) {\n      if (super.selectItemWithTextPrefix) { super.selectItemWithTextPrefix(prefix); }\n      if (prefix == null || prefix.length === 0) {\n        return;\n      }\n      const index = getIndexOfItemWithTextPrefix(this, prefix);\n      if (index >= 0) {\n        this.selectedIndex = index;\n      }\n    }\n\n  }\n\n  return KeyboardPrefixSelection;\n};\n\n\n// Time in milliseconds after which the user is considered to have stopped\n// typing.\nconst PREFIX_TIMEOUT_DURATION = 1000;\n\n\n// Return the index of the first item with the given prefix, else -1.\nfunction getIndexOfItemWithTextPrefix(element, prefix) {\n  const itemTextContents = getItemTextContents(element);\n  const prefixLength = prefix.length;\n  for (let i = 0; i < itemTextContents.length; i++) {\n    const itemTextContent = itemTextContents[i];\n    if (itemTextContent.substr(0, prefixLength) === prefix) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n// Return an array of the text content (in lowercase) of all items.\n// Cache these results.\nfunction getItemTextContents(element) {\n  if (!element[itemTextContentsSymbol]) {\n    const items = element.items;\n    element[itemTextContentsSymbol] = items.map(child => {\n      const text = child.textContent || child.alt;\n      return text.toLowerCase();\n    });\n  }\n  return element[itemTextContentsSymbol];\n}\n\nfunction handleBackspace(element) {\n  const length = element[typedPrefixSymbol] ? element[typedPrefixSymbol].length : 0;\n  if (length > 0) {\n    element[typedPrefixSymbol] = element[typedPrefixSymbol].substr(0, length - 1);\n  }\n  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n  setPrefixTimeout(element);\n}\n\nfunction handlePlainCharacter(element, char) {\n  const prefix = element[typedPrefixSymbol] || '';\n  element[typedPrefixSymbol] = prefix + char.toLowerCase();\n  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n  setPrefixTimeout(element);\n}\n\nfunction resetPrefixTimeout(element) {\n  if (element[prefixTimeoutSymbol]) {\n    clearTimeout(element[prefixTimeoutSymbol]);\n    element[prefixTimeoutSymbol] = false;\n  }\n}\n\nfunction resetTypedPrefix(element) {\n  element[typedPrefixSymbol] = '';\n  resetPrefixTimeout(element);\n}\n\nfunction setPrefixTimeout(element) {\n  resetPrefixTimeout(element);\n  element[prefixTimeoutSymbol] = setTimeout(() => {\n    resetTypedPrefix(element);\n  }, PREFIX_TIMEOUT_DURATION);\n}\n","import renderArrayAsElements from '../../basic-component-mixins/src/renderArrayAsElements';\nimport symbols from '../../basic-component-mixins/src/symbols';\nimport toggleClass from '../../basic-component-mixins/src/toggleClass';\n\n\n/* Exported function extends a base class with PageDots. */\nexport default (base) => {\n\n  /**\n   * Template mixin which adds small dots to show the number of items and let\n   * the user select a specific item.\n   *\n   * You can see a\n   * [live demo](http://basicwebcomponents.org/basic-web-components/packages/demos/carousel-with-dots.html)\n   * of this mixin applied to a carousel.\n   *\n   * There will be one dot for each item, and the dot for the currently selected\n   * item will be shown selected.\n   *\n   * Typical usage:\n   *\n   *     class CarouselWithDots extends PageDotsMixin(Carousel) {}\n   *     customElements.define('carousel-with-dots', CarouselWithDots);\n   *\n   * Although the dots are quite small by default, clicking/tapping a dot will\n   * will select the corresponding list item.\n   */\n  class PageDots extends base {\n\n    constructor() {\n      super();\n\n      this.$.dots.addEventListener('click', event => {\n        this[symbols.handlingUserInteraction] = true;\n        const dot = event.target;\n        const dotIndex = this.dots.indexOf(dot);\n        if (dotIndex >= 0) {\n          this.selectedIndex = dotIndex;\n        }\n        this[symbols.handlingUserInteraction] = false;\n      });\n    }\n\n    get dots() {\n      return [].slice.call(this.$.dots.querySelectorAll('.dot'));\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n      renderArrayAsElements(this.items, this.$.dots, (item, element) => {\n        // We don't use the item parameter, because any item will produce an\n        // identical corresponding dot.\n        if (!element) {\n          element = document.createElement('div');\n          element.classList.add('dot');\n          element.classList.add('style-scope');\n          element.classList.add('basic-page-dots');\n          element.setAttribute('role', 'none');\n          return element;\n        }\n      });\n      refreshDots(this);\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      const index = this.items.indexOf(item);\n      // See if the corresponding dot has already been created.\n      // If not, the correct dot will be selected when it gets created.\n      const dots = this.dots;\n      if (dots && dots.length > index) {\n        const dot = this.dots[index];\n        if (dot) {\n          toggleClass(dot, 'selected', selected);\n        }\n      }\n    }\n\n    /**\n     * The distance the user has moved the first touchpoint since the beginning\n     * of a drag, expressed as a fraction of the element's width.\n     *\n     * @type number\n     */\n    get selectedFraction() {\n      return super.selectedFraction;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      renderTransition(this, this.selectedIndex, value);\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n      refreshDots(this);\n    }\n\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n        :host {\n          display: -webkit-flex;\n          display: flex;\n          position: relative;\n        }\n\n        #dots {\n          bottom: 0;\n          display: -webkit-flex;\n          display: flex;\n          -webkit-justify-content: center;\n          justify-content: center;\n          position: absolute;\n          width: 100%;\n          z-index: 1;\n        }\n\n        #dotNavigationContainer {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          position: relative;\n          z-index: 0;\n        }\n\n        #container ::slotted(*) {\n          -webkit-flex: 1;\n          flex: 1;\n        }\n\n        .dot {\n          background: rgb(255, 255, 255);\n          border-radius: 7px;\n          box-shadow: 0 0 1px 1px rgba(0, 0, 0, 0.5);\n          box-sizing: border-box;\n          cursor: pointer;\n          height: 8px;\n          margin: 7px 5px;\n          opacity: 0.4;\n          padding: 0;\n          transition: background 0.2s box-shadow 0.2s;\n          width: 8px;\n        }\n\n        .dot:hover {\n          background: rgba(0, 0, 0, 0.75);\n          box-shadow: 0 0 1px 3px rgba(255, 255, 255, 0.5);\n        }\n\n        .dot.selected {\n          opacity: 0.95;\n        }\n\n        @media (min-width: 768px) {\n          .dot {\n            height: 12px;\n            width: 12px;\n          }\n        }\n        </style>\n\n        <div id=\"dots\" role=\"none\"></div>\n        <div id=\"dotNavigationContainer\" role=\"none\">\n          ${baseTemplate}\n        </div>\n      `;\n    }\n\n  }\n\n  return PageDots;\n};\n\n\n// Return the index, ensuring it stays between 0 and the given length.\nfunction keepIndexWithinBounds(length, index) {\n  // Handle possibility of negative mod.\n  // See http://stackoverflow.com/a/18618250/76472\n  return ((index % length) + length) % length;\n}\n\nfunction renderTransition(element, selectedIndex, selectedFraction) {\n  const dots = element.dots;\n  if (!dots || dots.length === 0) {\n    return;\n  }\n  const dotCount = dots.length;\n  const opacityMinimum = 0.4;\n  const opacityMaximum = 0.95;\n  const opacityRange = opacityMaximum - opacityMinimum;\n  const fractionalIndex = selectedIndex + selectedFraction;\n  const leftIndex = Math.floor(fractionalIndex);\n  const rightIndex = Math.ceil(fractionalIndex);\n  const selectionWraps = element.selectionWraps;\n  let awayIndex = selectedFraction >= 0 ? leftIndex : rightIndex;\n  let towardIndex = selectedFraction >= 0 ? rightIndex : leftIndex;\n  if (selectionWraps) {\n    awayIndex = keepIndexWithinBounds(dotCount, awayIndex);\n    towardIndex = keepIndexWithinBounds(dotCount, towardIndex);\n  }\n  // Stupid IE doesn't have Math.trunc.\n  // const truncatedSelectedFraction = Math.trunc(selectedFraction);\n  const truncatedSelectedFraction = selectedFraction < 0 ? Math.ceil(selectedFraction) : Math.floor(selectedFraction);\n  const progress = selectedFraction - truncatedSelectedFraction;\n  const opacityProgressThroughRange = Math.abs(progress) * opacityRange;\n  dots.forEach((dot, index) => {\n    let dotOpacity;\n    if (selectedFraction === 0) {\n      // Remove explicit opacity and rely on styling.\n      dotOpacity = '';\n    } else if (index === awayIndex) {\n      dotOpacity = opacityMaximum - opacityProgressThroughRange;\n    } else if (index === towardIndex) {\n      dotOpacity = opacityMinimum + opacityProgressThroughRange;\n    } else {\n      dotOpacity = opacityMinimum;\n    }\n    dot.style.opacity = dotOpacity;\n  });\n}\n\nfunction refreshDots(element) {\n  const selectedIndex = element.selectedIndex;\n  element.dots.forEach((dot, i) => {\n    toggleClass(dot, 'selected', i === selectedIndex);\n  });\n}\n","import safeAttributes from '../../basic-component-mixins/src/safeAttributes';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/* Exported function extends a base class with PlayControls. */\nexport default (base) => {\n\n  /**\n   * Template mixin which adds buttons for managing playback of a slideshow,\n   * audio playlist, etc.\n   *\n   * Typical usage:\n   *\n   *     class SlideshowWithControls extends PlayControlsMixin(Slideshow) {}\n   *     customElements.define('slideshow-with-controls', SlideshowWithControls);\n   *\n   */\n  class PlayControls extends base {\n\n    constructor() {\n      super();\n      this.$.previousButton.addEventListener('click', event => {\n        this[symbols.handlingUserInteraction] = true;\n        this.selectPrevious();\n        this[symbols.handlingUserInteraction] = false;\n      });\n      this.$.playButton.addEventListener('click', event => {\n        this[symbols.handlingUserInteraction] = true;\n        this.playing = !this.playing;\n        this[symbols.handlingUserInteraction] = false;\n      });\n      this.$.nextButton.addEventListener('click', event => {\n        this[symbols.handlingUserInteraction] = true;\n        this.selectNext();\n        this[symbols.handlingUserInteraction] = false;\n      });\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    [symbols.keydown](event) {\n      let handled;\n\n      switch (event.keyCode) {\n        case 32: /* Space */\n          this.playing = !this.playing;\n          handled = true;\n          break;\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    get playing() {\n      return super.playing;\n    }\n    set playing(value) {\n      if ('playing' in base.prototype) { super.playing = value; }\n      safeAttributes.toggleClass(this, 'playing', value);\n    }\n\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n        :host {\n          display: -webkit-flex;\n          display: flex;\n          position: relative;\n        }\n\n        #buttons {\n          bottom: 0;\n          box-sizing: border-box;\n          padding: 0.5em;\n          position: absolute;\n          text-align: center;\n          width: 100%;\n          z-index: 1;\n        }\n\n        button {\n          background: transparent;\n          border: none;\n          fill: rgba(255, 255, 255, 0.5);\n          padding: 0;\n          transition: fill 0.5s;\n          vertical-align: middle;\n        }\n        :host(:hover) button {\n          fill: rgba(255, 255, 255, 0.7);\n        }\n        button:hover {\n          fill: rgba(255, 255, 255, 0.85);\n        }\n        button:active {\n          fill: white;\n        }\n\n        .icon {\n          height: 30px;\n          width: 30px;\n        }\n        #playButton .icon {\n          height: 40px;\n          width: 40px;\n        }\n\n        :host(.playing) .pausedControl {\n          display: none;\n        }\n        :host(:not(.playing)) .playingControl {\n          display: none;\n        }\n\n        #container {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n        }\n\n        #container ::slotted(*) {\n          -webkit-flex: 1;\n          flex: 1;\n        }\n        </style>\n\n        <div id=\"buttons\">\n          <button id=\"previousButton\">\n            <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n              <g id=\"skip-previous\">\n                <path d=\"M6 6h2v12H6zm3.5 6l8.5 6V6z\"/>\n              </g>\n            </svg>\n          </button>\n          <button id=\"playButton\">\n            <svg class=\"icon playingControl\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n              <g id=\"pause-circle-outline\">\n                <path d=\"M9 16h2V8H9v8zm3-14C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm1-4h2V8h-2v8z\"></path>\n              </g>\n            </svg>\n            <svg class=\"icon pausedControl\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n              <g id=\"play-circle-outline\">\n                <path d=\"M10 16.5l6-4.5-6-4.5v9zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"></path>\n              </g>\n            </svg>\n          </button>\n          <button id=\"nextButton\">\n            <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n              <g id=\"skip-next\">\n                <path d=\"M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z\"/>\n              </g>\n            </svg>\n          </button>\n        </div>\n\n        <div id=\"container\" role=\"none\">\n          ${baseTemplate}\n        </div>\n      `;\n    }\n\n  }\n\n  return PlayControls;\n};\n","import createSymbol from './createSymbol';\nimport FractionalSelectionMixin from './FractionalSelectionMixin';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst animationSymbol = createSymbol('animation');\nconst draggingSymbol = createSymbol('dragging');\nconst lastAnimationSymbol = createSymbol('lastAnimation');\nconst playingAnimationSymbol = createSymbol('animatingSelection');\nconst previousSelectionSymbol = createSymbol('previousSelection');\nconst selectionAnimationDurationSymbol = createSymbol('selectionAnimationDuration');\nconst selectionAnimationEffectSymbol = createSymbol('selectionAnimationEffect');\nconst selectionAnimationKeyframesSymbol = createSymbol('selectionAnimationKeyframes');\nconst resetAnimationsOnNextRenderSymbol = createSymbol('resetAnimationsOnNextRender');\n\n\n/* Exported function extends a base class with SelectionAnimation. */\nexport default function mixin(base) {\n\n  /**\n   * Mixin which uses animation to show transitions between selection states.\n   *\n   * This mixin can be used by components that want to provide visible\n   * animations when changing the selection. For example, a carousel component\n   * may want to define a sliding animation effect shown when moving between\n   * items.\n   *\n   * The animation is defined by a `selectionAnimationKeyframes` property; see\n   * that property for details on how to define these keyframes. This animation\n   * will be used in two ways. First, when moving strictly between items, the\n   * animation will play smoothly to show the selection changing. Second, the\n   * animation can be used to render the selection at a fixed point in the\n   * transition between states. E.g., if the user pauses halfway through\n   * dragging an element using [SwipeDirectionMixin](SwipeDirectionMixin.md)\n   * or [TrackpadDirectionMixin](TrackpadDirectionMixin.md)s, then the selection\n   * animation will be shown at the point exactly halfway through.\n   *\n   * This mixin expects a component to provide an `items` array of all elements\n   * in the list, which can be provided via\n   * [ContentItemsMixin](ContentItemsMixin.md). This mixin also expects\n   * `selectedIndex` and `selectedItem` properties, which can be provided via\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   *\n   * This mixin supports a `selectionWraps` property. When true, the user can\n   * navigate forward from the last item in the list and wrap around to the\n   * first item, or navigate backward from the first item and wrap around to the\n   * last item.\n   *\n   * This mixin uses the Web Animations API. For use on browsers which\n   * do not support that API natively, you will need to load the\n   * [Web Animations polyfill](https://github.com/web-animations/web-animations-js).\n   */\n  class SelectionAnimation extends base {\n\n    constructor() {\n      super();\n\n      // Set defaults.\n      if (typeof this.selectionAnimationDuration === 'undefined') {\n        this.selectionAnimationDuration = this[symbols.defaults].selectionAnimationDuration;\n      }\n      if (typeof this.selectionAnimationEffect === 'undefined' && this.selectionAnimationKeyframes == null) {\n        this.selectionAnimationEffect = this[symbols.defaults].selectionAnimationEffect;\n      }\n\n      this[symbols.dragging] = false;\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionAnimationDuration = 250;\n      defaults.selectionAnimationEffect = 'slide';\n      return defaults;\n    }\n\n    /*\n     * Provide backing for the dragging property.\n     * Also, when a drag begins, reset the animations.\n     */\n    get [symbols.dragging]() {\n      return this[draggingSymbol];\n    }\n    set [symbols.dragging](value) {\n      const previousValue = this[symbols.dragging];\n      this[draggingSymbol] = value;\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n      if (value && !previousValue) {\n        // Have begun a drag.\n        this[resetAnimationsOnNextRenderSymbol] = true;\n      }\n    }\n\n    [symbols.itemAdded](item) {\n      // We mark new items in the list as explicitly visible to ARIA. Otherwise,\n      // when an item isn't visible on the screen, ARIA will assume the item is\n      // of no interest to the user, and leave it out of the accessibility tree.\n      // If the list contains 10 items, but only 3 are visible, a screen reader\n      // might then announce the list only has 3 items. To ensure that screen\n      // readers and other assistive technologies announce the correct total\n      // number of items, we explicitly mark all items as not hidden. This will\n      // expose them all in the accessibility tree, even the items which are\n      // currently not rendered.\n      //\n      // TODO: Generally speaking, this entire mixin assumes that the user can\n      // navigate through all items in a list. But an app could style an item as\n      // display:none or visibility:hidden because the user is not allowed to\n      // interact with that item at the moment. Support for this scenario should\n      // be added. This would entail changing all locations where a mixin\n      // function is counting items, iterating over the (visible) items, and\n      // showing or hiding items. Among other things, the code below to make\n      // items visible to ARIA would need to discriminate between items which\n      // are invisible because of animation state, or invisible because the user\n      // shouldn't interact with them.\n      item.setAttribute('aria-hidden', false);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      resetAnimations(this);\n\n      // TODO: Also reset our notion of the last rendered selection? This comes\n      // up when a DOM removal causes the selected item to change position.\n      // this[previousSelectionSymbol] = null;\n\n      renderSelection(this);\n    }\n\n    resetAnimations() {\n      resetAnimations(this);\n    }\n\n    /**\n     * A fractional value indicating how far the user has currently advanced to\n     * the next/previous item. E.g., a `selectedFraction` of 3.5 indicates the\n     * user is halfway between items 3 and 4.\n     *\n     * For more details, see [FractionalSelectionMixin](FractionalSelectionMixin.md)\n     * mixin.\n     *\n     * @type {number}\n     */\n    get selectedFraction() {\n      return super.selectedFraction || 0;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      renderSelection(this, this.selectedIndex, value);\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n      renderSelection(this, index, 0);\n    }\n\n    /**\n     * The duration of a selection animation in milliseconds.\n     *\n     * This measures the amount of time required for a selection animation to\n     * complete. This number remains constant, even if the number of items being\n     * animated increases.\n     *\n     * The default value is 250 milliseconds (a quarter a second).\n     *\n     * @type {number}\n     * @default 250\n     */\n    get selectionAnimationDuration() {\n      return this[selectionAnimationDurationSymbol];\n    }\n    set selectionAnimationDuration(value) {\n      this[selectionAnimationDurationSymbol] = value;\n      if ('selectionAnimationDuration' in base.prototype) { super.selectionAnimationDuration = value; }\n    }\n\n    /**\n     * The name of a standard selection animation effect.\n     *\n     * This is a shorthand for setting the `selectionAnimationKeyframes`\n     * property to standard keyframes. Supported string values:\n     *\n     * * \"crossfade\"\n     * * \"reveal\"\n     * * \"revealWithFade\"\n     * * \"showAdjacent\"\n     * * \"slide\"\n     * * \"slideWithGap\"\n     *\n     * @type {string}\n     * @default \"slide\"\n     */\n    get selectionAnimationEffect() {\n      return this[selectionAnimationEffectSymbol];\n    }\n    set selectionAnimationEffect(value) {\n      this[selectionAnimationEffectSymbol] = value;\n      if ('selectionAnimationEffect' in base.prototype) { super.selectionAnimationEffect = value; }\n      this.selectionAnimationKeyframes = mixin.standardEffectKeyframes[value];\n    }\n\n    /**\n     * The keyframes that define an animation that plays for an item when moving\n     * forward in the sequence.\n     *\n     * This is an array of CSS rules that will be applied. These are used as\n     * [keyframes](http://w3c.github.io/web-animations/#keyframes-section)\n     * to animate the item with the\n     * [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/animation).\n     *\n     * The animation represents the state of the next item as it moves from\n     * completely unselected (offstage, usually right), to selected (center\n     * stage), to completely unselected (offstage, usually left). The center time\n     * of the animation should correspond to the item's quiscent selected state,\n     * typically in the center of the stage and at the item's largest size.\n     *\n     * The default forward animation is a smooth slide at full size from right to\n     * left.\n     *\n     * When moving the selection backward, this animation is played in reverse.\n     *\n     * @type {cssRules[]}\n     */\n    get selectionAnimationKeyframes() {\n      // Standard animation slides left/right, keeps adjacent items out of view.\n      return this[selectionAnimationKeyframesSymbol];\n    }\n    set selectionAnimationKeyframes(value) {\n      this[selectionAnimationKeyframesSymbol] = value;\n      if ('selectionAnimationKeyframes' in base.prototype) { super.selectionAnimationKeyframes = value; }\n      resetAnimations(this);\n      renderSelection(this);\n    }\n\n    get selectionWraps() {\n      return super.selectionWraps;\n    }\n    set selectionWraps(value) {\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      resetAnimations(this);\n      renderSelection(this);\n    }\n  }\n\n  return SelectionAnimation;\n}\n\n\n// We expose helpers on the mixin function that we want to be able to unit test.\n// Since these are on the function, not on the class emitted by the function,\n// they don't end up getting exposed on actual element instances.\nmixin.helpers = {\n\n  /*\n   * Calculate the animation fractions for an element's items at the given\n   * selection point. This is used when rendering the element's selection state\n   * instantaneously.\n   *\n   * This function considers the selectedIndex parameter, which can be a whole\n   * or fractional number, and determines which items will be visible at that\n   * index. This function then calculates a corresponding animation fraction: a\n   * number between 0 and 1 indicating how far through the selection animation\n   * an item should be shown, or null if the item should not be visible at that\n   * selection index. These fractions are returned as an array, where the\n   * animation fraction at position N corresponds to how item N should be shown.\n   */\n  animationFractionsForSelection(element, selection) {\n\n    const items = element.items;\n    if (!items) {\n      return;\n    }\n\n    const itemCount = items.length;\n    const selectionWraps = element.selectionWraps;\n\n    return items.map((item, itemIndex) => {\n      // How many steps from the selection point to this item?\n      const steps = stepsToIndex(itemCount, selectionWraps, selection, itemIndex);\n      // To convert steps to animation fraction:\n      // steps      animation fraction\n      //  1         0     (stage right)\n      //  0         0.5   (center stage)\n      // -1         1     (stage left)\n      const animationFraction = (1 - steps) / 2;\n      return (animationFraction >= 0 && animationFraction <= 1) ?\n        animationFraction :\n        null; // Outside animation range\n    });\n  },\n\n  /*\n   * Calculate the animation timings that should be used to smoothly animate the\n   * element's items from one selection state to another.\n   *\n   * This returns an array of timings, where the timing at position N should be\n   * used to animate item N. If an item's timing is null, then that item should\n   * not take place in the animation, and should be hidden instead.\n   */\n  effectTimingsForSelectionAnimation(element, fromSelection, toSelection) {\n\n    const items = element.items;\n    if (!items) {\n      return;\n    }\n    const itemCount = items.length;\n    const selectionWraps = element.selectionWraps;\n    const toIndex = FractionalSelectionMixin.helpers.wrappedSelectionParts(toSelection, itemCount, selectionWraps).index;\n    const totalSteps = stepsToIndex(itemCount, selectionWraps, fromSelection, toSelection);\n    const direction = totalSteps >= 0 ? 'normal': 'reverse';\n    const fill = 'both';\n    const totalDuration = element.selectionAnimationDuration;\n    const stepDuration = totalSteps !== 0 ?\n      totalDuration * 2 / Math.ceil(Math.abs(totalSteps)) :\n      0;  // No steps required, animation will be instantenous.\n\n    const timings = items.map((item, itemIndex) => {\n      const steps = stepsToIndex(itemCount, selectionWraps, itemIndex, toSelection);\n      // If we include this item in the staggered sequence of animations we're\n      // creating, where would the item appear in the sequence?\n      let positionInSequence = totalSteps - steps;\n      if (totalSteps < 0) {\n        positionInSequence = -positionInSequence;\n      }\n      // So, is this item really included in the sequence?\n      if (Math.ceil(positionInSequence) >= 0 && positionInSequence <= Math.abs(totalSteps)) {\n        // Note that delay for first item will be negative. That will cause\n        // the animation to start halfway through, which is what we want.\n        const delay = stepDuration * (positionInSequence - 1)/2;\n        const endDelay = itemIndex === toIndex ?\n          -stepDuration/2 :   // Stop halfway through.\n          0;              // Play animation until end.\n        return { duration: stepDuration, direction, fill, delay, endDelay };\n      } else {\n        return null;\n      }\n    });\n\n    return timings;\n  }\n\n};\n\n\n// Keyframes for standard selection animation effects.\nmixin.standardEffectKeyframes = {\n\n  // Simple crossfade\n  crossfade: [\n    { opacity: 0 },\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n\n  // Reveal, as if sliding the top card off a deck of cards\n  reveal: [\n    { transform: 'translateX(0%)', zIndex: 0 },\n    { transform: 'translateX(0%)', zIndex: 1 },\n    { transform: 'translateX(-100%)', zIndex: 2 }\n  ],\n\n  // Google Photos-style reveal-with-fade animation\n  revealWithFade: [\n    { transform: 'translateX(0%) scale(0.75)', opacity: 0, zIndex: 0 },\n    { transform: 'translateX(0%) scale(1.0)', opacity: 1, zIndex: 1 },\n    { transform: 'translateX(-100%) scale(1.0)', opacity: 1, zIndex: 2 }\n  ],\n\n  // Carousel variant with a bit of off-stage elements showing\n  showAdjacent: [\n    { transform: 'translateX(78%) scale(0.7)', zIndex: 0 },\n    { transform: 'translateX(0%) scale(0.82)', zIndex: 1 },\n    { transform: 'translateX(-78%) scale(0.7)', zIndex: 0 }\n  ],\n\n  // Simple slide\n  slide: [\n    { transform: 'translateX(100%)' },\n    { transform: 'translateX(-100%)' }\n  ],\n\n  // Slide, with a gap between\n  slideWithGap: [\n    { transform: 'translateX(110%)' },\n    { transform: 'translateX(-110%)' }\n  ]\n\n};\n\n\n/*\n * Smoothly animate the selection between the indicated \"from\" and \"to\"\n * indices. The former can be a fraction, e.g., when the user releases a finger\n * to complete a touch drag, and the selection will snap to the closest whole\n * index.\n */\nfunction animateSelection(element, fromSelection, toSelection) {\n\n  resetAnimations(element);\n\n  // Calculate the animation timings.\n  const items = element.items;\n  const keyframes = element.selectionAnimationKeyframes;\n  element[playingAnimationSymbol] = true;\n  const timings = mixin.helpers.effectTimingsForSelectionAnimation(element, fromSelection, toSelection);\n\n  // Figure out which item will be the one *after* the one we're selecting.\n  const itemCount = items.length;\n  const selectionWraps = element.selectionWraps;\n  const selectionIndex = FractionalSelectionMixin.helpers.selectionParts(toSelection, itemCount, selectionWraps).index;\n  const totalSteps = stepsToIndex(itemCount, selectionWraps, fromSelection, toSelection);\n  const forward = totalSteps >= 0;\n  let nextUpIndex = selectionIndex + (forward ? 1 : - 1);\n  if (selectionWraps) {\n    nextUpIndex = FractionalSelectionMixin.helpers.wrappedSelection(nextUpIndex, itemCount);\n  } else if (!isItemIndexInBounds(element, nextUpIndex)) {\n    nextUpIndex = null; // At start/end of list; don't have a next item to show.\n  }\n\n  // Play the animations using those timings.\n  let lastAnimationDetails;\n  timings.forEach((timing, index) => {\n    const item = items[index];\n    if (timing) {\n      showItem(item, true);\n      const animation = item.animate(keyframes, timing);\n      element[animationSymbol][index] = animation;\n      if (index === nextUpIndex) {\n        // This item will be animated, so will already be in the desired state\n        // after the animation completes.\n        nextUpIndex = null;\n      }\n      if (timing.endDelay !== 0) {\n        // This is the animation for the item that will be left selected.\n        // We want to clean up when this animation completes.\n        lastAnimationDetails = { animation, index, timing, forward };\n      }\n    } else {\n      // This item doesn't participate in the animation.\n      showItem(item, false);\n    }\n  });\n\n  if (lastAnimationDetails != null) {\n    // Arrange for clean-up work to be performed.\n    lastAnimationDetails.nextUpIndex = nextUpIndex;\n    lastAnimationDetails.animation.onfinish = event => selectionAnimationFinished(element, lastAnimationDetails);\n    element[lastAnimationSymbol] = lastAnimationDetails.animation;\n  } else {\n    // Shouldn't happen -- we should always have at least one animation.\n    element[playingAnimationSymbol] = false;\n  }\n}\n\n\nfunction getAnimationForItemIndex(element, index) {\n  if (element[animationSymbol] == null) {\n    // Not ready yet;\n    return null;\n  }\n  let animation = element[animationSymbol][index];\n  if (!animation) {\n    const item = element.items[index];\n    animation = item.animate(element.selectionAnimationKeyframes, {\n      duration: element.selectionAnimationDuration,\n      fill: 'both'\n    });\n    animation.pause();\n    element[animationSymbol][index] = animation;\n  }\n  return animation;\n}\n\nfunction isItemIndexInBounds(element, index) {\n  return index >= 0 && element.items && index < element.items.length;\n}\n\n/*\n * Render the selection state of the element.\n *\n * This can be used to re-render a previous selection state (if the\n * selectedIndex param is omitted), render the selection instantly at a given\n * whole or fractional selection index, or animate to a given selection index.\n *\n * There are several distinct scenarios we need to cover:\n *\n * 1. Initial positioning, or repositioning after changing a property like\n *    selectionAnimationKeyframes that affects rendering.\n * 2. Animate on selectedIndex change. This should override any animation/swipe\n *    already in progress.\n * 3. Instantly render the current position of a drag operation in progress.\n * 4. Complete a drag operation. If the drag wasn't far enough to affect\n *    selection, we'll just be restoring the selectedFraction to 0.\n *\n * If the list does not wrap, any selection position outside the list's bounds\n * will be damped to produce a visual effect of tension.\n */\nfunction renderSelection(element, selectedIndex=element.selectedIndex, selectedFraction=element.selectedFraction) {\n  const itemCount = element.items ? element.items.length : 0;\n  if (itemCount === 0) {\n    // Nothing to render.\n    return;\n  }\n  if (selectedIndex < 0) {\n    // TODO: Handle no selection.\n    return;\n  }\n  let selection = selectedIndex + selectedFraction;\n  if (element.selectionWraps) {\n    // Apply wrapping to ensure consistent representation of selection.\n    selection = FractionalSelectionMixin.helpers.wrappedSelection(selection, itemCount);\n  } else {\n    // Apply damping if necessary.\n    selection = FractionalSelectionMixin.helpers.dampedSelection(selection, itemCount);\n  }\n  const previousSelection = element[previousSelectionSymbol];\n  // TODO: If an item changes position in the DOM, we end up animating from\n  // its old index to its new index, but we really don't want to animate at all.\n  if (!element[symbols.dragging] && previousSelection != null &&\n      previousSelection !== selection) {\n    // Animate selection from previous state to new state.\n    animateSelection(element, previousSelection, selection);\n  } else if (selectedFraction === 0 && element[playingAnimationSymbol]) {\n    // Already in process of animating to fraction 0. During that process,\n    // ignore subsequent attempts to renderSelection to fraction 0.\n    return;\n  } else {\n    // Render current selection state instantly.\n    renderSelectionInstantly(element, selection);\n  }\n  element[previousSelectionSymbol] = selection;\n}\n\n/*\n * Instantly render (don't animate) the element's items at the given whole or\n * fractional selection index.\n */\nfunction renderSelectionInstantly(element, toSelection) {\n  if (element[resetAnimationsOnNextRenderSymbol]) {\n    resetAnimations(element);\n    element[resetAnimationsOnNextRenderSymbol] = false;\n  }\n  const animationFractions = mixin.helpers.animationFractionsForSelection(element, toSelection);\n  animationFractions.map((animationFraction, index) => {\n    const item = element.items[index];\n    if (animationFraction != null) {\n      showItem(item, true);\n      setAnimationFraction(element, index, animationFraction);\n    } else {\n      showItem(item, false);\n    }\n  });\n}\n\n/*\n * We maintain an array containing an animation per item. This is used for two\n * reasons:\n *\n * * During a drag operation, we want to be able to reuse animations between\n *   drag updates.\n * * When a selection animation completes, we need to be able to leave the\n *   visibile items in a paused state. Later, we'll want to be able to clean up\n *   those animations.\n *\n * Note that this array is sparse: it will only hold up from 0–3 animations at\n * any given point.\n */\nfunction resetAnimations(element) {\n  const animations = element[animationSymbol];\n  if (animations) {\n    // Cancel existing animations to remove the effects they're applying.\n    animations.forEach((animation, index) => {\n      if (animation) {\n        animation.cancel();\n        animations[index] = null;\n      }\n    });\n  }\n  const itemCount = element.items ? element.items.length : 0;\n  if (!animations || animations.length !== itemCount) {\n    // Haven't animated before with this number of items; (re)create array.\n    element[animationSymbol] = new Array(itemCount);\n  }\n}\n\n/*\n * The last animation in our selection animation has completed. Clean up.\n */\nfunction selectionAnimationFinished(element, details) {\n\n  // When the last animation completes, show the next item in the direction\n  // we're going. Waiting to that until this point is a bit of a hack to avoid\n  // having a next item that's higher in the natural z-order obscure other items\n  // during animation.\n  const nextUpIndex = details.nextUpIndex;\n  if (nextUpIndex != null) {\n    if (element[animationSymbol][nextUpIndex]) {\n      // Cancel existing selection animation so we can construct a new one.\n      element[animationSymbol][nextUpIndex].cancel();\n      element[animationSymbol][nextUpIndex] = null;\n    }\n    const animationFraction = details.forward ? 0 : 1;\n    setAnimationFraction(element, nextUpIndex, animationFraction);\n    showItem(element.items[nextUpIndex], true);\n  }\n\n  element[lastAnimationSymbol].onfinish = null;\n  element[playingAnimationSymbol] = false;\n}\n\n/*\n * Pause the indicated animation and have it show the animation at the given\n * fraction (between 0 and 1) of the way through the animation.\n */\nfunction setAnimationFraction(element, itemIndex, fraction) {\n  const animation = getAnimationForItemIndex(element, itemIndex);\n  if (animation) {\n    const duration = element.selectionAnimationDuration;\n    if (duration) {\n      animation.currentTime = fraction * duration;\n    }\n  }\n}\n\nfunction showItem(item, flag) {\n  item.style.visibility = flag ? 'visible' : 'hidden';\n}\n\n/*\n * Figure out how many steps it will take to go from fromSelection to\n * toSelection. To go from item 3 to item 4 is one step.\n *\n * If wrapping is allowed, then going from the last item to the first will take\n * one step (forward), and going from the first item to the last will take one\n * step (backward).\n */\nfunction stepsToIndex(length, allowWrap, fromSelection, toSelection) {\n  let steps = toSelection - fromSelection;\n  // Wrapping only kicks in when list has more than 1 item.\n  if (allowWrap && length > 1) {\n    const wrapSteps = length - Math.abs(steps);\n    if (wrapSteps <= 1) {\n      // Special case\n      steps = steps < 0 ?\n        wrapSteps :   // Wrap forward from last item to first.\n        -wrapSteps;   // Wrap backward from first item to last.\n    }\n  }\n  return steps;\n}\n","import symbols from './symbols';\n\n\n// Used to assign unique IDs to item elements without IDs.\nlet idCount = 0;\n\n\n/* Exported function extends a base class with SelectionAriaActive. */\nexport default (base) => {\n\n  /**\n   * Mixin which treats the selected item in a list as the active item in ARIA\n   * accessibility terms.\n   *\n   * Handling ARIA selection state properly is actually quite complex:\n   *\n   * * The items in the list need to be indicated as possible items via an ARIA\n   *   `role` attribute value such as \"option\".\n   * * The selected item need to be marked as selected by setting the item's\n   *   `aria-selected` attribute to true *and* the other items need be marked as\n   *   *not* selected by setting `aria-selected` to false.\n   * * The outermost element with the keyboard focus needs to have attributes\n   *   set on it so that the selection is knowable at the list level via the\n   *   `aria-activedescendant` attribute.\n   * * Use of `aria-activedescendant` in turn requires that all items in the\n   *   list have ID attributes assigned to them.\n   *\n   * This mixin tries to address all of the above requirements. To that end,\n   * this mixin will assign generated IDs to any item that doesn't already have\n   * an ID.\n   *\n   * ARIA relies on elements to provide `role` attributes. This mixin will apply\n   * a default role of \"listbox\" on the outer list if it doesn't already have an\n   * explicit role. Similarly, this mixin will apply a default role of \"option\"\n   * to any list item that does not already have a role specified.\n   *\n   * This mixin expects a set of members that manage the state of the selection:\n   * `[symbols.itemSelected]`, `itemAdded`, and `selectedIndex`. You can\n   * supply these yourself, or do so via\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class SelectionAriaActive extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      // Set default ARIA role.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'listbox';\n      return defaults;\n    }\n\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n\n      if (!item.getAttribute('role')) {\n        // Assign a default ARIA role.\n        item.setAttribute('role', 'option');\n      }\n\n      // Ensure each item has an ID so we can set aria-activedescendant on the\n      // overall list whenever the selection changes.\n      //\n      // The ID will take the form of a base ID plus a unique integer. The base\n      // ID will be incorporate the component's own ID. E.g., if a component has\n      // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n      // the compnent has no ID itself, its items will get IDs that look like\n      // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n      // them from manually-assigned IDs, and to minimize the potential for ID\n      // conflicts.\n      if (!item.id) {\n        const baseId = this.id ?\n            \"_\" + this.id + \"Option\" :\n            \"_option\";\n        item.id = baseId + idCount++;\n      }\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      item.setAttribute('aria-selected', selected);\n      const itemId = item.id;\n      if (itemId && selected) {\n        this.setAttribute('aria-activedescendant', itemId);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item == null) {\n        // Selection was removed.\n        this.removeAttribute('aria-activedescendant');\n      }\n    }\n\n  }\n\n  return SelectionAriaActive;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with SelectionHighlight. */\nexport default (base) => {\n\n  /**\n   * Template mixin which applies standard highlight colors to a selected item.\n   *\n   * This mixin highlights textual items (e.g., in a list) in a standard way by\n   * using the CSS `highlight` and `highlighttext` color values. These values\n   * respect operating system defaults and user preferences, and hence are good\n   * default values for highlight colors.\n   *\n   * This mixin expects a `selected` class to be applied to selected items. You\n   * can use [ContentItemsMixin](ContentItemsMixin.md) for that purpose.\n   */\n  class SelectionHighlight extends base {\n\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n          :host([generic=\"\"]) ::slotted(.selected) {\n            background-color: highlight;\n            color: highlighttext;\n          }\n        </style>\n        ${baseTemplate}\n      `;\n    }\n\n  }\n\n  return SelectionHighlight;\n};\n","/* Exported function extends a base class with SelectionInView. */\nexport default (base) => {\n\n  /**\n   * Mixin which scrolls a container to ensure that a newly-selected item is\n   * visible to the user.\n   *\n   * When the selected item in a list-like component changes, it's easier for\n   * the to confirm that the selection has changed to an appropriate item if the\n   * user can actually see that item.\n   *\n   * This mixin expects a `selectedItem` property to be set when the selection\n   * changes. You can supply that yourself, or use\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class SelectionInView extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      const selectedItem = this.selectedItem;\n      if (selectedItem) {\n        this.scrollItemIntoView(selectedItem);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item) {\n        // Keep the selected item in view.\n        this.scrollItemIntoView(item);\n      }\n    }\n\n    /**\n     * Scroll the given element completely into view, minimizing the degree of\n     * scrolling performed.\n     *\n     * Blink has a `scrollIntoViewIfNeeded()` function that does something\n     * similar, but unfortunately it's non-standard, and in any event often ends\n     * up scrolling more than is absolutely necessary.\n     *\n     * @param {HTMLElement} item - the item to scroll into view.\n     */\n    scrollItemIntoView(item) {\n      if (super.scrollItemIntoView) { super.scrollItemIntoView(); }\n      // Get the relative position of the item with respect to the top of the\n      // list's scrollable canvas. An item at the top of the list will have a\n      // elementTop of 0.\n\n      const scrollTarget = this.scrollTarget;\n      const elementTop = item.offsetTop - scrollTarget.offsetTop - scrollTarget.clientTop;\n      const elementBottom = elementTop + item.offsetHeight;\n      // Determine the bottom of the scrollable canvas.\n      const scrollBottom = scrollTarget.scrollTop + scrollTarget.clientHeight;\n      if (elementBottom > scrollBottom) {\n        // Scroll up until item is entirely visible.\n        scrollTarget.scrollTop += elementBottom - scrollBottom;\n      }\n      else if (elementTop < scrollTarget.scrollTop) {\n        // Scroll down until item is entirely visible.\n        scrollTarget.scrollTop = elementTop;\n      }\n    }\n\n    /**\n     * The element that should be scrolled to bring an item into view.\n     *\n     * The default value of this property is the element itself.\n     *\n     * @type {HTMLElement}\n     */\n    get scrollTarget() {\n      // Prefer base result.\n      return 'scrollTarget' in base.prototype ? super.scrollTarget : this;\n    }\n    set scrollTarget(element) {\n      if ('scrollTarget' in base.prototype) { super.scrollTarget = element; }\n    }\n\n  }\n\n  return SelectionInView;\n};\n","/* Exported function extends a base class with ShadowElementReferences. */\nexport default (base) => {\n\n  /**\n   * Mixin to create references to elements in a component's Shadow DOM subtree.\n   *\n   * This adds a member on the component called `this.$` that can be used to\n   * reference shadow elements with IDs. E.g., if component's shadow contains an\n   * element `<button id=\"foo\">`, then this mixin will create a member\n   * `this.$.foo` that points to that button.\n   *\n   * Such references simplify a component's access to its own elements. In\n   * exchange, this mixin trades off a one-time cost of querying all elements in\n   * the shadow tree instead of paying an ongoing cost to query for an element\n   * each time the component wants to inspect or manipulate it.\n   *\n   * This mixin expects the component to define a Shadow DOM subtree. You can\n   * create that tree yourself, or make use of\n   * [ShadowTemplateMixin](ShadowTemplateMixin.md).\n   *\n   * This mixin is inspired by Polymer's [automatic\n   * node finding](https://www.polymer-project.org/1.0/docs/devguide/local-dom.html#node-finding)\n   * feature.\n   */\n  class ShadowElementReferences extends base {\n\n    constructor() {\n      super();\n      if (this.shadowRoot) {\n        // Look for elements in the shadow subtree that have id attributes.\n        // An alternatively implementation of this mixin would be to just define\n        // a this.$ getter that lazily does this search the first time someone\n        // tries to access this.$. That might introduce some complexity – if the\n        // the tree changed after it was first populated, the result of\n        // searching for a node might be somewhat unpredictable.\n        this.$ = {};\n        const nodesWithIds = this.shadowRoot.querySelectorAll('[id]');\n        [].forEach.call(nodesWithIds, node => {\n          const id = node.getAttribute('id');\n          this.$[id] = node;\n        });\n      }\n    }\n\n    /**\n     * The collection of references to the elements with IDs in a component's\n     * Shadow DOM subtree.\n     *\n     * @type {object}\n     * @member $\n     */\n  }\n\n  return ShadowElementReferences;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with ShadowTemplate. */\nexport default (base) => {\n\n  /**\n   * Mixin for stamping a template into a Shadow DOM subtree upon component\n   * instantiation.\n   *\n   * To use this mixin, define a `template` property as a string or HTML\n   * `<template>` element:\n   *\n   *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n   *       get [symbols.template]() {\n   *         return `Hello, <em>world</em>.`;\n   *       }\n   *     }\n   *\n   * When your component class is instantiated, a shadow root will be created on\n   * the instance, and the contents of the template will be cloned into the\n   * shadow root. If your component does not define a `template` property, this\n   * mixin has no effect.\n   *\n   * For the time being, this extension retains support for Shadow DOM v0. That\n   * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n   * implement Shadow DOM v1.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n      let template = this[symbols.template];\n      // TODO: Save the processed template with the component's class prototype\n      // so it doesn't need to be processed with every instantiation.\n      if (template) {\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          template = createTemplateWithInnerHTML(template);\n        }\n\n        if (window.ShadowDOMPolyfill) {\n          shimTemplateStyles(template, this.localName);\n        }\n\n        const root = this.attachShadow({ mode: 'open' });\n        const clone = document.importNode(template.content, true);\n        root.appendChild(clone);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n};\n\n\n// Convert a plain string of HTML into a real template element.\nfunction createTemplateWithInnerHTML(innerHTML) {\n  const template = document.createElement('template');\n  // REVIEW: Is there an easier way to do this?\n  // We'd like to just set innerHTML on the template content, but since it's\n  // a DocumentFragment, that doesn't work.\n  const div = document.createElement('div');\n  div.innerHTML = innerHTML;\n  while (div.childNodes.length > 0) {\n    template.content.appendChild(div.childNodes[0]);\n  }\n  return template;\n}\n\n// Invoke basic style shimming with ShadowCSS.\nfunction shimTemplateStyles(template, tag) {\n  window.WebComponents.ShadowCSS.shimStyling(template.content, tag);\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = createSymbol('canSelectNext');\nconst canSelectPreviousSymbol = createSymbol('canSelectPrevious');\nconst selectionRequiredSymbol = createSymbol('selectionRequired');\nconst selectionWrapsSymbol = createSymbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = createSymbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = createSymbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = createSymbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = createSymbol('internalSelectedItem');\n\n\n/* Exported function extends a base class with SingleSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages single-selection semantics for items in a list.\n   *\n   * This mixin expects a component to provide an `items` Array or NodeList of\n   * all elements in the list. A standard way to do that with is the\n   * [ContentItemsMixin](ContentItemsMixin.md), which takes a component's\n   * content (typically its distributed children) as the set of list items; see\n   * that mixin for details.\n   *\n   * This mixin tracks a single selected item in the list, and provides means to\n   * get and set that state by item position (`selectedIndex`) or item identity\n   * (`selectedItem`). The selection can be moved in the list via the methods\n   * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n   *\n   * This mixin does not produce any user-visible effects to represent\n   * selection. Other mixins, such as\n   * [SelectionAriaActiveMixin](SelectionAriaActiveMixin.md),\n   * [SelectionHighlightMixin](SelectionHighlightMixin.md) and\n   * [SelectionInViewMixin](SelectionInViewMixin.md), modify the selected item\n   * in common ways to let the user know a given item is selected or not\n   * selected.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const previousCanSelectNext = this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (canSelectNext !== previousCanSelectNext && this[symbols.handlingUserInteraction]) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const previousCanSelectPrevious = this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (canSelectPrevious !== previousCanSelectPrevious && this[symbols.handlingUserInteraction]) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedIndex = this[internalSelectedIndexSymbol];\n      let item;\n      if (index !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && index >= 0 && index < items.length)) {\n          index = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = index;\n        item = hasItems && index >= 0 ? items[index] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (index !== previousSelectedIndex) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = index;\n\n        if (this[symbols.handlingUserInteraction]) {\n          const event = new CustomEvent('selected-index-changed', {\n            detail: {\n              selectedIndex: index,\n              value: index // for Polymer binding. TODO: Verify still necessary\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (item !== previousSelectedItem) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        if (this[symbols.handlingUserInteraction]) {\n          const event = new CustomEvent('selected-item-changed', {\n            detail: {\n              selectedItem: item,\n              value: item // for Polymer binding\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      this[selectionRequiredSymbol] = selectionRequired;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      trackSelectedItem(this);\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(value) {\n      this[selectionWrapsSymbol] = String(value) === 'true';\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Select the last item in the list.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the selectedItem property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     * @param {HTMLElement} detail.previousItem The previously selected item.\n     */\n\n    /**\n     * Fires when the selectedIndex property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n  }\n\n  return SingleSelection;\n};\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n  const count = element.items.length;\n\n  const boundedIndex = (element.selectionWraps) ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst deltaXSymbol = createSymbol('deltaX');\nconst deltaYSymbol = createSymbol('deltaY');\nconst multiTouchSymbol = createSymbol('multiTouch');\nconst previousXSymbol = createSymbol('previousX');\nconst previousYSymbol = createSymbol('previousY');\nconst startXSymbol = createSymbol('startX');\nconst travelFractionSymbol = createSymbol('travelFraction');\n\n\n/* Exported function extends a base class with SwipeDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps touch gestures (swipe left, swipe right) to direction\n   * semantics (go right, go left).\n   *\n   * By default, this mixin presents no user-visible effects; it just indicates\n   * a direction in which the user is currently swiping or has finished swiping.\n   * To map the direction to a change in selection, use\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n   */\n  class SwipeDirection extends base {\n\n    constructor() {\n      super();\n\n      this.travelFraction = 0;\n\n      // In all touch events, only handle single touches. We don't want to\n      // inadvertently do work when the user's trying to pinch-zoom for example.\n      // TODO: Even better approach than below would be to ignore touches after\n      // the first if the user has already begun a swipe.\n      // TODO: Touch events should probably be factored out into its own mixin.\n      if (window.PointerEvent) {\n        // Prefer listening to standard pointer events.\n        this.addEventListener('pointerdown', event => {\n          this[symbols.handlingUserInteraction] = true;\n          if (isEventForPenOrPrimaryTouch(event)) {\n            touchStart(this, event.clientX, event.clientY);\n          }\n          this[symbols.handlingUserInteraction] = false;\n        });\n        this.addEventListener('pointermove', event => {\n          this[symbols.handlingUserInteraction] = true;\n          if (isEventForPenOrPrimaryTouch(event)) {\n            const handled = touchMove(this, event.clientX, event.clientY);\n            if (handled) {\n              event.preventDefault();\n            }\n          }\n          this[symbols.handlingUserInteraction] = false;\n        });\n        this.addEventListener('pointerup', event => {\n          this[symbols.handlingUserInteraction] = true;\n          if (isEventForPenOrPrimaryTouch(event)) {\n            touchEnd(this, event.clientX, event.clientY);\n          }\n          this[symbols.handlingUserInteraction] = false;\n        });\n      } else {\n        // Pointer events not supported -- listen to older touch events.\n        this.addEventListener('touchstart', event => {\n          this[symbols.handlingUserInteraction] = true;\n          if (this[multiTouchSymbol]) {\n            return;\n          } else if (event.touches.length === 1) {\n            const clientX = event.changedTouches[0].clientX;\n            const clientY = event.changedTouches[0].clientY;\n            touchStart(this, clientX, clientY);\n          } else {\n            this[multiTouchSymbol] = true;\n          }\n          this[symbols.handlingUserInteraction] = false;\n        });\n        this.addEventListener('touchmove', event => {\n          this[symbols.handlingUserInteraction] = true;\n          if (!this[multiTouchSymbol] && event.touches.length === 1) {\n            const clientX = event.changedTouches[0].clientX;\n            const clientY = event.changedTouches[0].clientY;\n            const handled = touchMove(this, clientX, clientY);\n            if (handled) {\n              event.preventDefault();\n            }\n          }\n          this[symbols.handlingUserInteraction] = false;\n        });\n        this.addEventListener('touchend', event => {\n          this[symbols.handlingUserInteraction] = true;\n          if (event.touches.length === 0) {\n            // All touches removed; gesture is complete.\n            if (!this[multiTouchSymbol]) {\n              // Single-touch swipe has finished.\n              const clientX = event.changedTouches[0].clientX;\n              const clientY = event.changedTouches[0].clientY;\n              touchEnd(this, clientX, clientY);\n            }\n            this[multiTouchSymbol] = false;\n          }\n          this[symbols.handlingUserInteraction] = false;\n        });\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // For the component to receive PointerEvents in IE/Edge, we need to set\n      // touch-action: none. Only make this change if touch-action is currently\n      // the default value (\"auto\"), in case the developer knows better than we\n      // do what they want in their particular context.\n      if (getComputedStyle(this).touchAction === 'auto') {\n        this.style.touchAction = 'none';\n      }\n    }\n\n    // Default implementation.\n    get [symbols.dragging]() {\n      return super[symbols.dragging];\n    }\n    set [symbols.dragging](value) {\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * The distance the first touchpoint has traveled since the beginning of a\n     * drag, expressed as a fraction of the element's width.\n     *\n     * @type number\n     */\n    get travelFraction() {\n      return this[travelFractionSymbol];\n    }\n    set travelFraction(value) {\n      this[travelFractionSymbol] = value;\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n    }\n\n  }\n\n  return SwipeDirection;\n};\n\n\n// Return true if the pointer event is for the pen, or the primary touch point.\nfunction isEventForPenOrPrimaryTouch(event) {\n  return event.pointerType === 'pen' ||\n      (event.pointerType === 'touch' && event.isPrimary);\n}\n\n/*\n * Invoked when the user has finished a touch operation.\n */\nfunction touchEnd(element, clientX, clientY) {\n  element[symbols.dragging] = false;\n  if (element[deltaXSymbol] >= 20) {\n    // Finished going right at high speed.\n    element[symbols.goLeft]();\n  } else if (element[deltaXSymbol] <= -20) {\n    // Finished going left at high speed.\n    element[symbols.goRight]();\n  } else {\n    // Finished at low speed.\n    trackTo(element, clientX);\n    const travelFraction = element.travelFraction;\n    if (travelFraction >= 0.5) {\n      element[symbols.goRight]();\n    } else if (travelFraction <= -0.5) {\n      element[symbols.goLeft]();\n    }\n  }\n  element.travelFraction = 0;\n  element[deltaXSymbol] = null;\n  element[deltaYSymbol] = null;\n}\n\n/*\n * Invoked when the user has moved during a touch operation.\n */\nfunction touchMove(element, clientX, clientY) {\n\n  element[deltaXSymbol] = clientX - element[previousXSymbol];\n  element[deltaYSymbol] = clientY - element[previousYSymbol];\n  element[previousXSymbol] = clientX;\n  element[previousYSymbol] = clientY;\n  if (Math.abs(element[deltaXSymbol]) > Math.abs(element[deltaYSymbol])) {\n    // Move was mostly horizontal.\n    trackTo(element, clientX);\n    // Indicate that the event was handled. It'd be nicer if we didn't have\n    // to do this so that, e.g., a user could be swiping left and right\n    // while simultaneously scrolling up and down. (Native touch apps can do\n    // that.) However, Mobile Safari wants to handle swipe events near the\n    // page and interpret them as navigations. To avoid having a horiziontal\n    // swipe misintepreted as a navigation, we indicate that we've handled\n    // the event, and prevent default behavior.\n    return true;\n  } else {\n    // Move was mostly vertical.\n    return false; // Not handled\n  }\n}\n\n/*\n * Invoked when the user has begun a touch operation.\n */\nfunction touchStart(element, clientX, clientY) {\n  element[symbols.dragging] = true;\n  element[startXSymbol] = clientX;\n  element[previousXSymbol] = clientX;\n  element[previousYSymbol] = clientY;\n  element[deltaXSymbol] = 0;\n  element[deltaYSymbol] = 0;\n}\n\nfunction trackTo(element, x) {\n  const width = element.offsetWidth;\n  const dragDistance = element[startXSymbol] - x;\n  const fraction = width > 0 ?\n    dragDistance / width :\n    0;\n  element.travelFraction = fraction;\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\nconst playingSymbol = createSymbol('playing');\nconst selectionTimerDurationSymbol = createSymbol('selectionTimerDuration');\nconst timerTimeoutSymbol = createSymbol('timerTimeout');\n\n\n/* Exported function extends a base class with TimerSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which provides for automatic timed changes in selection.\n   *\n   * This mixin is useful for creating slideshow-like elements such as\n   * [basic-slideshow](../../basic-slideshow) and\n   * [basic-slideshow-with-controls](../../basic-slideshow-with-controls).\n   *\n   * Typical usage:\n   *\n   *     class CarouselWithTimer extends TimerSelectionMixin(Carousel) {}\n   *     customElements.define('carousel-with-arrows', CarouselWithTimer);\n   *\n   * This mixin expects the component to define an `items` property, as well as\n   * `selectFirst` and `selectNext` methods. You can implement those yourself,\n   * or use [ContentItemsMixin](ContentItemsMixin.md) and\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class TimerSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.playing === 'undefined') {\n        this.playing = this[symbols.defaults].playing;\n      }\n      if (typeof this.selectionTimerDuration === 'undefined') {\n        this.selectionTimerDuration = this[symbols.defaults].selectionTimerDuration;\n      }\n    }\n\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n      restartTimer(this);\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.playing = false;\n      defaults.selectionTimerDuration = 1000;\n      return defaults;\n    }\n\n    /**\n     * Begin automatic progression of the selection.\n     */\n    play() {\n      if (super.play) { super.play(); }\n      startTimer(this);\n      this[playingSymbol] = true;\n    }\n\n    /**\n     * Pause automatic progression of the selection.\n     */\n    pause() {\n      if (super.pause) { super.pause(); }\n      clearTimer(this);\n      this[playingSymbol] = false;\n    }\n\n    /**\n     * True if the selection is being automatically advanced.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get playing() {\n      return this[playingSymbol];\n    }\n    set playing(playing) {\n      const previousPlaying = this[playingSymbol];\n      const parsed = String(playing) === 'true'; // Cast to boolean\n      if ('playing' in base.prototype) { super.playing = playing; }\n      if (parsed !== previousPlaying) {\n        if (playing) {\n          this.play();\n        } else {\n          this.pause();\n        }\n      }\n    }\n\n    /*\n     * When the selected item changes (because of something this mixin did, or\n     * was changed by an outside agent like the user), we wait before advancing\n     * to the next item. By triggering the next item this way, we implicitly get\n     * a desirable behavior: if the user changes the selection (e.g., in a\n     * carousel), we let them see that selection state for a while before\n     * advancing the selection ourselves.\n     */\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      restartTimer(this);\n    }\n\n    /**\n     * The time in milliseconds that will elapse after the selection changes\n     * before the selection will be advanced to the next item in the list.\n     *\n     * @type {number} - Time in milliseconds\n     * @default 1000 (1 second)\n     */\n    get selectionTimerDuration() {\n      return this[selectionTimerDurationSymbol];\n    }\n    set selectionTimerDuration(value) {\n      this[selectionTimerDurationSymbol] = parseInt(value);\n      if ('selectionTimerDuration' in base.prototype) { super.selectionTimerDuration = value; }\n    }\n\n  }\n\n  return TimerSelection;\n};\n\n\nfunction clearTimer(element) {\n  if (element[timerTimeoutSymbol]) {\n    clearTimeout(element[timerTimeoutSymbol]);\n    element[timerTimeoutSymbol] = null;\n  }\n}\n\nfunction restartTimer(element) {\n  clearTimer(element);\n  if (element.playing && element.items && element.items.length > 0) {\n    startTimer(element);\n  }\n}\n\nfunction startTimer(element) {\n  // If play() is called more than once, cancel any existing timer.\n  clearTimer(element);\n  element[timerTimeoutSymbol] = setTimeout(() => {\n    // A timeout counts as an internal event, so we need to let outside\n    // listeners know about property changes that happen while handling it.\n    element[symbols.handlingUserInteraction] = true;\n    selectNextWithWrap(element);\n    element[symbols.handlingUserInteraction] = false;\n  }, element.selectionTimerDuration);\n}\n\n// Select the next item, wrapping to first item if necessary.\nfunction selectNextWithWrap(element) {\n  const items = element.items;\n  if (items && items.length > 0) {\n    if (element.selectedIndex == null || element.selectedIndex === items.length - 1) {\n      element.selectFirst();\n    } else {\n      element.selectNext();\n    }\n  }\n}\n","import createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst absorbDecelerationSymbol = createSymbol('absorbDeceleration');\nconst lastDeltaXSymbol = createSymbol('lastDeltaX');\nconst lastWheelTimeoutSymbol = createSymbol('lastWheelTimeout');\nconst postNavigateDelayCompleteSymbol = createSymbol('postNavigateDelayComplete');\nconst wheelDistanceSymbol = createSymbol('wheelDistance');\n\n\n/* Exported function extends a base class with TrackpadDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps a horizontal trackpad swipe gestures (or horizontal mouse\n   * wheel actions) to direction semantics.\n   *\n   * You can use this mixin with a mixin like\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md) to let the user\n   * change the selection with the trackpad or mouse wheel.\n   *\n   * To respond to the trackpad, we can listen to the DOM's \"wheel\" events.\n   * These events are fired as the user drags their fingers across a trackpad.\n   * Unfortunately, browsers are missing a critical event — there is no event\n   * when the user *stops* a gestured on the trackpad or mouse wheel.\n   *\n   * To make things worse, the mainstream browsers continue to generate fake\n   * wheel events even after the user has stopped dragging their fingers. These\n   * fake events simulate the user gradually slowing down the drag until they\n   * come to a smooth stop. In some contexts, these fake wheel events might be\n   * helpful, but in trying to supply typical trackpad swipe navigation, these\n   * fake events get in the way.\n   *\n   * This component uses heuristics to work around these problems, but the\n   * complex nature of the problem make it extremely difficult to achieve the\n   * same degree of trackpad responsiveness possible with native applications.\n   */\n  class TrackpadDirection extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('wheel', event => {\n        this[symbols.handlingUserInteraction] = true;\n        const handled = wheel(this, event);\n        if (handled) {\n          event.preventDefault();\n        }\n        this[symbols.handlingUserInteraction] = false;\n      });\n      resetWheelTracking(this);\n    }\n\n    // Default implementation.\n    get [symbols.dragging]() {\n      return super[symbols.dragging];\n    }\n    set [symbols.dragging](value) {\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * The distance the user has moved the first touchpoint since the beginning\n     * of a trackpad/wheel operation, expressed as a fraction of the element's\n     * width.\n     *\n     * @type number\n     */\n    get travelFraction() {\n      return super.travelFraction;\n    }\n    set travelFraction(value) {\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n    }\n\n  }\n\n  return TrackpadDirection;\n};\n\n\n// Time we wait following a navigation before paying attention to wheel\n// events again.\nconst POST_NAVIGATE_TIME = 250;\n\n// Time we wait after the last wheel event before we reset things.\nconst WHEEL_TIME = 100;\n\n\n// Following a navigation, partially reset our wheel tracking.\nfunction postNavigate(element) {\n  element.travelFraction = 0;\n  element[wheelDistanceSymbol] = 0;\n  element[postNavigateDelayCompleteSymbol] = true;\n  element[absorbDecelerationSymbol] = true;\n  setTimeout(() => {\n    element[postNavigateDelayCompleteSymbol] = false;\n  }, POST_NAVIGATE_TIME);\n}\n\n// Reset all state related to the tracking of the wheel.\nfunction resetWheelTracking(element) {\n  element.travelFraction = 0;\n  element[wheelDistanceSymbol] = 0;\n  element[lastDeltaXSymbol] = 0;\n  element[absorbDecelerationSymbol] = false;\n  element[postNavigateDelayCompleteSymbol] = false;\n  if (element[lastWheelTimeoutSymbol]) {\n    clearTimeout(element[lastWheelTimeoutSymbol]);\n    element[lastWheelTimeoutSymbol] = null;\n  }\n}\n\n// Define our own sign function, since (as of May 2015), Safari and IE don't\n// supply Math.sign().\nfunction sign(x) {\n  return (x === 0) ?\n    0 :\n    (x > 0) ?\n      1 :\n      -1;\n}\n\n// TODO: Damping, or some other treatment for going past the ends.\n\n/*\n * A wheel event has been generated. This could be a real wheel event, or it\n * could be fake (see notes in the header).\n *\n * This handler uses several strategies to try to approximate native trackpad\n * swipe navigation.\n *\n * If the user has dragged enough to cause a navigation, then for a short\n * delay following that navigation, subsequent wheel events will be ignored.\n *\n * Furthermore, follwowing a navigation, we ignore all wheel events until we\n * receive at least one event where the event's deltaX (distance traveled) is\n * *greater* than the previous event's deltaX. This helps us filter out the\n * fake wheel events generated by the browser to simulate deceleration.\n *\n */\nfunction wheel(element, event) {\n\n  // Since we have a new wheel event, reset our timer waiting for the last\n  // wheel event to pass.\n  if (element[lastWheelTimeoutSymbol]) {\n    clearTimeout(element[lastWheelTimeoutSymbol]);\n  }\n  element[lastWheelTimeoutSymbol] = setTimeout(() => {\n    wheelTimedOut(element);\n  }, WHEEL_TIME);\n\n  const deltaX = event.deltaX;\n  const deltaY = event.deltaY;\n\n  // See if element event represents acceleration or deceleration.\n  const acceleration = sign(deltaX) * (deltaX - element[lastDeltaXSymbol]);\n  element[lastDeltaXSymbol] = deltaX;\n\n  if (Math.abs(deltaX) < Math.abs(deltaY)) {\n    // Move was mostly vertical. The user may be trying scroll with the\n    // trackpad/wheel. To be on the safe, we ignore such events.\n    return false;\n  }\n\n  if (element[postNavigateDelayCompleteSymbol]) {\n    // It's too soon after a navigation; ignore the event.\n    return true;\n  }\n\n  if (acceleration > 0) {\n    // The events are not (or are no longer) decelerating, so we can start\n    // paying attention to them again.\n    element[absorbDecelerationSymbol] = false;\n  } else if (element[absorbDecelerationSymbol]) {\n    // The wheel event was likely faked to simulate deceleration; ignore it.\n    return true;\n  }\n\n  element[wheelDistanceSymbol] += deltaX;\n\n  // Update the travel fraction of the element being navigated.\n  const width = element.offsetWidth;\n  let travelFraction = width > 0 ?\n    element[wheelDistanceSymbol] / width :\n    0;\n  element[symbols.dragging] = true;\n  travelFraction = sign(travelFraction) * Math.min(Math.abs(travelFraction), 1);\n  element.travelFraction = travelFraction;\n\n  // If the user has dragged enough to reach the previous/next item, then\n  // complete a navigation to that item.\n  if (travelFraction === 1) {\n    element[symbols.dragging] = false;\n    element[symbols.goRight]();\n    postNavigate(element);\n  } else if (travelFraction === -1) {\n    element[symbols.dragging] = false;\n    element[symbols.goLeft]();\n    postNavigate(element);\n  }\n\n  return true;\n}\n\n// A sufficiently long period of time has passed since the last wheel event.\n// We snap the selection to the closest item, then reset our state.\nfunction wheelTimedOut(element) {\n\n  // We treat this timeout as if it were a user interaction for purposes of\n  // deciding whether we should raise property change events. In this case,\n  // the user interaction was the user stopping trackpad movement.\n  element[symbols.handlingUserInteraction] = true;\n\n  // Snap to the closest item.\n  element[symbols.dragging] = false;\n  const travelFraction = element.travelFraction;\n  if (travelFraction >= 0.5) {\n    element[symbols.goRight]();\n  } else if (travelFraction <= -0.5) {\n    element[symbols.goLeft]();\n  }\n\n  // TODO: Listen for the transition to complete, and then restore\n  // dragging to false (or the previous value).\n\n  resetWheelTracking(element);\n  element[symbols.handlingUserInteraction] = false;\n}\n","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n","/*\n * Microtask helper for IE 11.\n *\n * Executing a function as a microtask is trivial in browsers that support\n * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n * promises, but does support MutationObservers, which are also executed as\n * microtasks. So this helper uses an MutationObserver to achieve microtask\n * timing.\n *\n * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * Inspired by Polymer's async() function.\n */\n\n\n// The queue of pending callbacks to be executed as microtasks.\nconst callbacks = [];\n\n// Create an element that we will modify to force observable mutations.\nconst element = document.createTextNode('');\n\n// A monotonically-increasing value.\nlet counter = 0;\n\n\n/**\n * Add a callback to the microtask queue.\n *\n * This uses a MutationObserver so that it works on IE 11.\n *\n * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n * needs more investigation.\n *\n * @function microtask\n * @param {function} callback\n */\nexport default function microtask(callback) {\n  callbacks.push(callback);\n  // Force a mutation.\n  element.textContent = ++counter;\n}\n\n\n// Execute any pending callbacks.\nfunction executeCallbacks() {\n  while (callbacks.length > 0) {\n    const callback = callbacks.shift();\n    callback();\n  }\n}\n\n\n// Create the observer.\nconst observer = new MutationObserver(executeCallbacks);\nobserver.observe(element, {\n  characterData: true\n});\n","/**\n * Helper function for rendering an array of items as elements.\n *\n * This is not a mixin, but a function components can use if they need to\n * generate a set of elements for the items in an array.\n *\n * This function will reuse existing elements if possible. E.g., if it is called\n * to render an array of 4 items, and later called to render an array of 5\n * items, it can reuse the existing 4 items, creating just one new element.\n * Note, however, that this re-rendering is not automatic. If, after calling\n * this function, you manipulate the array you used, you must still call this\n * function again to re-render the array.\n *\n * The `renderItem` parameter takes a function of two arguments: an item to\n * to render, and an existing element (if one exists) which can be repurposed to\n * render that item. If the latter argument is null, the `renderItem()` function\n * should create a new element and return it. The function should do the same\n * if the supplied existing element is not suitable for rendering the given\n * item; the returned element will be used to replace the existing one. If the\n * existing element *is* suitable, the function can simply update it and return\n * it as is.\n *\n * Example: The following will render an array of strings in divs as children\n * of the `container` element:\n *\n *     let strings = ['a', 'b', 'c', ...];\n *     let container = this.querySelector(...);\n *     renderArrayAsElements(strings, container, (string, element) => {\n *       if (!element) {\n *         // No element exists yet, so create a new one.\n *         element = document.createElement('div');\n *       }\n *       // Set/update the text content of the element.\n *       element.textContent = string;\n *       return element;\n *     });\n *\n * @param {Array} items - the items to render\n * @param {HTMLElement} container - the parent that will hold the elements\n * @param {function} renderItem - returns a new element for an item, or\n *                                repurposes an existing element for an item\n */\nfunction renderArrayAsElements(items, container, renderItem) {\n  // Create a new set of elements for the current items.\n  items.forEach((item, index) => {\n    const oldElement = container.childNodes[index];\n    const newElement = renderItem(item, oldElement);\n    if (newElement) {\n      if (!oldElement) {\n        container.appendChild(newElement);\n      } else if (newElement !== oldElement) {\n        container.replaceChild(newElement, oldElement);\n      }\n    }\n  });\n\n  // If the array shrank, remove the extra elements which are no longer needed.\n  while (container.childNodes.length > items.length) {\n    container.removeChild(container.childNodes[items.length]);\n  }\n}\n\nexport default renderArrayAsElements;\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\n\n\n// Symbols for private data members on an element.\nconst safeToSetAttributesSymbol = createSymbol('safeToSetAttributes');\nconst pendingAttributesSymbol = createSymbol('pendingAttributes');\nconst pendingClassesSymbol = createSymbol('pendingClasses');\n\n\n/**\n * Helper functions for updating attributes, including the `class` attribute.\n */\nexport default {\n\n  /**\n   * Perform any pending updates to attributes and classes.\n   *\n   * This writes any `setAttribute` or `toggleClass` values that were performed\n   * before an element was attached to the document for the first time.\n   *\n   * This method should be called by mixins/components in their\n   * `connectedCallback`. If mulitple mixins/components invoke this during the\n   * same `connectedCallback`, only the first call will have any effect. The\n   * subsequent calls will be harmless.\n   *\n   * @param {HTMLElement} element - The element being added to the document.\n   */\n  connected(element) {\n    element[safeToSetAttributesSymbol] = true;\n\n    // Set any pending attributes.\n    if (element[pendingAttributesSymbol]) {\n      for (let attribute in element[pendingAttributesSymbol]) {\n        const value = element[pendingAttributesSymbol][attribute];\n        setAttributeToElement(element, attribute, value);\n      }\n      element[pendingAttributesSymbol] = null;\n    }\n\n    // Set any pending classes.\n    if (element[pendingClassesSymbol]) {\n      for (let className in element[pendingClassesSymbol]) {\n        const value = element[pendingClassesSymbol][className];\n        toggleClass(element, className, value);\n      }\n      element[pendingClassesSymbol] = null;\n    }\n  },\n\n  /**\n   * Set/unset the attribute with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as an attribute. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes. A call to `setAttribute` during the constructor will\n   * be deferred until the element is connected to the document.\n   *\n   * @param {string} attribute - The name of the *attribute* (not property) to set.\n   * @param {object} value - The value to set. If null, the attribute will be removed.\n   */\n  setAttribute(element, attribute, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set attributes immediately.\n      setAttributeToElement(element, attribute, value);\n    } else {\n      // Defer setting attributes until the first time we're connected.\n      if (!element[pendingAttributesSymbol]) {\n        element[pendingAttributesSymbol] = {};\n      }\n      element[pendingAttributesSymbol][attribute] = value;\n    }\n  },\n\n  /**\n   * Set/unset the class with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as as class. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes, including the `class` attribute. A call to\n   * `toggleClass` during the constructor will be deferred until the element\n   * is connected to the document.\n   *\n   * @param {string} className - The name of the class to set.\n   * @param {object} value - True to set the class, false to remove it.\n   */\n  toggleClass(element, className, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set class immediately.\n      toggleClass(element, className, value);\n    } else {\n      // Defer setting class until the first time we're connected.\n      if (!element[pendingClassesSymbol]) {\n        element[pendingClassesSymbol] = {};\n      }\n      element[pendingClassesSymbol][className] = value;\n    }\n  }\n\n};\n\n\n// Reflect the attribute to the given element.\n// If the value is null, remove the attribute.\nfunction setAttributeToElement(element, attributeName, value) {\n  if (value === null || typeof value === 'undefined') {\n    element.removeAttribute(attributeName);\n  } else {\n    const text = String(value);\n    // Avoid recursive attributeChangedCallback calls.\n    if (element.getAttribute(attributeName) !== text) {\n      element.setAttribute(attributeName, value);\n    }\n  }\n}\n","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'basic-component-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'basic-component-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `dragging` property.\n   *\n   * Components like carousels often define animated CSS transitions for\n   * sliding effects. Such a transition should usually *not* be applied while\n   * the user is dragging, because a CSS animation will introduce a lag that\n   * makes the swipe feel sluggish. Instead, as long as the user is dragging\n   * with their finger down, the transition should be suppressed. When the\n   * user releases their finger, the transition can be restored, allowing the\n   * animation to show the carousel sliding into its final position.\n   *\n   * @type {boolean} true if a drag is in progress, false if not.\n   */\n  dragging: createSymbol('dragging'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: createSymbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: createSymbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: createSymbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: createSymbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: createSymbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: createSymbol('goUp'),\n\n  /**\n   * Symbol for the `handlingUserInteraction` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. This property can be used\n   * to manage events as follows.\n   *\n   * First, UI event listeners should set this property to `true` at the start\n   * of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.handlingUserInteraction] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.handlingUserInteraction] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.handlingUserInteraction]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   */\n  handlingUserInteraction: createSymbol('handlingUserInteraction'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: createSymbol('keydown'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLElement}\n   */\n  template: createSymbol('template')\n};\n\nexport default symbols;\n","/**\n * Helper function for standard classList.toggle() behavior on old browsers,\n * namely IE 11.\n *\n * The standard\n * [classlist](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)\n * object has a `toggle()` function that supports a second Boolean parameter\n * that can be used to succinctly turn a class on or off. This feature is often\n * useful in designing custom elements, which may want to externally reflect\n * component state in a CSS class that can be used for styling purposes.\n *\n * Unfortunately, IE 11 does not support the Boolean parameter to\n * `classList.toggle()`. This helper function behaves like the standard\n * `toggle()`, including support for the Boolean parameter, so that it can be\n * used even on IE 11.\n *\n * @function toggleClass\n * @param {HTMLElement} element - The element to modify\n * @param {string} className - The class to add/remove\n * @param {boolean} [force] - Force the class to be added (if true) or removed\n *                            (if false)\n */\nexport default function toggleClass(element, className, force) {\n  const classList = element.classList;\n  const addClass = (typeof force === 'undefined') ?\n    !classList.contains(className) :\n    force;\n  if (addClass) {\n    classList.add(className);\n  } else {\n    classList.remove(className);\n  }\n  return addClass;\n}\n"]}