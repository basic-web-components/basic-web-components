{"version":3,"sources":["node_modules/browser-pack/_prelude.js","packages/basic-component-mixins/globals.js","packages/basic-component-mixins/src/ArrowSelectionMixin.js","packages/basic-component-mixins/src/AttributeMarshallingMixin.js","packages/basic-component-mixins/src/ClickSelectionMixin.js","packages/basic-component-mixins/src/ComposableMixin.js","packages/basic-component-mixins/src/ContentItemsMixin.js","packages/basic-component-mixins/src/DirectionSelectionMixin.js","packages/basic-component-mixins/src/DistributedChildrenContentMixin.js","packages/basic-component-mixins/src/DistributedChildrenMixin.js","packages/basic-component-mixins/src/FractionalSelectionMixin.js","packages/basic-component-mixins/src/GenericMixin.js","packages/basic-component-mixins/src/KeyboardDirectionMixin.js","packages/basic-component-mixins/src/KeyboardMixin.js","packages/basic-component-mixins/src/KeyboardPagedSelectionMixin.js","packages/basic-component-mixins/src/KeyboardPrefixSelectionMixin.js","packages/basic-component-mixins/src/PageDotsMixin.js","packages/basic-component-mixins/src/PlayControlsMixin.js","packages/basic-component-mixins/src/SelectionAnimationMixin.js","packages/basic-component-mixins/src/SelectionAriaActiveMixin.js","packages/basic-component-mixins/src/SelectionHighlightMixin.js","packages/basic-component-mixins/src/SelectionInViewMixin.js","packages/basic-component-mixins/src/ShadowElementReferencesMixin.js","packages/basic-component-mixins/src/ShadowTemplateMixin.js","packages/basic-component-mixins/src/SingleSelectionMixin.js","packages/basic-component-mixins/src/SwipeDirectionMixin.js","packages/basic-component-mixins/src/TimerSelectionMixin.js","packages/basic-component-mixins/src/TrackpadDirectionMixin.js","packages/basic-component-mixins/src/createSymbol.js","packages/basic-component-mixins/src/microtask.js","packages/basic-component-mixins/src/renderArrayAsElements.js","packages/basic-component-mixins/src/safeAttributes.js","packages/basic-component-mixins/src/symbols.js","packages/basic-component-mixins/src/toggleClass.js"],"names":[],"mappings":"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","file":"basic-component-mixins.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport ArrowSelectionMixin from './src/ArrowSelectionMixin';\nimport AttributeMarshallingMixin from './src/AttributeMarshallingMixin';\nimport ClickSelectionMixin from './src/ClickSelectionMixin';\nimport ComposableMixin from './src/ComposableMixin';\nimport ContentItemsMixin from './src/ContentItemsMixin';\nimport createSymbol from './src/createSymbol';\nimport DirectionSelectionMixin from './src/DirectionSelectionMixin';\nimport DistributedChildrenMixin from './src/DistributedChildrenMixin';\nimport DistributedChildrenContentMixin from './src/DistributedChildrenContentMixin';\nimport GenericMixin from './src/GenericMixin';\nimport KeyboardMixin from './src/KeyboardMixin';\nimport KeyboardDirectionMixin from './src/KeyboardDirectionMixin';\nimport KeyboardPagedSelectionMixin from './src/KeyboardPagedSelectionMixin';\nimport KeyboardPrefixSelectionMixin from './src/KeyboardPrefixSelectionMixin';\nimport microtask from './src/microtask';\nimport PageDotsMixin from './src/PageDotsMixin';\nimport PlayControlsMixin from './src/PlayControlsMixin';\nimport safeAttributes from './src/safeAttributes';\nimport SelectionAnimationMixin from './src/SelectionAnimationMixin';\nimport SelectionAriaActiveMixin from './src/SelectionAriaActiveMixin';\nimport SelectionHighlightMixin from './src/SelectionHighlightMixin';\nimport SelectionInViewMixin from './src/SelectionInViewMixin';\nimport ShadowElementReferencesMixin from './src/ShadowElementReferencesMixin';\nimport ShadowTemplateMixin from './src/ShadowTemplateMixin';\nimport SingleSelectionMixin from './src/SingleSelectionMixin';\nimport SwipeDirectionMixin from './src/SwipeDirectionMixin';\nimport symbols from './src/symbols';\nimport TimerSelectionMixin from './src/TimerSelectionMixin';\nimport TrackpadDirectionMixin from './src/TrackpadDirectionMixin';\n\nwindow.Basic = window.Basic || {};\n\nwindow.Basic.ArrowSelectionMixin = ArrowSelectionMixin;\nwindow.Basic.AttributeMarshallingMixin = AttributeMarshallingMixin;\nwindow.Basic.ClickSelectionMixin = ClickSelectionMixin;\nwindow.Basic.ComposableMixin = ComposableMixin;\nwindow.Basic.ContentItemsMixin = ContentItemsMixin;\nwindow.Basic.createSymbol = createSymbol;\nwindow.Basic.DirectionSelectionMixin = DirectionSelectionMixin;\nwindow.Basic.DistributedChildrenMixin = DistributedChildrenMixin;\nwindow.Basic.DistributedChildrenContentMixin = DistributedChildrenContentMixin;\nwindow.Basic.generic = GenericMixin;\nwindow.Basic.KeyboardMixin = KeyboardMixin;\nwindow.Basic.KeyboardDirectionMixin = KeyboardDirectionMixin;\nwindow.Basic.KeyboardPagedSelectionMixin = KeyboardPagedSelectionMixin;\nwindow.Basic.KeyboardPrefixSelectionMixin = KeyboardPrefixSelectionMixin;\nwindow.Basic.microtask = microtask;\nwindow.Basic.PageDotsMixin = PageDotsMixin;\nwindow.Basic.PlayControlsMixin = PlayControlsMixin;\nwindow.Basic.safeAttributes = safeAttributes;\nwindow.Basic.SelectionAnimationMixin = SelectionAnimationMixin;\nwindow.Basic.SelectionAriaActiveMixin = SelectionAriaActiveMixin;\nwindow.Basic.SelectionHighlightMixin = SelectionHighlightMixin;\nwindow.Basic.SelectionInViewMixin = SelectionInViewMixin;\nwindow.Basic.ShadowElementReferencesMixin = ShadowElementReferencesMixin;\nwindow.Basic.ShadowTemplateMixin = ShadowTemplateMixin;\nwindow.Basic.SingleSelectionMixin = SingleSelectionMixin;\nwindow.Basic.SwipeDirectionMixin = SwipeDirectionMixin;\nwindow.Basic.symbols = symbols;\nwindow.Basic.TimerSelectionMixin = TimerSelectionMixin;\nwindow.Basic.TrackpadDirectionMixin = TrackpadDirectionMixin;\n","import createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n// Symbols for private data members on an element.\nconst mousedownListenerSymbol = createSymbol('mousedownListener');\nconst mousemoveListenerSymbol = createSymbol('mousemoveListener');\nconst lastMouseXSymbol = createSymbol('lastMouseX');\nconst lastMouseYSymbol = createSymbol('lastMouseY');\nconst mouseTimeoutSymbol = createSymbol('mouseTimeout');\n\n\n/* Exported function extends a base class with ArrowSelection. */\nexport default (base) => {\n\n  /**\n   * Template mixin which adds prominent left and right arrow buttons to a\n   * wrapped child such as a carousel.\n   *\n   * You can see a\n   * [live demo](http://basicwebcomponents.org/basic-web-components/packages/demos/carousel-with-arrows.html)\n   * of this mixin applied to a carousel.\n   *\n   * Clicking the left/right buttons selects the previous/next item.\n   *\n   * Typical usage:\n   *\n   *     class CarouselWithArrows extends ArrowSelectionMixin(Carousel) {}\n   *     customElements.define('carousel-with-arrows', CarouselWithArrows);\n   *\n   * By default, the arrow buttons are shown on devices with a mouse or mouse-like\n   * pointing device. They are not shown on a touch-capable device unless mouse\n   * movement is detected. To cause the buttons to always appear, apply the\n   * 'showArrows' CSS class.\n   */\n  class ArrowSelection extends base {\n\n    constructor() {\n      super();\n\n      this.$.buttonLeft.addEventListener('click', event => {\n        this.selectPrevious();\n        event.stopPropagation();\n      });\n      this.$.buttonRight.addEventListener('click', event => {\n        this.selectNext();\n        event.stopPropagation();\n      });\n      assumeButtonFocus(this, this.$.buttonLeft);\n      assumeButtonFocus(this, this.$.buttonRight);\n    }\n\n    get canSelectNext() {\n      return super.canSelectNext;\n    }\n    set canSelectNext(canSelectNext) {\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      this.$.buttonRight.disabled = !canSelectNext;\n    }\n\n    get canSelectPrevious() {\n      return super.canSelectPrevious;\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      this.$.buttonLeft.disabled = !canSelectPrevious;\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      if (!this.classList.contains('showArrows')) {\n        // Determine whether we should show arrow buttons or not.\n        if (deviceSupportsTouch()) {\n          // A touch device might also support a mouse, but we can't know whether\n          // there's actually a mouse until we hear from it.\n          listenForMouse(this);\n        } else {\n          // The device doesn't support touch, so assume it has a mouse.\n          showArrows(this);\n        }\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.navigationAxis = 'horizontal';\n      return defaults;\n    }\n\n    /*\n     * The template uses the chevron-left and chevron-right SVG icons from\n     * https://github.com/PolymerElements/iron-icons/blob/master/iron-icons.html.\n     */\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n        :host {\n          -webkit-align-items: stretch;\n          align-items: stretch;\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          -webkit-justify-content: center;\n          justify-content: center;\n        }\n\n        #arrowNavigationContainer {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          position: relative;\n        }\n\n        .navigationButton {\n          background: transparent;\n          border: 1px solid transparent;\n          box-sizing: border-box;\n          color: rgba(0, 0, 0, 0.7);\n          fill: currentColor;\n          margin: 0;\n          opacity: 1;\n          outline: none; /* REVIEW: Accessibility should be provided by other elements. */\n          padding: 0;\n          transition: opacity 1s;\n          z-index: 1;\n        }\n\n        .navigationButton:hover:not(:disabled) {\n          background: rgba(0, 0, 0, 0.5);\n          color: rgba(0, 0, 0, 0.8);\n          cursor: pointer;\n        }\n        .navigationButton:active:not(:disabled) {\n          background: rgba(0, 0, 0, 0.7);\n          color: rgba(0, 0, 0, 0.9);\n        }\n        .navigationButton:disabled {\n          color: rgba(0, 0, 0, 0.2);\n        }\n\n        :host(:not(.showArrows)) .navigationButton {\n          opacity: 0;\n          visibility: hidden;\n        }\n\n        .navigationButton .icon {\n          height: 48px;\n          width: 48px;\n        }\n\n        /* Overlay variant */\n        :host(.overlayArrows) {\n          position: relative;\n        }\n        :host(.overlayArrows) .navigationButton {\n          bottom: 0;\n          color: rgba(255, 255, 255, 0.7);\n          position: absolute;\n          top: 0;\n        }\n        :host(.overlayArrows) #buttonLeft {\n          left: 0;\n        }\n        :host(.overlayArrows) #buttonRight {\n          right: 0;\n        }\n        :host(.overlayArrows) .navigationButton:hover:not(:disabled) {\n          background: rgba(255, 255, 255, 0.2);\n          color: rgba(255, 255, 255, 0.8);\n        }\n        :host(.overlayArrows) .navigationButton:active:not(:disabled) {\n          background: rgba(255, 255, 255, 0.4);\n          color: rgba(255, 255, 255, 0.9);\n        }\n        :host(.overlayArrows) .navigationButton:disabled {\n          color: rgba(255, 255, 255, 0.3);\n        }\n        </style>\n\n        <!--\n        Accessibility note: since the navigation offered by the arrow buttons should\n        be redundant (that is, there should be other ways of navigating the list),\n        we mark the button as aria-hidden so that assistive devices ignore them.\n        -->\n        <button id=\"buttonLeft\" class=\"navigationButton\" disabled tabindex=\"-1\" aria-hidden=\"true\">\n          <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n            <g id=\"chevron-left\">\n              <path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"/>\n            </g>\n          </svg>\n        </button>\n        <div id=\"arrowNavigationContainer\" role=\"none\">\n          ${baseTemplate}\n        </div>\n        <button id=\"buttonRight\" class=\"navigationButton\" disabled tabindex=\"-1\" aria-hidden=\"true\">\n          <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n            <g id=\"chevron-right\">\n              <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"/>\n            </g>\n          </svg>\n        </button>\n      `;\n    }\n\n  }\n\n  return ArrowSelection;\n};\n\n\n/*\n * By default, a button will always take focus on mousedown. For this component,\n * we want to override that behavior, such that a mousedown on a button keeps\n * the focus on the outer component.\n */\nfunction assumeButtonFocus(element, button) {\n  button.addEventListener('mousedown', event => {\n    // Given the main element the focus if it doesn't already have it.\n    element.focus();\n    // Prevent the default focus-on-mousedown behavior.\n    event.preventDefault();\n  });\n}\n\nfunction deviceSupportsTouch() {\n  return 'ontouchstart' in window ||\n      (window.DocumentTouch && document instanceof window.DocumentTouch);\n}\n\n// We try to detect the presence of a mouse by listening for mousemove events\n// which are *not* the result of a mousedown. On a touch device, a tap on the\n// page will generate a fake mousemove, followed by a mousedown. We don't want\n// to respond to those fake mousemove events. To discriminate between fake and\n// real mousemove events, when we get a mousemove event, we wait for a bit to\n// see if the same location is reported as the location of a subsequent\n// mousedown.\nfunction listenForMouse(element) {\n\n  element[mousedownListenerSymbol] = event => {\n    if (element[mouseTimeoutSymbol]) {\n      clearTimeout(element[mouseTimeoutSymbol]);\n    }\n    element[lastMouseXSymbol] = event.pageX;\n    element[lastMouseYSymbol] = event.pageY;\n  };\n  window.addEventListener('mousedown', element[mousedownListenerSymbol]);\n\n  element[mousemoveListenerSymbol] = event => {\n    // Postpone checking the mousemove location to give the mousedown event a\n    // chance to fire. The 250 ms delay is just guesswork; a shorter delay\n    // doesn't seem to work.\n    element[mouseTimeoutSymbol] = setTimeout(() => {\n      if (element[lastMouseXSymbol] != null && event.pageX !== element[lastMouseXSymbol] ||\n          element[lastMouseYSymbol] != null && event.pageY !== element[lastMouseYSymbol]) {\n        // mousemove event was at a location other than the last mousedown,\n        // and hence most likely a real mousemove event.\n        mouseDetected(element);\n      } else {\n        element[lastMouseXSymbol] = event.pageX;\n        element[lastMouseYSymbol] = event.pageY;\n      }\n    }, 250);\n  };\n  window.addEventListener('mousemove', element[mousemoveListenerSymbol]);\n}\n\nfunction mouseDetected(element) {\n  showArrows(element);\n\n  // We can stop listening for mouse events now.\n  if (element[mouseTimeoutSymbol]) {\n    clearTimeout(element[mouseTimeoutSymbol]);\n  }\n  window.removeEventListener('mousedown', element[mousedownListenerSymbol]);\n  window.removeEventListener('mousemove', element[mousemoveListenerSymbol]);\n  element[mousedownListenerSymbol] = null;\n  element[mousemoveListenerSymbol] = null;\n}\n\nfunction showArrows(element) {\n  element.classList.add('showArrows');\n}\n","import safeAttributes from './safeAttributes';\n\n\n// Memoized maps of attribute to property names and vice versa.\nconst attributeToPropertyNames = {};\nconst propertyNamesToAttributes = {};\n\n\n/* Exported function extends a base class with AttributeMarshalling. */\nexport default (base) => {\n\n  /**\n   * Mixin which marshalls attributes to properties and vice versa.\n   *\n   * If your component exposes a setter for a property, it's generally a good\n   * idea to let devs using your component be able to set that property in HTML\n   * via an element attribute. You can code that yourself by writing an\n   * `attributeChangedCallback`, or you can use this mixin to get a degree of\n   * automatic support.\n   *\n   * This mixin implements an `attributeChangedCallback` that will attempt to\n   * convert a change in an element attribute into a call to the corresponding\n   * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n   * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n   * respects that convention, automatically mapping the hyphenated attribute\n   * name to the corresponding camelCase property name.\n   *\n   * Example: You define a component using this mixin:\n   *\n   *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n   *       get fooBar() { return this._fooBar; }\n   *       set fooBar(value) { this._fooBar = value; }\n   *     }\n   *     customElements.define('my-element', MyElement);\n   *\n   * If someone then instantiates your component in HTML:\n   *\n   *     <my-element foo-bar=\"Hello\"></my-element>\n   *\n   * Then, after the element has been upgraded, the `fooBar` setter will\n   * automatically be invoked with the initial value \"Hello\".\n   *\n   * For the time being, this mixin only supports string-valued properties.\n   * If you'd like to convert string attributes to other types (numbers,\n   * booleans), you need to implement `attributeChangedCallback` yourself.\n   */\n  class AttributeMarshalling extends base {\n\n    /*\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n      const propertyName = attributeToPropertyName(attributeName);\n      // If the attribute name corresponds to a property name, set the property.\n      // Ignore standard HTMLElement properties handled by the DOM.\n      if (propertyName in this && !(propertyName in HTMLElement.prototype)) {\n        this[propertyName] = newValue;\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    static get observedAttributes() {\n      return attributesForClass(this);\n    }\n\n    /**\n     * Set/unset the attribute with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as an attribute. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes. A call to `reflectAttribute` during the constructor will\n     * be deferred until the element is connected to the document.\n     *\n     * @param {string} attribute - The name of the *attribute* (not property) to set.\n     * @param {object} value - The value to set. If null, the attribute will be removed.\n     */\n    reflectAttribute(attribute, value) {\n      return safeAttributes.setAttribute(this, attribute, value);\n    }\n\n    /**\n     * Set/unset the class with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as as class. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes, including the `class` attribute. A call to\n     * `reflectClass` during the constructor will be deferred until the element\n     * is connected to the document.\n     *\n     * @param {string} className - The name of the class to set.\n     * @param {object} value - True to set the class, false to remove it.\n     */\n    reflectClass(className, value) {\n      return safeAttributes.toggleClass(this, className, value);\n    }\n\n  }\n\n  return AttributeMarshalling;\n};\n\n\n// Convert hyphenated foo-bar attribute name to camel case fooBar property name.\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hypenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hypenRegEx,\n        match => match[1].toUpperCase());\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\nfunction attributesForClass(classFn) {\n\n  // We treat the element base classes as if they have no attributes, since we\n  // don't want to receive attributeChangedCallback for them.\n  if (classFn === HTMLElement || classFn === Object) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n  const baseAttributes = attributesForClass(baseClass);\n\n  // Get attributes for this class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter(propertyName =>\n    typeof Object.getOwnPropertyDescriptor(\n        classFn.prototype, propertyName).set === 'function');\n  const attributes = setterNames.map(setterName =>\n      propertyNameToAttribute(setterName));\n\n  // Merge.\n  const diff = attributes.filter(attribute =>\n      baseAttributes.indexOf(attribute) < 0);\n  return baseAttributes.concat(diff);\n}\n\n// Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, '-$1').toLowerCase();\n  }\n  return attribute;\n}\n","/* Exported function extends a base class with ClickSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps a click (actually, a mousedown) to a selection.\n   *\n   * This simple mixin is useful in list box-like elements, where a click on a\n   * list item implicitly selects it.\n   *\n   * This mixin expects the component to provide an `items` property. You can\n   * provide that property yourself, or use\n   * [ContentItemsMixin](ContentItemsMixin.md). This mixin also expects the\n   * component to define a `selectedIndex` property. You can provide that\n   * yourself, or use [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class ClickSelection extends base {\n\n    constructor() {\n      super();\n      /*\n       * REVIEW: Which event should we listen to here?\n       *\n       * The standard use for this mixin is in list boxes. List boxes don't\n       * appear to be consistent with regard to whether they select on mousedown\n       * or click/mouseup.\n       */\n      this.addEventListener('mousedown', event => {\n        // HACK: If the item is a button, the event seems to be raised in\n        // phase 2 (AT_TARGET), but the target is the component, not item.\n        // Need to invesigate.\n        const target = event.target === this ?\n          event.path[0] :\n          event.target;\n        const index = indexOfContainingItem(this, target);\n        if (index >= 0) {\n          this.selectedIndex = index;\n          // Note: We don't call preventDefault here. The default behavior for\n          // mousedown includes setting keyboard focus if the element doesn't\n          // already have the focus, and we want to preserve that behavior.\n          event.stopPropagation();\n        }\n      });\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n    }\n\n  }\n\n  return ClickSelection;\n};\n\n\n/*\n * Return index of the element items that either is or contains the indicated\n * target. Return -1 if not found.\n */\nfunction indexOfContainingItem(element, target) {\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n  for (let i = 0; i < itemCount; i++) {\n    let item = items[i];\n    if (item === target || item.contains(target)) {\n      return i;\n    }\n  }\n  return -1;\n}\n","/* Exported function extends a base class with Composable. */\nexport default (base) => {\n\n  /**\n   * Mixin to make a class more easily composable with other mixins.\n   *\n   * This mixin contributes a `compose` method that applies a set of mixin\n   * functions and returns the resulting new class. This sugar can make the\n   * application of many mixins at once easier to read.\n   */\n  class Composable extends base {\n\n    /**\n     * Apply a set of mixin functions or mixin objects to the present class and\n     * return the new class.\n     *\n     * Instead of writing:\n     *\n     *     let MyClass = Mixin1(Mixin2(Mixin3(Mixin4(Mixin5(BaseClass)))));\n     *\n     * You can write:\n     *\n     *     let MyClass = ComposableMixin(BaseClass).compose(\n     *       Mixin1,\n     *       Mixin2,\n     *       Mixin3,\n     *       Mixin4,\n     *       Mixin5\n     *     );\n     *\n     * This function can also take mixin objects. A mixin object is just a\n     * shorthand for a mixin function that creates a new subclass with the given\n     * members. The mixin object's members are *not* copied directly onto the\n     * prototype of the base class, as with traditional mixins.\n     *\n     * In addition to providing syntactic sugar, this mixin can be used to\n     * define a class in ES5, which lacks ES6's `class` keyword.\n     *\n     * @param {...mixins} mixins - A set of mixin functions or objects to apply.\n     */\n    static compose(...mixins) {\n      // We create a new subclass for each mixin in turn. The result becomes\n      // the base class extended by any subsequent mixins. It turns out that\n      // we can use Array.reduce() to concisely express this, using the current\n      // object as the seed for reduce().\n      return mixins.reduce(composeClass, this);\n    }\n\n  }\n\n  return Composable;\n};\n\n\n// Properties defined by Object that we don't want to mixin.\nconst NON_MIXABLE_OBJECT_PROPERTIES = [\n  'constructor'\n];\n\n/*\n * Apply the mixin to the given base class to return a new class.\n * The mixin can either be a function that returns the modified class, or a\n * plain object whose members will be copied to the new class' prototype.\n */\nfunction composeClass(base, mixin) {\n  if (typeof mixin === 'function') {\n    // Mixin function\n    return mixin(base);\n  } else {\n    // Mixin object\n    class Subclass extends base {}\n    copyOwnProperties(mixin, Subclass.prototype, NON_MIXABLE_OBJECT_PROPERTIES);\n    return Subclass;\n  }\n}\n\n\n/*\n * Copy the given properties/methods to the target.\n * Return the updated target.\n */\nfunction copyOwnProperties(source, target, ignorePropertyNames = []) {\n  Object.getOwnPropertyNames(source).forEach(name => {\n    if (ignorePropertyNames.indexOf(name) < 0) {\n      const descriptor = Object.getOwnPropertyDescriptor(source, name);\n      Object.defineProperty(target, name, descriptor);\n    }\n  });\n  return target;\n}\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemsSymbol = createSymbol('items');\nconst itemInitializedSymbol = createSymbol('itemInitialized');\n\n\n/* Exported function extends a base class with ContentItems. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps content semantics (elements) to list item semantics.\n   *\n   * Items differ from element contents in several ways:\n   *\n   * * They are often referenced via index.\n   * * They may have a selection state.\n   * * It's common to do work to initialize the appearance or state of a new\n   *   item.\n   * * Auxiliary invisible child elements are filtered out and not counted as\n   *   items. Auxiliary elements include link, script, style, and template\n   *   elements. This filtering ensures that those auxiliary elements can be\n   *   used in markup inside of a list without being treated as list items.\n   *\n   * This mixin expects a component to provide a `content` property returning a\n   * raw set of elements. You can provide that yourself, or use\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md).\n   *\n   * The most commonly referenced property defined by this mixin is the `items`\n   * property. To avoid having to do work each time that property is requested,\n   * this mixin supports an optimized mode. If you invoke the `contentChanged`\n   * method when the set of items changes, the mixin concludes that you'll take\n   * care of notifying it of future changes, and turns on the optimization. With\n   * that on, the mixin saves a reference to the computed set of items, and will\n   * return that immediately on subsequent calls to the `items` property. If you\n   * use this mixin in conjunction with\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md), the\n   * `contentChanged` method will be invoked for you when the element's children\n   * change, turning on the optimization automatically.\n   */\n  class ContentItems extends base {\n\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n\n      // Since we got the contentChanged call, we'll assume we'll be notified if\n      // the set of items changes later. We turn on memoization of the items\n      // property by setting our internal property to null (instead of\n      // undefined).\n      this[itemsSymbol] = null;\n\n      this[symbols.itemsChanged]();\n    }\n\n    /**\n     * This method is invoked whenever a new item is added to the list.\n     *\n     * The default implementation of this method does nothing. You can override\n     * this to perform per-item initialization.\n     *\n     * @param {HTMLElement} item - The item that was added.\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n    }\n\n    /**\n     * The selection state for a single item has changed.\n     *\n     * Invoke this method to signal that the selected state of the indicated item\n     * has changed. By default, this applies a `selected` CSS class if the item\n     * is selected, and removed it if not selected.\n     *\n     * @param {HTMLElement} item - The item whose selection state has changed.\n     * @param {boolean} selected - True if the item is selected, false if not.\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      toggleClass(item, 'selected', selected);\n    }\n\n    /**\n     * The current set of items in the list. See the top-level documentation for\n     * mixin for a description of how items differ from plain content.\n     *\n     * @type {HTMLElement[]}\n     */\n    get items() {\n      let items;\n      if (this[itemsSymbol] == null) {\n        items = filterAuxiliaryElements(this.content);\n        // Note: test for *equality* with null; don't treat undefined as a match.\n        if (this[itemsSymbol] === null) {\n          // Memoize the set of items.\n          this[itemsSymbol] = items;\n        }\n      } else {\n        // Return the memoized items.\n        items = this[itemsSymbol];\n      }\n      return items;\n    }\n\n    /**\n     * This method is invoked when the underlying contents change. It is also\n     * invoked on component initialization  since the items have \"changed\" from\n     * being nothing.\n     */\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // Perform per-item initialization.\n      Array.prototype.forEach.call(this.items, item => {\n        if (!item[itemInitializedSymbol]) {\n          this[symbols.itemAdded](item);\n          item[itemInitializedSymbol] = true;\n        }\n      });\n\n      this.dispatchEvent(new CustomEvent('items-changed'));\n    }\n\n    /**\n     * Fires when the items in the list change.\n     *\n     * @memberof ContentItems\n     * @event items-changed\n     */\n  }\n\n  return ContentItems;\n};\n\n\n// Return the given elements, filtering out auxiliary elements that aren't\n// typically visible. Items which are not elements are returned as is.\nfunction filterAuxiliaryElements(items) {\n  const auxiliaryTags = [\n    'link',\n    'script',\n    'style',\n    'template'\n  ];\n  return [].filter.call(items, function(item) {\n    return !item.localName || auxiliaryTags.indexOf(item.localName) < 0;\n  });\n}\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with DirectionSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps direction semantics (goLeft, goRight, etc.) to selection\n   * semantics (selectPrevious, selectNext, etc.).\n   *\n   * This mixin can be used in conjunction with\n   * [KeyboardDirectionMixin](KeyboardDirectionMixin.md) (which maps keyboard\n   * events to directions) and a mixin that handles selection like\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class DirectionSelection extends base {\n\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { super[symbols.goDown](); }\n      return this.selectNext();\n    }\n\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { super[symbols.goEnd](); }\n      return this.selectLast();\n    }\n\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { super[symbols.goLeft](); }\n      return this.selectPrevious();\n    }\n\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { super[symbols.goRight](); }\n      return this.selectNext();\n    }\n\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { super[symbols.goStart](); }\n      return this.selectFirst();\n    }\n\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { super[symbols.goUp](); }\n      return this.selectPrevious();\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    get selectedFraction() {\n      return super.selectedFraction;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectFirst() {\n      if (super.selectFirst) { return super.selectFirst(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectLast() {\n      if (super.selectLast) { return super.selectLast(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectNext() {\n      if (super.selectNext) { return super.selectNext(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectPrevious() {\n      if (super.selectPrevious) { return super.selectPrevious(); }\n    }\n\n    // Map drag travel fraction to selection fraction.\n    get travelFraction() {\n      return super.travelFraction;\n    }\n    set travelFraction(value) {\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n      this.selectedFraction = value;\n    }\n\n  }\n\n  return DirectionSelection;\n};\n","import microtask from './microtask';\n\n\n/* Exported function extends a base class with DistributedChildrenContent. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines a component's content as its children, expanding any\n   * nodes distributed to the component's slots.\n   *\n   * This also provides notification of changes to a component's content. It\n   * will invoke a `contentChanged` method when the component is first\n   * instantiated, and whenever its distributed children change. This is an\n   * easy way to satisfy the Gold Standard checklist item for monitoring\n   * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n   *\n   * Example:\n   *\n   * ```\n   * let base = DistributedChildrenContentMixin(DistributedChildrenMixin(HTMLElement));\n   * class CountingElement extends base {\n   *\n   *   constructor() {\n   *     super();\n   *     let root = this.attachShadow({ mode: 'open' });\n   *     root.innerHTML = `<slot></slot>`;\n   *   }\n   *\n   *   contentChanged() {\n   *     // Count the component's children, both initially and when changed.\n   *     this.count = this.distributedChildren.length;\n   *   }\n   *\n   * }\n   * ```\n   *\n   * Note that content change detection depends upon the element having at least\n   * one `slot` element in its shadow subtree.\n   *\n   * This mixin is intended for use with the\n   * [DistributedChildrenMixin](DistributedChildrenMixin.md). See that mixin for\n   * a discussion of how that works. This DistributedChildrenContentMixin\n   * provides an easy way of defining the \"content\" of a component as the\n   * component's distributed children. That in turn lets mixins like\n   * [ContentItemsMixin](ContentItemsMixin.md) manipulate the children as list\n   * items.\n   */\n  class DistributedChildrenContent extends base {\n\n    constructor() {\n      super();\n\n      if (this.shadowRoot) {\n        // Listen to changes on all slots.\n        const slots = this.shadowRoot.querySelectorAll('slot');\n        slots.forEach(slot => slot.addEventListener('slotchange', event => {\n          this.contentChanged();\n        }));\n      }\n\n      // Make an initial call to contentChanged() so that the component can do\n      // initialization that it normally does when content changes.\n      //\n      // This will invoke contentChanged() handlers in other mixins. In order\n      // that those mixins have a chance to complete their own initialization,\n      // we add the contentChanged() call to the microtask queue.\n      microtask(() => this.contentChanged());\n    }\n\n    /**\n     * Invoked when the contents of the component (including distributed\n     * children) have changed.\n     *\n     * This method is also invoked when a component is first instantiated; the\n     * contents have essentially \"changed\" from being nothing. This allows the\n     * component to perform initial processing of its children.\n     */\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n      const event = new CustomEvent('content-changed');\n      this.dispatchEvent(event);\n    }\n\n    /**\n     * The content of this component, defined to be the flattened array of\n     * children distributed to the component.\n     *\n     * @type {HTMLElement[]}\n     */\n    get content() {\n      const distributedChildren = this.distributedChildren;\n      if (typeof distributedChildren === 'undefined') {\n        console.warn(`DistributedChildrenContentMixin expects the component to define a \"distributedChildren\" property.`);\n      }\n      return distributedChildren;\n    }\n    set content(value) {\n      if ('content' in base.prototype) { super.content = value; }\n      // TODO: Set the children to the given value (which should be an array of\n      // elements)?\n    }\n\n    /**\n     * This event is raised when the component's contents (including distributed\n     * children) have changed.\n     *\n     * @memberof DistributedChildrenContent\n     * @event content-changed\n     */\n  }\n\n  return DistributedChildrenContent;\n};\n","/* Exported function extends a base class with DistributedChildren. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines helpers for accessing a component's distributed\n   * children as a flattened array or string.\n   *\n   * The standard DOM API provides several ways of accessing child content:\n   * `children`, `childNodes`, and `textContent`. None of these functions are\n   * Shadow DOM aware. This mixin defines variations of those functions that\n   * *are* Shadow DOM aware.\n   *\n   * Example: you create a component `<count-children>` that displays a number\n   * equal to the number of children placed inside that component. If someone\n   * instantiates your component like:\n   *\n   *     <count-children>\n   *       <div></div>\n   *       <div></div>\n   *       <div></div>\n   *     </count-children>\n   *\n   * Then the component should show \"3\", because there are three children. To\n   * calculate the number of children, the component can just calculate\n   * `this.children.length`. However, suppose someone instantiates your\n   * component inside one of their own components, and puts a `<slot>` element\n   * inside your component:\n   *\n   *     <count-children>\n   *       <slot></slot>\n   *     </count-children>\n   *\n   * If your component only looks at `this.children`, it will always see exactly\n   * one child the `<slot>` element. But the user looking at the page will\n   * *see* any nodes distributed to that slot. To match what the user sees, your\n   * component should expand any `<slot>` elements it contains.\n   *\n   * That is the problem this mixin solves. After applying this mixin, your\n   * component code has access to `this.distributedChildren`, whose `length`\n   * will return the total number of all children distributed to your component\n   * in the composed tree.\n   *\n   * Note: The latest Custom Elements API design calls for a new function,\n   * `getAssignedNodes` that takes an optional `deep` parameter, that will solve\n   * this problem at the API level.\n   */\n  class DistributedChildren extends base {\n\n    /**\n     * An in-order collection of distributed children, expanding any slot\n     * elements. Like the standard children property, this skips text nodes.\n     *\n     * @type {HTMLElement[]}\n     */\n    get distributedChildren() {\n      return expandContentElements(this.children, false);\n    }\n\n    /**\n     * An in-order collection of distributed child nodes, expanding any slot\n     * elements. Like the standard childNodes property, this includes text\n     * nodes.\n     *\n     * @type {Node[]}\n     */\n    get distributedChildNodes() {\n      return expandContentElements(this.childNodes, true);\n    }\n\n    /**\n     * The concatenated text content of all distributed child nodes, expanding\n     * any slot elements.\n     *\n     * @type {string}\n     */\n    get distributedTextContent() {\n      const strings = this.distributedChildNodes.map(function(child) {\n        return child.textContent;\n      });\n      return strings.join('');\n    }\n\n  }\n\n  return DistributedChildren;\n};\n\n\n/*\n * Given a array of nodes, return a new array with any content elements expanded\n * to the nodes distributed to that content element. This rule is applied\n * recursively.\n *\n * If includeTextNodes is true, text nodes will be included, as in the\n * standard childNodes property; by default, this skips text nodes, like the\n * standard children property.\n */\nfunction expandContentElements(nodes, includeTextNodes) {\n  const expanded = Array.prototype.map.call(nodes, node => {\n    // We want to see if the node is an instanceof HTMLSlotELement, but\n    // that class won't exist if the browser that doesn't support native\n    // Shadow DOM and if the Shadow DOM polyfill hasn't been loaded. Instead,\n    // we do a simplistic check to see if the tag name is \"slot\".\n    const isSlot = typeof HTMLSlotElement !== 'undefined' ?\n      node instanceof HTMLSlotElement :\n      node.localName === 'slot';\n    if (isSlot) {\n      // Use the nodes assigned to this node instead.\n      const assignedNodes = node.assignedNodes({ flatten: true });\n      return assignedNodes ?\n        expandContentElements(assignedNodes, includeTextNodes) :\n        [];\n    } else if (node instanceof HTMLElement) {\n      // Plain element; use as is.\n      return [node];\n    } else if (node instanceof Text && includeTextNodes) {\n      // Text node.\n      return [node];\n    } else {\n      // Comment, processing instruction, etc.; skip.\n      return [];\n    }\n  });\n  const flattened = [].concat(...expanded);\n  return flattened;\n}\n","import createSymbol from './createSymbol';\n\n\n// Symbols for private data members on an element.\nconst selectedFractionSymbol = createSymbol('selectedFraction');\n\n\n/* Exported function extends a base class with FractionalSelection. */\nexport default function mixin(base) {\n\n  /**\n   * Adds support for fractional selection: treating a selection as a real\n   * number that combines an integer portion (an index into a list), and a\n   * fraction (indicating how far of the way we are to the next or previous\n   * item).\n   *\n   * This is useful in components that support incremental operations during\n   * dragging and swiping. Example: a carousel component has several items, and the\n   * currently selected item is item 3. The user begins swiping to the left,\n   * moving towards selecting item 4. Halfway through this operation, the\n   * fractional selection value is 3.5.\n   *\n   * This value permits communication between mixins like\n   * [SwipeDirectionMixin](./SwipeDirectionMixin.md) and\n   * [TrackpadDirectionMixin](./TrackpadDirectionMixin.md), which generate\n   * fractional selection values, and mixins like\n   * [SelectionAnimationMixin](./SelectionAnimationMixin.md), which can render\n   * selection at a fractional value.\n   */\n  class FractionalSelection extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      this.selectedFraction = 0;\n    }\n\n    /**\n     * A fractional value indicating how far the user has currently advanced to\n     * the next/previous item. E.g., a `selectedFraction` of 3.5 indicates the\n     * user is halfway between items 3 and 4.\n     *\n     * @type {number}\n     */\n    get selectedFraction() {\n      return this[selectedFractionSymbol];\n    }\n    set selectedFraction(value) {\n      this[selectedFractionSymbol] = value;\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      const event = new CustomEvent('selected-fraction-changed');\n      this.dispatchEvent(event);\n    }\n\n  }\n\n  return FractionalSelection;\n}\n\n\nmixin.helpers = {\n\n  /*\n   * Dampen a selection that goes past the beginning or end of a list. This is\n   * generally used to produce a visual effect of tension as the user tries to\n   * go further in a direction that has no more items.\n   *\n   * Example: suppose `itemCount` is 5, indicating a list of 5 items. The index of\n   * the last item is 4. If the `selection` parameter is 4.5, the user is trying\n   * to go past this last item. When a damping function is applied, the resulting\n   * value will be less than 4.5 (the actual value will be 4.25). When this\n   * selection state is rendered, the user will see that, each unit distance the\n   * drag travels has less and less visible effect. This is perceived as tension.\n   *\n   * @param {number} selection - A real number indicating a selection position\n   * @param {number} itemCount - An integer for the number of items in the list\n   * @returns {number} A real number representing the damped selection value.\n   */\n  dampedSelection(selection, itemCount) {\n    const bound = itemCount - 1;\n    let damped;\n    if (selection < 0) {\n      // Trying to go past beginning of list. Apply tension from the left edge.\n      damped = -mixin.helpers.damping(-selection);\n    } else if (selection >= bound) {\n      // Trying to go past end of list. Apply tension from the right edge.\n      damped = bound + mixin.helpers.damping(selection - bound);\n    } else {\n      // No damping required.\n      damped = selection;\n    }\n    return damped;\n  },\n\n  /*\n   * Calculate damping as a function of the distance past the minimum/maximum\n   * values.\n   *\n   * We want to asymptotically approach an absolute minimum of 1 unit\n   * below/above the actual minimum/maximum. This requires calculating a\n   * hyperbolic function.\n   *\n   * See http://www.wolframalpha.com/input/?i=y+%3D+-1%2F%28x%2B1%29+%2B+1\n   * for the one we use. The only portion of that function we care about is when\n   * x is zero or greater. An important consideration is that the curve be\n   * tangent to the diagonal line x=y at (0, 0). This ensures smooth continuity\n   * with the normal drag behavior, in which the visible sliding is linear with\n   * the distance the touchpoint has been dragged.\n   */\n  damping(x) {\n    const y = (-1 / (x + 1)) + 1;\n    return y;\n  },\n\n  /*\n   * Return the current fractional selection value for the given element.\n   *\n   * This simply adds the element's `selectedIndex` and `selectedFraction`\n   * properties.\n   *\n   * @param {HTMLElement} element - An element that supports selection\n   */\n  elementSelection(element) {\n    const selectedIndex = element.selectedIndex;\n    if (selectedIndex < 0) {\n      // No selection\n      return;\n    }\n    const selectedFraction = element.selectedFraction || 0;\n    return selectedIndex + selectedFraction;\n  },\n\n  /*\n   * Breaks a fractional selection into its integer and fractional parts.\n   *\n   * Example: if passed 3.5, this returns { index: 3, fraction: 5 }.\n   *\n   * @param {number} selection A real number representing a selection point\n   * @returns {object} - An object with an `index` property holding the\n   * selection's integer component, and a `fraction` property holding the\n   * selection's fractional component.\n   */\n  selectionParts(selection) {\n    // Stupid IE doesn't have Math.trunc.\n    // const index = Math.trunc(selection);\n    const index = selection < 0 ? Math.ceil(selection) : Math.floor(selection);\n    const fraction = selection - index;\n    return { index, fraction };\n  },\n\n  /*\n   * Returns a fractional selection point after accounting for wrapping, ensuring\n   * that the integer portion of the selection stays between 0 and `itemCount`-1.\n   * That is, the integer portion will always be a valid index into the list.\n   *\n   * Example of wrapping past the end of the list: if `selection` is 5.5 and\n   * `itemCount` is 5, this returns 0.5. Example of wrapping past the beginning of\n   * the list: if `selection` is 0.5 and `itemCount` is 5, this returns 4.5.\n   *\n   * @param {number} selection - A real number representing a selection point\n   * @param {number} itemCount - The number of items in the list\n   * @returns {number} - The result of wrapping the selection point\n   */\n  wrappedSelection(selection, itemCount) {\n    // Handles possibility of negative mod.\n    // See http://stackoverflow.com/a/18618250/76472\n    return ((selection % itemCount) + itemCount) % itemCount;\n  },\n\n  /*\n   * Return the parts of a selection, first wrapping if necessary.\n   *\n   * @param {number} selection  A real number representing a selection point\n   * @param {number} itemCount - The number of items in the list\n   * @param {boolean} wrap  True if the selection should wrap to stay within the\n   * list\n   * @returns {object}  The parts of the selection, using the same format as\n   * `selectionParts`.\n   */\n  wrappedSelectionParts(selection, itemCount, wrap) {\n    if (wrap) {\n      selection = mixin.helpers.wrappedSelection(selection, itemCount);\n    }\n    return mixin.helpers.selectionParts(selection);\n  }\n\n};\n","import createSymbol from './createSymbol';\nimport safeAttributes from './safeAttributes';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst genericSymbol = createSymbol('generic');\n\n\n/* Exported function extends a base class with Generic. */\nexport default (base) => {\n\n  /**\n   * Mixin which allows a component to support a \"generic\" style: a minimalist\n   * style that can easily be removed to reset its visual appearance to a\n   * baseline state.\n   *\n   * By default, a component should provide a minimal visual presentation that\n   * allows the component to function. However, the more styling the component\n   * provides by default, the harder it becomes to get the component to fit in\n   * in other settings. Each CSS rule has to be overridden. Worse, new CSS rules\n   * added to the default style won't be overridden by default, making it hard\n   * to know whether a new version of a component will still look okay.\n   *\n   * As a compromise, the mixin defines a `generic` attribute. This attribute is\n   * normally set by default, and styles can be written that apply only when the\n   * generic attribute is set. This allows the construction of CSS rules that\n   * will only apply to generic components like:\n   *\n   *     :host([generic=\"\"]) {\n   *       ... generic appearance defined here ...\n   *     }\n   *\n   * This makes it easy to remove all default styling  set the `GenericMixin`\n   * attribute to false, and all default styling will be removed.\n   */\n  class Generic extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.generic === 'undefined') {\n        this.generic = this[symbols.defaults].generic;\n      }\n    }\n\n    // This mixin doesn't actually respond to attribute changes, but relies\n    // on separately-defined behavior (e.g., in AttributeMarshallingMixin) for that.\n    // Still, we need define a baseline attributeChangedCallback that does\n    // nothing, in case this mixin gets used on its own.\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(name, oldValue, newValue); }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.generic = true;\n      return defaults;\n    }\n\n    /**\n     * True if the component would like to receive generic styling.\n     *\n     * This property is true by default set it to false to turn off all\n     * generic styles. This makes it easier to apply custom styling; you won't\n     * have to explicitly override styling you don't want.\n     *\n     * @type Boolean\n     * @default true\n     */\n    get generic() {\n      return this[genericSymbol];\n    }\n    set generic(value) {\n      const parsed = typeof value === 'string' ?\n        String(value) !== 'false' :\n        value;\n      this[genericSymbol] = parsed;\n\n      if ('generic' in base.prototype) { super.generic = value; }\n\n      // We roll our own attribute setting so that an explicitly false value\n      // shows up as GenericMixin=\"false\".\n      if (parsed === false) {\n        // Explicitly use false string.\n        safeAttributes.setAttribute(this, 'generic', 'false');\n      } else if (parsed == null) {\n        // Explicitly remove attribute. (Always safe to do this.)\n        this.removeAttribute('generic');\n      } else {\n        // Use the empty string to get attribute to appear with no value.\n        safeAttributes.setAttribute(this, 'generic', '');\n      }\n    }\n\n  }\n\n  return Generic;\n};\n\n\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst navigationAxisSymbol = createSymbol('navigationAxis');\n\n\n/* Exported function extends a base class with KeyboardDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps direction keys (Left, Right, etc.) to direction semantics\n   * (go left, go right, etc.).\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   *\n   * This mixin calls methods such as `goLeft` and `goRight`. You can define\n   * what that means by implementing those methods yourself. If you want to use\n   * direction keys to navigate a selection, use this mixin with\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n   */\n  class KeyboardDirection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.navigationAxis === 'undefined') {\n        this.navigationAxis = this[symbols.defaults].navigationAxis;\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.navigationAxis = 'both';\n      return defaults;\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate down.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { return super[symbols.goDown](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the end (e.g., of a list).\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { return super[symbols.goEnd](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the start (e.g., of a\n     * list). The default implementation of this method does nothing.\n     */\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { return super[symbols.goStart](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate up.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { return super[symbols.goUp](); }\n    }\n\n    /**\n     * Indicates the direction of permitted navigation with the keyboard.\n     *\n     * Accepted values are \"horizontal\", \"vertical\", or \"both\" (the default).\n     * If this property is \"horizontal\", the Up Arrow and Down Arrow keys will\n     * be ignored. Conversely, if this is \"vertical\", the Left Arrow and Right\n     * Arrow keys will be ignored.\n     *\n     * @type {string}\n     */\n    get navigationAxis() {\n      return this[navigationAxisSymbol];\n    }\n    set navigationAxis(value) {\n      this[navigationAxisSymbol] = value;\n      if ('navigationAxis' in base.prototype) { super.navigationAxis = value; }\n    }\n\n    [symbols.keydown](event) {\n      let handled;\n\n      const axis = this.navigationAxis;\n      const horizontal = (axis === 'horizontal' || axis === 'both');\n      const vertical = (axis === 'vertical' || axis === 'both');\n\n      // Ignore Left/Right keys when metaKey or altKey modifier is also pressed,\n      // as the user may be trying to navigate back or forward in the browser.\n      switch (event.keyCode) {\n        case 35: // End\n          handled = this[symbols.goEnd]();\n          break;\n        case 36: // Home\n          handled = this[symbols.goStart]();\n          break;\n        case 37: // Left\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goLeft]();\n          }\n          break;\n        case 38: // Up\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goStart]() : this[symbols.goUp]();\n          }\n          break;\n        case 39: // Right\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goRight]();\n          }\n          break;\n        case 40: // Down\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goEnd]() : this[symbols.goDown]();\n          }\n          break;\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n  }\n\n  return KeyboardDirection;\n};\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with Keyboard. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages the keydown handling for a component.\n   *\n   * This mixin handles several keyboard-related features.\n   *\n   * First, it wires up a single keydown event handler that can be shared by\n   * multiple mixins on a component. The event handler will invoke a `keydown`\n   * method with the event object, and any mixin along the prototype chain that\n   * wants to handle that method can do so.\n   *\n   * If a mixin wants to indicate that keyboard event has been handled, and that\n   * other mixins should *not* handle it, the mixin's `keydown` handler should\n   * return a value of true. The convention that seems to work well is that a\n   * mixin should see if it wants to handle the event and, if not, then ask the\n   * superclass to see if it wants to handle the event. This has the effect of\n   * giving the mixin that was applied last the first chance at handling a\n   * keyboard event.\n   *\n   * Example:\n   *\n   *     [symbols.keydown](event) {\n   *       let handled;\n   *       switch (event.keyCode) {\n   *         // Handle the keys you want, setting handled = true if appropriate.\n   *       }\n   *       // Prefer mixin result if it's defined, otherwise use base result.\n   *       return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n   *     }\n   *\n   * A second feature provided by this mixin is that it implicitly makes the\n   * component a tab stop if it isn't already, by setting `tabIndex` to 0. This\n   * has the effect of adding the component to the tab order in document order.\n   */\n  class Keyboard extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('keydown', event => {\n        const handled = this[symbols.keydown](event);\n        if (handled) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      });\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (this.getAttribute('tabindex') == null && this[symbols.defaults].tabindex !== null) {\n        this.setAttribute('tabindex', this[symbols.defaults].tabindex);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      // The default tab index is 0 (document order).\n      defaults.tabindex = 0;\n      return defaults;\n    }\n\n    /**\n     * Handle the indicated keyboard event.\n     *\n     * The default implementation of this method does nothing. This will\n     * typically be handled by other mixins.\n     *\n     * @param {KeyboardEvent} event - the keyboard event\n     * @return {boolean} true if the event was handled\n     */\n    [symbols.keydown](event) {\n      if (super[symbols.keydown]) { return super[symbols.keydown](event); }\n    }\n\n  }\n\n  return Keyboard;\n};\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with KeyboardPagedSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps page keys (Page Up, Page Down) into operations that move\n   * the selection by one page.\n   *\n   * The keyboard interaction model generally follows that of Microsoft Windows'\n   * list boxes instead of those in OS X:\n   *\n   * * The Page Up/Down and Home/End keys actually change the selection, rather\n   *   than just scrolling. The former behavior seems more generally useful for\n   *   keyboard users.\n   *\n   * * Pressing Page Up/Down will change the selection to the topmost/bottommost\n   *   visible item if the selection is not already there. Thereafter, the key\n   *   will move the selection up/down by a page, and (per the above point) make\n   *   the selected item visible.\n   *\n   * To ensure the selected item is in view following use of Page Up/Down, use\n   * the related [SelectionInViewMixin](SelectionInViewMixin.md).\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   */\n  class KeyboardPagedSelection extends base {\n\n    [symbols.keydown](event) {\n      let handled;\n      switch (event.keyCode) {\n        case 33: // Page Up\n          handled = this.pageUp();\n          break;\n        case 34: // Page Down\n          handled = this.pageDown();\n          break;\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    /**\n     * Scroll down one page.\n     */\n    pageDown() {\n      if (super.pageDown) { super.pageDown(); }\n      return scrollOnePage(this, true);\n    }\n\n    /**\n     * Scroll up one page.\n     */\n    pageUp() {\n      if (super.pageUp) { super.pageUp(); }\n      return scrollOnePage(this, false);\n    }\n\n    /**\n     * The element that should be scrolled with the Page Up/Down keys.\n     * Default is the current element.\n     *\n     * @type {HTMLElement}\n     */\n    get scrollTarget() {\n      // Prefer base result.\n      return 'scrollTarget' in base.prototype ? super.scrollTarget : this;\n    }\n    set scrollTarget(element) {\n      if ('scrollTarget' in base.prototype) { super.scrollTarget = element; }\n    }\n  }\n\n  return KeyboardPagedSelection;\n};\n\n\n// Return the item whose content spans the given y position (relative to the\n// top of the list's scrolling client area), or null if not found.\n//\n// If downward is true, move down the list of items to find the first item\n// found at the given y position; if downward is false, move up the list of\n// items to find the last item at that position.\nfunction getIndexOfItemAtY(element, y, downward) {\n  const items = element.items;\n  const start = downward ? 0 : items.length - 1;\n  const end = downward ? items.length : 0;\n  const step = downward ? 1 : -1;\n  const scrollTarget = element.scrollTarget;\n  const topOfClientArea = scrollTarget.offsetTop + scrollTarget.clientTop;\n\n  // Find the item spanning the indicated y coordinate.\n  let item;\n  let itemIndex = start;\n  let itemTop;\n  let found = false;\n  while (itemIndex !== end) {\n    item = items[itemIndex];\n    itemTop = item.offsetTop - topOfClientArea;\n    const itemBottom = itemTop + item.offsetHeight;\n    if (itemTop <= y && itemBottom >= y) {\n      // Item spans the indicated y coordinate.\n      found = true;\n      break;\n    }\n    itemIndex += step;\n  }\n\n  if (!found) {\n    return null;\n  }\n\n  // We may have found an item whose padding spans the given y coordinate,\n  // but whose content is actually above/below that point.\n  // TODO: If the item has a border, then padding should be included in\n  // considering a hit.\n  const itemStyle = getComputedStyle(item);\n  const itemPaddingTop = parseFloat(itemStyle.paddingTop);\n  const itemPaddingBottom = parseFloat(itemStyle.paddingBottom);\n  const contentTop = itemTop + item.clientTop + itemPaddingTop;\n  const contentBottom = contentTop + item.clientHeight - itemPaddingTop - itemPaddingBottom;\n  if (downward && contentTop <= y || !downward && contentBottom >= y) {\n    // The indicated coordinate hits the actual item content.\n    return itemIndex;\n  }\n  else {\n    // The indicated coordinate falls within the item's padding. Back up to\n    // the item below/above the item we found and return that.\n    return itemIndex - step;\n  }\n}\n\n// Move by one page downward (if downward is true), or upward (if false).\n// Return true if we ended up changing the selection, false if not.\n// TODO: Better support for horizontal lists.\nfunction scrollOnePage(element, downward) {\n\n  // Determine the item visible just at the edge of direction we're heading.\n  // We'll select that item if it's not already selected.\n  const scrollTarget = element.scrollTarget;\n  const edge = scrollTarget.scrollTop + (downward ? scrollTarget.clientHeight : 0);\n  const indexOfItemAtEdge = getIndexOfItemAtY(element, edge, downward);\n\n  const selectedIndex = element.selectedIndex;\n  let newIndex;\n  if (indexOfItemAtEdge && selectedIndex === indexOfItemAtEdge) {\n    // The item at the edge was already selected, so scroll in the indicated\n    // direction by one page. Leave the new item at that edge selected.\n    const delta = (downward ? 1 : -1) * scrollTarget.clientHeight;\n    newIndex = getIndexOfItemAtY(element, edge + delta, downward);\n  }\n  else {\n    // The item at the edge wasn't selected yet. Instead of scrolling, we'll\n    // just select that item. That is, the first attempt to page up/down\n    // usually just moves the selection to the edge in that direction.\n    newIndex = indexOfItemAtEdge;\n  }\n\n  if (!newIndex) {\n    // We can't find an item in the direction we want to travel. Select the\n    // last item (if moving downward) or first item (if moving upward).\n    newIndex = (downward ? element.items.length - 1 : 0);\n  }\n\n  if (newIndex !== selectedIndex) {\n    element.selectedIndex = newIndex;\n    return true; // We handled the page up/down ourselves.\n  }\n  else {\n    return false; // We didn't do anything.\n  }\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemTextContentsSymbol = createSymbol('itemTextContents');\nconst typedPrefixSymbol = createSymbol('typedPrefix');\nconst prefixTimeoutSymbol = createSymbol('prefixTimeout');\n\n\n/* Exported function extends a base class with KeyboardPrefixSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin that handles list box-style prefix typing, in which the user can type\n   * a string to select the first item that begins with that string.\n   *\n   * Example: suppose a component using this mixin has the following items:\n   *\n   *     <sample-list-component>\n   *       <div>Apple</div>\n   *       <div>Apricot</div>\n   *       <div>Banana</div>\n   *       <div>Blackberry</div>\n   *       <div>Blueberry</div>\n   *       <div>Cantaloupe</div>\n   *       <div>Cherry</div>\n   *       <div>Lemon</div>\n   *       <div>Lime</div>\n   *     </sample-list-component>\n   *\n   * If this component receives the focus, and the user presses the \"b\" or \"B\"\n   * key, the \"Banana\" item will be selected, because it's the first item that\n   * matches the prefix \"b\". (Matching is case-insensitive.) If the user now\n   * presses the \"l\" or \"L\" key quickly, the prefix to match becomes \"bl\", so\n   * \"Blackberry\" will be selected.\n   *\n   * The prefix typing feature has a one second timeout the prefix to match\n   * will be reset after a second has passed since the user last typed a key.\n   * If, in the above example, the user waits a second between typing \"b\" and\n   * \"l\", the prefix will become \"l\", so \"Lemon\" would be selected.\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   *\n   * This mixin also expects the component to provide an `items` property. The\n   * `textContent` of those items will be used for purposes of prefix matching.\n   */\n  class KeyboardPrefixSelection extends base {\n\n    // TODO: If the set of items is changed, reset the prefix.\n    // [symbols.itemsChanged]() {\n    //   this[itemTextContentsSymbol] = null;\n    //   resetTypedPrefix(this);\n    // }\n\n    // TODO: If the selection is changed by some other means (e.g., arrow keys)\n    // other than prefix typing, then that act should reset the prefix.\n\n    [symbols.keydown](event) {\n      let handled;\n      let resetPrefix = true;\n\n      switch (event.keyCode) {\n        case 8: // Backspace\n          handleBackspace(this);\n          handled = true;\n          resetPrefix = false;\n          break;\n        case 27: // Escape\n          handled = true;\n          break;\n        default:\n          if (!event.ctrlKey && !event.metaKey && !event.altKey &&\n              event.which !== 32 /* Space */) {\n            handlePlainCharacter(this, String.fromCharCode(event.which));\n          }\n          resetPrefix = false;\n      }\n\n      if (resetPrefix) {\n        resetTypedPrefix(this);\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    /**\n     * Select the first item whose text content begins with the given prefix.\n     *\n     * @param prefix [String] The prefix string to search for\n     */\n    selectItemWithTextPrefix(prefix) {\n      if (super.selectItemWithTextPrefix) { super.selectItemWithTextPrefix(prefix); }\n      if (prefix == null || prefix.length === 0) {\n        return;\n      }\n      const index = getIndexOfItemWithTextPrefix(this, prefix);\n      if (index >= 0) {\n        this.selectedIndex = index;\n      }\n    }\n\n  }\n\n  return KeyboardPrefixSelection;\n};\n\n\n// Time in milliseconds after which the user is considered to have stopped\n// typing.\nconst PREFIX_TIMEOUT_DURATION = 1000;\n\n\n// Return the index of the first item with the given prefix, else -1.\nfunction getIndexOfItemWithTextPrefix(element, prefix) {\n  const itemTextContents = getItemTextContents(element);\n  const prefixLength = prefix.length;\n  for (let i = 0; i < itemTextContents.length; i++) {\n    const itemTextContent = itemTextContents[i];\n    if (itemTextContent.substr(0, prefixLength) === prefix) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n// Return an array of the text content (in lowercase) of all items.\n// Cache these results.\nfunction getItemTextContents(element) {\n  if (!element[itemTextContentsSymbol]) {\n    const items = element.items;\n    element[itemTextContentsSymbol] = items.map(child => {\n      const text = child.textContent || child.alt;\n      return text.toLowerCase();\n    });\n  }\n  return element[itemTextContentsSymbol];\n}\n\nfunction handleBackspace(element) {\n  const length = element[typedPrefixSymbol] ? element[typedPrefixSymbol].length : 0;\n  if (length > 0) {\n    element[typedPrefixSymbol] = element[typedPrefixSymbol].substr(0, length - 1);\n  }\n  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n  setPrefixTimeout(element);\n}\n\nfunction handlePlainCharacter(element, char) {\n  const prefix = element[typedPrefixSymbol] || '';\n  element[typedPrefixSymbol] = prefix + char.toLowerCase();\n  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n  setPrefixTimeout(element);\n}\n\nfunction resetPrefixTimeout(element) {\n  if (element[prefixTimeoutSymbol]) {\n    clearTimeout(element[prefixTimeoutSymbol]);\n    element[prefixTimeoutSymbol] = false;\n  }\n}\n\nfunction resetTypedPrefix(element) {\n  element[typedPrefixSymbol] = '';\n  resetPrefixTimeout(element);\n}\n\nfunction setPrefixTimeout(element) {\n  resetPrefixTimeout(element);\n  element[prefixTimeoutSymbol] = setTimeout(() => {\n    resetTypedPrefix(element);\n  }, PREFIX_TIMEOUT_DURATION);\n}\n","import renderArrayAsElements from '../../basic-component-mixins/src/renderArrayAsElements';\nimport symbols from '../../basic-component-mixins/src/symbols';\nimport toggleClass from '../../basic-component-mixins/src/toggleClass';\n\n\n/* Exported function extends a base class with PageDots. */\nexport default (base) => {\n\n  /**\n   * Template mixin which adds small dots to show the number of items and let\n   * the user select a specific item.\n   *\n   * You can see a\n   * [live demo](http://basicwebcomponents.org/basic-web-components/packages/demos/carousel-with-dots.html)\n   * of this mixin applied to a carousel.\n   *\n   * There will be one dot for each item, and the dot for the currently selected\n   * item will be shown selected.\n   *\n   * Typical usage:\n   *\n   *     class CarouselWithDots extends PageDotsMixin(Carousel) {}\n   *     customElements.define('carousel-with-dots', CarouselWithDots);\n   *\n   * Although the dots are quite small by default, clicking/tapping a dot will\n   * will select the corresponding list item.\n   */\n  class PageDots extends base {\n\n    constructor() {\n      super();\n\n      this.$.dots.addEventListener('click', event => {\n        const dot = event.target;\n        const dotIndex = this.dots.indexOf(dot);\n        if (dotIndex >= 0) {\n          this.selectedIndex = dotIndex;\n        }\n      });\n    }\n\n    get dots() {\n      return [].slice.call(this.$.dots.querySelectorAll('.dot'));\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n      renderArrayAsElements(this.items, this.$.dots, (item, element) => {\n        // We don't use the item parameter, because any item will produce an\n        // identical corresponding dot.\n        if (!element) {\n          element = document.createElement('div');\n          element.classList.add('dot');\n          element.classList.add('style-scope');\n          element.classList.add('basic-page-dots');\n          element.setAttribute('role', 'none');\n          return element;\n        }\n      });\n      refreshDots(this);\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      const index = this.items.indexOf(item);\n      // See if the corresponding dot has already been created.\n      // If not, the correct dot will be selected when it gets created.\n      const dots = this.dots;\n      if (dots && dots.length > index) {\n        const dot = this.dots[index];\n        if (dot) {\n          toggleClass(dot, 'selected', selected);\n        }\n      }\n    }\n\n    /**\n     * The distance the user has moved the first touchpoint since the beginning\n     * of a drag, expressed as a fraction of the element's width.\n     *\n     * @type number\n     */\n    get selectedFraction() {\n      return super.selectedFraction;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      renderTransition(this, this.selectedIndex, value);\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n      refreshDots(this);\n    }\n\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n        :host {\n          display: -webkit-flex;\n          display: flex;\n          position: relative;\n        }\n\n        #dots {\n          bottom: 0;\n          display: -webkit-flex;\n          display: flex;\n          -webkit-justify-content: center;\n          justify-content: center;\n          position: absolute;\n          width: 100%;\n          z-index: 1;\n        }\n\n        #dotNavigationContainer {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          position: relative;\n          z-index: 0;\n        }\n\n        #container ::slotted(*) {\n          -webkit-flex: 1;\n          flex: 1;\n        }\n\n        .dot {\n          background: rgb(255, 255, 255);\n          border-radius: 7px;\n          box-shadow: 0 0 1px 1px rgba(0, 0, 0, 0.5);\n          box-sizing: border-box;\n          cursor: pointer;\n          height: 8px;\n          margin: 7px 5px;\n          opacity: 0.4;\n          padding: 0;\n          transition: background 0.2s box-shadow 0.2s;\n          width: 8px;\n        }\n\n        .dot:hover {\n          background: rgba(0, 0, 0, 0.75);\n          box-shadow: 0 0 1px 3px rgba(255, 255, 255, 0.5);\n        }\n\n        .dot.selected {\n          opacity: 0.95;\n        }\n\n        @media (min-width: 768px) {\n          .dot {\n            height: 12px;\n            width: 12px;\n          }\n        }\n        </style>\n\n        <div id=\"dots\" role=\"none\"></div>\n        <div id=\"dotNavigationContainer\" role=\"none\">\n          ${baseTemplate}\n        </div>\n      `;\n    }\n\n  }\n\n  return PageDots;\n};\n\n\n// Return the index, ensuring it stays between 0 and the given length.\nfunction keepIndexWithinBounds(length, index) {\n  // Handle possibility of negative mod.\n  // See http://stackoverflow.com/a/18618250/76472\n  return ((index % length) + length) % length;\n}\n\nfunction renderTransition(element, selectedIndex, selectedFraction) {\n  const dots = element.dots;\n  if (!dots || dots.length === 0) {\n    return;\n  }\n  const dotCount = dots.length;\n  const opacityMinimum = 0.4;\n  const opacityMaximum = 0.95;\n  const opacityRange = opacityMaximum - opacityMinimum;\n  const fractionalIndex = selectedIndex + selectedFraction;\n  const leftIndex = Math.floor(fractionalIndex);\n  const rightIndex = Math.ceil(fractionalIndex);\n  const selectionWraps = element.selectionWraps;\n  let awayIndex = selectedFraction >= 0 ? leftIndex : rightIndex;\n  let towardIndex = selectedFraction >= 0 ? rightIndex : leftIndex;\n  if (selectionWraps) {\n    awayIndex = keepIndexWithinBounds(dotCount, awayIndex);\n    towardIndex = keepIndexWithinBounds(dotCount, towardIndex);\n  }\n  // Stupid IE doesn't have Math.trunc.\n  // const truncatedSelectedFraction = Math.trunc(selectedFraction);\n  const truncatedSelectedFraction = selectedFraction < 0 ? Math.ceil(selectedFraction) : Math.floor(selectedFraction);\n  const progress = selectedFraction - truncatedSelectedFraction;\n  const opacityProgressThroughRange = Math.abs(progress) * opacityRange;\n  dots.forEach((dot, index) => {\n    let dotOpacity;\n    if (selectedFraction === 0) {\n      // Remove explicit opacity and rely on styling.\n      dotOpacity = '';\n    } else if (index === awayIndex) {\n      dotOpacity = opacityMaximum - opacityProgressThroughRange;\n    } else if (index === towardIndex) {\n      dotOpacity = opacityMinimum + opacityProgressThroughRange;\n    } else {\n      dotOpacity = opacityMinimum;\n    }\n    dot.style.opacity = dotOpacity;\n  });\n}\n\nfunction refreshDots(element) {\n  const selectedIndex = element.selectedIndex;\n  element.dots.forEach((dot, i) => {\n    toggleClass(dot, 'selected', i === selectedIndex);\n  });\n}\n","import safeAttributes from '../../basic-component-mixins/src/safeAttributes';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/* Exported function extends a base class with PlayControls. */\nexport default (base) => {\n\n  /**\n   * Template mixin which adds buttons for managing playback of a slideshow,\n   * audio playlist, etc.\n   *\n   * Typical usage:\n   *\n   *     class SlideshowWithControls extends PlayControlsMixin(Slideshow) {}\n   *     customElements.define('slideshow-with-controls', SlideshowWithControls);\n   *\n   */\n  class PlayControls extends base {\n\n    constructor() {\n      super();\n      this.$.previousButton.addEventListener('click', event => {\n        this.selectPrevious();\n      });\n      this.$.playButton.addEventListener('click', event => {\n        this.playing = !this.playing;\n      });\n      this.$.nextButton.addEventListener('click', event => {\n        this.selectNext();\n      });\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    [symbols.keydown](event) {\n      let handled;\n\n      switch (event.keyCode) {\n        case 32: /* Space */\n          this.playing = !this.playing;\n          handled = true;\n          break;\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    get playing() {\n      return super.playing;\n    }\n    set playing(value) {\n      if ('playing' in base.prototype) { super.playing = value; }\n      safeAttributes.toggleClass(this, 'playing', value);\n    }\n\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n        :host {\n          display: -webkit-flex;\n          display: flex;\n          position: relative;\n        }\n\n        #buttons {\n          bottom: 0;\n          box-sizing: border-box;\n          padding: 0.5em;\n          position: absolute;\n          text-align: center;\n          width: 100%;\n          z-index: 1;\n        }\n\n        button {\n          background: transparent;\n          border: none;\n          fill: rgba(255, 255, 255, 0.5);\n          padding: 0;\n          transition: fill 0.5s;\n          vertical-align: middle;\n        }\n        :host(:hover) button {\n          fill: rgba(255, 255, 255, 0.7);\n        }\n        button:hover {\n          fill: rgba(255, 255, 255, 0.85);\n        }\n        button:active {\n          fill: white;\n        }\n\n        .icon {\n          height: 30px;\n          width: 30px;\n        }\n        #playButton .icon {\n          height: 40px;\n          width: 40px;\n        }\n\n        :host(.playing) .pausedControl {\n          display: none;\n        }\n        :host(:not(.playing)) .playingControl {\n          display: none;\n        }\n\n        #container {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n        }\n\n        #container ::slotted(*) {\n          -webkit-flex: 1;\n          flex: 1;\n        }\n        </style>\n\n        <div id=\"buttons\">\n          <button id=\"previousButton\">\n            <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n              <g id=\"skip-previous\">\n                <path d=\"M6 6h2v12H6zm3.5 6l8.5 6V6z\"/>\n              </g>\n            </svg>\n          </button>\n          <button id=\"playButton\">\n            <svg class=\"icon playingControl\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n              <g id=\"pause-circle-outline\">\n                <path d=\"M9 16h2V8H9v8zm3-14C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm1-4h2V8h-2v8z\"></path>\n              </g>\n            </svg>\n            <svg class=\"icon pausedControl\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n              <g id=\"play-circle-outline\">\n                <path d=\"M10 16.5l6-4.5-6-4.5v9zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"></path>\n              </g>\n            </svg>\n          </button>\n          <button id=\"nextButton\">\n            <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n              <g id=\"skip-next\">\n                <path d=\"M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z\"/>\n              </g>\n            </svg>\n          </button>\n        </div>\n\n        <div id=\"container\" role=\"none\">\n          ${baseTemplate}\n        </div>\n      `;\n    }\n\n  }\n\n  return PlayControls;\n};\n","import createSymbol from './createSymbol';\nimport FractionalSelectionMixin from './FractionalSelectionMixin';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst animationSymbol = createSymbol('animation');\nconst draggingSymbol = createSymbol('dragging');\nconst lastAnimationSymbol = createSymbol('lastAnimation');\nconst playingAnimationSymbol = createSymbol('animatingSelection');\nconst previousSelectionSymbol = createSymbol('previousSelection');\nconst selectionAnimationDurationSymbol = createSymbol('selectionAnimationDuration');\nconst selectionAnimationEffectSymbol = createSymbol('selectionAnimationEffect');\nconst selectionAnimationKeyframesSymbol = createSymbol('selectionAnimationKeyframes');\nconst resetAnimationsOnNextRenderSymbol = createSymbol('resetAnimationsOnNextRender');\n\n\n/* Exported function extends a base class with SelectionAnimation. */\nexport default function mixin(base) {\n\n  /**\n   * Mixin which uses animation to show transitions between selection states.\n   *\n   * This mixin can be used by components that want to provide visible\n   * animations when changing the selection. For example, a carousel component\n   * may want to define a sliding animation effect shown when moving between\n   * items.\n   *\n   * The animation is defined by a `selectionAnimationKeyframes` property; see\n   * that property for details on how to define these keyframes. This animation\n   * will be used in two ways. First, when moving strictly between items, the\n   * animation will play smoothly to show the selection changing. Second, the\n   * animation can be used to render the selection at a fixed point in the\n   * transition between states. E.g., if the user pauses halfway through\n   * dragging an element using [SwipeDirectionMixin](SwipeDirectionMixin.md)\n   * or [TrackpadDirectionMixin](TrackpadDirectionMixin.md)s, then the selection\n   * animation will be shown at the point exactly halfway through.\n   *\n   * This mixin expects a component to provide an `items` array of all elements\n   * in the list, which can be provided via\n   * [ContentItemsMixin](ContentItemsMixin.md). This mixin also expects\n   * `selectedIndex` and `selectedItem` properties, which can be provided via\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   *\n   * This mixin supports a `selectionWraps` property. When true, the user can\n   * navigate forward from the last item in the list and wrap around to the\n   * first item, or navigate backward from the first item and wrap around to the\n   * last item.\n   *\n   * This mixin uses the Web Animations API. For use on browsers which\n   * do not support that API natively, you will need to load the\n   * [Web Animations polyfill](https://github.com/web-animations/web-animations-js).\n   */\n  class SelectionAnimation extends base {\n\n    constructor() {\n      super();\n\n      // Set defaults.\n      if (typeof this.selectionAnimationDuration === 'undefined') {\n        this.selectionAnimationDuration = this[symbols.defaults].selectionAnimationDuration;\n      }\n      if (typeof this.selectionAnimationEffect === 'undefined' && this.selectionAnimationKeyframes == null) {\n        this.selectionAnimationEffect = this[symbols.defaults].selectionAnimationEffect;\n      }\n\n      this[symbols.dragging] = false;\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionAnimationDuration = 250;\n      defaults.selectionAnimationEffect = 'slide';\n      return defaults;\n    }\n\n    /*\n     * Provide backing for the dragging property.\n     * Also, when a drag begins, reset the animations.\n     */\n    get [symbols.dragging]() {\n      return this[draggingSymbol];\n    }\n    set [symbols.dragging](value) {\n      const previousValue = this[symbols.dragging];\n      this[draggingSymbol] = value;\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n      if (value && !previousValue) {\n        // Have begun a drag.\n        this[resetAnimationsOnNextRenderSymbol] = true;\n      }\n    }\n\n    [symbols.itemAdded](item) {\n      // We mark new items in the list as explicitly visible to ARIA. Otherwise,\n      // when an item isn't visible on the screen, ARIA will assume the item is\n      // of no interest to the user, and leave it out of the accessibility tree.\n      // If the list contains 10 items, but only 3 are visible, a screen reader\n      // might then announce the list only has 3 items. To ensure that screen\n      // readers and other assistive technologies announce the correct total\n      // number of items, we explicitly mark all items as not hidden. This will\n      // expose them all in the accessibility tree, even the items which are\n      // currently not rendered.\n      //\n      // TODO: Generally speaking, this entire mixin assumes that the user can\n      // navigate through all items in a list. But an app could style an item as\n      // display:none or visibility:hidden because the user is not allowed to\n      // interact with that item at the moment. Support for this scenario should\n      // be added. This would entail changing all locations where a mixin\n      // function is counting items, iterating over the (visible) items, and\n      // showing or hiding items. Among other things, the code below to make\n      // items visible to ARIA would need to discriminate between items which\n      // are invisible because of animation state, or invisible because the user\n      // shouldn't interact with them.\n      item.setAttribute('aria-hidden', false);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      resetAnimations(this);\n\n      // TODO: Also reset our notion of the last rendered selection? This comes\n      // up when a DOM removal causes the selected item to change position.\n      // this[previousSelectionSymbol] = null;\n\n      renderSelection(this);\n    }\n\n    resetAnimations() {\n      resetAnimations(this);\n    }\n\n    /**\n     * A fractional value indicating how far the user has currently advanced to\n     * the next/previous item. E.g., a `selectedFraction` of 3.5 indicates the\n     * user is halfway between items 3 and 4.\n     *\n     * For more details, see [FractionalSelectionMixin](FractionalSelectionMixin.md)\n     * mixin.\n     *\n     * @type {number}\n     */\n    get selectedFraction() {\n      return super.selectedFraction || 0;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      renderSelection(this, this.selectedIndex, value);\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n      renderSelection(this, index, 0);\n    }\n\n    /**\n     * The duration of a selection animation in milliseconds.\n     *\n     * This measures the amount of time required for a selection animation to\n     * complete. This number remains constant, even if the number of items being\n     * animated increases.\n     *\n     * The default value is 250 milliseconds (a quarter a second).\n     *\n     * @type {number}\n     * @default 250\n     */\n    get selectionAnimationDuration() {\n      return this[selectionAnimationDurationSymbol];\n    }\n    set selectionAnimationDuration(value) {\n      this[selectionAnimationDurationSymbol] = value;\n      if ('selectionAnimationDuration' in base.prototype) { super.selectionAnimationDuration = value; }\n    }\n\n    /**\n     * The name of a standard selection animation effect.\n     *\n     * This is a shorthand for setting the `selectionAnimationKeyframes`\n     * property to standard keyframes. Supported string values:\n     *\n     * * \"crossfade\"\n     * * \"reveal\"\n     * * \"revealWithFade\"\n     * * \"showAdjacent\"\n     * * \"slide\"\n     * * \"slideWithGap\"\n     *\n     * @type {string}\n     * @default \"slide\"\n     */\n    get selectionAnimationEffect() {\n      return this[selectionAnimationEffectSymbol];\n    }\n    set selectionAnimationEffect(value) {\n      this[selectionAnimationEffectSymbol] = value;\n      if ('selectionAnimationEffect' in base.prototype) { super.selectionAnimationEffect = value; }\n      this.selectionAnimationKeyframes = mixin.standardEffectKeyframes[value];\n    }\n\n    /**\n     * The keyframes that define an animation that plays for an item when moving\n     * forward in the sequence.\n     *\n     * This is an array of CSS rules that will be applied. These are used as\n     * [keyframes](http://w3c.github.io/web-animations/#keyframes-section)\n     * to animate the item with the\n     * [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/animation).\n     *\n     * The animation represents the state of the next item as it moves from\n     * completely unselected (offstage, usually right), to selected (center\n     * stage), to completely unselected (offstage, usually left). The center time\n     * of the animation should correspond to the item's quiscent selected state,\n     * typically in the center of the stage and at the item's largest size.\n     *\n     * The default forward animation is a smooth slide at full size from right to\n     * left.\n     *\n     * When moving the selection backward, this animation is played in reverse.\n     *\n     * @type {cssRules[]}\n     */\n    get selectionAnimationKeyframes() {\n      // Standard animation slides left/right, keeps adjacent items out of view.\n      return this[selectionAnimationKeyframesSymbol];\n    }\n    set selectionAnimationKeyframes(value) {\n      this[selectionAnimationKeyframesSymbol] = value;\n      if ('selectionAnimationKeyframes' in base.prototype) { super.selectionAnimationKeyframes = value; }\n      resetAnimations(this);\n      renderSelection(this);\n    }\n\n    get selectionWraps() {\n      return super.selectionWraps;\n    }\n    set selectionWraps(value) {\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      resetAnimations(this);\n      renderSelection(this);\n    }\n  }\n\n  return SelectionAnimation;\n}\n\n\n// We expose helpers on the mixin function that we want to be able to unit test.\n// Since these are on the function, not on the class emitted by the function,\n// they don't end up getting exposed on actual element instances.\nmixin.helpers = {\n\n  /*\n   * Calculate the animation fractions for an element's items at the given\n   * selection point. This is used when rendering the element's selection state\n   * instantaneously.\n   *\n   * This function considers the selectedIndex parameter, which can be a whole\n   * or fractional number, and determines which items will be visible at that\n   * index. This function then calculates a corresponding animation fraction: a\n   * number between 0 and 1 indicating how far through the selection animation\n   * an item should be shown, or null if the item should not be visible at that\n   * selection index. These fractions are returned as an array, where the\n   * animation fraction at position N corresponds to how item N should be shown.\n   */\n  animationFractionsForSelection(element, selection) {\n\n    const items = element.items;\n    if (!items) {\n      return;\n    }\n\n    const itemCount = items.length;\n    const selectionWraps = element.selectionWraps;\n\n    return items.map((item, itemIndex) => {\n      // How many steps from the selection point to this item?\n      const steps = stepsToIndex(itemCount, selectionWraps, selection, itemIndex);\n      // To convert steps to animation fraction:\n      // steps      animation fraction\n      //  1         0     (stage right)\n      //  0         0.5   (center stage)\n      // -1         1     (stage left)\n      const animationFraction = (1 - steps) / 2;\n      return (animationFraction >= 0 && animationFraction <= 1) ?\n        animationFraction :\n        null; // Outside animation range\n    });\n  },\n\n  /*\n   * Calculate the animation timings that should be used to smoothly animate the\n   * element's items from one selection state to another.\n   *\n   * This returns an array of timings, where the timing at position N should be\n   * used to animate item N. If an item's timing is null, then that item should\n   * not take place in the animation, and should be hidden instead.\n   */\n  effectTimingsForSelectionAnimation(element, fromSelection, toSelection) {\n\n    const items = element.items;\n    if (!items) {\n      return;\n    }\n    const itemCount = items.length;\n    const selectionWraps = element.selectionWraps;\n    const toIndex = FractionalSelectionMixin.helpers.wrappedSelectionParts(toSelection, itemCount, selectionWraps).index;\n    const totalSteps = stepsToIndex(itemCount, selectionWraps, fromSelection, toSelection);\n    const direction = totalSteps >= 0 ? 'normal': 'reverse';\n    const fill = 'both';\n    const totalDuration = element.selectionAnimationDuration;\n    const stepDuration = totalSteps !== 0 ?\n      totalDuration * 2 / Math.ceil(Math.abs(totalSteps)) :\n      0;  // No steps required, animation will be instantenous.\n\n    const timings = items.map((item, itemIndex) => {\n      const steps = stepsToIndex(itemCount, selectionWraps, itemIndex, toSelection);\n      // If we include this item in the staggered sequence of animations we're\n      // creating, where would the item appear in the sequence?\n      let positionInSequence = totalSteps - steps;\n      if (totalSteps < 0) {\n        positionInSequence = -positionInSequence;\n      }\n      // So, is this item really included in the sequence?\n      if (Math.ceil(positionInSequence) >= 0 && positionInSequence <= Math.abs(totalSteps)) {\n        // Note that delay for first item will be negative. That will cause\n        // the animation to start halfway through, which is what we want.\n        const delay = stepDuration * (positionInSequence - 1)/2;\n        const endDelay = itemIndex === toIndex ?\n          -stepDuration/2 :   // Stop halfway through.\n          0;              // Play animation until end.\n        return { duration: stepDuration, direction, fill, delay, endDelay };\n      } else {\n        return null;\n      }\n    });\n\n    return timings;\n  }\n\n};\n\n\n// Keyframes for standard selection animation effects.\nmixin.standardEffectKeyframes = {\n\n  // Simple crossfade\n  crossfade: [\n    { opacity: 0 },\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n\n  // Reveal, as if sliding the top card off a deck of cards\n  reveal: [\n    { transform: 'translateX(0%)', zIndex: 0 },\n    { transform: 'translateX(0%)', zIndex: 1 },\n    { transform: 'translateX(-100%)', zIndex: 2 }\n  ],\n\n  // Google Photos-style reveal-with-fade animation\n  revealWithFade: [\n    { transform: 'translateX(0%) scale(0.75)', opacity: 0, zIndex: 0 },\n    { transform: 'translateX(0%) scale(1.0)', opacity: 1, zIndex: 1 },\n    { transform: 'translateX(-100%) scale(1.0)', opacity: 1, zIndex: 2 }\n  ],\n\n  // Carousel variant with a bit of off-stage elements showing\n  showAdjacent: [\n    { transform: 'translateX(78%) scale(0.7)', zIndex: 0 },\n    { transform: 'translateX(0%) scale(0.82)', zIndex: 1 },\n    { transform: 'translateX(-78%) scale(0.7)', zIndex: 0 }\n  ],\n\n  // Simple slide\n  slide: [\n    { transform: 'translateX(100%)' },\n    { transform: 'translateX(-100%)' }\n  ],\n\n  // Slide, with a gap between\n  slideWithGap: [\n    { transform: 'translateX(110%)' },\n    { transform: 'translateX(-110%)' }\n  ]\n\n};\n\n\n/*\n * Smoothly animate the selection between the indicated \"from\" and \"to\"\n * indices. The former can be a fraction, e.g., when the user releases a finger\n * to complete a touch drag, and the selection will snap to the closest whole\n * index.\n */\nfunction animateSelection(element, fromSelection, toSelection) {\n\n  resetAnimations(element);\n\n  // Calculate the animation timings.\n  const items = element.items;\n  const keyframes = element.selectionAnimationKeyframes;\n  element[playingAnimationSymbol] = true;\n  const timings = mixin.helpers.effectTimingsForSelectionAnimation(element, fromSelection, toSelection);\n\n  // Figure out which item will be the one *after* the one we're selecting.\n  const itemCount = items.length;\n  const selectionWraps = element.selectionWraps;\n  const selectionIndex = FractionalSelectionMixin.helpers.selectionParts(toSelection, itemCount, selectionWraps).index;\n  const totalSteps = stepsToIndex(itemCount, selectionWraps, fromSelection, toSelection);\n  const forward = totalSteps >= 0;\n  let nextUpIndex = selectionIndex + (forward ? 1 : - 1);\n  if (selectionWraps) {\n    nextUpIndex = FractionalSelectionMixin.helpers.wrappedSelection(nextUpIndex, itemCount);\n  } else if (!isItemIndexInBounds(element, nextUpIndex)) {\n    nextUpIndex = null; // At start/end of list; don't have a next item to show.\n  }\n\n  // Play the animations using those timings.\n  let lastAnimationDetails;\n  timings.forEach((timing, index) => {\n    const item = items[index];\n    if (timing) {\n      showItem(item, true);\n      const animation = item.animate(keyframes, timing);\n      element[animationSymbol][index] = animation;\n      if (index === nextUpIndex) {\n        // This item will be animated, so will already be in the desired state\n        // after the animation completes.\n        nextUpIndex = null;\n      }\n      if (timing.endDelay !== 0) {\n        // This is the animation for the item that will be left selected.\n        // We want to clean up when this animation completes.\n        lastAnimationDetails = { animation, index, timing, forward };\n      }\n    } else {\n      // This item doesn't participate in the animation.\n      showItem(item, false);\n    }\n  });\n\n  if (lastAnimationDetails != null) {\n    // Arrange for clean-up work to be performed.\n    lastAnimationDetails.nextUpIndex = nextUpIndex;\n    lastAnimationDetails.animation.onfinish = event => selectionAnimationFinished(element, lastAnimationDetails);\n    element[lastAnimationSymbol] = lastAnimationDetails.animation;\n  } else {\n    // Shouldn't happen -- we should always have at least one animation.\n    element[playingAnimationSymbol] = false;\n  }\n}\n\n\nfunction getAnimationForItemIndex(element, index) {\n  if (element[animationSymbol] == null) {\n    // Not ready yet;\n    return null;\n  }\n  let animation = element[animationSymbol][index];\n  if (!animation) {\n    const item = element.items[index];\n    animation = item.animate(element.selectionAnimationKeyframes, {\n      duration: element.selectionAnimationDuration,\n      fill: 'both'\n    });\n    animation.pause();\n    element[animationSymbol][index] = animation;\n  }\n  return animation;\n}\n\nfunction isItemIndexInBounds(element, index) {\n  return index >= 0 && element.items && index < element.items.length;\n}\n\n/*\n * Render the selection state of the element.\n *\n * This can be used to re-render a previous selection state (if the\n * selectedIndex param is omitted), render the selection instantly at a given\n * whole or fractional selection index, or animate to a given selection index.\n *\n * There are several distinct scenarios we need to cover:\n *\n * 1. Initial positioning, or repositioning after changing a property like\n *    selectionAnimationKeyframes that affects rendering.\n * 2. Animate on selectedIndex change. This should override any animation/swipe\n *    already in progress.\n * 3. Instantly render the current position of a drag operation in progress.\n * 4. Complete a drag operation. If the drag wasn't far enough to affect\n *    selection, we'll just be restoring the selectedFraction to 0.\n *\n * If the list does not wrap, any selection position outside the list's bounds\n * will be damped to produce a visual effect of tension.\n */\nfunction renderSelection(element, selectedIndex=element.selectedIndex, selectedFraction=element.selectedFraction) {\n  const itemCount = element.items ? element.items.length : 0;\n  if (itemCount === 0) {\n    // Nothing to render.\n    return;\n  }\n  if (selectedIndex < 0) {\n    // TODO: Handle no selection.\n    return;\n  }\n  let selection = selectedIndex + selectedFraction;\n  if (element.selectionWraps) {\n    // Apply wrapping to ensure consistent representation of selection.\n    selection = FractionalSelectionMixin.helpers.wrappedSelection(selection, itemCount);\n  } else {\n    // Apply damping if necessary.\n    selection = FractionalSelectionMixin.helpers.dampedSelection(selection, itemCount);\n  }\n  const previousSelection = element[previousSelectionSymbol];\n  // TODO: If an item changes position in the DOM, we end up animating from\n  // its old index to its new index, but we really don't want to animate at all.\n  if (!element[symbols.dragging] && previousSelection != null &&\n      previousSelection !== selection) {\n    // Animate selection from previous state to new state.\n    animateSelection(element, previousSelection, selection);\n  } else if (selectedFraction === 0 && element[playingAnimationSymbol]) {\n    // Already in process of animating to fraction 0. During that process,\n    // ignore subsequent attempts to renderSelection to fraction 0.\n    return;\n  } else {\n    // Render current selection state instantly.\n    renderSelectionInstantly(element, selection);\n  }\n  element[previousSelectionSymbol] = selection;\n}\n\n/*\n * Instantly render (don't animate) the element's items at the given whole or\n * fractional selection index.\n */\nfunction renderSelectionInstantly(element, toSelection) {\n  if (element[resetAnimationsOnNextRenderSymbol]) {\n    resetAnimations(element);\n    element[resetAnimationsOnNextRenderSymbol] = false;\n  }\n  const animationFractions = mixin.helpers.animationFractionsForSelection(element, toSelection);\n  animationFractions.map((animationFraction, index) => {\n    const item = element.items[index];\n    if (animationFraction != null) {\n      showItem(item, true);\n      setAnimationFraction(element, index, animationFraction);\n    } else {\n      showItem(item, false);\n    }\n  });\n}\n\n/*\n * We maintain an array containing an animation per item. This is used for two\n * reasons:\n *\n * * During a drag operation, we want to be able to reuse animations between\n *   drag updates.\n * * When a selection animation completes, we need to be able to leave the\n *   visibile items in a paused state. Later, we'll want to be able to clean up\n *   those animations.\n *\n * Note that this array is sparse: it will only hold up from 03 animations at\n * any given point.\n */\nfunction resetAnimations(element) {\n  const animations = element[animationSymbol];\n  if (animations) {\n    // Cancel existing animations to remove the effects they're applying.\n    animations.forEach((animation, index) => {\n      if (animation) {\n        animation.cancel();\n        animations[index] = null;\n      }\n    });\n  }\n  const itemCount = element.items ? element.items.length : 0;\n  if (!animations || animations.length !== itemCount) {\n    // Haven't animated before with this number of items; (re)create array.\n    element[animationSymbol] = new Array(itemCount);\n  }\n}\n\n/*\n * The last animation in our selection animation has completed. Clean up.\n */\nfunction selectionAnimationFinished(element, details) {\n\n  // When the last animation completes, show the next item in the direction\n  // we're going. Waiting to that until this point is a bit of a hack to avoid\n  // having a next item that's higher in the natural z-order obscure other items\n  // during animation.\n  const nextUpIndex = details.nextUpIndex;\n  if (nextUpIndex != null) {\n    if (element[animationSymbol][nextUpIndex]) {\n      // Cancel existing selection animation so we can construct a new one.\n      element[animationSymbol][nextUpIndex].cancel();\n      element[animationSymbol][nextUpIndex] = null;\n    }\n    const animationFraction = details.forward ? 0 : 1;\n    setAnimationFraction(element, nextUpIndex, animationFraction);\n    showItem(element.items[nextUpIndex], true);\n  }\n\n  element[lastAnimationSymbol].onfinish = null;\n  element[playingAnimationSymbol] = false;\n}\n\n/*\n * Pause the indicated animation and have it show the animation at the given\n * fraction (between 0 and 1) of the way through the animation.\n */\nfunction setAnimationFraction(element, itemIndex, fraction) {\n  const animation = getAnimationForItemIndex(element, itemIndex);\n  if (animation) {\n    const duration = element.selectionAnimationDuration;\n    if (duration) {\n      animation.currentTime = fraction * duration;\n    }\n  }\n}\n\nfunction showItem(item, flag) {\n  item.style.visibility = flag ? 'visible' : 'hidden';\n}\n\n/*\n * Figure out how many steps it will take to go from fromSelection to\n * toSelection. To go from item 3 to item 4 is one step.\n *\n * If wrapping is allowed, then going from the last item to the first will take\n * one step (forward), and going from the first item to the last will take one\n * step (backward).\n */\nfunction stepsToIndex(length, allowWrap, fromSelection, toSelection) {\n  let steps = toSelection - fromSelection;\n  // Wrapping only kicks in when list has more than 1 item.\n  if (allowWrap && length > 1) {\n    const wrapSteps = length - Math.abs(steps);\n    if (wrapSteps <= 1) {\n      // Special case\n      steps = steps < 0 ?\n        wrapSteps :   // Wrap forward from last item to first.\n        -wrapSteps;   // Wrap backward from first item to last.\n    }\n  }\n  return steps;\n}\n","import symbols from './symbols';\n\n\n// Used to assign unique IDs to item elements without IDs.\nlet idCount = 0;\n\n\n/* Exported function extends a base class with SelectionAriaActive. */\nexport default (base) => {\n\n  /**\n   * Mixin which treats the selected item in a list as the active item in ARIA\n   * accessibility terms.\n   *\n   * Handling ARIA selection state properly is actually quite complex:\n   *\n   * * The items in the list need to be indicated as possible items via an ARIA\n   *   `role` attribute value such as \"option\".\n   * * The selected item need to be marked as selected by setting the item's\n   *   `aria-selected` attribute to true *and* the other items need be marked as\n   *   *not* selected by setting `aria-selected` to false.\n   * * The outermost element with the keyboard focus needs to have attributes\n   *   set on it so that the selection is knowable at the list level via the\n   *   `aria-activedescendant` attribute.\n   * * Use of `aria-activedescendant` in turn requires that all items in the\n   *   list have ID attributes assigned to them.\n   *\n   * This mixin tries to address all of the above requirements. To that end,\n   * this mixin will assign generated IDs to any item that doesn't already have\n   * an ID.\n   *\n   * ARIA relies on elements to provide `role` attributes. This mixin will apply\n   * a default role of \"listbox\" on the outer list if it doesn't already have an\n   * explicit role. Similarly, this mixin will apply a default role of \"option\"\n   * to any list item that does not already have a role specified.\n   *\n   * This mixin expects a set of members that manage the state of the selection:\n   * `[symbols.itemSelected]`, `itemAdded`, and `selectedIndex`. You can\n   * supply these yourself, or do so via\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class SelectionAriaActive extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      // Set default ARIA role.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'listbox';\n      return defaults;\n    }\n\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n\n      if (!item.getAttribute('role')) {\n        // Assign a default ARIA role.\n        item.setAttribute('role', 'option');\n      }\n\n      // Ensure each item has an ID so we can set aria-activedescendant on the\n      // overall list whenever the selection changes.\n      //\n      // The ID will take the form of a base ID plus a unique integer. The base\n      // ID will be incorporate the component's own ID. E.g., if a component has\n      // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n      // the compnent has no ID itself, its items will get IDs that look like\n      // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n      // them from manually-assigned IDs, and to minimize the potential for ID\n      // conflicts.\n      if (!item.id) {\n        const baseId = this.id ?\n            \"_\" + this.id + \"Option\" :\n            \"_option\";\n        item.id = baseId + idCount++;\n      }\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      item.setAttribute('aria-selected', selected);\n      const itemId = item.id;\n      if (itemId && selected) {\n        this.setAttribute('aria-activedescendant', itemId);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item == null) {\n        // Selection was removed.\n        this.removeAttribute('aria-activedescendant');\n      }\n    }\n\n  }\n\n  return SelectionAriaActive;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with SelectionHighlight. */\nexport default (base) => {\n\n  /**\n   * Template mixin which applies standard highlight colors to a selected item.\n   *\n   * This mixin highlights textual items (e.g., in a list) in a standard way by\n   * using the CSS `highlight` and `highlighttext` color values. These values\n   * respect operating system defaults and user preferences, and hence are good\n   * default values for highlight colors.\n   *\n   * This mixin expects a `selected` class to be applied to selected items. You\n   * can use [ContentItemsMixin](ContentItemsMixin.md) for that purpose.\n   */\n  class SelectionHighlight extends base {\n\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n          :host([generic=\"\"]) ::slotted(.selected) {\n            background-color: highlight;\n            color: highlighttext;\n          }\n        </style>\n        ${baseTemplate}\n      `;\n    }\n\n  }\n\n  return SelectionHighlight;\n};\n","/* Exported function extends a base class with SelectionInView. */\nexport default (base) => {\n\n  /**\n   * Mixin which scrolls a container to ensure that a newly-selected item is\n   * visible to the user.\n   *\n   * When the selected item in a list-like component changes, it's easier for\n   * the to confirm that the selection has changed to an appropriate item if the\n   * user can actually see that item.\n   *\n   * This mixin expects a `selectedItem` property to be set when the selection\n   * changes. You can supply that yourself, or use\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class SelectionInView extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      const selectedItem = this.selectedItem;\n      if (selectedItem) {\n        this.scrollItemIntoView(selectedItem);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item) {\n        // Keep the selected item in view.\n        this.scrollItemIntoView(item);\n      }\n    }\n\n    /**\n     * Scroll the given element completely into view, minimizing the degree of\n     * scrolling performed.\n     *\n     * Blink has a `scrollIntoViewIfNeeded()` function that does something\n     * similar, but unfortunately it's non-standard, and in any event often ends\n     * up scrolling more than is absolutely necessary.\n     *\n     * @param {HTMLElement} item - the item to scroll into view.\n     */\n    scrollItemIntoView(item) {\n      if (super.scrollItemIntoView) { super.scrollItemIntoView(); }\n      // Get the relative position of the item with respect to the top of the\n      // list's scrollable canvas. An item at the top of the list will have a\n      // elementTop of 0.\n\n      const scrollTarget = this.scrollTarget;\n      const elementTop = item.offsetTop - scrollTarget.offsetTop - scrollTarget.clientTop;\n      const elementBottom = elementTop + item.offsetHeight;\n      // Determine the bottom of the scrollable canvas.\n      const scrollBottom = scrollTarget.scrollTop + scrollTarget.clientHeight;\n      if (elementBottom > scrollBottom) {\n        // Scroll up until item is entirely visible.\n        scrollTarget.scrollTop += elementBottom - scrollBottom;\n      }\n      else if (elementTop < scrollTarget.scrollTop) {\n        // Scroll down until item is entirely visible.\n        scrollTarget.scrollTop = elementTop;\n      }\n    }\n\n    /**\n     * The element that should be scrolled to bring an item into view.\n     *\n     * The default value of this property is the element itself.\n     *\n     * @type {HTMLElement}\n     */\n    get scrollTarget() {\n      // Prefer base result.\n      return 'scrollTarget' in base.prototype ? super.scrollTarget : this;\n    }\n    set scrollTarget(element) {\n      if ('scrollTarget' in base.prototype) { super.scrollTarget = element; }\n    }\n\n  }\n\n  return SelectionInView;\n};\n","/* Exported function extends a base class with ShadowElementReferences. */\nexport default (base) => {\n\n  /**\n   * Mixin to create references to elements in a component's Shadow DOM subtree.\n   *\n   * This adds a member on the component called `this.$` that can be used to\n   * reference shadow elements with IDs. E.g., if component's shadow contains an\n   * element `<button id=\"foo\">`, then this mixin will create a member\n   * `this.$.foo` that points to that button.\n   *\n   * Such references simplify a component's access to its own elements. In\n   * exchange, this mixin trades off a one-time cost of querying all elements in\n   * the shadow tree instead of paying an ongoing cost to query for an element\n   * each time the component wants to inspect or manipulate it.\n   *\n   * This mixin expects the component to define a Shadow DOM subtree. You can\n   * create that tree yourself, or make use of\n   * [ShadowTemplateMixin](ShadowTemplateMixin.md).\n   *\n   * This mixin is inspired by Polymer's [automatic\n   * node finding](https://www.polymer-project.org/1.0/docs/devguide/local-dom.html#node-finding)\n   * feature.\n   */\n  class ShadowElementReferences extends base {\n\n    constructor() {\n      super();\n      if (this.shadowRoot) {\n        // Look for elements in the shadow subtree that have id attributes.\n        // An alternatively implementation of this mixin would be to just define\n        // a this.$ getter that lazily does this search the first time someone\n        // tries to access this.$. That might introduce some complexity  if the\n        // the tree changed after it was first populated, the result of\n        // searching for a node might be somewhat unpredictable.\n        this.$ = {};\n        const nodesWithIds = this.shadowRoot.querySelectorAll('[id]');\n        [].forEach.call(nodesWithIds, node => {\n          const id = node.getAttribute('id');\n          this.$[id] = node;\n        });\n      }\n    }\n\n    /**\n     * The collection of references to the elements with IDs in a component's\n     * Shadow DOM subtree.\n     *\n     * @type {object}\n     * @member $\n     */\n  }\n\n  return ShadowElementReferences;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with ShadowTemplate. */\nexport default (base) => {\n\n  /**\n   * Mixin for stamping a template into a Shadow DOM subtree upon component\n   * instantiation.\n   *\n   * To use this mixin, define a `template` property as a string or HTML\n   * `<template>` element:\n   *\n   *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n   *       get [symbols.template]() {\n   *         return `Hello, <em>world</em>.`;\n   *       }\n   *     }\n   *\n   * When your component class is instantiated, a shadow root will be created on\n   * the instance, and the contents of the template will be cloned into the\n   * shadow root. If your component does not define a `template` property, this\n   * mixin has no effect.\n   *\n   * For the time being, this extension retains support for Shadow DOM v0. That\n   * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n   * implement Shadow DOM v1.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n      let template = this[symbols.template];\n      // TODO: Save the processed template with the component's class prototype\n      // so it doesn't need to be processed with every instantiation.\n      if (template) {\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          template = createTemplateWithInnerHTML(template);\n        }\n\n        if (window.ShadowDOMPolyfill) {\n          shimTemplateStyles(template, this.localName);\n        }\n\n        const root = this.attachShadow({ mode: 'open' });\n        const clone = document.importNode(template.content, true);\n        root.appendChild(clone);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n};\n\n\n// Convert a plain string of HTML into a real template element.\nfunction createTemplateWithInnerHTML(innerHTML) {\n  const template = document.createElement('template');\n  // REVIEW: Is there an easier way to do this?\n  // We'd like to just set innerHTML on the template content, but since it's\n  // a DocumentFragment, that doesn't work.\n  const div = document.createElement('div');\n  div.innerHTML = innerHTML;\n  while (div.childNodes.length > 0) {\n    template.content.appendChild(div.childNodes[0]);\n  }\n  return template;\n}\n\n// Invoke basic style shimming with ShadowCSS.\nfunction shimTemplateStyles(template, tag) {\n  window.WebComponents.ShadowCSS.shimStyling(template.content, tag);\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = createSymbol('canSelectNext');\nconst canSelectPreviousSymbol = createSymbol('canSelectPrevious');\nconst selectionRequiredSymbol = createSymbol('selectionRequired');\nconst selectionWrapsSymbol = createSymbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = createSymbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = createSymbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = createSymbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = createSymbol('internalSelectedItem');\n\n\n/* Exported function extends a base class with SingleSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages single-selection semantics for items in a list.\n   *\n   * This mixin expects a component to provide an `items` Array or NodeList of\n   * all elements in the list. A standard way to do that with is the\n   * [ContentItemsMixin](ContentItemsMixin.md), which takes a component's\n   * content (typically its distributed children) as the set of list items; see\n   * that mixin for details.\n   *\n   * This mixin tracks a single selected item in the list, and provides means to\n   * get and set that state by item position (`selectedIndex`) or item identity\n   * (`selectedItem`). The selection can be moved in the list via the methods\n   * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n   *\n   * This mixin does not produce any user-visible effects to represent\n   * selection. Other mixins, such as\n   * [SelectionAriaActiveMixin](SelectionAriaActiveMixin.md),\n   * [SelectionHighlightMixin](SelectionHighlightMixin.md) and\n   * [SelectionInViewMixin](SelectionInViewMixin.md), modify the selected item\n   * in common ways to let the user know a given item is selected or not\n   * selected.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const previousCanSelectNext = this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (canSelectNext !== previousCanSelectNext) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const previousCanSelectPrevious = this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (canSelectPrevious !== previousCanSelectPrevious) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedIndex = this[internalSelectedIndexSymbol];\n      let item;\n      if (index !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && index >= 0 && index < items.length)) {\n          index = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = index;\n        item = hasItems && index >= 0 ? items[index] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (index !== previousSelectedIndex) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = index;\n\n        const event = new CustomEvent('selected-index-changed', {\n          detail: {\n            selectedIndex: index,\n            value: index // for Polymer binding. TODO: Verify still necessary\n          }\n        });\n        this.dispatchEvent(event);\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (item !== previousSelectedItem) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        const event = new CustomEvent('selected-item-changed', {\n          detail: {\n            selectedItem: item,\n            value: item // for Polymer binding\n          }\n        });\n        this.dispatchEvent(event);\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      this[selectionRequiredSymbol] = selectionRequired;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      trackSelectedItem(this);\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(value) {\n      this[selectionWrapsSymbol] = String(value) === 'true';\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Select the last item in the list.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the selectedItem property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     * @param {HTMLElement} detail.previousItem The previously selected item.\n     */\n\n    /**\n     * Fires when the selectedIndex property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n  }\n\n  return SingleSelection;\n};\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n  const count = element.items.length;\n\n  const boundedIndex = (element.selectionWraps) ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst deltaXSymbol = createSymbol('deltaX');\nconst deltaYSymbol = createSymbol('deltaY');\nconst multiTouchSymbol = createSymbol('multiTouch');\nconst previousXSymbol = createSymbol('previousX');\nconst previousYSymbol = createSymbol('previousY');\nconst startXSymbol = createSymbol('startX');\nconst travelFractionSymbol = createSymbol('travelFraction');\n\n\n/* Exported function extends a base class with SwipeDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps touch gestures (swipe left, swipe right) to direction\n   * semantics (go right, go left).\n   *\n   * By default, this mixin presents no user-visible effects; it just indicates\n   * a direction in which the user is currently swiping or has finished swiping.\n   * To map the direction to a change in selection, use\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n   */\n  class SwipeDirection extends base {\n\n    constructor() {\n      super();\n\n      this.travelFraction = 0;\n\n      // In all touch events, only handle single touches. We don't want to\n      // inadvertently do work when the user's trying to pinch-zoom for example.\n      // TODO: Even better approach than below would be to ignore touches after\n      // the first if the user has already begun a swipe.\n      // TODO: Touch events should probably be factored out into its own mixin.\n      if (window.PointerEvent) {\n        // Prefer listening to standard pointer events.\n        this.addEventListener('pointerdown', event => {\n          if (isEventForPenOrPrimaryTouch(event)) {\n            touchStart(this, event.clientX, event.clientY);\n          }\n        });\n        this.addEventListener('pointermove', event => {\n          if (isEventForPenOrPrimaryTouch(event)) {\n            const handled = touchMove(this, event.clientX, event.clientY);\n            if (handled) {\n              event.preventDefault();\n            }\n          }\n        });\n        this.addEventListener('pointerup', event => {\n          if (isEventForPenOrPrimaryTouch(event)) {\n            touchEnd(this, event.clientX, event.clientY);\n          }\n        });\n      } else {\n        // Pointer events not supported -- listen to older touch events.\n        this.addEventListener('touchstart', event => {\n          if (this[multiTouchSymbol]) {\n            return;\n          } else if (event.touches.length === 1) {\n            const clientX = event.changedTouches[0].clientX;\n            const clientY = event.changedTouches[0].clientY;\n            touchStart(this, clientX, clientY);\n          } else {\n            this[multiTouchSymbol] = true;\n          }\n        });\n        this.addEventListener('touchmove', event => {\n          if (!this[multiTouchSymbol] && event.touches.length === 1) {\n            const clientX = event.changedTouches[0].clientX;\n            const clientY = event.changedTouches[0].clientY;\n            const handled = touchMove(this, clientX, clientY);\n            if (handled) {\n              event.preventDefault();\n            }\n          }\n        });\n        this.addEventListener('touchend', event => {\n          if (event.touches.length === 0) {\n            // All touches removed; gesture is complete.\n            if (!this[multiTouchSymbol]) {\n              // Single-touch swipe has finished.\n              const clientX = event.changedTouches[0].clientX;\n              const clientY = event.changedTouches[0].clientY;\n              touchEnd(this, clientX, clientY);\n            }\n            this[multiTouchSymbol] = false;\n          }\n        });\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // For the component to receive PointerEvents in IE/Edge, we need to set\n      // touch-action: none. Only make this change if touch-action is currently\n      // the default value (\"auto\"), in case the developer knows better than we\n      // do what they want in their particular context.\n      if (getComputedStyle(this).touchAction === 'auto') {\n        this.style.touchAction = 'none';\n      }\n    }\n\n    // Default implementation.\n    get [symbols.dragging]() {\n      return super[symbols.dragging];\n    }\n    set [symbols.dragging](value) {\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * The distance the first touchpoint has traveled since the beginning of a\n     * drag, expressed as a fraction of the element's width.\n     *\n     * @type number\n     */\n    get travelFraction() {\n      return this[travelFractionSymbol];\n    }\n    set travelFraction(value) {\n      this[travelFractionSymbol] = value;\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n    }\n\n  }\n\n  return SwipeDirection;\n};\n\n\n// Return true if the pointer event is for the pen, or the primary touch point.\nfunction isEventForPenOrPrimaryTouch(event) {\n  return event.pointerType === 'pen' ||\n      (event.pointerType === 'touch' && event.isPrimary);\n}\n\n/*\n * Invoked when the user has finished a touch operation.\n */\nfunction touchEnd(element, clientX, clientY) {\n  element[symbols.dragging] = false;\n  if (element[deltaXSymbol] >= 20) {\n    // Finished going right at high speed.\n    element[symbols.goLeft]();\n  } else if (element[deltaXSymbol] <= -20) {\n    // Finished going left at high speed.\n    element[symbols.goRight]();\n  } else {\n    // Finished at low speed.\n    trackTo(element, clientX);\n    const travelFraction = element.travelFraction;\n    if (travelFraction >= 0.5) {\n      element[symbols.goRight]();\n    } else if (travelFraction <= -0.5) {\n      element[symbols.goLeft]();\n    }\n  }\n  element.travelFraction = 0;\n  element[deltaXSymbol] = null;\n  element[deltaYSymbol] = null;\n}\n\n/*\n * Invoked when the user has moved during a touch operation.\n */\nfunction touchMove(element, clientX, clientY) {\n\n  element[deltaXSymbol] = clientX - element[previousXSymbol];\n  element[deltaYSymbol] = clientY - element[previousYSymbol];\n  element[previousXSymbol] = clientX;\n  element[previousYSymbol] = clientY;\n  if (Math.abs(element[deltaXSymbol]) > Math.abs(element[deltaYSymbol])) {\n    // Move was mostly horizontal.\n    trackTo(element, clientX);\n    // Indicate that the event was handled. It'd be nicer if we didn't have\n    // to do this so that, e.g., a user could be swiping left and right\n    // while simultaneously scrolling up and down. (Native touch apps can do\n    // that.) However, Mobile Safari wants to handle swipe events near the\n    // page and interpret them as navigations. To avoid having a horiziontal\n    // swipe misintepreted as a navigation, we indicate that we've handled\n    // the event, and prevent default behavior.\n    return true;\n  } else {\n    // Move was mostly vertical.\n    return false; // Not handled\n  }\n}\n\n/*\n * Invoked when the user has begun a touch operation.\n */\nfunction touchStart(element, clientX, clientY) {\n  element[symbols.dragging] = true;\n  element[startXSymbol] = clientX;\n  element[previousXSymbol] = clientX;\n  element[previousYSymbol] = clientY;\n  element[deltaXSymbol] = 0;\n  element[deltaYSymbol] = 0;\n}\n\nfunction trackTo(element, x) {\n  const width = element.offsetWidth;\n  const dragDistance = element[startXSymbol] - x;\n  const fraction = width > 0 ?\n    dragDistance / width :\n    0;\n  element.travelFraction = fraction;\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\nconst playingSymbol = createSymbol('playing');\nconst selectionTimerDurationSymbol = createSymbol('selectionTimerDuration');\nconst timerTimeoutSymbol = createSymbol('timerTimeout');\n\n\n/* Exported function extends a base class with TimerSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which provides for automatic timed changes in selection.\n   *\n   * This mixin is useful for creating slideshow-like elements such as\n   * [basic-slideshow](../../basic-slideshow) and\n   * [basic-slideshow-with-controls](../../basic-slideshow-with-controls).\n   *\n   * Typical usage:\n   *\n   *     class CarouselWithTimer extends TimerSelectionMixin(Carousel) {}\n   *     customElements.define('carousel-with-arrows', CarouselWithTimer);\n   *\n   * This mixin expects the component to define an `items` property, as well as\n   * `selectFirst` and `selectNext` methods. You can implement those yourself,\n   * or use [ContentItemsMixin](ContentItemsMixin.md) and\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class TimerSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.playing === 'undefined') {\n        this.playing = this[symbols.defaults].playing;\n      }\n      if (typeof this.selectionTimerDuration === 'undefined') {\n        this.selectionTimerDuration = this[symbols.defaults].selectionTimerDuration;\n      }\n    }\n\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n      restartTimer(this);\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.playing = false;\n      defaults.selectionTimerDuration = 1000;\n      return defaults;\n    }\n\n    /**\n     * Begin automatic progression of the selection.\n     */\n    play() {\n      if (super.play) { super.play(); }\n      startTimer(this);\n      this[playingSymbol] = true;\n    }\n\n    /**\n     * Pause automatic progression of the selection.\n     */\n    pause() {\n      if (super.pause) { super.pause(); }\n      clearTimer(this);\n      this[playingSymbol] = false;\n    }\n\n    /**\n     * True if the selection is being automatically advanced.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get playing() {\n      return this[playingSymbol];\n    }\n    set playing(playing) {\n      const previousPlaying = this[playingSymbol];\n      const parsed = String(playing) === 'true'; // Cast to boolean\n      if ('playing' in base.prototype) { super.playing = playing; }\n      if (parsed !== previousPlaying) {\n        if (playing) {\n          this.play();\n        } else {\n          this.pause();\n        }\n      }\n    }\n\n    /*\n     * When the selected item changes (because of something this mixin did, or\n     * was changed by an outside agent like the user), we wait before advancing\n     * to the next item. By triggering the next item this way, we implicitly get\n     * a desirable behavior: if the user changes the selection (e.g., in a\n     * carousel), we let them see that selection state for a while before\n     * advancing the selection ourselves.\n     */\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      restartTimer(this);\n    }\n\n    /**\n     * The time in milliseconds that will elapse after the selection changes\n     * before the selection will be advanced to the next item in the list.\n     *\n     * @type {number} - Time in milliseconds\n     * @default 1000 (1 second)\n     */\n    get selectionTimerDuration() {\n      return this[selectionTimerDurationSymbol];\n    }\n    set selectionTimerDuration(value) {\n      this[selectionTimerDurationSymbol] = parseInt(value);\n      if ('selectionTimerDuration' in base.prototype) { super.selectionTimerDuration = value; }\n    }\n\n  }\n\n  return TimerSelection;\n};\n\n\nfunction clearTimer(element) {\n  if (element[timerTimeoutSymbol]) {\n    clearTimeout(element[timerTimeoutSymbol]);\n    element[timerTimeoutSymbol] = null;\n  }\n}\n\nfunction restartTimer(element) {\n  clearTimer(element);\n  if (element.playing && element.items && element.items.length > 0) {\n    startTimer(element);\n  }\n}\n\nfunction startTimer(element) {\n  // If play() is called more than once, cancel any existing timer.\n  clearTimer(element);\n  element[timerTimeoutSymbol] = setTimeout(() => {\n    selectNextWithWrap(element);\n  }, element.selectionTimerDuration);\n}\n\n// Select the next item, wrapping to first item if necessary.\nfunction selectNextWithWrap(element) {\n  const items = element.items;\n  if (items && items.length > 0) {\n    if (element.selectedIndex == null || element.selectedIndex === items.length - 1) {\n      element.selectFirst();\n    } else {\n      element.selectNext();\n    }\n  }\n}\n","import createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst absorbDecelerationSymbol = createSymbol('absorbDeceleration');\nconst lastDeltaXSymbol = createSymbol('lastDeltaX');\nconst lastWheelTimeoutSymbol = createSymbol('lastWheelTimeout');\nconst postNavigateDelayCompleteSymbol = createSymbol('postNavigateDelayComplete');\nconst wheelDistanceSymbol = createSymbol('wheelDistance');\n\n\n/* Exported function extends a base class with TrackpadDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps a horizontal trackpad swipe gestures (or horizontal mouse\n   * wheel actions) to direction semantics.\n   *\n   * You can use this mixin with a mixin like\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md) to let the user\n   * change the selection with the trackpad or mouse wheel.\n   *\n   * To respond to the trackpad, we can listen to the DOM's \"wheel\" events.\n   * These events are fired as the user drags their fingers across a trackpad.\n   * Unfortunately, browsers are missing a critical event there is no event\n   * when the user *stops* a gestured on the trackpad or mouse wheel.\n   *\n   * To make things worse, the mainstream browsers continue to generate fake\n   * wheel events even after the user has stopped dragging their fingers. These\n   * fake events simulate the user gradually slowing down the drag until they\n   * come to a smooth stop. In some contexts, these fake wheel events might be\n   * helpful, but in trying to supply typical trackpad swipe navigation, these\n   * fake events get in the way.\n   *\n   * This component uses heuristics to work around these problems, but the\n   * complex nature of the problem make it extremely difficult to achieve the\n   * same degree of trackpad responsiveness possible with native applications.\n   */\n  class TrackpadDirection extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('wheel', event => {\n        const handled = wheel(this, event);\n        if (handled) {\n          event.preventDefault();\n        }\n      });\n      resetWheelTracking(this);\n    }\n\n    // Default implementation.\n    get [symbols.dragging]() {\n      return super[symbols.dragging];\n    }\n    set [symbols.dragging](value) {\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * The distance the user has moved the first touchpoint since the beginning\n     * of a trackpad/wheel operation, expressed as a fraction of the element's\n     * width.\n     *\n     * @type number\n     */\n    get travelFraction() {\n      return super.travelFraction;\n    }\n    set travelFraction(value) {\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n    }\n\n  }\n\n  return TrackpadDirection;\n};\n\n\n// Time we wait following a navigation before paying attention to wheel\n// events again.\nconst POST_NAVIGATE_TIME = 250;\n\n// Time we wait after the last wheel event before we reset things.\nconst WHEEL_TIME = 100;\n\n\n// Following a navigation, partially reset our wheel tracking.\nfunction postNavigate(element) {\n  element.travelFraction = 0;\n  element[wheelDistanceSymbol] = 0;\n  element[postNavigateDelayCompleteSymbol] = true;\n  element[absorbDecelerationSymbol] = true;\n  setTimeout(() => {\n    element[postNavigateDelayCompleteSymbol] = false;\n  }, POST_NAVIGATE_TIME);\n}\n\n// Reset all state related to the tracking of the wheel.\nfunction resetWheelTracking(element) {\n  element.travelFraction = 0;\n  element[wheelDistanceSymbol] = 0;\n  element[lastDeltaXSymbol] = 0;\n  element[absorbDecelerationSymbol] = false;\n  element[postNavigateDelayCompleteSymbol] = false;\n  if (element[lastWheelTimeoutSymbol]) {\n    clearTimeout(element[lastWheelTimeoutSymbol]);\n    element[lastWheelTimeoutSymbol] = null;\n  }\n}\n\n// Define our own sign function, since (as of May 2015), Safari and IE don't\n// supply Math.sign().\nfunction sign(x) {\n  return (x === 0) ?\n    0 :\n    (x > 0) ?\n      1 :\n      -1;\n}\n\n// TODO: Damping, or some other treatment for going past the ends.\n\n/*\n * A wheel event has been generated. This could be a real wheel event, or it\n * could be fake (see notes in the header).\n *\n * This handler uses several strategies to try to approximate native trackpad\n * swipe navigation.\n *\n * If the user has dragged enough to cause a navigation, then for a short\n * delay following that navigation, subsequent wheel events will be ignored.\n *\n * Furthermore, follwowing a navigation, we ignore all wheel events until we\n * receive at least one event where the event's deltaX (distance traveled) is\n * *greater* than the previous event's deltaX. This helps us filter out the\n * fake wheel events generated by the browser to simulate deceleration.\n *\n */\nfunction wheel(element, event) {\n\n  // Since we have a new wheel event, reset our timer waiting for the last\n  // wheel event to pass.\n  if (element[lastWheelTimeoutSymbol]) {\n    clearTimeout(element[lastWheelTimeoutSymbol]);\n  }\n  element[lastWheelTimeoutSymbol] = setTimeout(() => {\n    wheelTimedOut(element);\n  }, WHEEL_TIME);\n\n  const deltaX = event.deltaX;\n  const deltaY = event.deltaY;\n\n  // See if element event represents acceleration or deceleration.\n  const acceleration = sign(deltaX) * (deltaX - element[lastDeltaXSymbol]);\n  element[lastDeltaXSymbol] = deltaX;\n\n  if (Math.abs(deltaX) < Math.abs(deltaY)) {\n    // Move was mostly vertical. The user may be trying scroll with the\n    // trackpad/wheel. To be on the safe, we ignore such events.\n    return false;\n  }\n\n  if (element[postNavigateDelayCompleteSymbol]) {\n    // It's too soon after a navigation; ignore the event.\n    return true;\n  }\n\n  if (acceleration > 0) {\n    // The events are not (or are no longer) decelerating, so we can start\n    // paying attention to them again.\n    element[absorbDecelerationSymbol] = false;\n  } else if (element[absorbDecelerationSymbol]) {\n    // The wheel event was likely faked to simulate deceleration; ignore it.\n    return true;\n  }\n\n  element[wheelDistanceSymbol] += deltaX;\n\n  // Update the travel fraction of the element being navigated.\n  const width = element.offsetWidth;\n  let travelFraction = width > 0 ?\n    element[wheelDistanceSymbol] / width :\n    0;\n  element[symbols.dragging] = true;\n  travelFraction = sign(travelFraction) * Math.min(Math.abs(travelFraction), 1);\n  element.travelFraction = travelFraction;\n\n  // If the user has dragged enough to reach the previous/next item, then\n  // complete a navigation to that item.\n  if (travelFraction === 1) {\n    element[symbols.dragging] = false;\n    element[symbols.goRight]();\n    postNavigate(element);\n  } else if (travelFraction === -1) {\n    element[symbols.dragging] = false;\n    element[symbols.goLeft]();\n    postNavigate(element);\n  }\n\n  return true;\n}\n\n// A sufficiently long period of time has passed since the last wheel event.\n// We snap the selection to the closest item, then reset our state.\nfunction wheelTimedOut(element) {\n\n  // Snap to the closest item.\n  element[symbols.dragging] = false;\n  const travelFraction = element.travelFraction;\n  if (travelFraction >= 0.5) {\n    element[symbols.goRight]();\n  } else if (travelFraction <= -0.5) {\n    element[symbols.goLeft]();\n  }\n\n  // TODO: Listen for the transition to complete, and then restore\n  // dragging to false (or the previous value).\n\n  resetWheelTracking(element);\n}\n","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n","/*\n * Microtask helper for IE 11.\n *\n * Executing a function as a microtask is trivial in browsers that support\n * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n * promises, but does support MutationObservers, which are also executed as\n * microtasks. So this helper uses an MutationObserver to achieve microtask\n * timing.\n *\n * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * Inspired by Polymer's async() function.\n */\n\n\n// The queue of pending callbacks to be executed as microtasks.\nconst callbacks = [];\n\n// Create an element that we will modify to force observable mutations.\nconst element = document.createTextNode('');\n\n// A monotonically-increasing value.\nlet counter = 0;\n\n\n/**\n * Add a callback to the microtask queue.\n *\n * This uses a MutationObserver so that it works on IE 11.\n *\n * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n * needs more investigation.\n *\n * @function microtask\n * @param {function} callback\n */\nexport default function microtask(callback) {\n  callbacks.push(callback);\n  // Force a mutation.\n  element.textContent = ++counter;\n}\n\n\n// Execute any pending callbacks.\nfunction executeCallbacks() {\n  while (callbacks.length > 0) {\n    const callback = callbacks.shift();\n    callback();\n  }\n}\n\n\n// Create the observer.\nconst observer = new MutationObserver(executeCallbacks);\nobserver.observe(element, {\n  characterData: true\n});\n","/**\n * Helper function for rendering an array of items as elements.\n *\n * This is not a mixin, but a function components can use if they need to\n * generate a set of elements for the items in an array.\n *\n * This function will reuse existing elements if possible. E.g., if it is called\n * to render an array of 4 items, and later called to render an array of 5\n * items, it can reuse the existing 4 items, creating just one new element.\n * Note, however, that this re-rendering is not automatic. If, after calling\n * this function, you manipulate the array you used, you must still call this\n * function again to re-render the array.\n *\n * The `renderItem` parameter takes a function of two arguments: an item to\n * to render, and an existing element (if one exists) which can be repurposed to\n * render that item. If the latter argument is null, the `renderItem()` function\n * should create a new element and return it. The function should do the same\n * if the supplied existing element is not suitable for rendering the given\n * item; the returned element will be used to replace the existing one. If the\n * existing element *is* suitable, the function can simply update it and return\n * it as is.\n *\n * Example: The following will render an array of strings in divs as children\n * of the `container` element:\n *\n *     let strings = ['a', 'b', 'c', ...];\n *     let container = this.querySelector(...);\n *     renderArrayAsElements(strings, container, (string, element) => {\n *       if (!element) {\n *         // No element exists yet, so create a new one.\n *         element = document.createElement('div');\n *       }\n *       // Set/update the text content of the element.\n *       element.textContent = string;\n *       return element;\n *     });\n *\n * @param {Array} items - the items to render\n * @param {HTMLElement} container - the parent that will hold the elements\n * @param {function} renderItem - returns a new element for an item, or\n *                                repurposes an existing element for an item\n */\nfunction renderArrayAsElements(items, container, renderItem) {\n  // Create a new set of elements for the current items.\n  items.forEach((item, index) => {\n    const oldElement = container.childNodes[index];\n    const newElement = renderItem(item, oldElement);\n    if (newElement) {\n      if (!oldElement) {\n        container.appendChild(newElement);\n      } else if (newElement !== oldElement) {\n        container.replaceChild(newElement, oldElement);\n      }\n    }\n  });\n\n  // If the array shrank, remove the extra elements which are no longer needed.\n  while (container.childNodes.length > items.length) {\n    container.removeChild(container.childNodes[items.length]);\n  }\n}\n\nexport default renderArrayAsElements;\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\n\n\n// Symbols for private data members on an element.\nconst safeToSetAttributesSymbol = createSymbol('safeToSetAttributes');\nconst pendingAttributesSymbol = createSymbol('pendingAttributes');\nconst pendingClassesSymbol = createSymbol('pendingClasses');\n\n\n/**\n * Helper functions for updating attributes, including the `class` attribute.\n */\nexport default {\n\n  /**\n   * Perform any pending updates to attributes and classes.\n   *\n   * This writes any `setAttribute` or `toggleClass` values that were performed\n   * before an element was attached to the document for the first time.\n   *\n   * This method should be called by mixins/components in their\n   * `connectedCallback`. If mulitple mixins/components invoke this during the\n   * same `connectedCallback`, only the first call will have any effect. The\n   * subsequent calls will be harmless.\n   *\n   * @param {HTMLElement} element - The element being added to the document.\n   */\n  connected(element) {\n    element[safeToSetAttributesSymbol] = true;\n\n    // Set any pending attributes.\n    if (element[pendingAttributesSymbol]) {\n      for (let attribute in element[pendingAttributesSymbol]) {\n        const value = element[pendingAttributesSymbol][attribute];\n        setAttributeToElement(element, attribute, value);\n      }\n      element[pendingAttributesSymbol] = null;\n    }\n\n    // Set any pending classes.\n    if (element[pendingClassesSymbol]) {\n      for (let className in element[pendingClassesSymbol]) {\n        const value = element[pendingClassesSymbol][className];\n        toggleClass(element, className, value);\n      }\n      element[pendingClassesSymbol] = null;\n    }\n  },\n\n  /**\n   * Set/unset the attribute with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as an attribute. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes. A call to `setAttribute` during the constructor will\n   * be deferred until the element is connected to the document.\n   *\n   * @param {string} attribute - The name of the *attribute* (not property) to set.\n   * @param {object} value - The value to set. If null, the attribute will be removed.\n   */\n  setAttribute(element, attribute, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set attributes immediately.\n      setAttributeToElement(element, attribute, value);\n    } else {\n      // Defer setting attributes until the first time we're connected.\n      if (!element[pendingAttributesSymbol]) {\n        element[pendingAttributesSymbol] = {};\n      }\n      element[pendingAttributesSymbol][attribute] = value;\n    }\n  },\n\n  /**\n   * Set/unset the class with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as as class. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes, including the `class` attribute. A call to\n   * `toggleClass` during the constructor will be deferred until the element\n   * is connected to the document.\n   *\n   * @param {string} className - The name of the class to set.\n   * @param {object} value - True to set the class, false to remove it.\n   */\n  toggleClass(element, className, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set class immediately.\n      toggleClass(element, className, value);\n    } else {\n      // Defer setting class until the first time we're connected.\n      if (!element[pendingClassesSymbol]) {\n        element[pendingClassesSymbol] = {};\n      }\n      element[pendingClassesSymbol][className] = value;\n    }\n  }\n\n};\n\n\n// Reflect the attribute to the given element.\n// If the value is null, remove the attribute.\nfunction setAttributeToElement(element, attributeName, value) {\n  if (value === null || typeof value === 'undefined') {\n    element.removeAttribute(attributeName);\n  } else {\n    const text = String(value);\n    // Avoid recursive attributeChangedCallback calls.\n    if (element.getAttribute(attributeName) !== text) {\n      element.setAttribute(attributeName, value);\n    }\n  }\n}\n","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'basic-component-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'basic-component-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `dragging` property.\n   *\n   * Components like carousels often define animated CSS transitions for\n   * sliding effects. Such a transition should usually *not* be applied while\n   * the user is dragging, because a CSS animation will introduce a lag that\n   * makes the swipe feel sluggish. Instead, as long as the user is dragging\n   * with their finger down, the transition should be suppressed. When the\n   * user releases their finger, the transition can be restored, allowing the\n   * animation to show the carousel sliding into its final position.\n   *\n   * @type {boolean} true if a drag is in progress, false if not.\n   */\n  dragging: createSymbol('dragging'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: createSymbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: createSymbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: createSymbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: createSymbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: createSymbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: createSymbol('goUp'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization  since the items have \"changed\" from\n   * being nothing.\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: createSymbol('keydown'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLElement}\n   */\n  template: createSymbol('template')\n};\n\nexport default symbols;\n","/**\n * Helper function for standard classList.toggle() behavior on old browsers,\n * namely IE 11.\n *\n * The standard\n * [classlist](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)\n * object has a `toggle()` function that supports a second Boolean parameter\n * that can be used to succinctly turn a class on or off. This feature is often\n * useful in designing custom elements, which may want to externally reflect\n * component state in a CSS class that can be used for styling purposes.\n *\n * Unfortunately, IE 11 does not support the Boolean parameter to\n * `classList.toggle()`. This helper function behaves like the standard\n * `toggle()`, including support for the Boolean parameter, so that it can be\n * used even on IE 11.\n *\n * @function toggleClass\n * @param {HTMLElement} element - The element to modify\n * @param {string} className - The class to add/remove\n * @param {boolean} [force] - Force the class to be added (if true) or removed\n *                            (if false)\n */\nexport default function toggleClass(element, className, force) {\n  const classList = element.classList;\n  const addClass = (typeof force === 'undefined') ?\n    !classList.contains(className) :\n    force;\n  if (addClass) {\n    classList.add(className);\n  } else {\n    classList.remove(className);\n  }\n  return addClass;\n}\n"],"preExisting":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL2dsb2JhbHMuanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9BcnJvd1NlbGVjdGlvbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQXR0cmlidXRlTWFyc2hhbGxpbmdNaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0NsaWNrU2VsZWN0aW9uTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9Db21wb3NhYmxlTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9Db250ZW50SXRlbXNNaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0RpcmVjdGlvblNlbGVjdGlvbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0Rpc3RyaWJ1dGVkQ2hpbGRyZW5NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0ZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0dlbmVyaWNNaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0tleWJvYXJkRGlyZWN0aW9uTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9LZXlib2FyZE1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvS2V5Ym9hcmRQYWdlZFNlbGVjdGlvbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvS2V5Ym9hcmRQcmVmaXhTZWxlY3Rpb25NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1BhZ2VEb3RzTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9QbGF5Q29udHJvbHNNaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NlbGVjdGlvbkFuaW1hdGlvbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2VsZWN0aW9uSGlnaGxpZ2h0TWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TZWxlY3Rpb25JblZpZXdNaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NoYWRvd0VsZW1lbnRSZWZlcmVuY2VzTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TaGFkb3dUZW1wbGF0ZU1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2luZ2xlU2VsZWN0aW9uTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9Td2lwZURpcmVjdGlvbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvVGltZXJTZWxlY3Rpb25NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1RyYWNrcGFkRGlyZWN0aW9uTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9jcmVhdGVTeW1ib2wuanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9taWNyb3Rhc2suanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9yZW5kZXJBcnJheUFzRWxlbWVudHMuanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zYWZlQXR0cmlidXRlcy5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3N5bWJvbHMuanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy90b2dnbGVDbGFzcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDT0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsT0FBTyxLQUFQLEdBQWUsT0FBTyxLQUFQLElBQWdCLEVBQS9CLEMsQ0FyQ0E7Ozs7Ozs7QUF1Q0EsT0FBTyxLQUFQLENBQWEsbUJBQWI7QUFDQSxPQUFPLEtBQVAsQ0FBYSx5QkFBYjtBQUNBLE9BQU8sS0FBUCxDQUFhLG1CQUFiO0FBQ0EsT0FBTyxLQUFQLENBQWEsZUFBYjtBQUNBLE9BQU8sS0FBUCxDQUFhLGlCQUFiO0FBQ0EsT0FBTyxLQUFQLENBQWEsWUFBYjtBQUNBLE9BQU8sS0FBUCxDQUFhLHVCQUFiO0FBQ0EsT0FBTyxLQUFQLENBQWEsd0JBQWI7QUFDQSxPQUFPLEtBQVAsQ0FBYSwrQkFBYjtBQUNBLE9BQU8sS0FBUCxDQUFhLE9BQWI7QUFDQSxPQUFPLEtBQVAsQ0FBYSxhQUFiO0FBQ0EsT0FBTyxLQUFQLENBQWEsc0JB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LFNBQWIsQ0FqRks7O0FBbUZkOzs7Ozs7O0FBT0EsUUFBTSw0QkFBYSxNQUFiLENBMUZROztBQTRGZDs7Ozs7Ozs7QUFRQSxhQUFXLDRCQUFhLFdBQWIsQ0FwR0c7O0FBdUdkOzs7Ozs7O0FBT0EsZ0JBQWMsNEJBQWEsY0FBYixDQTlHQTs7QUFnSGQ7Ozs7Ozs7OztBQVNBLGdCQUFjLDRCQUFhLGNBQWIsQ0F6SEE7O0FBMkhkOzs7Ozs7OztBQVFBLFdBQVMsNEJBQWEsU0FBYixDQW5JSzs7QUFxSWQ7Ozs7Ozs7QUFPQSxZQUFVLDRCQUFhLFVBQWI7QUE1SUksQ0FBaEI7O2tCQStJZSxPOzs7Ozs7OztrQkNoSlMsVztBQXRCeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQmUsU0FBUyxXQUFULENBQXFCLE9BQXJCLEVBQThCLFNBQTlCLEVBQXlDLEtBQXpDLEVBQWdEO0FBQzdELE1BQU0sWUFBWSxRQUFRLFNBQTFCO0FBQ0EsTUFBTSxXQUFZLE9BQU8sS0FBUCxLQUFpQixXQUFsQixHQUNmLENBQUMsVUFBVSxRQUFWLENBQW1CLFNBQW5CLENBRGMsR0FFZixLQUZGO0FBR0EsTUFBSSxRQUFKLEVBQWM7QUFDWixjQUFVLEdBQVYsQ0FBYyxTQUFkO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsY0FBVSxNQUFWLENBQWlCLFNBQWpCO0FBQ0Q7QUFDRCxTQUFPLFFBQVA7QUFDRCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKlxuICogVGhpcyBmaWxlIGlzIHRyYW5zcGlsZWQgdG8gY3JlYXRlIGFuIEVTNS1jb21wYXRpYmxlIGRpc3RyaWJ1dGlvbiBpbiB3aGljaFxuICogdGhlIHBhY2thZ2UncyBtYWluIGZlYXR1cmUocykgYXJlIGF2YWlsYWJsZSB2aWEgdGhlIHdpbmRvdy5CYXNpYyBnbG9iYWwuXG4gKiBJZiB5b3UncmUgYWxyZWFkeSB1c2luZyBFUzYgeW91cnNlbGYsIGlnbm9yZSB0aGlzIGZpbGUsIGFuZCBpbnN0ZWFkIGltcG9ydFxuICogdGhlIHNvdXJjZSBmaWxlKHMpIHlvdSB3YW50IGZyb20gdGhlIHNyYyBmb2xkZXIuXG4gKi9cblxuaW1wb3J0IEFycm93U2VsZWN0aW9uTWl4aW4gZnJvbSAnLi9zcmMvQXJyb3dTZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgQXR0cmlidXRlTWFyc2hhbGxpbmdNaXhpbiBmcm9tICcuL3NyYy9BdHRyaWJ1dGVNYXJzaGFsbGluZ01peGluJztcbmltcG9ydCBDbGlja1NlbGVjdGlvbk1peGluIGZyb20gJy4vc3JjL0NsaWNrU2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IENvbXBvc2FibGVNaXhpbiBmcm9tICcuL3NyYy9Db21wb3NhYmxlTWl4aW4nO1xuaW1wb3J0IENvbnRlbnRJdGVtc01peGluIGZyb20gJy4vc3JjL0NvbnRlbnRJdGVtc01peGluJztcbmltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi9zcmMvY3JlYXRlU3ltYm9sJztcbmltcG9ydCBEaXJlY3Rpb25TZWxlY3Rpb25NaXhpbiBmcm9tICcuL3NyYy9EaXJlY3Rpb25TZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgRGlzdHJpYnV0ZWRDaGlsZHJlbk1peGluIGZyb20gJy4vc3JjL0Rpc3RyaWJ1dGVkQ2hpbGRyZW5NaXhpbic7XG5pbXBvcnQgRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbiBmcm9tICcuL3NyYy9EaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluJztcbmltcG9ydCBHZW5lcmljTWl4aW4gZnJvbSAnLi9zcmMvR2VuZXJpY01peGluJztcbmltcG9ydCBLZXlib2FyZE1peGluIGZyb20gJy4vc3JjL0tleWJvYXJkTWl4aW4nO1xuaW1wb3J0IEtleWJvYXJkRGlyZWN0aW9uTWl4aW4gZnJvbSAnLi9zcmMvS2V5Ym9hcmREaXJlY3Rpb25NaXhpbic7XG5pbXBvcnQgS2V5Ym9hcmRQYWdlZFNlbGVjdGlvbk1peGluIGZyb20gJy4vc3JjL0tleWJvYXJkUGFnZWRTZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgS2V5Ym9hcmRQcmVmaXhTZWxlY3Rpb25NaXhpbiBmcm9tICcuL3NyYy9LZXlib2FyZFByZWZpeFNlbGVjdGlvbk1peGluJztcbmltcG9ydCBtaWNyb3Rhc2sgZnJvbSAnLi9zcmMvbWljcm90YXNrJztcbmltcG9ydCBQYWdlRG90c01peGluIGZyb20gJy4vc3JjL1BhZ2VEb3RzTWl4aW4nO1xuaW1wb3J0IFBsYXlDb250cm9sc01peGluIGZyb20gJy4vc3JjL1BsYXlDb250cm9sc01peGluJztcbmltcG9ydCBzYWZlQXR0cmlidXRlcyBmcm9tICcuL3NyYy9zYWZlQXR0cmlidXRlcyc7XG5pbXBvcnQgU2VsZWN0aW9uQW5pbWF0aW9uTWl4aW4gZnJvbSAnLi9zcmMvU2VsZWN0aW9uQW5pbWF0aW9uTWl4aW4nO1xuaW1wb3J0IFNlbGVjdGlvbkFyaWFBY3RpdmVNaXhpbiBmcm9tICcuL3NyYy9TZWxlY3Rpb25BcmlhQWN0aXZlTWl4aW4nO1xuaW1wb3J0IFNlbGVjdGlvbkhpZ2hsaWdodE1peGluIGZyb20gJy4vc3JjL1NlbGVjdGlvbkhpZ2hsaWdodE1peGluJztcbmltcG9ydCBTZWxlY3Rpb25JblZpZXdNaXhpbiBmcm9tICcuL3NyYy9TZWxlY3Rpb25JblZpZXdNaXhpbic7XG5pbXBvcnQgU2hhZG93RWxlbWVudFJlZmVyZW5jZXNNaXhpbiBmcm9tICcuL3NyYy9TaGFkb3dFbGVtZW50UmVmZXJlbmNlc01peGluJztcbmltcG9ydCBTaGFkb3dUZW1wbGF0ZU1peGluIGZyb20gJy4vc3JjL1NoYWRvd1RlbXBsYXRlTWl4aW4nO1xuaW1wb3J0IFNpbmdsZVNlbGVjdGlvbk1peGluIGZyb20gJy4vc3JjL1NpbmdsZVNlbGVjdGlvbk1peGluJztcbmltcG9ydCBTd2lwZURpcmVjdGlvbk1peGluIGZyb20gJy4vc3JjL1N3aXBlRGlyZWN0aW9uTWl4aW4nO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi9zcmMvc3ltYm9scyc7XG5pbXBvcnQgVGltZXJTZWxlY3Rpb25NaXhpbiBmcm9tICcuL3NyYy9UaW1lclNlbGVjdGlvbk1peGluJztcbmltcG9ydCBUcmFja3BhZERpcmVjdGlvbk1peGluIGZyb20gJy4vc3JjL1RyYWNrcGFkRGlyZWN0aW9uTWl4aW4nO1xuXG53aW5kb3cuQmFzaWMgPSB3aW5kb3cuQmFzaWMgfHwge307XG5cbndpbmRvdy5CYXNpYy5BcnJvd1NlbGVjdGlvbk1peGluID0gQXJyb3dTZWxlY3Rpb25NaXhpbjtcbndpbmRvdy5CYXNpYy5BdHRyaWJ1dGVNYXJzaGFsbGluZ01peGluID0gQXR0cmlidXRlTWFyc2hhbGxpbmdNaXhpbjtcbndpbmRvdy5CYXNpYy5DbGlja1NlbGVjdGlvbk1peGluID0gQ2xpY2tTZWxlY3Rpb25NaXhpbjtcbndpbmRvdy5CYXNpYy5Db21wb3NhYmxlTWl4aW4gPSBDb21wb3NhYmxlTWl4aW47XG53aW5kb3cuQmFzaWMuQ29udGVudEl0ZW1zTWl4aW4gPSBDb250ZW50SXRlbXNNaXhpbjtcbndpbmRvdy5CYXNpYy5jcmVhdGVTeW1ib2wgPSBjcmVhdGVTeW1ib2w7XG53aW5kb3cuQmFzaWMuRGlyZWN0aW9uU2VsZWN0aW9uTWl4aW4gPSBEaXJlY3Rpb25TZWxlY3Rpb25NaXhpbjtcbndpbmRvdy5CYXNpYy5EaXN0cmlidXRlZENoaWxkcmVuTWl4aW4gPSBEaXN0cmlidXRlZENoaWxkcmVuTWl4aW47XG53aW5kb3cuQmFzaWMuRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbiA9IERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW47XG53aW5kb3cuQmFzaWMuZ2VuZXJpYyA9IEdlbmVyaWNNaXhpbjtcbndpbmRvdy5CYXNpYy5LZXlib2FyZE1peGluID0gS2V5Ym9hcmRNaXhpbjtcbndpbmRvdy5CYXNpYy5LZXlib2FyZERpcmVjdGlvbk1peGluID0gS2V5Ym9hcmREaXJlY3Rpb25NaXhpbjtcbndpbmRvdy5CYXNpYy5LZXlib2FyZFBhZ2VkU2VsZWN0aW9uTWl4aW4gPSBLZXlib2FyZFBhZ2VkU2VsZWN0aW9uTWl4aW47XG53aW5kb3cuQmFzaWMuS2V5Ym9hcmRQcmVmaXhTZWxlY3Rpb25NaXhpbiA9IEtleWJvYXJkUHJlZml4U2VsZWN0aW9uTWl4aW47XG53aW5kb3cuQmFzaWMubWljcm90YXNrID0gbWljcm90YXNrO1xud2luZG93LkJhc2ljLlBhZ2VEb3RzTWl4aW4gPSBQYWdlRG90c01peGluO1xud2luZG93LkJhc2ljLlBsYXlDb250cm9sc01peGluID0gUGxheUNvbnRyb2xzTWl4aW47XG53aW5kb3cuQmFzaWMuc2FmZUF0dHJpYnV0ZXMgPSBzYWZlQXR0cmlidXRlcztcbndpbmRvdy5CYXNpYy5TZWxlY3Rpb25BbmltYXRpb25NaXhpbiA9IFNlbGVjdGlvbkFuaW1hdGlvbk1peGluO1xud2luZG93LkJhc2ljLlNlbGVjdGlvbkFyaWFBY3RpdmVNaXhpbiA9IFNlbGVjdGlvbkFyaWFBY3RpdmVNaXhpbjtcbndpbmRvdy5CYXNpYy5TZWxlY3Rpb25IaWdobGlnaHRNaXhpbiA9IFNlbGVjdGlvbkhpZ2hsaWdodE1peGluO1xud2luZG93LkJhc2ljLlNlbGVjdGlvbkluVmlld01peGluID0gU2VsZWN0aW9uSW5WaWV3TWl4aW47XG53aW5kb3cuQmFzaWMuU2hhZG93RWxlbWVudFJlZmVyZW5jZXNNaXhpbiA9IFNoYWRvd0VsZW1lbnRSZWZlcmVuY2VzTWl4aW47XG53aW5kb3cuQmFzaWMuU2hhZG93VGVtcGxhdGVNaXhpbiA9IFNoYWRvd1RlbXBsYXRlTWl4aW47XG53aW5kb3cuQmFzaWMuU2luZ2xlU2VsZWN0aW9uTWl4aW4gPSBTaW5nbGVTZWxlY3Rpb25NaXhpbjtcbndpbmRvdy5CYXNpYy5Td2lwZURpcmVjdGlvbk1peGluID0gU3dpcGVEaXJlY3Rpb25NaXhpbjtcbndpbmRvdy5CYXNpYy5zeW1ib2xzID0gc3ltYm9scztcbndpbmRvdy5CYXNpYy5UaW1lclNlbGVjdGlvbk1peGluID0gVGltZXJTZWxlY3Rpb25NaXhpbjtcbndpbmRvdy5CYXNpYy5UcmFja3BhZERpcmVjdGlvbk1peGluID0gVHJhY2twYWREaXJlY3Rpb25NaXhpbjtcbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvY3JlYXRlU3ltYm9sJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3N5bWJvbHMnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBtb3VzZWRvd25MaXN0ZW5lclN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbW91c2Vkb3duTGlzdGVuZXInKTtcbmNvbnN0IG1vdXNlbW92ZUxpc3RlbmVyU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdtb3VzZW1vdmVMaXN0ZW5lcicpO1xuY29uc3QgbGFzdE1vdXNlWFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbGFzdE1vdXNlWCcpO1xuY29uc3QgbGFzdE1vdXNlWVN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbGFzdE1vdXNlWScpO1xuY29uc3QgbW91c2VUaW1lb3V0U3ltYm9sID0gY3JlYXRlU3ltYm9sKCdtb3VzZVRpbWVvdXQnKTtcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIEFycm93U2VsZWN0aW9uLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogVGVtcGxhdGUgbWl4aW4gd2hpY2ggYWRkcyBwcm9taW5lbnQgbGVmdCBhbmQgcmlnaHQgYXJyb3cgYnV0dG9ucyB0byBhXG4gICAqIHdyYXBwZWQgY2hpbGQgc3VjaCBhcyBhIGNhcm91c2VsLlxuICAgKlxuICAgKiBZb3UgY2FuIHNlZSBhXG4gICAqIFtsaXZlIGRlbW9dKGh0dHA6Ly9iYXNpY3dlYmNvbXBvbmVudHMub3JnL2Jhc2ljLXdlYi1jb21wb25lbnRzL3BhY2thZ2VzL2RlbW9zL2Nhcm91c2VsLXdpdGgtYXJyb3dzLmh0bWwpXG4gICAqIG9mIHRoaXMgbWl4aW4gYXBwbGllZCB0byBhIGNhcm91c2VsLlxuICAgKlxuICAgKiBDbGlja2luZyB0aGUgbGVmdC9yaWdodCBidXR0b25zIHNlbGVjdHMgdGhlIHByZXZpb3VzL25leHQgaXRlbS5cbiAgICpcbiAgICogVHlwaWNhbCB1c2FnZTpcbiAgICpcbiAgICogICAgIGNsYXNzIENhcm91c2VsV2l0aEFycm93cyBleHRlbmRzIEFycm93U2VsZWN0aW9uTWl4aW4oQ2Fyb3VzZWwpIHt9XG4gICAqICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ2Nhcm91c2VsLXdpdGgtYXJyb3dzJywgQ2Fyb3VzZWxXaXRoQXJyb3dzKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIGFycm93IGJ1dHRvbnMgYXJlIHNob3duIG9uIGRldmljZXMgd2l0aCBhIG1vdXNlIG9yIG1vdXNlLWxpa2VcbiAgICogcG9pbnRpbmcgZGV2aWNlLiBUaGV5IGFyZSBub3Qgc2hvd24gb24gYSB0b3VjaC1jYXBhYmxlIGRldmljZSB1bmxlc3MgbW91c2VcbiAgICogbW92ZW1lbnQgaXMgZGV0ZWN0ZWQuIFRvIGNhdXNlIHRoZSBidXR0b25zIHRvIGFsd2F5cyBhcHBlYXIsIGFwcGx5IHRoZVxuICAgKiAnc2hvd0Fycm93cycgQ1NTIGNsYXNzLlxuICAgKi9cbiAgY2xhc3MgQXJyb3dTZWxlY3Rpb24gZXh0ZW5kcyBiYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcblxuICAgICAgdGhpcy4kLmJ1dHRvbkxlZnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJC5idXR0b25SaWdodC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5zZWxlY3ROZXh0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSk7XG4gICAgICBhc3N1bWVCdXR0b25Gb2N1cyh0aGlzLCB0aGlzLiQuYnV0dG9uTGVmdCk7XG4gICAgICBhc3N1bWVCdXR0b25Gb2N1cyh0aGlzLCB0aGlzLiQuYnV0dG9uUmlnaHQpO1xuICAgIH1cblxuICAgIGdldCBjYW5TZWxlY3ROZXh0KCkge1xuICAgICAgcmV0dXJuIHN1cGVyLmNhblNlbGVjdE5leHQ7XG4gICAgfVxuICAgIHNldCBjYW5TZWxlY3ROZXh0KGNhblNlbGVjdE5leHQpIHtcbiAgICAgIGlmICgnY2FuU2VsZWN0TmV4dCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuY2FuU2VsZWN0TmV4dCA9IGNhblNlbGVjdE5leHQ7IH1cbiAgICAgIHRoaXMuJC5idXR0b25SaWdodC5kaXNhYmxlZCA9ICFjYW5TZWxlY3ROZXh0O1xuICAgIH1cblxuICAgIGdldCBjYW5TZWxlY3RQcmV2aW91cygpIHtcbiAgICAgIHJldHVybiBzdXBlci5jYW5TZWxlY3RQcmV2aW91cztcbiAgICB9XG4gICAgc2V0IGNhblNlbGVjdFByZXZpb3VzKGNhblNlbGVjdFByZXZpb3VzKSB7XG4gICAgICBpZiAoJ2NhblNlbGVjdFByZXZpb3VzJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5jYW5TZWxlY3RQcmV2aW91cyA9IGNhblNlbGVjdFByZXZpb3VzOyB9XG4gICAgICB0aGlzLiQuYnV0dG9uTGVmdC5kaXNhYmxlZCA9ICFjYW5TZWxlY3RQcmV2aW91cztcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG5cbiAgICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3dBcnJvd3MnKSkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB3ZSBzaG91bGQgc2hvdyBhcnJvdyBidXR0b25zIG9yIG5vdC5cbiAgICAgICAgaWYgKGRldmljZVN1cHBvcnRzVG91Y2goKSkge1xuICAgICAgICAgIC8vIEEgdG91Y2ggZGV2aWNlIG1pZ2h0IGFsc28gc3VwcG9ydCBhIG1vdXNlLCBidXQgd2UgY2FuJ3Qga25vdyB3aGV0aGVyXG4gICAgICAgICAgLy8gdGhlcmUncyBhY3R1YWxseSBhIG1vdXNlIHVudGlsIHdlIGhlYXIgZnJvbSBpdC5cbiAgICAgICAgICBsaXN0ZW5Gb3JNb3VzZSh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGUgZGV2aWNlIGRvZXNuJ3Qgc3VwcG9ydCB0b3VjaCwgc28gYXNzdW1lIGl0IGhhcyBhIG1vdXNlLlxuICAgICAgICAgIHNob3dBcnJvd3ModGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgW3N5bWJvbHMuZGVmYXVsdHNdKCkge1xuICAgICAgY29uc3QgZGVmYXVsdHMgPSBzdXBlcltzeW1ib2xzLmRlZmF1bHRzXSB8fCB7fTtcbiAgICAgIGRlZmF1bHRzLm5hdmlnYXRpb25BeGlzID0gJ2hvcml6b250YWwnO1xuICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogVGhlIHRlbXBsYXRlIHVzZXMgdGhlIGNoZXZyb24tbGVmdCBhbmQgY2hldnJvbi1yaWdodCBTVkcgaWNvbnMgZnJvbVxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyRWxlbWVudHMvaXJvbi1pY29ucy9ibG9iL21hc3Rlci9pcm9uLWljb25zLmh0bWwuXG4gICAgICovXG4gICAgZ2V0IFtzeW1ib2xzLnRlbXBsYXRlXSgpIHtcbiAgICAgIGNvbnN0IGJhc2VUZW1wbGF0ZSA9IHN1cGVyW3N5bWJvbHMudGVtcGxhdGVdIHx8ICcnO1xuICAgICAgcmV0dXJuIGBcbiAgICAgICAgPHN0eWxlPlxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgLXdlYmtpdC1hbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICAgICAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAtd2Via2l0LWZsZXg6IDE7XG4gICAgICAgICAgZmxleDogMTtcbiAgICAgICAgICAtd2Via2l0LWp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgI2Fycm93TmF2aWdhdGlvbkNvbnRhaW5lciB7XG4gICAgICAgICAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgLXdlYmtpdC1mbGV4OiAxO1xuICAgICAgICAgIGZsZXg6IDE7XG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB9XG5cbiAgICAgICAgLm5hdmlnYXRpb25CdXR0b24ge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgICAgICBmaWxsOiBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICAgICAgb3V0bGluZTogbm9uZTsgLyogUkVWSUVXOiBBY2Nlc3NpYmlsaXR5IHNob3VsZCBiZSBwcm92aWRlZCBieSBvdGhlciBlbGVtZW50cy4gKi9cbiAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMXM7XG4gICAgICAgICAgei1pbmRleDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5uYXZpZ2F0aW9uQnV0dG9uOmhvdmVyOm5vdCg6ZGlzYWJsZWQpIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNSk7XG4gICAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44KTtcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgLm5hdmlnYXRpb25CdXR0b246YWN0aXZlOm5vdCg6ZGlzYWJsZWQpIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNyk7XG4gICAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC45KTtcbiAgICAgICAgfVxuICAgICAgICAubmF2aWdhdGlvbkJ1dHRvbjpkaXNhYmxlZCB7XG4gICAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIDpob3N0KDpub3QoLnNob3dBcnJvd3MpKSAubmF2aWdhdGlvbkJ1dHRvbiB7XG4gICAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICAubmF2aWdhdGlvbkJ1dHRvbiAuaWNvbiB7XG4gICAgICAgICAgaGVpZ2h0OiA0OHB4O1xuICAgICAgICAgIHdpZHRoOiA0OHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgLyogT3ZlcmxheSB2YXJpYW50ICovXG4gICAgICAgIDpob3N0KC5vdmVybGF5QXJyb3dzKSB7XG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB9XG4gICAgICAgIDpob3N0KC5vdmVybGF5QXJyb3dzKSAubmF2aWdhdGlvbkJ1dHRvbiB7XG4gICAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyk7XG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgIHRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdCgub3ZlcmxheUFycm93cykgI2J1dHRvbkxlZnQge1xuICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QoLm92ZXJsYXlBcnJvd3MpICNidXR0b25SaWdodCB7XG4gICAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QoLm92ZXJsYXlBcnJvd3MpIC5uYXZpZ2F0aW9uQnV0dG9uOmhvdmVyOm5vdCg6ZGlzYWJsZWQpIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XG4gICAgICAgICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdCgub3ZlcmxheUFycm93cykgLm5hdmlnYXRpb25CdXR0b246YWN0aXZlOm5vdCg6ZGlzYWJsZWQpIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNCk7XG4gICAgICAgICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45KTtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdCgub3ZlcmxheUFycm93cykgLm5hdmlnYXRpb25CdXR0b246ZGlzYWJsZWQge1xuICAgICAgICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XG4gICAgICAgIH1cbiAgICAgICAgPC9zdHlsZT5cblxuICAgICAgICA8IS0tXG4gICAgICAgIEFjY2Vzc2liaWxpdHkgbm90ZTogc2luY2UgdGhlIG5hdmlnYXRpb24gb2ZmZXJlZCBieSB0aGUgYXJyb3cgYnV0dG9ucyBzaG91bGRcbiAgICAgICAgYmUgcmVkdW5kYW50ICh0aGF0IGlzLCB0aGVyZSBzaG91bGQgYmUgb3RoZXIgd2F5cyBvZiBuYXZpZ2F0aW5nIHRoZSBsaXN0KSxcbiAgICAgICAgd2UgbWFyayB0aGUgYnV0dG9uIGFzIGFyaWEtaGlkZGVuIHNvIHRoYXQgYXNzaXN0aXZlIGRldmljZXMgaWdub3JlIHRoZW0uXG4gICAgICAgIC0tPlxuICAgICAgICA8YnV0dG9uIGlkPVwiYnV0dG9uTGVmdFwiIGNsYXNzPVwibmF2aWdhdGlvbkJ1dHRvblwiIGRpc2FibGVkIHRhYmluZGV4PVwiLTFcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgICAgICA8c3ZnIGNsYXNzPVwiaWNvblwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pZFlNaWQgbWVldFwiPlxuICAgICAgICAgICAgPGcgaWQ9XCJjaGV2cm9uLWxlZnRcIj5cbiAgICAgICAgICAgICAgPHBhdGggZD1cIk0xNS40MSA3LjQxTDE0IDZsLTYgNiA2IDYgMS40MS0xLjQxTDEwLjgzIDEyelwiLz5cbiAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxkaXYgaWQ9XCJhcnJvd05hdmlnYXRpb25Db250YWluZXJcIiByb2xlPVwibm9uZVwiPlxuICAgICAgICAgICR7YmFzZVRlbXBsYXRlfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGJ1dHRvbiBpZD1cImJ1dHRvblJpZ2h0XCIgY2xhc3M9XCJuYXZpZ2F0aW9uQnV0dG9uXCIgZGlzYWJsZWQgdGFiaW5kZXg9XCItMVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgICAgIDxzdmcgY2xhc3M9XCJpY29uXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCI+XG4gICAgICAgICAgICA8ZyBpZD1cImNoZXZyb24tcmlnaHRcIj5cbiAgICAgICAgICAgICAgPHBhdGggZD1cIk0xMCA2TDguNTkgNy40MSAxMy4xNyAxMmwtNC41OCA0LjU5TDEwIDE4bDYtNnpcIi8+XG4gICAgICAgICAgICA8L2c+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgYDtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBBcnJvd1NlbGVjdGlvbjtcbn07XG5cblxuLypcbiAqIEJ5IGRlZmF1bHQsIGEgYnV0dG9uIHdpbGwgYWx3YXlzIHRha2UgZm9jdXMgb24gbW91c2Vkb3duLiBGb3IgdGhpcyBjb21wb25lbnQsXG4gKiB3ZSB3YW50IHRvIG92ZXJyaWRlIHRoYXQgYmVoYXZpb3IsIHN1Y2ggdGhhdCBhIG1vdXNlZG93biBvbiBhIGJ1dHRvbiBrZWVwc1xuICogdGhlIGZvY3VzIG9uIHRoZSBvdXRlciBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIGFzc3VtZUJ1dHRvbkZvY3VzKGVsZW1lbnQsIGJ1dHRvbikge1xuICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZXZlbnQgPT4ge1xuICAgIC8vIEdpdmVuIHRoZSBtYWluIGVsZW1lbnQgdGhlIGZvY3VzIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBoYXZlIGl0LlxuICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAvLyBQcmV2ZW50IHRoZSBkZWZhdWx0IGZvY3VzLW9uLW1vdXNlZG93biBiZWhhdmlvci5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGV2aWNlU3VwcG9ydHNUb3VjaCgpIHtcbiAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fFxuICAgICAgKHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpO1xufVxuXG4vLyBXZSB0cnkgdG8gZGV0ZWN0IHRoZSBwcmVzZW5jZSBvZiBhIG1vdXNlIGJ5IGxpc3RlbmluZyBmb3IgbW91c2Vtb3ZlIGV2ZW50c1xuLy8gd2hpY2ggYXJlICpub3QqIHRoZSByZXN1bHQgb2YgYSBtb3VzZWRvd24uIE9uIGEgdG91Y2ggZGV2aWNlLCBhIHRhcCBvbiB0aGVcbi8vIHBhZ2Ugd2lsbCBnZW5lcmF0ZSBhIGZha2UgbW91c2Vtb3ZlLCBmb2xsb3dlZCBieSBhIG1vdXNlZG93bi4gV2UgZG9uJ3Qgd2FudFxuLy8gdG8gcmVzcG9uZCB0byB0aG9zZSBmYWtlIG1vdXNlbW92ZSBldmVudHMuIFRvIGRpc2NyaW1pbmF0ZSBiZXR3ZWVuIGZha2UgYW5kXG4vLyByZWFsIG1vdXNlbW92ZSBldmVudHMsIHdoZW4gd2UgZ2V0IGEgbW91c2Vtb3ZlIGV2ZW50LCB3ZSB3YWl0IGZvciBhIGJpdCB0b1xuLy8gc2VlIGlmIHRoZSBzYW1lIGxvY2F0aW9uIGlzIHJlcG9ydGVkIGFzIHRoZSBsb2NhdGlvbiBvZiBhIHN1YnNlcXVlbnRcbi8vIG1vdXNlZG93bi5cbmZ1bmN0aW9uIGxpc3RlbkZvck1vdXNlKGVsZW1lbnQpIHtcblxuICBlbGVtZW50W21vdXNlZG93bkxpc3RlbmVyU3ltYm9sXSA9IGV2ZW50ID0+IHtcbiAgICBpZiAoZWxlbWVudFttb3VzZVRpbWVvdXRTeW1ib2xdKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZWxlbWVudFttb3VzZVRpbWVvdXRTeW1ib2xdKTtcbiAgICB9XG4gICAgZWxlbWVudFtsYXN0TW91c2VYU3ltYm9sXSA9IGV2ZW50LnBhZ2VYO1xuICAgIGVsZW1lbnRbbGFzdE1vdXNlWVN5bWJvbF0gPSBldmVudC5wYWdlWTtcbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGVsZW1lbnRbbW91c2Vkb3duTGlzdGVuZXJTeW1ib2xdKTtcblxuICBlbGVtZW50W21vdXNlbW92ZUxpc3RlbmVyU3ltYm9sXSA9IGV2ZW50ID0+IHtcbiAgICAvLyBQb3N0cG9uZSBjaGVja2luZyB0aGUgbW91c2Vtb3ZlIGxvY2F0aW9uIHRvIGdpdmUgdGhlIG1vdXNlZG93biBldmVudCBhXG4gICAgLy8gY2hhbmNlIHRvIGZpcmUuIFRoZSAyNTAgbXMgZGVsYXkgaXMganVzdCBndWVzc3dvcms7IGEgc2hvcnRlciBkZWxheVxuICAgIC8vIGRvZXNuJ3Qgc2VlbSB0byB3b3JrLlxuICAgIGVsZW1lbnRbbW91c2VUaW1lb3V0U3ltYm9sXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGVsZW1lbnRbbGFzdE1vdXNlWFN5bWJvbF0gIT0gbnVsbCAmJiBldmVudC5wYWdlWCAhPT0gZWxlbWVudFtsYXN0TW91c2VYU3ltYm9sXSB8fFxuICAgICAgICAgIGVsZW1lbnRbbGFzdE1vdXNlWVN5bWJvbF0gIT0gbnVsbCAmJiBldmVudC5wYWdlWSAhPT0gZWxlbWVudFtsYXN0TW91c2VZU3ltYm9sXSkge1xuICAgICAgICAvLyBtb3VzZW1vdmUgZXZlbnQgd2FzIGF0IGEgbG9jYXRpb24gb3RoZXIgdGhhbiB0aGUgbGFzdCBtb3VzZWRvd24sXG4gICAgICAgIC8vIGFuZCBoZW5jZSBtb3N0IGxpa2VseSBhIHJlYWwgbW91c2Vtb3ZlIGV2ZW50LlxuICAgICAgICBtb3VzZURldGVjdGVkKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudFtsYXN0TW91c2VYU3ltYm9sXSA9IGV2ZW50LnBhZ2VYO1xuICAgICAgICBlbGVtZW50W2xhc3RNb3VzZVlTeW1ib2xdID0gZXZlbnQucGFnZVk7XG4gICAgICB9XG4gICAgfSwgMjUwKTtcbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGVsZW1lbnRbbW91c2Vtb3ZlTGlzdGVuZXJTeW1ib2xdKTtcbn1cblxuZnVuY3Rpb24gbW91c2VEZXRlY3RlZChlbGVtZW50KSB7XG4gIHNob3dBcnJvd3MoZWxlbWVudCk7XG5cbiAgLy8gV2UgY2FuIHN0b3AgbGlzdGVuaW5nIGZvciBtb3VzZSBldmVudHMgbm93LlxuICBpZiAoZWxlbWVudFttb3VzZVRpbWVvdXRTeW1ib2xdKSB7XG4gICAgY2xlYXJUaW1lb3V0KGVsZW1lbnRbbW91c2VUaW1lb3V0U3ltYm9sXSk7XG4gIH1cbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGVsZW1lbnRbbW91c2Vkb3duTGlzdGVuZXJTeW1ib2xdKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGVsZW1lbnRbbW91c2Vtb3ZlTGlzdGVuZXJTeW1ib2xdKTtcbiAgZWxlbWVudFttb3VzZWRvd25MaXN0ZW5lclN5bWJvbF0gPSBudWxsO1xuICBlbGVtZW50W21vdXNlbW92ZUxpc3RlbmVyU3ltYm9sXSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNob3dBcnJvd3MoZWxlbWVudCkge1xuICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Nob3dBcnJvd3MnKTtcbn1cbiIsImltcG9ydCBzYWZlQXR0cmlidXRlcyBmcm9tICcuL3NhZmVBdHRyaWJ1dGVzJztcblxuXG4vLyBNZW1vaXplZCBtYXBzIG9mIGF0dHJpYnV0ZSB0byBwcm9wZXJ0eSBuYW1lcyBhbmQgdmljZSB2ZXJzYS5cbmNvbnN0IGF0dHJpYnV0ZVRvUHJvcGVydHlOYW1lcyA9IHt9O1xuY29uc3QgcHJvcGVydHlOYW1lc1RvQXR0cmlidXRlcyA9IHt9O1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggQXR0cmlidXRlTWFyc2hhbGxpbmcuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYXJzaGFsbHMgYXR0cmlidXRlcyB0byBwcm9wZXJ0aWVzIGFuZCB2aWNlIHZlcnNhLlxuICAgKlxuICAgKiBJZiB5b3VyIGNvbXBvbmVudCBleHBvc2VzIGEgc2V0dGVyIGZvciBhIHByb3BlcnR5LCBpdCdzIGdlbmVyYWxseSBhIGdvb2RcbiAgICogaWRlYSB0byBsZXQgZGV2cyB1c2luZyB5b3VyIGNvbXBvbmVudCBiZSBhYmxlIHRvIHNldCB0aGF0IHByb3BlcnR5IGluIEhUTUxcbiAgICogdmlhIGFuIGVsZW1lbnQgYXR0cmlidXRlLiBZb3UgY2FuIGNvZGUgdGhhdCB5b3Vyc2VsZiBieSB3cml0aW5nIGFuXG4gICAqIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLCBvciB5b3UgY2FuIHVzZSB0aGlzIG1peGluIHRvIGdldCBhIGRlZ3JlZSBvZlxuICAgKiBhdXRvbWF0aWMgc3VwcG9ydC5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBpbXBsZW1lbnRzIGFuIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHRoYXQgd2lsbCBhdHRlbXB0IHRvXG4gICAqIGNvbnZlcnQgYSBjaGFuZ2UgaW4gYW4gZWxlbWVudCBhdHRyaWJ1dGUgaW50byBhIGNhbGwgdG8gdGhlIGNvcnJlc3BvbmRpbmdcbiAgICogcHJvcGVydHkgc2V0dGVyLiBBdHRyaWJ1dGVzIHR5cGljYWxseSBmb2xsb3cgaHlwaGVuYXRlZCBuYW1lcyAoXCJmb28tYmFyXCIpLFxuICAgKiB3aGVyZWFzIHByb3BlcnRpZXMgdHlwaWNhbGx5IHVzZSBjYW1lbENhc2UgbmFtZXMgKFwiZm9vQmFyXCIpLiBUaGlzIG1peGluXG4gICAqIHJlc3BlY3RzIHRoYXQgY29udmVudGlvbiwgYXV0b21hdGljYWxseSBtYXBwaW5nIHRoZSBoeXBoZW5hdGVkIGF0dHJpYnV0ZVxuICAgKiBuYW1lIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNhbWVsQ2FzZSBwcm9wZXJ0eSBuYW1lLlxuICAgKlxuICAgKiBFeGFtcGxlOiBZb3UgZGVmaW5lIGEgY29tcG9uZW50IHVzaW5nIHRoaXMgbWl4aW46XG4gICAqXG4gICAqICAgICBjbGFzcyBNeUVsZW1lbnQgZXh0ZW5kcyBBdHRyaWJ1dGVNYXJzaGFsbGluZ01peGluKEhUTUxFbGVtZW50KSB7XG4gICAqICAgICAgIGdldCBmb29CYXIoKSB7IHJldHVybiB0aGlzLl9mb29CYXI7IH1cbiAgICogICAgICAgc2V0IGZvb0Jhcih2YWx1ZSkgeyB0aGlzLl9mb29CYXIgPSB2YWx1ZTsgfVxuICAgKiAgICAgfVxuICAgKiAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdteS1lbGVtZW50JywgTXlFbGVtZW50KTtcbiAgICpcbiAgICogSWYgc29tZW9uZSB0aGVuIGluc3RhbnRpYXRlcyB5b3VyIGNvbXBvbmVudCBpbiBIVE1MOlxuICAgKlxuICAgKiAgICAgPG15LWVsZW1lbnQgZm9vLWJhcj1cIkhlbGxvXCI+PC9teS1lbGVtZW50PlxuICAgKlxuICAgKiBUaGVuLCBhZnRlciB0aGUgZWxlbWVudCBoYXMgYmVlbiB1cGdyYWRlZCwgdGhlIGBmb29CYXJgIHNldHRlciB3aWxsXG4gICAqIGF1dG9tYXRpY2FsbHkgYmUgaW52b2tlZCB3aXRoIHRoZSBpbml0aWFsIHZhbHVlIFwiSGVsbG9cIi5cbiAgICpcbiAgICogRm9yIHRoZSB0aW1lIGJlaW5nLCB0aGlzIG1peGluIG9ubHkgc3VwcG9ydHMgc3RyaW5nLXZhbHVlZCBwcm9wZXJ0aWVzLlxuICAgKiBJZiB5b3UnZCBsaWtlIHRvIGNvbnZlcnQgc3RyaW5nIGF0dHJpYnV0ZXMgdG8gb3RoZXIgdHlwZXMgKG51bWJlcnMsXG4gICAqIGJvb2xlYW5zKSwgeW91IG5lZWQgdG8gaW1wbGVtZW50IGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHlvdXJzZWxmLlxuICAgKi9cbiAgY2xhc3MgQXR0cmlidXRlTWFyc2hhbGxpbmcgZXh0ZW5kcyBiYXNlIHtcblxuICAgIC8qXG4gICAgICogSGFuZGxlIGEgY2hhbmdlIHRvIHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0cmlidXRlTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICBpZiAoc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKSB7IHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygpOyB9XG4gICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBhdHRyaWJ1dGVUb1Byb3BlcnR5TmFtZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUgbmFtZSBjb3JyZXNwb25kcyB0byBhIHByb3BlcnR5IG5hbWUsIHNldCB0aGUgcHJvcGVydHkuXG4gICAgICAvLyBJZ25vcmUgc3RhbmRhcmQgSFRNTEVsZW1lbnQgcHJvcGVydGllcyBoYW5kbGVkIGJ5IHRoZSBET00uXG4gICAgICBpZiAocHJvcGVydHlOYW1lIGluIHRoaXMgJiYgIShwcm9wZXJ0eU5hbWUgaW4gSFRNTEVsZW1lbnQucHJvdG90eXBlKSkge1xuICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgICBzYWZlQXR0cmlidXRlcy5jb25uZWN0ZWQodGhpcyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlc0ZvckNsYXNzKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldC91bnNldCB0aGUgYXR0cmlidXRlIHdpdGggdGhlIGluZGljYXRlZCBuYW1lLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZXhpc3RzIHByaW1hcmlseSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYW4gZWxlbWVudCB3YW50cyB0b1xuICAgICAqIHNldCBhIGRlZmF1bHQgcHJvcGVydHkgdmFsdWUgdGhhdCBzaG91bGQgYmUgcmVmbGVjdGVkIGFzIGFuIGF0dHJpYnV0ZS4gQW5cbiAgICAgKiBpbXBvcnRhbnQgbGltaXRhdGlvbiBvZiBjdXN0b20gZWxlbWVudCBjb25zdHVyY3RvcnMgaXMgdGhhdCB0aGV5IGNhbm5vdFxuICAgICAqIHNldCBhdHRyaWJ1dGVzLiBBIGNhbGwgdG8gYHJlZmxlY3RBdHRyaWJ1dGVgIGR1cmluZyB0aGUgY29uc3RydWN0b3Igd2lsbFxuICAgICAqIGJlIGRlZmVycmVkIHVudGlsIHRoZSBlbGVtZW50IGlzIGNvbm5lY3RlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIC0gVGhlIG5hbWUgb2YgdGhlICphdHRyaWJ1dGUqIChub3QgcHJvcGVydHkpIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0LiBJZiBudWxsLCB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICByZWZsZWN0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBzYWZlQXR0cmlidXRlcy5zZXRBdHRyaWJ1dGUodGhpcywgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0L3Vuc2V0IHRoZSBjbGFzcyB3aXRoIHRoZSBpbmRpY2F0ZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGV4aXN0cyBwcmltYXJpbHkgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFuIGVsZW1lbnQgd2FudHMgdG9cbiAgICAgKiBzZXQgYSBkZWZhdWx0IHByb3BlcnR5IHZhbHVlIHRoYXQgc2hvdWxkIGJlIHJlZmxlY3RlZCBhcyBhcyBjbGFzcy4gQW5cbiAgICAgKiBpbXBvcnRhbnQgbGltaXRhdGlvbiBvZiBjdXN0b20gZWxlbWVudCBjb25zdHVyY3RvcnMgaXMgdGhhdCB0aGV5IGNhbm5vdFxuICAgICAqIHNldCBhdHRyaWJ1dGVzLCBpbmNsdWRpbmcgdGhlIGBjbGFzc2AgYXR0cmlidXRlLiBBIGNhbGwgdG9cbiAgICAgKiBgcmVmbGVjdENsYXNzYCBkdXJpbmcgdGhlIGNvbnN0cnVjdG9yIHdpbGwgYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVsZW1lbnRcbiAgICAgKiBpcyBjb25uZWN0ZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjbGFzcyB0byBzZXQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlIC0gVHJ1ZSB0byBzZXQgdGhlIGNsYXNzLCBmYWxzZSB0byByZW1vdmUgaXQuXG4gICAgICovXG4gICAgcmVmbGVjdENsYXNzKGNsYXNzTmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBzYWZlQXR0cmlidXRlcy50b2dnbGVDbGFzcyh0aGlzLCBjbGFzc05hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBBdHRyaWJ1dGVNYXJzaGFsbGluZztcbn07XG5cblxuLy8gQ29udmVydCBoeXBoZW5hdGVkIGZvby1iYXIgYXR0cmlidXRlIG5hbWUgdG8gY2FtZWwgY2FzZSBmb29CYXIgcHJvcGVydHkgbmFtZS5cbmZ1bmN0aW9uIGF0dHJpYnV0ZVRvUHJvcGVydHlOYW1lKGF0dHJpYnV0ZU5hbWUpIHtcbiAgbGV0IHByb3BlcnR5TmFtZSA9IGF0dHJpYnV0ZVRvUHJvcGVydHlOYW1lc1thdHRyaWJ1dGVOYW1lXTtcbiAgaWYgKCFwcm9wZXJ0eU5hbWUpIHtcbiAgICAvLyBDb252ZXJ0IGFuZCBtZW1vaXplLlxuICAgIGNvbnN0IGh5cGVuUmVnRXggPSAvLShbYS16XSkvZztcbiAgICBwcm9wZXJ0eU5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoaHlwZW5SZWdFeCxcbiAgICAgICAgbWF0Y2ggPT4gbWF0Y2hbMV0udG9VcHBlckNhc2UoKSk7XG4gICAgYXR0cmlidXRlVG9Qcm9wZXJ0eU5hbWVzW2F0dHJpYnV0ZU5hbWVdID0gcHJvcGVydHlOYW1lO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eU5hbWU7XG59XG5cbmZ1bmN0aW9uIGF0dHJpYnV0ZXNGb3JDbGFzcyhjbGFzc0ZuKSB7XG5cbiAgLy8gV2UgdHJlYXQgdGhlIGVsZW1lbnQgYmFzZSBjbGFzc2VzIGFzIGlmIHRoZXkgaGF2ZSBubyBhdHRyaWJ1dGVzLCBzaW5jZSB3ZVxuICAvLyBkb24ndCB3YW50IHRvIHJlY2VpdmUgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIGZvciB0aGVtLlxuICBpZiAoY2xhc3NGbiA9PT0gSFRNTEVsZW1lbnQgfHwgY2xhc3NGbiA9PT0gT2JqZWN0KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gR2V0IGF0dHJpYnV0ZXMgZm9yIHBhcmVudCBjbGFzcy5cbiAgY29uc3QgYmFzZUNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNsYXNzRm4ucHJvdG90eXBlKS5jb25zdHJ1Y3RvcjtcbiAgY29uc3QgYmFzZUF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzRm9yQ2xhc3MoYmFzZUNsYXNzKTtcblxuICAvLyBHZXQgYXR0cmlidXRlcyBmb3IgdGhpcyBjbGFzcy5cbiAgY29uc3QgcHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNsYXNzRm4ucHJvdG90eXBlKTtcbiAgY29uc3Qgc2V0dGVyTmFtZXMgPSBwcm9wZXJ0eU5hbWVzLmZpbHRlcihwcm9wZXJ0eU5hbWUgPT5cbiAgICB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgY2xhc3NGbi5wcm90b3R5cGUsIHByb3BlcnR5TmFtZSkuc2V0ID09PSAnZnVuY3Rpb24nKTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHNldHRlck5hbWVzLm1hcChzZXR0ZXJOYW1lID0+XG4gICAgICBwcm9wZXJ0eU5hbWVUb0F0dHJpYnV0ZShzZXR0ZXJOYW1lKSk7XG5cbiAgLy8gTWVyZ2UuXG4gIGNvbnN0IGRpZmYgPSBhdHRyaWJ1dGVzLmZpbHRlcihhdHRyaWJ1dGUgPT5cbiAgICAgIGJhc2VBdHRyaWJ1dGVzLmluZGV4T2YoYXR0cmlidXRlKSA8IDApO1xuICByZXR1cm4gYmFzZUF0dHJpYnV0ZXMuY29uY2F0KGRpZmYpO1xufVxuXG4vLyBDb252ZXJ0IGEgY2FtZWwgY2FzZSBmb29CYXIgcHJvcGVydHkgbmFtZSB0byBhIGh5cGhlbmF0ZWQgZm9vLWJhciBhdHRyaWJ1dGUuXG5mdW5jdGlvbiBwcm9wZXJ0eU5hbWVUb0F0dHJpYnV0ZShwcm9wZXJ0eU5hbWUpIHtcbiAgbGV0IGF0dHJpYnV0ZSA9IHByb3BlcnR5TmFtZXNUb0F0dHJpYnV0ZXNbcHJvcGVydHlOYW1lXTtcbiAgaWYgKCFhdHRyaWJ1dGUpIHtcbiAgICAvLyBDb252ZXJ0IGFuZCBtZW1vaXplLlxuICAgIGNvbnN0IHVwcGVyY2FzZVJlZ0V4ID0gLyhbQS1aXSkvZztcbiAgICBhdHRyaWJ1dGUgPSBwcm9wZXJ0eU5hbWUucmVwbGFjZSh1cHBlcmNhc2VSZWdFeCwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZTtcbn1cbiIsIi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggQ2xpY2tTZWxlY3Rpb24uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYXBzIGEgY2xpY2sgKGFjdHVhbGx5LCBhIG1vdXNlZG93bikgdG8gYSBzZWxlY3Rpb24uXG4gICAqXG4gICAqIFRoaXMgc2ltcGxlIG1peGluIGlzIHVzZWZ1bCBpbiBsaXN0IGJveC1saWtlIGVsZW1lbnRzLCB3aGVyZSBhIGNsaWNrIG9uIGFcbiAgICogbGlzdCBpdGVtIGltcGxpY2l0bHkgc2VsZWN0cyBpdC5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBleHBlY3RzIHRoZSBjb21wb25lbnQgdG8gcHJvdmlkZSBhbiBgaXRlbXNgIHByb3BlcnR5LiBZb3UgY2FuXG4gICAqIHByb3ZpZGUgdGhhdCBwcm9wZXJ0eSB5b3Vyc2VsZiwgb3IgdXNlXG4gICAqIFtDb250ZW50SXRlbXNNaXhpbl0oQ29udGVudEl0ZW1zTWl4aW4ubWQpLiBUaGlzIG1peGluIGFsc28gZXhwZWN0cyB0aGVcbiAgICogY29tcG9uZW50IHRvIGRlZmluZSBhIGBzZWxlY3RlZEluZGV4YCBwcm9wZXJ0eS4gWW91IGNhbiBwcm92aWRlIHRoYXRcbiAgICogeW91cnNlbGYsIG9yIHVzZSBbU2luZ2xlU2VsZWN0aW9uTWl4aW5dKFNpbmdsZVNlbGVjdGlvbk1peGluLm1kKS5cbiAgICovXG4gIGNsYXNzIENsaWNrU2VsZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICAvKlxuICAgICAgICogUkVWSUVXOiBXaGljaCBldmVudCBzaG91bGQgd2UgbGlzdGVuIHRvIGhlcmU/XG4gICAgICAgKlxuICAgICAgICogVGhlIHN0YW5kYXJkIHVzZSBmb3IgdGhpcyBtaXhpbiBpcyBpbiBsaXN0IGJveGVzLiBMaXN0IGJveGVzIGRvbid0XG4gICAgICAgKiBhcHBlYXIgdG8gYmUgY29uc2lzdGVudCB3aXRoIHJlZ2FyZCB0byB3aGV0aGVyIHRoZXkgc2VsZWN0IG9uIG1vdXNlZG93blxuICAgICAgICogb3IgY2xpY2svbW91c2V1cC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBldmVudCA9PiB7XG4gICAgICAgIC8vIEhBQ0s6IElmIHRoZSBpdGVtIGlzIGEgYnV0dG9uLCB0aGUgZXZlbnQgc2VlbXMgdG8gYmUgcmFpc2VkIGluXG4gICAgICAgIC8vIHBoYXNlIDIgKEFUX1RBUkdFVCksIGJ1dCB0aGUgdGFyZ2V0IGlzIHRoZSBjb21wb25lbnQsIG5vdCBpdGVtLlxuICAgICAgICAvLyBOZWVkIHRvIGludmVzaWdhdGUuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCA9PT0gdGhpcyA/XG4gICAgICAgICAgZXZlbnQucGF0aFswXSA6XG4gICAgICAgICAgZXZlbnQudGFyZ2V0O1xuICAgICAgICBjb25zdCBpbmRleCA9IGluZGV4T2ZDb250YWluaW5nSXRlbSh0aGlzLCB0YXJnZXQpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgICAgIC8vIE5vdGU6IFdlIGRvbid0IGNhbGwgcHJldmVudERlZmF1bHQgaGVyZS4gVGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yXG4gICAgICAgICAgLy8gbW91c2Vkb3duIGluY2x1ZGVzIHNldHRpbmcga2V5Ym9hcmQgZm9jdXMgaWYgdGhlIGVsZW1lbnQgZG9lc24ndFxuICAgICAgICAgIC8vIGFscmVhZHkgaGF2ZSB0aGUgZm9jdXMsIGFuZCB3ZSB3YW50IHRvIHByZXNlcnZlIHRoYXQgYmVoYXZpb3IuXG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24uIFRoaXMgd2lsbCB0eXBpY2FsbHkgYmUgaGFuZGxlZCBieSBvdGhlciBtaXhpbnMuXG4gICAgZ2V0IHNlbGVjdGVkSW5kZXgoKSB7XG4gICAgICByZXR1cm4gc3VwZXIuc2VsZWN0ZWRJbmRleDtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICAgIGlmICgnc2VsZWN0ZWRJbmRleCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRJbmRleCA9IGluZGV4OyB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQ2xpY2tTZWxlY3Rpb247XG59O1xuXG5cbi8qXG4gKiBSZXR1cm4gaW5kZXggb2YgdGhlIGVsZW1lbnQgaXRlbXMgdGhhdCBlaXRoZXIgaXMgb3IgY29udGFpbnMgdGhlIGluZGljYXRlZFxuICogdGFyZ2V0LiBSZXR1cm4gLTEgaWYgbm90IGZvdW5kLlxuICovXG5mdW5jdGlvbiBpbmRleE9mQ29udGFpbmluZ0l0ZW0oZWxlbWVudCwgdGFyZ2V0KSB7XG4gIGNvbnN0IGl0ZW1zID0gZWxlbWVudC5pdGVtcztcbiAgY29uc3QgaXRlbUNvdW50ID0gaXRlbXMgPyBpdGVtcy5sZW5ndGggOiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1Db3VudDsgaSsrKSB7XG4gICAgbGV0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBpZiAoaXRlbSA9PT0gdGFyZ2V0IHx8IGl0ZW0uY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggQ29tcG9zYWJsZS4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHRvIG1ha2UgYSBjbGFzcyBtb3JlIGVhc2lseSBjb21wb3NhYmxlIHdpdGggb3RoZXIgbWl4aW5zLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGNvbnRyaWJ1dGVzIGEgYGNvbXBvc2VgIG1ldGhvZCB0aGF0IGFwcGxpZXMgYSBzZXQgb2YgbWl4aW5cbiAgICogZnVuY3Rpb25zIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgbmV3IGNsYXNzLiBUaGlzIHN1Z2FyIGNhbiBtYWtlIHRoZVxuICAgKiBhcHBsaWNhdGlvbiBvZiBtYW55IG1peGlucyBhdCBvbmNlIGVhc2llciB0byByZWFkLlxuICAgKi9cbiAgY2xhc3MgQ29tcG9zYWJsZSBleHRlbmRzIGJhc2Uge1xuXG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBzZXQgb2YgbWl4aW4gZnVuY3Rpb25zIG9yIG1peGluIG9iamVjdHMgdG8gdGhlIHByZXNlbnQgY2xhc3MgYW5kXG4gICAgICogcmV0dXJuIHRoZSBuZXcgY2xhc3MuXG4gICAgICpcbiAgICAgKiBJbnN0ZWFkIG9mIHdyaXRpbmc6XG4gICAgICpcbiAgICAgKiAgICAgbGV0IE15Q2xhc3MgPSBNaXhpbjEoTWl4aW4yKE1peGluMyhNaXhpbjQoTWl4aW41KEJhc2VDbGFzcykpKSkpO1xuICAgICAqXG4gICAgICogWW91IGNhbiB3cml0ZTpcbiAgICAgKlxuICAgICAqICAgICBsZXQgTXlDbGFzcyA9IENvbXBvc2FibGVNaXhpbihCYXNlQ2xhc3MpLmNvbXBvc2UoXG4gICAgICogICAgICAgTWl4aW4xLFxuICAgICAqICAgICAgIE1peGluMixcbiAgICAgKiAgICAgICBNaXhpbjMsXG4gICAgICogICAgICAgTWl4aW40LFxuICAgICAqICAgICAgIE1peGluNVxuICAgICAqICAgICApO1xuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYWxzbyB0YWtlIG1peGluIG9iamVjdHMuIEEgbWl4aW4gb2JqZWN0IGlzIGp1c3QgYVxuICAgICAqIHNob3J0aGFuZCBmb3IgYSBtaXhpbiBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgc3ViY2xhc3Mgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgKiBtZW1iZXJzLiBUaGUgbWl4aW4gb2JqZWN0J3MgbWVtYmVycyBhcmUgKm5vdCogY29waWVkIGRpcmVjdGx5IG9udG8gdGhlXG4gICAgICogcHJvdG90eXBlIG9mIHRoZSBiYXNlIGNsYXNzLCBhcyB3aXRoIHRyYWRpdGlvbmFsIG1peGlucy5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIHByb3ZpZGluZyBzeW50YWN0aWMgc3VnYXIsIHRoaXMgbWl4aW4gY2FuIGJlIHVzZWQgdG9cbiAgICAgKiBkZWZpbmUgYSBjbGFzcyBpbiBFUzUsIHdoaWNoIGxhY2tzIEVTNidzIGBjbGFzc2Aga2V5d29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4ubWl4aW5zfSBtaXhpbnMgLSBBIHNldCBvZiBtaXhpbiBmdW5jdGlvbnMgb3Igb2JqZWN0cyB0byBhcHBseS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcG9zZSguLi5taXhpbnMpIHtcbiAgICAgIC8vIFdlIGNyZWF0ZSBhIG5ldyBzdWJjbGFzcyBmb3IgZWFjaCBtaXhpbiBpbiB0dXJuLiBUaGUgcmVzdWx0IGJlY29tZXNcbiAgICAgIC8vIHRoZSBiYXNlIGNsYXNzIGV4dGVuZGVkIGJ5IGFueSBzdWJzZXF1ZW50IG1peGlucy4gSXQgdHVybnMgb3V0IHRoYXRcbiAgICAgIC8vIHdlIGNhbiB1c2UgQXJyYXkucmVkdWNlKCkgdG8gY29uY2lzZWx5IGV4cHJlc3MgdGhpcywgdXNpbmcgdGhlIGN1cnJlbnRcbiAgICAgIC8vIG9iamVjdCBhcyB0aGUgc2VlZCBmb3IgcmVkdWNlKCkuXG4gICAgICByZXR1cm4gbWl4aW5zLnJlZHVjZShjb21wb3NlQ2xhc3MsIHRoaXMpO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIENvbXBvc2FibGU7XG59O1xuXG5cbi8vIFByb3BlcnRpZXMgZGVmaW5lZCBieSBPYmplY3QgdGhhdCB3ZSBkb24ndCB3YW50IHRvIG1peGluLlxuY29uc3QgTk9OX01JWEFCTEVfT0JKRUNUX1BST1BFUlRJRVMgPSBbXG4gICdjb25zdHJ1Y3Rvcidcbl07XG5cbi8qXG4gKiBBcHBseSB0aGUgbWl4aW4gdG8gdGhlIGdpdmVuIGJhc2UgY2xhc3MgdG8gcmV0dXJuIGEgbmV3IGNsYXNzLlxuICogVGhlIG1peGluIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG1vZGlmaWVkIGNsYXNzLCBvciBhXG4gKiBwbGFpbiBvYmplY3Qgd2hvc2UgbWVtYmVycyB3aWxsIGJlIGNvcGllZCB0byB0aGUgbmV3IGNsYXNzJyBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VDbGFzcyhiYXNlLCBtaXhpbikge1xuICBpZiAodHlwZW9mIG1peGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gTWl4aW4gZnVuY3Rpb25cbiAgICByZXR1cm4gbWl4aW4oYmFzZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTWl4aW4gb2JqZWN0XG4gICAgY2xhc3MgU3ViY2xhc3MgZXh0ZW5kcyBiYXNlIHt9XG4gICAgY29weU93blByb3BlcnRpZXMobWl4aW4sIFN1YmNsYXNzLnByb3RvdHlwZSwgTk9OX01JWEFCTEVfT0JKRUNUX1BST1BFUlRJRVMpO1xuICAgIHJldHVybiBTdWJjbGFzcztcbiAgfVxufVxuXG5cbi8qXG4gKiBDb3B5IHRoZSBnaXZlbiBwcm9wZXJ0aWVzL21ldGhvZHMgdG8gdGhlIHRhcmdldC5cbiAqIFJldHVybiB0aGUgdXBkYXRlZCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPd25Qcm9wZXJ0aWVzKHNvdXJjZSwgdGFyZ2V0LCBpZ25vcmVQcm9wZXJ0eU5hbWVzID0gW10pIHtcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGlmIChpZ25vcmVQcm9wZXJ0eU5hbWVzLmluZGV4T2YobmFtZSkgPCAwKSB7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIG5hbWUpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IHRvZ2dsZUNsYXNzIGZyb20gJy4vdG9nZ2xlQ2xhc3MnO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi9zeW1ib2xzJztcblxuXG4vLyBTeW1ib2xzIGZvciBwcml2YXRlIGRhdGEgbWVtYmVycyBvbiBhbiBlbGVtZW50LlxuY29uc3QgaXRlbXNTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2l0ZW1zJyk7XG5jb25zdCBpdGVtSW5pdGlhbGl6ZWRTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2l0ZW1Jbml0aWFsaXplZCcpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggQ29udGVudEl0ZW1zLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gd2hpY2ggbWFwcyBjb250ZW50IHNlbWFudGljcyAoZWxlbWVudHMpIHRvIGxpc3QgaXRlbSBzZW1hbnRpY3MuXG4gICAqXG4gICAqIEl0ZW1zIGRpZmZlciBmcm9tIGVsZW1lbnQgY29udGVudHMgaW4gc2V2ZXJhbCB3YXlzOlxuICAgKlxuICAgKiAqIFRoZXkgYXJlIG9mdGVuIHJlZmVyZW5jZWQgdmlhIGluZGV4LlxuICAgKiAqIFRoZXkgbWF5IGhhdmUgYSBzZWxlY3Rpb24gc3RhdGUuXG4gICAqICogSXQncyBjb21tb24gdG8gZG8gd29yayB0byBpbml0aWFsaXplIHRoZSBhcHBlYXJhbmNlIG9yIHN0YXRlIG9mIGEgbmV3XG4gICAqICAgaXRlbS5cbiAgICogKiBBdXhpbGlhcnkgaW52aXNpYmxlIGNoaWxkIGVsZW1lbnRzIGFyZSBmaWx0ZXJlZCBvdXQgYW5kIG5vdCBjb3VudGVkIGFzXG4gICAqICAgaXRlbXMuIEF1eGlsaWFyeSBlbGVtZW50cyBpbmNsdWRlIGxpbmssIHNjcmlwdCwgc3R5bGUsIGFuZCB0ZW1wbGF0ZVxuICAgKiAgIGVsZW1lbnRzLiBUaGlzIGZpbHRlcmluZyBlbnN1cmVzIHRoYXQgdGhvc2UgYXV4aWxpYXJ5IGVsZW1lbnRzIGNhbiBiZVxuICAgKiAgIHVzZWQgaW4gbWFya3VwIGluc2lkZSBvZiBhIGxpc3Qgd2l0aG91dCBiZWluZyB0cmVhdGVkIGFzIGxpc3QgaXRlbXMuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyBhIGNvbXBvbmVudCB0byBwcm92aWRlIGEgYGNvbnRlbnRgIHByb3BlcnR5IHJldHVybmluZyBhXG4gICAqIHJhdyBzZXQgb2YgZWxlbWVudHMuIFlvdSBjYW4gcHJvdmlkZSB0aGF0IHlvdXJzZWxmLCBvciB1c2VcbiAgICogW0Rpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW5dKERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4ubWQpLlxuICAgKlxuICAgKiBUaGUgbW9zdCBjb21tb25seSByZWZlcmVuY2VkIHByb3BlcnR5IGRlZmluZWQgYnkgdGhpcyBtaXhpbiBpcyB0aGUgYGl0ZW1zYFxuICAgKiBwcm9wZXJ0eS4gVG8gYXZvaWQgaGF2aW5nIHRvIGRvIHdvcmsgZWFjaCB0aW1lIHRoYXQgcHJvcGVydHkgaXMgcmVxdWVzdGVkLFxuICAgKiB0aGlzIG1peGluIHN1cHBvcnRzIGFuIG9wdGltaXplZCBtb2RlLiBJZiB5b3UgaW52b2tlIHRoZSBgY29udGVudENoYW5nZWRgXG4gICAqIG1ldGhvZCB3aGVuIHRoZSBzZXQgb2YgaXRlbXMgY2hhbmdlcywgdGhlIG1peGluIGNvbmNsdWRlcyB0aGF0IHlvdSdsbCB0YWtlXG4gICAqIGNhcmUgb2Ygbm90aWZ5aW5nIGl0IG9mIGZ1dHVyZSBjaGFuZ2VzLCBhbmQgdHVybnMgb24gdGhlIG9wdGltaXphdGlvbi4gV2l0aFxuICAgKiB0aGF0IG9uLCB0aGUgbWl4aW4gc2F2ZXMgYSByZWZlcmVuY2UgdG8gdGhlIGNvbXB1dGVkIHNldCBvZiBpdGVtcywgYW5kIHdpbGxcbiAgICogcmV0dXJuIHRoYXQgaW1tZWRpYXRlbHkgb24gc3Vic2VxdWVudCBjYWxscyB0byB0aGUgYGl0ZW1zYCBwcm9wZXJ0eS4gSWYgeW91XG4gICAqIHVzZSB0aGlzIG1peGluIGluIGNvbmp1bmN0aW9uIHdpdGhcbiAgICogW0Rpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW5dKERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4ubWQpLCB0aGVcbiAgICogYGNvbnRlbnRDaGFuZ2VkYCBtZXRob2Qgd2lsbCBiZSBpbnZva2VkIGZvciB5b3Ugd2hlbiB0aGUgZWxlbWVudCdzIGNoaWxkcmVuXG4gICAqIGNoYW5nZSwgdHVybmluZyBvbiB0aGUgb3B0aW1pemF0aW9uIGF1dG9tYXRpY2FsbHkuXG4gICAqL1xuICBjbGFzcyBDb250ZW50SXRlbXMgZXh0ZW5kcyBiYXNlIHtcblxuICAgIGNvbnRlbnRDaGFuZ2VkKCkge1xuICAgICAgaWYgKHN1cGVyLmNvbnRlbnRDaGFuZ2VkKSB7IHN1cGVyLmNvbnRlbnRDaGFuZ2VkKCk7IH1cblxuICAgICAgLy8gU2luY2Ugd2UgZ290IHRoZSBjb250ZW50Q2hhbmdlZCBjYWxsLCB3ZSdsbCBhc3N1bWUgd2UnbGwgYmUgbm90aWZpZWQgaWZcbiAgICAgIC8vIHRoZSBzZXQgb2YgaXRlbXMgY2hhbmdlcyBsYXRlci4gV2UgdHVybiBvbiBtZW1vaXphdGlvbiBvZiB0aGUgaXRlbXNcbiAgICAgIC8vIHByb3BlcnR5IGJ5IHNldHRpbmcgb3VyIGludGVybmFsIHByb3BlcnR5IHRvIG51bGwgKGluc3RlYWQgb2ZcbiAgICAgIC8vIHVuZGVmaW5lZCkuXG4gICAgICB0aGlzW2l0ZW1zU3ltYm9sXSA9IG51bGw7XG5cbiAgICAgIHRoaXNbc3ltYm9scy5pdGVtc0NoYW5nZWRdKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuZXZlciBhIG5ldyBpdGVtIGlzIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLiBZb3UgY2FuIG92ZXJyaWRlXG4gICAgICogdGhpcyB0byBwZXJmb3JtIHBlci1pdGVtIGluaXRpYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaXRlbSAtIFRoZSBpdGVtIHRoYXQgd2FzIGFkZGVkLlxuICAgICAqL1xuICAgIFtzeW1ib2xzLml0ZW1BZGRlZF0oaXRlbSkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuaXRlbUFkZGVkXSkgeyBzdXBlcltzeW1ib2xzLml0ZW1BZGRlZF0oaXRlbSk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0aW9uIHN0YXRlIGZvciBhIHNpbmdsZSBpdGVtIGhhcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogSW52b2tlIHRoaXMgbWV0aG9kIHRvIHNpZ25hbCB0aGF0IHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiB0aGUgaW5kaWNhdGVkIGl0ZW1cbiAgICAgKiBoYXMgY2hhbmdlZC4gQnkgZGVmYXVsdCwgdGhpcyBhcHBsaWVzIGEgYHNlbGVjdGVkYCBDU1MgY2xhc3MgaWYgdGhlIGl0ZW1cbiAgICAgKiBpcyBzZWxlY3RlZCwgYW5kIHJlbW92ZWQgaXQgaWYgbm90IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaXRlbSAtIFRoZSBpdGVtIHdob3NlIHNlbGVjdGlvbiBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkIC0gVHJ1ZSBpZiB0aGUgaXRlbSBpcyBzZWxlY3RlZCwgZmFsc2UgaWYgbm90LlxuICAgICAqL1xuICAgIFtzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgc2VsZWN0ZWQpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1TZWxlY3RlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIHNlbGVjdGVkKTsgfVxuICAgICAgdG9nZ2xlQ2xhc3MoaXRlbSwgJ3NlbGVjdGVkJywgc2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHNldCBvZiBpdGVtcyBpbiB0aGUgbGlzdC4gU2VlIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnRhdGlvbiBmb3JcbiAgICAgKiBtaXhpbiBmb3IgYSBkZXNjcmlwdGlvbiBvZiBob3cgaXRlbXMgZGlmZmVyIGZyb20gcGxhaW4gY29udGVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudFtdfVxuICAgICAqL1xuICAgIGdldCBpdGVtcygpIHtcbiAgICAgIGxldCBpdGVtcztcbiAgICAgIGlmICh0aGlzW2l0ZW1zU3ltYm9sXSA9PSBudWxsKSB7XG4gICAgICAgIGl0ZW1zID0gZmlsdGVyQXV4aWxpYXJ5RWxlbWVudHModGhpcy5jb250ZW50KTtcbiAgICAgICAgLy8gTm90ZTogdGVzdCBmb3IgKmVxdWFsaXR5KiB3aXRoIG51bGw7IGRvbid0IHRyZWF0IHVuZGVmaW5lZCBhcyBhIG1hdGNoLlxuICAgICAgICBpZiAodGhpc1tpdGVtc1N5bWJvbF0gPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBNZW1vaXplIHRoZSBzZXQgb2YgaXRlbXMuXG4gICAgICAgICAgdGhpc1tpdGVtc1N5bWJvbF0gPSBpdGVtcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBtZW1vaXplZCBpdGVtcy5cbiAgICAgICAgaXRlbXMgPSB0aGlzW2l0ZW1zU3ltYm9sXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gdGhlIHVuZGVybHlpbmcgY29udGVudHMgY2hhbmdlLiBJdCBpcyBhbHNvXG4gICAgICogaW52b2tlZCBvbiBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24g4oCTIHNpbmNlIHRoZSBpdGVtcyBoYXZlIFwiY2hhbmdlZFwiIGZyb21cbiAgICAgKiBiZWluZyBub3RoaW5nLlxuICAgICAqL1xuICAgIFtzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtc0NoYW5nZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpOyB9XG5cbiAgICAgIC8vIFBlcmZvcm0gcGVyLWl0ZW0gaW5pdGlhbGl6YXRpb24uXG4gICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRoaXMuaXRlbXMsIGl0ZW0gPT4ge1xuICAgICAgICBpZiAoIWl0ZW1baXRlbUluaXRpYWxpemVkU3ltYm9sXSkge1xuICAgICAgICAgIHRoaXNbc3ltYm9scy5pdGVtQWRkZWRdKGl0ZW0pO1xuICAgICAgICAgIGl0ZW1baXRlbUluaXRpYWxpemVkU3ltYm9sXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdpdGVtcy1jaGFuZ2VkJykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIGl0ZW1zIGluIHRoZSBsaXN0IGNoYW5nZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDb250ZW50SXRlbXNcbiAgICAgKiBAZXZlbnQgaXRlbXMtY2hhbmdlZFxuICAgICAqL1xuICB9XG5cbiAgcmV0dXJuIENvbnRlbnRJdGVtcztcbn07XG5cblxuLy8gUmV0dXJuIHRoZSBnaXZlbiBlbGVtZW50cywgZmlsdGVyaW5nIG91dCBhdXhpbGlhcnkgZWxlbWVudHMgdGhhdCBhcmVuJ3Rcbi8vIHR5cGljYWxseSB2aXNpYmxlLiBJdGVtcyB3aGljaCBhcmUgbm90IGVsZW1lbnRzIGFyZSByZXR1cm5lZCBhcyBpcy5cbmZ1bmN0aW9uIGZpbHRlckF1eGlsaWFyeUVsZW1lbnRzKGl0ZW1zKSB7XG4gIGNvbnN0IGF1eGlsaWFyeVRhZ3MgPSBbXG4gICAgJ2xpbmsnLFxuICAgICdzY3JpcHQnLFxuICAgICdzdHlsZScsXG4gICAgJ3RlbXBsYXRlJ1xuICBdO1xuICByZXR1cm4gW10uZmlsdGVyLmNhbGwoaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gIWl0ZW0ubG9jYWxOYW1lIHx8IGF1eGlsaWFyeVRhZ3MuaW5kZXhPZihpdGVtLmxvY2FsTmFtZSkgPCAwO1xuICB9KTtcbn1cbiIsImltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBEaXJlY3Rpb25TZWxlY3Rpb24uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYXBzIGRpcmVjdGlvbiBzZW1hbnRpY3MgKGdvTGVmdCwgZ29SaWdodCwgZXRjLikgdG8gc2VsZWN0aW9uXG4gICAqIHNlbWFudGljcyAoc2VsZWN0UHJldmlvdXMsIHNlbGVjdE5leHQsIGV0Yy4pLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGhcbiAgICogW0tleWJvYXJkRGlyZWN0aW9uTWl4aW5dKEtleWJvYXJkRGlyZWN0aW9uTWl4aW4ubWQpICh3aGljaCBtYXBzIGtleWJvYXJkXG4gICAqIGV2ZW50cyB0byBkaXJlY3Rpb25zKSBhbmQgYSBtaXhpbiB0aGF0IGhhbmRsZXMgc2VsZWN0aW9uIGxpa2VcbiAgICogW1NpbmdsZVNlbGVjdGlvbk1peGluXShTaW5nbGVTZWxlY3Rpb25NaXhpbi5tZCkuXG4gICAqL1xuICBjbGFzcyBEaXJlY3Rpb25TZWxlY3Rpb24gZXh0ZW5kcyBiYXNlIHtcblxuICAgIFtzeW1ib2xzLmdvRG93bl0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0Rvd25dKSB7IHN1cGVyW3N5bWJvbHMuZ29Eb3duXSgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3ROZXh0KCk7XG4gICAgfVxuXG4gICAgW3N5bWJvbHMuZ29FbmRdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuZ29FbmRdKSB7IHN1cGVyW3N5bWJvbHMuZ29FbmRdKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdExhc3QoKTtcbiAgICB9XG5cbiAgICBbc3ltYm9scy5nb0xlZnRdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuZ29MZWZ0XSkgeyBzdXBlcltzeW1ib2xzLmdvTGVmdF0oKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0UHJldmlvdXMoKTtcbiAgICB9XG5cbiAgICBbc3ltYm9scy5nb1JpZ2h0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvUmlnaHRdKSB7IHN1cGVyW3N5bWJvbHMuZ29SaWdodF0oKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0TmV4dCgpO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLmdvU3RhcnRdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuZ29TdGFydF0pIHsgc3VwZXJbc3ltYm9scy5nb1N0YXJ0XSgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RGaXJzdCgpO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLmdvVXBdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuZ29VcF0pIHsgc3VwZXJbc3ltYm9scy5nb1VwXSgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RQcmV2aW91cygpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24uIFRoaXMgd2lsbCB0eXBpY2FsbHkgYmUgaGFuZGxlZCBieSBvdGhlciBtaXhpbnMuXG4gICAgZ2V0IHNlbGVjdGVkRnJhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3VwZXIuc2VsZWN0ZWRGcmFjdGlvbjtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkRnJhY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICgnc2VsZWN0ZWRGcmFjdGlvbicgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRGcmFjdGlvbiA9IHZhbHVlOyB9XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbi4gVGhpcyB3aWxsIHR5cGljYWxseSBiZSBoYW5kbGVkIGJ5IG90aGVyIG1peGlucy5cbiAgICBzZWxlY3RGaXJzdCgpIHtcbiAgICAgIGlmIChzdXBlci5zZWxlY3RGaXJzdCkgeyByZXR1cm4gc3VwZXIuc2VsZWN0Rmlyc3QoKTsgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24uIFRoaXMgd2lsbCB0eXBpY2FsbHkgYmUgaGFuZGxlZCBieSBvdGhlciBtaXhpbnMuXG4gICAgc2VsZWN0TGFzdCgpIHtcbiAgICAgIGlmIChzdXBlci5zZWxlY3RMYXN0KSB7IHJldHVybiBzdXBlci5zZWxlY3RMYXN0KCk7IH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uLiBUaGlzIHdpbGwgdHlwaWNhbGx5IGJlIGhhbmRsZWQgYnkgb3RoZXIgbWl4aW5zLlxuICAgIHNlbGVjdE5leHQoKSB7XG4gICAgICBpZiAoc3VwZXIuc2VsZWN0TmV4dCkgeyByZXR1cm4gc3VwZXIuc2VsZWN0TmV4dCgpOyB9XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbi4gVGhpcyB3aWxsIHR5cGljYWxseSBiZSBoYW5kbGVkIGJ5IG90aGVyIG1peGlucy5cbiAgICBzZWxlY3RQcmV2aW91cygpIHtcbiAgICAgIGlmIChzdXBlci5zZWxlY3RQcmV2aW91cykgeyByZXR1cm4gc3VwZXIuc2VsZWN0UHJldmlvdXMoKTsgfVxuICAgIH1cblxuICAgIC8vIE1hcCBkcmFnIHRyYXZlbCBmcmFjdGlvbiB0byBzZWxlY3Rpb24gZnJhY3Rpb24uXG4gICAgZ2V0IHRyYXZlbEZyYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnRyYXZlbEZyYWN0aW9uO1xuICAgIH1cbiAgICBzZXQgdHJhdmVsRnJhY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICgndHJhdmVsRnJhY3Rpb24nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnRyYXZlbEZyYWN0aW9uID0gdmFsdWU7IH1cbiAgICAgIHRoaXMuc2VsZWN0ZWRGcmFjdGlvbiA9IHZhbHVlO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIERpcmVjdGlvblNlbGVjdGlvbjtcbn07XG4iLCJpbXBvcnQgbWljcm90YXNrIGZyb20gJy4vbWljcm90YXNrJztcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50LiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gd2hpY2ggZGVmaW5lcyBhIGNvbXBvbmVudCdzIGNvbnRlbnQgYXMgaXRzIGNoaWxkcmVuLCBleHBhbmRpbmcgYW55XG4gICAqIG5vZGVzIGRpc3RyaWJ1dGVkIHRvIHRoZSBjb21wb25lbnQncyBzbG90cy5cbiAgICpcbiAgICogVGhpcyBhbHNvIHByb3ZpZGVzIG5vdGlmaWNhdGlvbiBvZiBjaGFuZ2VzIHRvIGEgY29tcG9uZW50J3MgY29udGVudC4gSXRcbiAgICogd2lsbCBpbnZva2UgYSBgY29udGVudENoYW5nZWRgIG1ldGhvZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZmlyc3RcbiAgICogaW5zdGFudGlhdGVkLCBhbmQgd2hlbmV2ZXIgaXRzIGRpc3RyaWJ1dGVkIGNoaWxkcmVuIGNoYW5nZS4gVGhpcyBpcyBhblxuICAgKiBlYXN5IHdheSB0byBzYXRpc2Z5IHRoZSBHb2xkIFN0YW5kYXJkIGNoZWNrbGlzdCBpdGVtIGZvciBtb25pdG9yaW5nXG4gICAqIFtDb250ZW50IENoYW5nZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL2dvbGQtc3RhbmRhcmQvd2lraS9Db250ZW50LUNoYW5nZXMpLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBcbiAgICogbGV0IGJhc2UgPSBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluKERpc3RyaWJ1dGVkQ2hpbGRyZW5NaXhpbihIVE1MRWxlbWVudCkpO1xuICAgKiBjbGFzcyBDb3VudGluZ0VsZW1lbnQgZXh0ZW5kcyBiYXNlIHtcbiAgICpcbiAgICogICBjb25zdHJ1Y3RvcigpIHtcbiAgICogICAgIHN1cGVyKCk7XG4gICAqICAgICBsZXQgcm9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgKiAgICAgcm9vdC5pbm5lckhUTUwgPSBgPHNsb3Q+PC9zbG90PmA7XG4gICAqICAgfVxuICAgKlxuICAgKiAgIGNvbnRlbnRDaGFuZ2VkKCkge1xuICAgKiAgICAgLy8gQ291bnQgdGhlIGNvbXBvbmVudCdzIGNoaWxkcmVuLCBib3RoIGluaXRpYWxseSBhbmQgd2hlbiBjaGFuZ2VkLlxuICAgKiAgICAgdGhpcy5jb3VudCA9IHRoaXMuZGlzdHJpYnV0ZWRDaGlsZHJlbi5sZW5ndGg7XG4gICAqICAgfVxuICAgKlxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBOb3RlIHRoYXQgY29udGVudCBjaGFuZ2UgZGV0ZWN0aW9uIGRlcGVuZHMgdXBvbiB0aGUgZWxlbWVudCBoYXZpbmcgYXQgbGVhc3RcbiAgICogb25lIGBzbG90YCBlbGVtZW50IGluIGl0cyBzaGFkb3cgc3VidHJlZS5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBpcyBpbnRlbmRlZCBmb3IgdXNlIHdpdGggdGhlXG4gICAqIFtEaXN0cmlidXRlZENoaWxkcmVuTWl4aW5dKERpc3RyaWJ1dGVkQ2hpbGRyZW5NaXhpbi5tZCkuIFNlZSB0aGF0IG1peGluIGZvclxuICAgKiBhIGRpc2N1c3Npb24gb2YgaG93IHRoYXQgd29ya3MuIFRoaXMgRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpblxuICAgKiBwcm92aWRlcyBhbiBlYXN5IHdheSBvZiBkZWZpbmluZyB0aGUgXCJjb250ZW50XCIgb2YgYSBjb21wb25lbnQgYXMgdGhlXG4gICAqIGNvbXBvbmVudCdzIGRpc3RyaWJ1dGVkIGNoaWxkcmVuLiBUaGF0IGluIHR1cm4gbGV0cyBtaXhpbnMgbGlrZVxuICAgKiBbQ29udGVudEl0ZW1zTWl4aW5dKENvbnRlbnRJdGVtc01peGluLm1kKSBtYW5pcHVsYXRlIHRoZSBjaGlsZHJlbiBhcyBsaXN0XG4gICAqIGl0ZW1zLlxuICAgKi9cbiAgY2xhc3MgRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnQgZXh0ZW5kcyBiYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcblxuICAgICAgaWYgKHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICAvLyBMaXN0ZW4gdG8gY2hhbmdlcyBvbiBhbGwgc2xvdHMuXG4gICAgICAgIGNvbnN0IHNsb3RzID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAgICAgc2xvdHMuZm9yRWFjaChzbG90ID0+IHNsb3QuYWRkRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIGV2ZW50ID0+IHtcbiAgICAgICAgICB0aGlzLmNvbnRlbnRDaGFuZ2VkKCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBhbiBpbml0aWFsIGNhbGwgdG8gY29udGVudENoYW5nZWQoKSBzbyB0aGF0IHRoZSBjb21wb25lbnQgY2FuIGRvXG4gICAgICAvLyBpbml0aWFsaXphdGlvbiB0aGF0IGl0IG5vcm1hbGx5IGRvZXMgd2hlbiBjb250ZW50IGNoYW5nZXMuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyB3aWxsIGludm9rZSBjb250ZW50Q2hhbmdlZCgpIGhhbmRsZXJzIGluIG90aGVyIG1peGlucy4gSW4gb3JkZXJcbiAgICAgIC8vIHRoYXQgdGhvc2UgbWl4aW5zIGhhdmUgYSBjaGFuY2UgdG8gY29tcGxldGUgdGhlaXIgb3duIGluaXRpYWxpemF0aW9uLFxuICAgICAgLy8gd2UgYWRkIHRoZSBjb250ZW50Q2hhbmdlZCgpIGNhbGwgdG8gdGhlIG1pY3JvdGFzayBxdWV1ZS5cbiAgICAgIG1pY3JvdGFzaygoKSA9PiB0aGlzLmNvbnRlbnRDaGFuZ2VkKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29udGVudHMgb2YgdGhlIGNvbXBvbmVudCAoaW5jbHVkaW5nIGRpc3RyaWJ1dGVkXG4gICAgICogY2hpbGRyZW4pIGhhdmUgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFsc28gaW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIGZpcnN0IGluc3RhbnRpYXRlZDsgdGhlXG4gICAgICogY29udGVudHMgaGF2ZSBlc3NlbnRpYWxseSBcImNoYW5nZWRcIiBmcm9tIGJlaW5nIG5vdGhpbmcuIFRoaXMgYWxsb3dzIHRoZVxuICAgICAqIGNvbXBvbmVudCB0byBwZXJmb3JtIGluaXRpYWwgcHJvY2Vzc2luZyBvZiBpdHMgY2hpbGRyZW4uXG4gICAgICovXG4gICAgY29udGVudENoYW5nZWQoKSB7XG4gICAgICBpZiAoc3VwZXIuY29udGVudENoYW5nZWQpIHsgc3VwZXIuY29udGVudENoYW5nZWQoKTsgfVxuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2NvbnRlbnQtY2hhbmdlZCcpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGVudCBvZiB0aGlzIGNvbXBvbmVudCwgZGVmaW5lZCB0byBiZSB0aGUgZmxhdHRlbmVkIGFycmF5IG9mXG4gICAgICogY2hpbGRyZW4gZGlzdHJpYnV0ZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudFtdfVxuICAgICAqL1xuICAgIGdldCBjb250ZW50KCkge1xuICAgICAgY29uc3QgZGlzdHJpYnV0ZWRDaGlsZHJlbiA9IHRoaXMuZGlzdHJpYnV0ZWRDaGlsZHJlbjtcbiAgICAgIGlmICh0eXBlb2YgZGlzdHJpYnV0ZWRDaGlsZHJlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluIGV4cGVjdHMgdGhlIGNvbXBvbmVudCB0byBkZWZpbmUgYSBcImRpc3RyaWJ1dGVkQ2hpbGRyZW5cIiBwcm9wZXJ0eS5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaXN0cmlidXRlZENoaWxkcmVuO1xuICAgIH1cbiAgICBzZXQgY29udGVudCh2YWx1ZSkge1xuICAgICAgaWYgKCdjb250ZW50JyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5jb250ZW50ID0gdmFsdWU7IH1cbiAgICAgIC8vIFRPRE86IFNldCB0aGUgY2hpbGRyZW4gdG8gdGhlIGdpdmVuIHZhbHVlICh3aGljaCBzaG91bGQgYmUgYW4gYXJyYXkgb2ZcbiAgICAgIC8vIGVsZW1lbnRzKT9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIHJhaXNlZCB3aGVuIHRoZSBjb21wb25lbnQncyBjb250ZW50cyAoaW5jbHVkaW5nIGRpc3RyaWJ1dGVkXG4gICAgICogY2hpbGRyZW4pIGhhdmUgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudFxuICAgICAqIEBldmVudCBjb250ZW50LWNoYW5nZWRcbiAgICAgKi9cbiAgfVxuXG4gIHJldHVybiBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudDtcbn07XG4iLCIvKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIERpc3RyaWJ1dGVkQ2hpbGRyZW4uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBkZWZpbmVzIGhlbHBlcnMgZm9yIGFjY2Vzc2luZyBhIGNvbXBvbmVudCdzIGRpc3RyaWJ1dGVkXG4gICAqIGNoaWxkcmVuIGFzIGEgZmxhdHRlbmVkIGFycmF5IG9yIHN0cmluZy5cbiAgICpcbiAgICogVGhlIHN0YW5kYXJkIERPTSBBUEkgcHJvdmlkZXMgc2V2ZXJhbCB3YXlzIG9mIGFjY2Vzc2luZyBjaGlsZCBjb250ZW50OlxuICAgKiBgY2hpbGRyZW5gLCBgY2hpbGROb2Rlc2AsIGFuZCBgdGV4dENvbnRlbnRgLiBOb25lIG9mIHRoZXNlIGZ1bmN0aW9ucyBhcmVcbiAgICogU2hhZG93IERPTSBhd2FyZS4gVGhpcyBtaXhpbiBkZWZpbmVzIHZhcmlhdGlvbnMgb2YgdGhvc2UgZnVuY3Rpb25zIHRoYXRcbiAgICogKmFyZSogU2hhZG93IERPTSBhd2FyZS5cbiAgICpcbiAgICogRXhhbXBsZTogeW91IGNyZWF0ZSBhIGNvbXBvbmVudCBgPGNvdW50LWNoaWxkcmVuPmAgdGhhdCBkaXNwbGF5cyBhIG51bWJlclxuICAgKiBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHBsYWNlZCBpbnNpZGUgdGhhdCBjb21wb25lbnQuIElmIHNvbWVvbmVcbiAgICogaW5zdGFudGlhdGVzIHlvdXIgY29tcG9uZW50IGxpa2U6XG4gICAqXG4gICAqICAgICA8Y291bnQtY2hpbGRyZW4+XG4gICAqICAgICAgIDxkaXY+PC9kaXY+XG4gICAqICAgICAgIDxkaXY+PC9kaXY+XG4gICAqICAgICAgIDxkaXY+PC9kaXY+XG4gICAqICAgICA8L2NvdW50LWNoaWxkcmVuPlxuICAgKlxuICAgKiBUaGVuIHRoZSBjb21wb25lbnQgc2hvdWxkIHNob3cgXCIzXCIsIGJlY2F1c2UgdGhlcmUgYXJlIHRocmVlIGNoaWxkcmVuLiBUb1xuICAgKiBjYWxjdWxhdGUgdGhlIG51bWJlciBvZiBjaGlsZHJlbiwgdGhlIGNvbXBvbmVudCBjYW4ganVzdCBjYWxjdWxhdGVcbiAgICogYHRoaXMuY2hpbGRyZW4ubGVuZ3RoYC4gSG93ZXZlciwgc3VwcG9zZSBzb21lb25lIGluc3RhbnRpYXRlcyB5b3VyXG4gICAqIGNvbXBvbmVudCBpbnNpZGUgb25lIG9mIHRoZWlyIG93biBjb21wb25lbnRzLCBhbmQgcHV0cyBhIGA8c2xvdD5gIGVsZW1lbnRcbiAgICogaW5zaWRlIHlvdXIgY29tcG9uZW50OlxuICAgKlxuICAgKiAgICAgPGNvdW50LWNoaWxkcmVuPlxuICAgKiAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAqICAgICA8L2NvdW50LWNoaWxkcmVuPlxuICAgKlxuICAgKiBJZiB5b3VyIGNvbXBvbmVudCBvbmx5IGxvb2tzIGF0IGB0aGlzLmNoaWxkcmVuYCwgaXQgd2lsbCBhbHdheXMgc2VlIGV4YWN0bHlcbiAgICogb25lIGNoaWxkIOKAlMKgdGhlIGA8c2xvdD5gIGVsZW1lbnQuIEJ1dCB0aGUgdXNlciBsb29raW5nIGF0IHRoZSBwYWdlIHdpbGxcbiAgICogKnNlZSogYW55IG5vZGVzIGRpc3RyaWJ1dGVkIHRvIHRoYXQgc2xvdC4gVG8gbWF0Y2ggd2hhdCB0aGUgdXNlciBzZWVzLCB5b3VyXG4gICAqIGNvbXBvbmVudCBzaG91bGQgZXhwYW5kIGFueSBgPHNsb3Q+YCBlbGVtZW50cyBpdCBjb250YWlucy5cbiAgICpcbiAgICogVGhhdCBpcyB0aGUgcHJvYmxlbSB0aGlzIG1peGluIHNvbHZlcy4gQWZ0ZXIgYXBwbHlpbmcgdGhpcyBtaXhpbiwgeW91clxuICAgKiBjb21wb25lbnQgY29kZSBoYXMgYWNjZXNzIHRvIGB0aGlzLmRpc3RyaWJ1dGVkQ2hpbGRyZW5gLCB3aG9zZSBgbGVuZ3RoYFxuICAgKiB3aWxsIHJldHVybiB0aGUgdG90YWwgbnVtYmVyIG9mIGFsbCBjaGlsZHJlbiBkaXN0cmlidXRlZCB0byB5b3VyIGNvbXBvbmVudFxuICAgKiBpbiB0aGUgY29tcG9zZWQgdHJlZS5cbiAgICpcbiAgICogTm90ZTogVGhlIGxhdGVzdCBDdXN0b20gRWxlbWVudHMgQVBJIGRlc2lnbiBjYWxscyBmb3IgYSBuZXcgZnVuY3Rpb24sXG4gICAqIGBnZXRBc3NpZ25lZE5vZGVzYCB0aGF0IHRha2VzIGFuIG9wdGlvbmFsIGBkZWVwYCBwYXJhbWV0ZXIsIHRoYXQgd2lsbCBzb2x2ZVxuICAgKiB0aGlzIHByb2JsZW0gYXQgdGhlIEFQSSBsZXZlbC5cbiAgICovXG4gIGNsYXNzIERpc3RyaWJ1dGVkQ2hpbGRyZW4gZXh0ZW5kcyBiYXNlIHtcblxuICAgIC8qKlxuICAgICAqIEFuIGluLW9yZGVyIGNvbGxlY3Rpb24gb2YgZGlzdHJpYnV0ZWQgY2hpbGRyZW4sIGV4cGFuZGluZyBhbnkgc2xvdFxuICAgICAqIGVsZW1lbnRzLiBMaWtlIHRoZSBzdGFuZGFyZCBjaGlsZHJlbiBwcm9wZXJ0eSwgdGhpcyBza2lwcyB0ZXh0IG5vZGVzLlxuICAgICAqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XG4gICAgICovXG4gICAgZ2V0IGRpc3RyaWJ1dGVkQ2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gZXhwYW5kQ29udGVudEVsZW1lbnRzKHRoaXMuY2hpbGRyZW4sIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbi1vcmRlciBjb2xsZWN0aW9uIG9mIGRpc3RyaWJ1dGVkIGNoaWxkIG5vZGVzLCBleHBhbmRpbmcgYW55IHNsb3RcbiAgICAgKiBlbGVtZW50cy4gTGlrZSB0aGUgc3RhbmRhcmQgY2hpbGROb2RlcyBwcm9wZXJ0eSwgdGhpcyBpbmNsdWRlcyB0ZXh0XG4gICAgICogbm9kZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Tm9kZVtdfVxuICAgICAqL1xuICAgIGdldCBkaXN0cmlidXRlZENoaWxkTm9kZXMoKSB7XG4gICAgICByZXR1cm4gZXhwYW5kQ29udGVudEVsZW1lbnRzKHRoaXMuY2hpbGROb2RlcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmNhdGVuYXRlZCB0ZXh0IGNvbnRlbnQgb2YgYWxsIGRpc3RyaWJ1dGVkIGNoaWxkIG5vZGVzLCBleHBhbmRpbmdcbiAgICAgKiBhbnkgc2xvdCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGRpc3RyaWJ1dGVkVGV4dENvbnRlbnQoKSB7XG4gICAgICBjb25zdCBzdHJpbmdzID0gdGhpcy5kaXN0cmlidXRlZENoaWxkTm9kZXMubWFwKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZC50ZXh0Q29udGVudDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0cmluZ3Muam9pbignJyk7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gRGlzdHJpYnV0ZWRDaGlsZHJlbjtcbn07XG5cblxuLypcbiAqIEdpdmVuIGEgYXJyYXkgb2Ygbm9kZXMsIHJldHVybiBhIG5ldyBhcnJheSB3aXRoIGFueSBjb250ZW50IGVsZW1lbnRzIGV4cGFuZGVkXG4gKiB0byB0aGUgbm9kZXMgZGlzdHJpYnV0ZWQgdG8gdGhhdCBjb250ZW50IGVsZW1lbnQuIFRoaXMgcnVsZSBpcyBhcHBsaWVkXG4gKiByZWN1cnNpdmVseS5cbiAqXG4gKiBJZiBpbmNsdWRlVGV4dE5vZGVzIGlzIHRydWUsIHRleHQgbm9kZXMgd2lsbCBiZSBpbmNsdWRlZCwgYXMgaW4gdGhlXG4gKiBzdGFuZGFyZCBjaGlsZE5vZGVzIHByb3BlcnR5OyBieSBkZWZhdWx0LCB0aGlzIHNraXBzIHRleHQgbm9kZXMsIGxpa2UgdGhlXG4gKiBzdGFuZGFyZCBjaGlsZHJlbiBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZXhwYW5kQ29udGVudEVsZW1lbnRzKG5vZGVzLCBpbmNsdWRlVGV4dE5vZGVzKSB7XG4gIGNvbnN0IGV4cGFuZGVkID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG5vZGVzLCBub2RlID0+IHtcbiAgICAvLyBXZSB3YW50IHRvIHNlZSBpZiB0aGUgbm9kZSBpcyBhbiBpbnN0YW5jZW9mIEhUTUxTbG90RUxlbWVudCwgYnV0XG4gICAgLy8gdGhhdCBjbGFzcyB3b24ndCBleGlzdCBpZiB0aGUgYnJvd3NlciB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBuYXRpdmVcbiAgICAvLyBTaGFkb3cgRE9NIGFuZCBpZiB0aGUgU2hhZG93IERPTSBwb2x5ZmlsbCBoYXNuJ3QgYmVlbiBsb2FkZWQuIEluc3RlYWQsXG4gICAgLy8gd2UgZG8gYSBzaW1wbGlzdGljIGNoZWNrIHRvIHNlZSBpZiB0aGUgdGFnIG5hbWUgaXMgXCJzbG90XCIuXG4gICAgY29uc3QgaXNTbG90ID0gdHlwZW9mIEhUTUxTbG90RWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgbm9kZSBpbnN0YW5jZW9mIEhUTUxTbG90RWxlbWVudCA6XG4gICAgICBub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnO1xuICAgIGlmIChpc1Nsb3QpIHtcbiAgICAgIC8vIFVzZSB0aGUgbm9kZXMgYXNzaWduZWQgdG8gdGhpcyBub2RlIGluc3RlYWQuXG4gICAgICBjb25zdCBhc3NpZ25lZE5vZGVzID0gbm9kZS5hc3NpZ25lZE5vZGVzKHsgZmxhdHRlbjogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiBhc3NpZ25lZE5vZGVzID9cbiAgICAgICAgZXhwYW5kQ29udGVudEVsZW1lbnRzKGFzc2lnbmVkTm9kZXMsIGluY2x1ZGVUZXh0Tm9kZXMpIDpcbiAgICAgICAgW107XG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIC8vIFBsYWluIGVsZW1lbnQ7IHVzZSBhcyBpcy5cbiAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgVGV4dCAmJiBpbmNsdWRlVGV4dE5vZGVzKSB7XG4gICAgICAvLyBUZXh0IG5vZGUuXG4gICAgICByZXR1cm4gW25vZGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb21tZW50LCBwcm9jZXNzaW5nIGluc3RydWN0aW9uLCBldGMuOyBza2lwLlxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGZsYXR0ZW5lZCA9IFtdLmNvbmNhdCguLi5leHBhbmRlZCk7XG4gIHJldHVybiBmbGF0dGVuZWQ7XG59XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcblxuXG4vLyBTeW1ib2xzIGZvciBwcml2YXRlIGRhdGEgbWVtYmVycyBvbiBhbiBlbGVtZW50LlxuY29uc3Qgc2VsZWN0ZWRGcmFjdGlvblN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnc2VsZWN0ZWRGcmFjdGlvbicpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggRnJhY3Rpb25hbFNlbGVjdGlvbi4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1peGluKGJhc2UpIHtcblxuICAvKipcbiAgICogQWRkcyBzdXBwb3J0IGZvciBmcmFjdGlvbmFsIHNlbGVjdGlvbjogdHJlYXRpbmcgYSBzZWxlY3Rpb24gYXMgYSByZWFsXG4gICAqIG51bWJlciB0aGF0IGNvbWJpbmVzIGFuIGludGVnZXIgcG9ydGlvbiAoYW4gaW5kZXggaW50byBhIGxpc3QpLCBhbmQgYVxuICAgKiBmcmFjdGlvbiAoaW5kaWNhdGluZyBob3cgZmFyIG9mIHRoZSB3YXkgd2UgYXJlIHRvIHRoZSBuZXh0IG9yIHByZXZpb3VzXG4gICAqIGl0ZW0pLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiBjb21wb25lbnRzIHRoYXQgc3VwcG9ydCBpbmNyZW1lbnRhbCBvcGVyYXRpb25zIGR1cmluZ1xuICAgKiBkcmFnZ2luZyBhbmQgc3dpcGluZy4gRXhhbXBsZTogYSBjYXJvdXNlbCBjb21wb25lbnQgaGFzIHNldmVyYWwgaXRlbXMsIGFuZCB0aGVcbiAgICogY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0gaXMgaXRlbSAzLiBUaGUgdXNlciBiZWdpbnMgc3dpcGluZyB0byB0aGUgbGVmdCxcbiAgICogbW92aW5nIHRvd2FyZHMgc2VsZWN0aW5nIGl0ZW0gNC4gSGFsZndheSB0aHJvdWdoIHRoaXMgb3BlcmF0aW9uLCB0aGVcbiAgICogZnJhY3Rpb25hbCBzZWxlY3Rpb24gdmFsdWUgaXMgMy41LlxuICAgKlxuICAgKiBUaGlzIHZhbHVlIHBlcm1pdHMgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIG1peGlucyBsaWtlXG4gICAqIFtTd2lwZURpcmVjdGlvbk1peGluXSguL1N3aXBlRGlyZWN0aW9uTWl4aW4ubWQpIGFuZFxuICAgKiBbVHJhY2twYWREaXJlY3Rpb25NaXhpbl0oLi9UcmFja3BhZERpcmVjdGlvbk1peGluLm1kKSwgd2hpY2ggZ2VuZXJhdGVcbiAgICogZnJhY3Rpb25hbCBzZWxlY3Rpb24gdmFsdWVzLCBhbmQgbWl4aW5zIGxpa2VcbiAgICogW1NlbGVjdGlvbkFuaW1hdGlvbk1peGluXSguL1NlbGVjdGlvbkFuaW1hdGlvbk1peGluLm1kKSwgd2hpY2ggY2FuIHJlbmRlclxuICAgKiBzZWxlY3Rpb24gYXQgYSBmcmFjdGlvbmFsIHZhbHVlLlxuICAgKi9cbiAgY2xhc3MgRnJhY3Rpb25hbFNlbGVjdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBpZiAoc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2spIHsgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTsgfVxuICAgICAgdGhpcy5zZWxlY3RlZEZyYWN0aW9uID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZyYWN0aW9uYWwgdmFsdWUgaW5kaWNhdGluZyBob3cgZmFyIHRoZSB1c2VyIGhhcyBjdXJyZW50bHkgYWR2YW5jZWQgdG9cbiAgICAgKiB0aGUgbmV4dC9wcmV2aW91cyBpdGVtLiBFLmcuLCBhIGBzZWxlY3RlZEZyYWN0aW9uYCBvZiAzLjUgaW5kaWNhdGVzIHRoZVxuICAgICAqIHVzZXIgaXMgaGFsZndheSBiZXR3ZWVuIGl0ZW1zIDMgYW5kIDQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZEZyYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNbc2VsZWN0ZWRGcmFjdGlvblN5bWJvbF07XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEZyYWN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzW3NlbGVjdGVkRnJhY3Rpb25TeW1ib2xdID0gdmFsdWU7XG4gICAgICBpZiAoJ3NlbGVjdGVkRnJhY3Rpb24nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGVkRnJhY3Rpb24gPSB2YWx1ZTsgfVxuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3NlbGVjdGVkLWZyYWN0aW9uLWNoYW5nZWQnKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gRnJhY3Rpb25hbFNlbGVjdGlvbjtcbn1cblxuXG5taXhpbi5oZWxwZXJzID0ge1xuXG4gIC8qXG4gICAqIERhbXBlbiBhIHNlbGVjdGlvbiB0aGF0IGdvZXMgcGFzdCB0aGUgYmVnaW5uaW5nIG9yIGVuZCBvZiBhIGxpc3QuIFRoaXMgaXNcbiAgICogZ2VuZXJhbGx5IHVzZWQgdG8gcHJvZHVjZSBhIHZpc3VhbCBlZmZlY3Qgb2YgdGVuc2lvbiBhcyB0aGUgdXNlciB0cmllcyB0b1xuICAgKiBnbyBmdXJ0aGVyIGluIGEgZGlyZWN0aW9uIHRoYXQgaGFzIG5vIG1vcmUgaXRlbXMuXG4gICAqXG4gICAqIEV4YW1wbGU6IHN1cHBvc2UgYGl0ZW1Db3VudGAgaXMgNSwgaW5kaWNhdGluZyBhIGxpc3Qgb2YgNSBpdGVtcy4gVGhlIGluZGV4IG9mXG4gICAqIHRoZSBsYXN0IGl0ZW0gaXMgNC4gSWYgdGhlIGBzZWxlY3Rpb25gIHBhcmFtZXRlciBpcyA0LjUsIHRoZSB1c2VyIGlzIHRyeWluZ1xuICAgKiB0byBnbyBwYXN0IHRoaXMgbGFzdCBpdGVtLiBXaGVuIGEgZGFtcGluZyBmdW5jdGlvbiBpcyBhcHBsaWVkLCB0aGUgcmVzdWx0aW5nXG4gICAqIHZhbHVlIHdpbGwgYmUgbGVzcyB0aGFuIDQuNSAodGhlIGFjdHVhbCB2YWx1ZSB3aWxsIGJlIDQuMjUpLiBXaGVuIHRoaXNcbiAgICogc2VsZWN0aW9uIHN0YXRlIGlzIHJlbmRlcmVkLCB0aGUgdXNlciB3aWxsIHNlZSB0aGF0LCBlYWNoIHVuaXQgZGlzdGFuY2UgdGhlXG4gICAqIGRyYWcgdHJhdmVscyBoYXMgbGVzcyBhbmQgbGVzcyB2aXNpYmxlIGVmZmVjdC4gVGhpcyBpcyBwZXJjZWl2ZWQgYXMgdGVuc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlbGVjdGlvbiAtIEEgcmVhbCBudW1iZXIgaW5kaWNhdGluZyBhIHNlbGVjdGlvbiBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gaXRlbUNvdW50IC0gQW4gaW50ZWdlciBmb3IgdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBBIHJlYWwgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgZGFtcGVkIHNlbGVjdGlvbiB2YWx1ZS5cbiAgICovXG4gIGRhbXBlZFNlbGVjdGlvbihzZWxlY3Rpb24sIGl0ZW1Db3VudCkge1xuICAgIGNvbnN0IGJvdW5kID0gaXRlbUNvdW50IC0gMTtcbiAgICBsZXQgZGFtcGVkO1xuICAgIGlmIChzZWxlY3Rpb24gPCAwKSB7XG4gICAgICAvLyBUcnlpbmcgdG8gZ28gcGFzdCBiZWdpbm5pbmcgb2YgbGlzdC4gQXBwbHkgdGVuc2lvbiBmcm9tIHRoZSBsZWZ0IGVkZ2UuXG4gICAgICBkYW1wZWQgPSAtbWl4aW4uaGVscGVycy5kYW1waW5nKC1zZWxlY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uID49IGJvdW5kKSB7XG4gICAgICAvLyBUcnlpbmcgdG8gZ28gcGFzdCBlbmQgb2YgbGlzdC4gQXBwbHkgdGVuc2lvbiBmcm9tIHRoZSByaWdodCBlZGdlLlxuICAgICAgZGFtcGVkID0gYm91bmQgKyBtaXhpbi5oZWxwZXJzLmRhbXBpbmcoc2VsZWN0aW9uIC0gYm91bmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBkYW1waW5nIHJlcXVpcmVkLlxuICAgICAgZGFtcGVkID0gc2VsZWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gZGFtcGVkO1xuICB9LFxuXG4gIC8qXG4gICAqIENhbGN1bGF0ZSBkYW1waW5nIGFzIGEgZnVuY3Rpb24gb2YgdGhlIGRpc3RhbmNlIHBhc3QgdGhlIG1pbmltdW0vbWF4aW11bVxuICAgKiB2YWx1ZXMuXG4gICAqXG4gICAqIFdlIHdhbnQgdG8gYXN5bXB0b3RpY2FsbHkgYXBwcm9hY2ggYW4gYWJzb2x1dGUgbWluaW11bSBvZiAxIHVuaXRcbiAgICogYmVsb3cvYWJvdmUgdGhlIGFjdHVhbCBtaW5pbXVtL21heGltdW0uIFRoaXMgcmVxdWlyZXMgY2FsY3VsYXRpbmcgYVxuICAgKiBoeXBlcmJvbGljIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBTZWUgaHR0cDovL3d3dy53b2xmcmFtYWxwaGEuY29tL2lucHV0Lz9pPXkrJTNEKy0xJTJGJTI4eCUyQjElMjkrJTJCKzFcbiAgICogZm9yIHRoZSBvbmUgd2UgdXNlLiBUaGUgb25seSBwb3J0aW9uIG9mIHRoYXQgZnVuY3Rpb24gd2UgY2FyZSBhYm91dCBpcyB3aGVuXG4gICAqIHggaXMgemVybyBvciBncmVhdGVyLiBBbiBpbXBvcnRhbnQgY29uc2lkZXJhdGlvbiBpcyB0aGF0IHRoZSBjdXJ2ZSBiZVxuICAgKiB0YW5nZW50IHRvIHRoZSBkaWFnb25hbCBsaW5lIHg9eSBhdCAoMCwgMCkuIFRoaXMgZW5zdXJlcyBzbW9vdGggY29udGludWl0eVxuICAgKiB3aXRoIHRoZSBub3JtYWwgZHJhZyBiZWhhdmlvciwgaW4gd2hpY2ggdGhlIHZpc2libGUgc2xpZGluZyBpcyBsaW5lYXIgd2l0aFxuICAgKiB0aGUgZGlzdGFuY2UgdGhlIHRvdWNocG9pbnQgaGFzIGJlZW4gZHJhZ2dlZC5cbiAgICovXG4gIGRhbXBpbmcoeCkge1xuICAgIGNvbnN0IHkgPSAoLTEgLyAoeCArIDEpKSArIDE7XG4gICAgcmV0dXJuIHk7XG4gIH0sXG5cbiAgLypcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IGZyYWN0aW9uYWwgc2VsZWN0aW9uIHZhbHVlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICpcbiAgICogVGhpcyBzaW1wbHkgYWRkcyB0aGUgZWxlbWVudCdzIGBzZWxlY3RlZEluZGV4YCBhbmQgYHNlbGVjdGVkRnJhY3Rpb25gXG4gICAqIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBBbiBlbGVtZW50IHRoYXQgc3VwcG9ydHMgc2VsZWN0aW9uXG4gICAqL1xuICBlbGVtZW50U2VsZWN0aW9uKGVsZW1lbnQpIHtcbiAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gZWxlbWVudC5zZWxlY3RlZEluZGV4O1xuICAgIGlmIChzZWxlY3RlZEluZGV4IDwgMCkge1xuICAgICAgLy8gTm8gc2VsZWN0aW9uXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGVkRnJhY3Rpb24gPSBlbGVtZW50LnNlbGVjdGVkRnJhY3Rpb24gfHwgMDtcbiAgICByZXR1cm4gc2VsZWN0ZWRJbmRleCArIHNlbGVjdGVkRnJhY3Rpb247XG4gIH0sXG5cbiAgLypcbiAgICogQnJlYWtzIGEgZnJhY3Rpb25hbCBzZWxlY3Rpb24gaW50byBpdHMgaW50ZWdlciBhbmQgZnJhY3Rpb25hbCBwYXJ0cy5cbiAgICpcbiAgICogRXhhbXBsZTogaWYgcGFzc2VkIDMuNSwgdGhpcyByZXR1cm5zIHsgaW5kZXg6IDMsIGZyYWN0aW9uOiA1IH0uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWxlY3Rpb24g4oCTwqBBIHJlYWwgbnVtYmVyIHJlcHJlc2VudGluZyBhIHNlbGVjdGlvbiBwb2ludFxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtIEFuIG9iamVjdCB3aXRoIGFuIGBpbmRleGAgcHJvcGVydHkgaG9sZGluZyB0aGVcbiAgICogc2VsZWN0aW9uJ3MgaW50ZWdlciBjb21wb25lbnQsIGFuZCBhIGBmcmFjdGlvbmAgcHJvcGVydHkgaG9sZGluZyB0aGVcbiAgICogc2VsZWN0aW9uJ3MgZnJhY3Rpb25hbCBjb21wb25lbnQuXG4gICAqL1xuICBzZWxlY3Rpb25QYXJ0cyhzZWxlY3Rpb24pIHtcbiAgICAvLyBTdHVwaWQgSUUgZG9lc24ndCBoYXZlIE1hdGgudHJ1bmMuXG4gICAgLy8gY29uc3QgaW5kZXggPSBNYXRoLnRydW5jKHNlbGVjdGlvbik7XG4gICAgY29uc3QgaW5kZXggPSBzZWxlY3Rpb24gPCAwID8gTWF0aC5jZWlsKHNlbGVjdGlvbikgOiBNYXRoLmZsb29yKHNlbGVjdGlvbik7XG4gICAgY29uc3QgZnJhY3Rpb24gPSBzZWxlY3Rpb24gLSBpbmRleDtcbiAgICByZXR1cm4geyBpbmRleCwgZnJhY3Rpb24gfTtcbiAgfSxcblxuICAvKlxuICAgKiBSZXR1cm5zIGEgZnJhY3Rpb25hbCBzZWxlY3Rpb24gcG9pbnQgYWZ0ZXIgYWNjb3VudGluZyBmb3Igd3JhcHBpbmcsIGVuc3VyaW5nXG4gICAqIHRoYXQgdGhlIGludGVnZXIgcG9ydGlvbiBvZiB0aGUgc2VsZWN0aW9uIHN0YXlzIGJldHdlZW4gMCBhbmQgYGl0ZW1Db3VudGAtMS5cbiAgICogVGhhdCBpcywgdGhlIGludGVnZXIgcG9ydGlvbiB3aWxsIGFsd2F5cyBiZSBhIHZhbGlkIGluZGV4IGludG8gdGhlIGxpc3QuXG4gICAqXG4gICAqIEV4YW1wbGUgb2Ygd3JhcHBpbmcgcGFzdCB0aGUgZW5kIG9mIHRoZSBsaXN0OiBpZiBgc2VsZWN0aW9uYCBpcyA1LjUgYW5kXG4gICAqIGBpdGVtQ291bnRgIGlzIDUsIHRoaXMgcmV0dXJucyAwLjUuIEV4YW1wbGUgb2Ygd3JhcHBpbmcgcGFzdCB0aGUgYmVnaW5uaW5nIG9mXG4gICAqIHRoZSBsaXN0OiBpZiBgc2VsZWN0aW9uYCBpcyAwLjUgYW5kIGBpdGVtQ291bnRgIGlzIDUsIHRoaXMgcmV0dXJucyA0LjUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWxlY3Rpb24gLSBBIHJlYWwgbnVtYmVyIHJlcHJlc2VudGluZyBhIHNlbGVjdGlvbiBwb2ludFxuICAgKiBAcGFyYW0ge251bWJlcn0gaXRlbUNvdW50IC0gVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSByZXN1bHQgb2Ygd3JhcHBpbmcgdGhlIHNlbGVjdGlvbiBwb2ludFxuICAgKi9cbiAgd3JhcHBlZFNlbGVjdGlvbihzZWxlY3Rpb24sIGl0ZW1Db3VudCkge1xuICAgIC8vIEhhbmRsZXMgcG9zc2liaWxpdHkgb2YgbmVnYXRpdmUgbW9kLlxuICAgIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xODYxODI1MC83NjQ3MlxuICAgIHJldHVybiAoKHNlbGVjdGlvbiAlIGl0ZW1Db3VudCkgKyBpdGVtQ291bnQpICUgaXRlbUNvdW50O1xuICB9LFxuXG4gIC8qXG4gICAqIFJldHVybiB0aGUgcGFydHMgb2YgYSBzZWxlY3Rpb24sIGZpcnN0IHdyYXBwaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlbGVjdGlvbiDigJMgQSByZWFsIG51bWJlciByZXByZXNlbnRpbmcgYSBzZWxlY3Rpb24gcG9pbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGl0ZW1Db3VudCAtIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAgICogQHBhcmFtIHtib29sZWFufSB3cmFwIOKAkyBUcnVlIGlmIHRoZSBzZWxlY3Rpb24gc2hvdWxkIHdyYXAgdG8gc3RheSB3aXRoaW4gdGhlXG4gICAqIGxpc3RcbiAgICogQHJldHVybnMge29iamVjdH0g4oCTIFRoZSBwYXJ0cyBvZiB0aGUgc2VsZWN0aW9uLCB1c2luZyB0aGUgc2FtZSBmb3JtYXQgYXNcbiAgICogYHNlbGVjdGlvblBhcnRzYC5cbiAgICovXG4gIHdyYXBwZWRTZWxlY3Rpb25QYXJ0cyhzZWxlY3Rpb24sIGl0ZW1Db3VudCwgd3JhcCkge1xuICAgIGlmICh3cmFwKSB7XG4gICAgICBzZWxlY3Rpb24gPSBtaXhpbi5oZWxwZXJzLndyYXBwZWRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpdGVtQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gbWl4aW4uaGVscGVycy5zZWxlY3Rpb25QYXJ0cyhzZWxlY3Rpb24pO1xuICB9XG5cbn07XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCBzYWZlQXR0cmlidXRlcyBmcm9tICcuL3NhZmVBdHRyaWJ1dGVzJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IGdlbmVyaWNTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2dlbmVyaWMnKTtcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIEdlbmVyaWMuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBhbGxvd3MgYSBjb21wb25lbnQgdG8gc3VwcG9ydCBhIFwiZ2VuZXJpY1wiIHN0eWxlOiBhIG1pbmltYWxpc3RcbiAgICogc3R5bGUgdGhhdCBjYW4gZWFzaWx5IGJlIHJlbW92ZWQgdG8gcmVzZXQgaXRzIHZpc3VhbCBhcHBlYXJhbmNlIHRvIGFcbiAgICogYmFzZWxpbmUgc3RhdGUuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGEgY29tcG9uZW50IHNob3VsZCBwcm92aWRlIGEgbWluaW1hbCB2aXN1YWwgcHJlc2VudGF0aW9uIHRoYXRcbiAgICogYWxsb3dzIHRoZSBjb21wb25lbnQgdG8gZnVuY3Rpb24uIEhvd2V2ZXIsIHRoZSBtb3JlIHN0eWxpbmcgdGhlIGNvbXBvbmVudFxuICAgKiBwcm92aWRlcyBieSBkZWZhdWx0LCB0aGUgaGFyZGVyIGl0IGJlY29tZXMgdG8gZ2V0IHRoZSBjb21wb25lbnQgdG8gZml0IGluXG4gICAqIGluIG90aGVyIHNldHRpbmdzLiBFYWNoIENTUyBydWxlIGhhcyB0byBiZSBvdmVycmlkZGVuLiBXb3JzZSwgbmV3IENTUyBydWxlc1xuICAgKiBhZGRlZCB0byB0aGUgZGVmYXVsdCBzdHlsZSB3b24ndCBiZSBvdmVycmlkZGVuIGJ5IGRlZmF1bHQsIG1ha2luZyBpdCBoYXJkXG4gICAqIHRvIGtub3cgd2hldGhlciBhIG5ldyB2ZXJzaW9uIG9mIGEgY29tcG9uZW50IHdpbGwgc3RpbGwgbG9vayBva2F5LlxuICAgKlxuICAgKiBBcyBhIGNvbXByb21pc2UsIHRoZSBtaXhpbiBkZWZpbmVzIGEgYGdlbmVyaWNgIGF0dHJpYnV0ZS4gVGhpcyBhdHRyaWJ1dGUgaXNcbiAgICogbm9ybWFsbHkgc2V0IGJ5IGRlZmF1bHQsIGFuZCBzdHlsZXMgY2FuIGJlIHdyaXR0ZW4gdGhhdCBhcHBseSBvbmx5IHdoZW4gdGhlXG4gICAqIGdlbmVyaWMgYXR0cmlidXRlIGlzIHNldC4gVGhpcyBhbGxvd3MgdGhlIGNvbnN0cnVjdGlvbiBvZiBDU1MgcnVsZXMgdGhhdFxuICAgKiB3aWxsIG9ubHkgYXBwbHkgdG8gZ2VuZXJpYyBjb21wb25lbnRzIGxpa2U6XG4gICAqXG4gICAqICAgICA6aG9zdChbZ2VuZXJpYz1cIlwiXSkge1xuICAgKiAgICAgICAuLi4gZ2VuZXJpYyBhcHBlYXJhbmNlIGRlZmluZWQgaGVyZSAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogVGhpcyBtYWtlcyBpdCBlYXN5IHRvIHJlbW92ZSBhbGwgZGVmYXVsdCBzdHlsaW5nIOKAlCBzZXQgdGhlIGBHZW5lcmljTWl4aW5gXG4gICAqIGF0dHJpYnV0ZSB0byBmYWxzZSwgYW5kIGFsbCBkZWZhdWx0IHN0eWxpbmcgd2lsbCBiZSByZW1vdmVkLlxuICAgKi9cbiAgY2xhc3MgR2VuZXJpYyBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgLy8gU2V0IGRlZmF1bHRzLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmdlbmVyaWMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJpYyA9IHRoaXNbc3ltYm9scy5kZWZhdWx0c10uZ2VuZXJpYztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIG1peGluIGRvZXNuJ3QgYWN0dWFsbHkgcmVzcG9uZCB0byBhdHRyaWJ1dGUgY2hhbmdlcywgYnV0IHJlbGllc1xuICAgIC8vIG9uIHNlcGFyYXRlbHktZGVmaW5lZCBiZWhhdmlvciAoZS5nLiwgaW4gQXR0cmlidXRlTWFyc2hhbGxpbmdNaXhpbikgZm9yIHRoYXQuXG4gICAgLy8gU3RpbGwsIHdlIG5lZWQgZGVmaW5lIGEgYmFzZWxpbmUgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIHRoYXQgZG9lc1xuICAgIC8vIG5vdGhpbmcsIGluIGNhc2UgdGhpcyBtaXhpbiBnZXRzIHVzZWQgb24gaXRzIG93bi5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICBpZiAoc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKSB7IHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpOyB9XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBpZiAoc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2spIHsgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTsgfVxuICAgICAgc2FmZUF0dHJpYnV0ZXMuY29ubmVjdGVkKHRoaXMpO1xuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMuZ2VuZXJpYyA9IHRydWU7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHdvdWxkIGxpa2UgdG8gcmVjZWl2ZSBnZW5lcmljIHN0eWxpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIHRydWUgYnkgZGVmYXVsdCDigJTCoHNldCBpdCB0byBmYWxzZSB0byB0dXJuIG9mZiBhbGxcbiAgICAgKiBnZW5lcmljIHN0eWxlcy4gVGhpcyBtYWtlcyBpdCBlYXNpZXIgdG8gYXBwbHkgY3VzdG9tIHN0eWxpbmc7IHlvdSB3b24ndFxuICAgICAqIGhhdmUgdG8gZXhwbGljaXRseSBvdmVycmlkZSBzdHlsaW5nIHlvdSBkb24ndCB3YW50LlxuICAgICAqXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBnZXQgZ2VuZXJpYygpIHtcbiAgICAgIHJldHVybiB0aGlzW2dlbmVyaWNTeW1ib2xdO1xuICAgIH1cbiAgICBzZXQgZ2VuZXJpYyh2YWx1ZSkge1xuICAgICAgY29uc3QgcGFyc2VkID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/XG4gICAgICAgIFN0cmluZyh2YWx1ZSkgIT09ICdmYWxzZScgOlxuICAgICAgICB2YWx1ZTtcbiAgICAgIHRoaXNbZ2VuZXJpY1N5bWJvbF0gPSBwYXJzZWQ7XG5cbiAgICAgIGlmICgnZ2VuZXJpYycgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuZ2VuZXJpYyA9IHZhbHVlOyB9XG5cbiAgICAgIC8vIFdlIHJvbGwgb3VyIG93biBhdHRyaWJ1dGUgc2V0dGluZyBzbyB0aGF0IGFuIGV4cGxpY2l0bHkgZmFsc2UgdmFsdWVcbiAgICAgIC8vIHNob3dzIHVwIGFzIEdlbmVyaWNNaXhpbj1cImZhbHNlXCIuXG4gICAgICBpZiAocGFyc2VkID09PSBmYWxzZSkge1xuICAgICAgICAvLyBFeHBsaWNpdGx5IHVzZSBmYWxzZSBzdHJpbmcuXG4gICAgICAgIHNhZmVBdHRyaWJ1dGVzLnNldEF0dHJpYnV0ZSh0aGlzLCAnZ2VuZXJpYycsICdmYWxzZScpO1xuICAgICAgfSBlbHNlIGlmIChwYXJzZWQgPT0gbnVsbCkge1xuICAgICAgICAvLyBFeHBsaWNpdGx5IHJlbW92ZSBhdHRyaWJ1dGUuIChBbHdheXMgc2FmZSB0byBkbyB0aGlzLilcbiAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2dlbmVyaWMnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzZSB0aGUgZW1wdHkgc3RyaW5nIHRvIGdldCBhdHRyaWJ1dGUgdG8gYXBwZWFyIHdpdGggbm8gdmFsdWUuXG4gICAgICAgIHNhZmVBdHRyaWJ1dGVzLnNldEF0dHJpYnV0ZSh0aGlzLCAnZ2VuZXJpYycsICcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBHZW5lcmljO1xufTtcblxuXG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IG5hdmlnYXRpb25BeGlzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCduYXZpZ2F0aW9uQXhpcycpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggS2V5Ym9hcmREaXJlY3Rpb24uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYXBzIGRpcmVjdGlvbiBrZXlzIChMZWZ0LCBSaWdodCwgZXRjLikgdG8gZGlyZWN0aW9uIHNlbWFudGljc1xuICAgKiAoZ28gbGVmdCwgZ28gcmlnaHQsIGV0Yy4pLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGV4cGVjdHMgdGhlIGNvbXBvbmVudCB0byBpbnZva2UgYSBga2V5ZG93bmAgbWV0aG9kIHdoZW4gYSBrZXkgaXNcbiAgICogcHJlc3NlZC4gWW91IGNhbiB1c2UgW0tleWJvYXJkTWl4aW5dKEtleWJvYXJkTWl4aW4ubWQpIGZvciB0aGF0XG4gICAqIHB1cnBvc2UsIG9yIHdpcmUgdXAgeW91ciBvd24ga2V5Ym9hcmQgaGFuZGxpbmcgYW5kIGNhbGwgYGtleWRvd25gIHlvdXJzZWxmLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGNhbGxzIG1ldGhvZHMgc3VjaCBhcyBgZ29MZWZ0YCBhbmQgYGdvUmlnaHRgLiBZb3UgY2FuIGRlZmluZVxuICAgKiB3aGF0IHRoYXQgbWVhbnMgYnkgaW1wbGVtZW50aW5nIHRob3NlIG1ldGhvZHMgeW91cnNlbGYuIElmIHlvdSB3YW50IHRvIHVzZVxuICAgKiBkaXJlY3Rpb24ga2V5cyB0byBuYXZpZ2F0ZSBhIHNlbGVjdGlvbiwgdXNlIHRoaXMgbWl4aW4gd2l0aFxuICAgKiBbRGlyZWN0aW9uU2VsZWN0aW9uTWl4aW5dKERpcmVjdGlvblNlbGVjdGlvbk1peGluLm1kKS5cbiAgICovXG4gIGNsYXNzIEtleWJvYXJkRGlyZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICAvLyBTZXQgZGVmYXVsdHMuXG4gICAgICBpZiAodHlwZW9mIHRoaXMubmF2aWdhdGlvbkF4aXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkF4aXMgPSB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLm5hdmlnYXRpb25BeGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMubmF2aWdhdGlvbkF4aXMgPSAnYm90aCc7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIGRvd24uXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgICAqL1xuICAgIFtzeW1ib2xzLmdvRG93bl0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0Rvd25dKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvRG93bl0oKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSB0byB0aGUgZW5kIChlLmcuLCBvZiBhIGxpc3QpLlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBbc3ltYm9scy5nb0VuZF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0VuZF0pIHsgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZ29FbmRdKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgbGVmdC5cbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICovXG4gICAgW3N5bWJvbHMuZ29MZWZ0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvTGVmdF0pIHsgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZ29MZWZ0XSgpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIHJpZ2h0LlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBbc3ltYm9scy5nb1JpZ2h0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvUmlnaHRdKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvUmlnaHRdKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgdG8gdGhlIHN0YXJ0IChlLmcuLCBvZiBhXG4gICAgICogbGlzdCkuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBbc3ltYm9scy5nb1N0YXJ0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvU3RhcnRdKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvU3RhcnRdKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgdXAuXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgICAqL1xuICAgIFtzeW1ib2xzLmdvVXBdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuZ29VcF0pIHsgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZ29VcF0oKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgZGlyZWN0aW9uIG9mIHBlcm1pdHRlZCBuYXZpZ2F0aW9uIHdpdGggdGhlIGtleWJvYXJkLlxuICAgICAqXG4gICAgICogQWNjZXB0ZWQgdmFsdWVzIGFyZSBcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiLCBvciBcImJvdGhcIiAodGhlIGRlZmF1bHQpLlxuICAgICAqIElmIHRoaXMgcHJvcGVydHkgaXMgXCJob3Jpem9udGFsXCIsIHRoZSBVcCBBcnJvdyBhbmQgRG93biBBcnJvdyBrZXlzIHdpbGxcbiAgICAgKiBiZSBpZ25vcmVkLiBDb252ZXJzZWx5LCBpZiB0aGlzIGlzIFwidmVydGljYWxcIiwgdGhlIExlZnQgQXJyb3cgYW5kIFJpZ2h0XG4gICAgICogQXJyb3cga2V5cyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBuYXZpZ2F0aW9uQXhpcygpIHtcbiAgICAgIHJldHVybiB0aGlzW25hdmlnYXRpb25BeGlzU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IG5hdmlnYXRpb25BeGlzKHZhbHVlKSB7XG4gICAgICB0aGlzW25hdmlnYXRpb25BeGlzU3ltYm9sXSA9IHZhbHVlO1xuICAgICAgaWYgKCduYXZpZ2F0aW9uQXhpcycgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIubmF2aWdhdGlvbkF4aXMgPSB2YWx1ZTsgfVxuICAgIH1cblxuICAgIFtzeW1ib2xzLmtleWRvd25dKGV2ZW50KSB7XG4gICAgICBsZXQgaGFuZGxlZDtcblxuICAgICAgY29uc3QgYXhpcyA9IHRoaXMubmF2aWdhdGlvbkF4aXM7XG4gICAgICBjb25zdCBob3Jpem9udGFsID0gKGF4aXMgPT09ICdob3Jpem9udGFsJyB8fCBheGlzID09PSAnYm90aCcpO1xuICAgICAgY29uc3QgdmVydGljYWwgPSAoYXhpcyA9PT0gJ3ZlcnRpY2FsJyB8fCBheGlzID09PSAnYm90aCcpO1xuXG4gICAgICAvLyBJZ25vcmUgTGVmdC9SaWdodCBrZXlzIHdoZW4gbWV0YUtleSBvciBhbHRLZXkgbW9kaWZpZXIgaXMgYWxzbyBwcmVzc2VkLFxuICAgICAgLy8gYXMgdGhlIHVzZXIgbWF5IGJlIHRyeWluZyB0byBuYXZpZ2F0ZSBiYWNrIG9yIGZvcndhcmQgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAzNTogLy8gRW5kXG4gICAgICAgICAgaGFuZGxlZCA9IHRoaXNbc3ltYm9scy5nb0VuZF0oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNjogLy8gSG9tZVxuICAgICAgICAgIGhhbmRsZWQgPSB0aGlzW3N5bWJvbHMuZ29TdGFydF0oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNzogLy8gTGVmdFxuICAgICAgICAgIGlmIChob3Jpem9udGFsICYmICFldmVudC5tZXRhS2V5ICYmICFldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0aGlzW3N5bWJvbHMuZ29MZWZ0XSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzODogLy8gVXBcbiAgICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSBldmVudC5hbHRLZXkgPyB0aGlzW3N5bWJvbHMuZ29TdGFydF0oKSA6IHRoaXNbc3ltYm9scy5nb1VwXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOTogLy8gUmlnaHRcbiAgICAgICAgICBpZiAoaG9yaXpvbnRhbCAmJiAhZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdGhpc1tzeW1ib2xzLmdvUmlnaHRdKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOiAvLyBEb3duXG4gICAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gZXZlbnQuYWx0S2V5ID8gdGhpc1tzeW1ib2xzLmdvRW5kXSgpIDogdGhpc1tzeW1ib2xzLmdvRG93bl0oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBQcmVmZXIgbWl4aW4gcmVzdWx0IGlmIGl0J3MgZGVmaW5lZCwgb3RoZXJ3aXNlIHVzZSBiYXNlIHJlc3VsdC5cbiAgICAgIHJldHVybiBoYW5kbGVkIHx8IChzdXBlcltzeW1ib2xzLmtleWRvd25dICYmIHN1cGVyW3N5bWJvbHMua2V5ZG93bl0oZXZlbnQpKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBLZXlib2FyZERpcmVjdGlvbjtcbn07XG4iLCJpbXBvcnQgc3ltYm9scyBmcm9tICcuL3N5bWJvbHMnO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggS2V5Ym9hcmQuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYW5hZ2VzIHRoZSBrZXlkb3duIGhhbmRsaW5nIGZvciBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBoYW5kbGVzIHNldmVyYWwga2V5Ym9hcmQtcmVsYXRlZCBmZWF0dXJlcy5cbiAgICpcbiAgICogRmlyc3QsIGl0IHdpcmVzIHVwIGEgc2luZ2xlIGtleWRvd24gZXZlbnQgaGFuZGxlciB0aGF0IGNhbiBiZSBzaGFyZWQgYnlcbiAgICogbXVsdGlwbGUgbWl4aW5zIG9uIGEgY29tcG9uZW50LiBUaGUgZXZlbnQgaGFuZGxlciB3aWxsIGludm9rZSBhIGBrZXlkb3duYFxuICAgKiBtZXRob2Qgd2l0aCB0aGUgZXZlbnQgb2JqZWN0LCBhbmQgYW55IG1peGluIGFsb25nIHRoZSBwcm90b3R5cGUgY2hhaW4gdGhhdFxuICAgKiB3YW50cyB0byBoYW5kbGUgdGhhdCBtZXRob2QgY2FuIGRvIHNvLlxuICAgKlxuICAgKiBJZiBhIG1peGluIHdhbnRzIHRvIGluZGljYXRlIHRoYXQga2V5Ym9hcmQgZXZlbnQgaGFzIGJlZW4gaGFuZGxlZCwgYW5kIHRoYXRcbiAgICogb3RoZXIgbWl4aW5zIHNob3VsZCAqbm90KiBoYW5kbGUgaXQsIHRoZSBtaXhpbidzIGBrZXlkb3duYCBoYW5kbGVyIHNob3VsZFxuICAgKiByZXR1cm4gYSB2YWx1ZSBvZiB0cnVlLiBUaGUgY29udmVudGlvbiB0aGF0IHNlZW1zIHRvIHdvcmsgd2VsbCBpcyB0aGF0IGFcbiAgICogbWl4aW4gc2hvdWxkIHNlZSBpZiBpdCB3YW50cyB0byBoYW5kbGUgdGhlIGV2ZW50IGFuZCwgaWYgbm90LCB0aGVuIGFzayB0aGVcbiAgICogc3VwZXJjbGFzcyB0byBzZWUgaWYgaXQgd2FudHMgdG8gaGFuZGxlIHRoZSBldmVudC4gVGhpcyBoYXMgdGhlIGVmZmVjdCBvZlxuICAgKiBnaXZpbmcgdGhlIG1peGluIHRoYXQgd2FzIGFwcGxpZWQgbGFzdCB0aGUgZmlyc3QgY2hhbmNlIGF0IGhhbmRsaW5nIGFcbiAgICoga2V5Ym9hcmQgZXZlbnQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBbc3ltYm9scy5rZXlkb3duXShldmVudCkge1xuICAgKiAgICAgICBsZXQgaGFuZGxlZDtcbiAgICogICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAqICAgICAgICAgLy8gSGFuZGxlIHRoZSBrZXlzIHlvdSB3YW50LCBzZXR0aW5nIGhhbmRsZWQgPSB0cnVlIGlmIGFwcHJvcHJpYXRlLlxuICAgKiAgICAgICB9XG4gICAqICAgICAgIC8vIFByZWZlciBtaXhpbiByZXN1bHQgaWYgaXQncyBkZWZpbmVkLCBvdGhlcndpc2UgdXNlIGJhc2UgcmVzdWx0LlxuICAgKiAgICAgICByZXR1cm4gaGFuZGxlZCB8fCAoc3VwZXJbc3ltYm9scy5rZXlkb3duXSAmJiBzdXBlcltzeW1ib2xzLmtleWRvd25dKGV2ZW50KSk7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEEgc2Vjb25kIGZlYXR1cmUgcHJvdmlkZWQgYnkgdGhpcyBtaXhpbiBpcyB0aGF0IGl0IGltcGxpY2l0bHkgbWFrZXMgdGhlXG4gICAqIGNvbXBvbmVudCBhIHRhYiBzdG9wIGlmIGl0IGlzbid0IGFscmVhZHksIGJ5IHNldHRpbmcgYHRhYkluZGV4YCB0byAwLiBUaGlzXG4gICAqIGhhcyB0aGUgZWZmZWN0IG9mIGFkZGluZyB0aGUgY29tcG9uZW50IHRvIHRoZSB0YWIgb3JkZXIgaW4gZG9jdW1lbnQgb3JkZXIuXG4gICAqL1xuICBjbGFzcyBLZXlib2FyZCBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVkID0gdGhpc1tzeW1ib2xzLmtleWRvd25dKGV2ZW50KTtcbiAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgPT0gbnVsbCAmJiB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnRhYmluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRoaXNbc3ltYm9scy5kZWZhdWx0c10udGFiaW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgLy8gVGhlIGRlZmF1bHQgdGFiIGluZGV4IGlzIDAgKGRvY3VtZW50IG9yZGVyKS5cbiAgICAgIGRlZmF1bHRzLnRhYmluZGV4ID0gMDtcbiAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGluZGljYXRlZCBrZXlib2FyZCBldmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy4gVGhpcyB3aWxsXG4gICAgICogdHlwaWNhbGx5IGJlIGhhbmRsZWQgYnkgb3RoZXIgbWl4aW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIHRoZSBrZXlib2FyZCBldmVudFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGV2ZW50IHdhcyBoYW5kbGVkXG4gICAgICovXG4gICAgW3N5bWJvbHMua2V5ZG93bl0oZXZlbnQpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmtleWRvd25dKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmtleWRvd25dKGV2ZW50KTsgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEtleWJvYXJkO1xufTtcbiIsImltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBLZXlib2FyZFBhZ2VkU2VsZWN0aW9uLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gd2hpY2ggbWFwcyBwYWdlIGtleXMgKFBhZ2UgVXAsIFBhZ2UgRG93bikgaW50byBvcGVyYXRpb25zIHRoYXQgbW92ZVxuICAgKiB0aGUgc2VsZWN0aW9uIGJ5IG9uZSBwYWdlLlxuICAgKlxuICAgKiBUaGUga2V5Ym9hcmQgaW50ZXJhY3Rpb24gbW9kZWwgZ2VuZXJhbGx5IGZvbGxvd3MgdGhhdCBvZiBNaWNyb3NvZnQgV2luZG93cydcbiAgICogbGlzdCBib3hlcyBpbnN0ZWFkIG9mIHRob3NlIGluIE9TIFg6XG4gICAqXG4gICAqICogVGhlIFBhZ2UgVXAvRG93biBhbmQgSG9tZS9FbmQga2V5cyBhY3R1YWxseSBjaGFuZ2UgdGhlIHNlbGVjdGlvbiwgcmF0aGVyXG4gICAqICAgdGhhbiBqdXN0IHNjcm9sbGluZy4gVGhlIGZvcm1lciBiZWhhdmlvciBzZWVtcyBtb3JlIGdlbmVyYWxseSB1c2VmdWwgZm9yXG4gICAqICAga2V5Ym9hcmQgdXNlcnMuXG4gICAqXG4gICAqICogUHJlc3NpbmcgUGFnZSBVcC9Eb3duIHdpbGwgY2hhbmdlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHRvcG1vc3QvYm90dG9tbW9zdFxuICAgKiAgIHZpc2libGUgaXRlbSBpZiB0aGUgc2VsZWN0aW9uIGlzIG5vdCBhbHJlYWR5IHRoZXJlLiBUaGVyZWFmdGVyLCB0aGUga2V5XG4gICAqICAgd2lsbCBtb3ZlIHRoZSBzZWxlY3Rpb24gdXAvZG93biBieSBhIHBhZ2UsIGFuZCAocGVyIHRoZSBhYm92ZSBwb2ludCkgbWFrZVxuICAgKiAgIHRoZSBzZWxlY3RlZCBpdGVtIHZpc2libGUuXG4gICAqXG4gICAqIFRvIGVuc3VyZSB0aGUgc2VsZWN0ZWQgaXRlbSBpcyBpbiB2aWV3IGZvbGxvd2luZyB1c2Ugb2YgUGFnZSBVcC9Eb3duLCB1c2VcbiAgICogdGhlIHJlbGF0ZWQgW1NlbGVjdGlvbkluVmlld01peGluXShTZWxlY3Rpb25JblZpZXdNaXhpbi5tZCkuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyB0aGUgY29tcG9uZW50IHRvIGludm9rZSBhIGBrZXlkb3duYCBtZXRob2Qgd2hlbiBhIGtleSBpc1xuICAgKiBwcmVzc2VkLiBZb3UgY2FuIHVzZSBbS2V5Ym9hcmRNaXhpbl0oS2V5Ym9hcmRNaXhpbi5tZCkgZm9yIHRoYXRcbiAgICogcHVycG9zZSwgb3Igd2lyZSB1cCB5b3VyIG93biBrZXlib2FyZCBoYW5kbGluZyBhbmQgY2FsbCBga2V5ZG93bmAgeW91cnNlbGYuXG4gICAqL1xuICBjbGFzcyBLZXlib2FyZFBhZ2VkU2VsZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBbc3ltYm9scy5rZXlkb3duXShldmVudCkge1xuICAgICAgbGV0IGhhbmRsZWQ7XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAzMzogLy8gUGFnZSBVcFxuICAgICAgICAgIGhhbmRsZWQgPSB0aGlzLnBhZ2VVcCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM0OiAvLyBQYWdlIERvd25cbiAgICAgICAgICBoYW5kbGVkID0gdGhpcy5wYWdlRG93bigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gUHJlZmVyIG1peGluIHJlc3VsdCBpZiBpdCdzIGRlZmluZWQsIG90aGVyd2lzZSB1c2UgYmFzZSByZXN1bHQuXG4gICAgICByZXR1cm4gaGFuZGxlZCB8fCAoc3VwZXJbc3ltYm9scy5rZXlkb3duXSAmJiBzdXBlcltzeW1ib2xzLmtleWRvd25dKGV2ZW50KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xsIGRvd24gb25lIHBhZ2UuXG4gICAgICovXG4gICAgcGFnZURvd24oKSB7XG4gICAgICBpZiAoc3VwZXIucGFnZURvd24pIHsgc3VwZXIucGFnZURvd24oKTsgfVxuICAgICAgcmV0dXJuIHNjcm9sbE9uZVBhZ2UodGhpcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHVwIG9uZSBwYWdlLlxuICAgICAqL1xuICAgIHBhZ2VVcCgpIHtcbiAgICAgIGlmIChzdXBlci5wYWdlVXApIHsgc3VwZXIucGFnZVVwKCk7IH1cbiAgICAgIHJldHVybiBzY3JvbGxPbmVQYWdlKHRoaXMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBzY3JvbGxlZCB3aXRoIHRoZSBQYWdlIFVwL0Rvd24ga2V5cy5cbiAgICAgKiBEZWZhdWx0IGlzIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0IHNjcm9sbFRhcmdldCgpIHtcbiAgICAgIC8vIFByZWZlciBiYXNlIHJlc3VsdC5cbiAgICAgIHJldHVybiAnc2Nyb2xsVGFyZ2V0JyBpbiBiYXNlLnByb3RvdHlwZSA/IHN1cGVyLnNjcm9sbFRhcmdldCA6IHRoaXM7XG4gICAgfVxuICAgIHNldCBzY3JvbGxUYXJnZXQoZWxlbWVudCkge1xuICAgICAgaWYgKCdzY3JvbGxUYXJnZXQnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNjcm9sbFRhcmdldCA9IGVsZW1lbnQ7IH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gS2V5Ym9hcmRQYWdlZFNlbGVjdGlvbjtcbn07XG5cblxuLy8gUmV0dXJuIHRoZSBpdGVtIHdob3NlIGNvbnRlbnQgc3BhbnMgdGhlIGdpdmVuIHkgcG9zaXRpb24gKHJlbGF0aXZlIHRvIHRoZVxuLy8gdG9wIG9mIHRoZSBsaXN0J3Mgc2Nyb2xsaW5nIGNsaWVudCBhcmVhKSwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4vL1xuLy8gSWYgZG93bndhcmQgaXMgdHJ1ZSwgbW92ZSBkb3duIHRoZSBsaXN0IG9mIGl0ZW1zIHRvIGZpbmQgdGhlIGZpcnN0IGl0ZW1cbi8vIGZvdW5kIGF0IHRoZSBnaXZlbiB5IHBvc2l0aW9uOyBpZiBkb3dud2FyZCBpcyBmYWxzZSwgbW92ZSB1cCB0aGUgbGlzdCBvZlxuLy8gaXRlbXMgdG8gZmluZCB0aGUgbGFzdCBpdGVtIGF0IHRoYXQgcG9zaXRpb24uXG5mdW5jdGlvbiBnZXRJbmRleE9mSXRlbUF0WShlbGVtZW50LCB5LCBkb3dud2FyZCkge1xuICBjb25zdCBpdGVtcyA9IGVsZW1lbnQuaXRlbXM7XG4gIGNvbnN0IHN0YXJ0ID0gZG93bndhcmQgPyAwIDogaXRlbXMubGVuZ3RoIC0gMTtcbiAgY29uc3QgZW5kID0gZG93bndhcmQgPyBpdGVtcy5sZW5ndGggOiAwO1xuICBjb25zdCBzdGVwID0gZG93bndhcmQgPyAxIDogLTE7XG4gIGNvbnN0IHNjcm9sbFRhcmdldCA9IGVsZW1lbnQuc2Nyb2xsVGFyZ2V0O1xuICBjb25zdCB0b3BPZkNsaWVudEFyZWEgPSBzY3JvbGxUYXJnZXQub2Zmc2V0VG9wICsgc2Nyb2xsVGFyZ2V0LmNsaWVudFRvcDtcblxuICAvLyBGaW5kIHRoZSBpdGVtIHNwYW5uaW5nIHRoZSBpbmRpY2F0ZWQgeSBjb29yZGluYXRlLlxuICBsZXQgaXRlbTtcbiAgbGV0IGl0ZW1JbmRleCA9IHN0YXJ0O1xuICBsZXQgaXRlbVRvcDtcbiAgbGV0IGZvdW5kID0gZmFsc2U7XG4gIHdoaWxlIChpdGVtSW5kZXggIT09IGVuZCkge1xuICAgIGl0ZW0gPSBpdGVtc1tpdGVtSW5kZXhdO1xuICAgIGl0ZW1Ub3AgPSBpdGVtLm9mZnNldFRvcCAtIHRvcE9mQ2xpZW50QXJlYTtcbiAgICBjb25zdCBpdGVtQm90dG9tID0gaXRlbVRvcCArIGl0ZW0ub2Zmc2V0SGVpZ2h0O1xuICAgIGlmIChpdGVtVG9wIDw9IHkgJiYgaXRlbUJvdHRvbSA+PSB5KSB7XG4gICAgICAvLyBJdGVtIHNwYW5zIHRoZSBpbmRpY2F0ZWQgeSBjb29yZGluYXRlLlxuICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGl0ZW1JbmRleCArPSBzdGVwO1xuICB9XG5cbiAgaWYgKCFmb3VuZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gV2UgbWF5IGhhdmUgZm91bmQgYW4gaXRlbSB3aG9zZSBwYWRkaW5nIHNwYW5zIHRoZSBnaXZlbiB5IGNvb3JkaW5hdGUsXG4gIC8vIGJ1dCB3aG9zZSBjb250ZW50IGlzIGFjdHVhbGx5IGFib3ZlL2JlbG93IHRoYXQgcG9pbnQuXG4gIC8vIFRPRE86IElmIHRoZSBpdGVtIGhhcyBhIGJvcmRlciwgdGhlbiBwYWRkaW5nIHNob3VsZCBiZSBpbmNsdWRlZCBpblxuICAvLyBjb25zaWRlcmluZyBhIGhpdC5cbiAgY29uc3QgaXRlbVN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShpdGVtKTtcbiAgY29uc3QgaXRlbVBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KGl0ZW1TdHlsZS5wYWRkaW5nVG9wKTtcbiAgY29uc3QgaXRlbVBhZGRpbmdCb3R0b20gPSBwYXJzZUZsb2F0KGl0ZW1TdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgY29uc3QgY29udGVudFRvcCA9IGl0ZW1Ub3AgKyBpdGVtLmNsaWVudFRvcCArIGl0ZW1QYWRkaW5nVG9wO1xuICBjb25zdCBjb250ZW50Qm90dG9tID0gY29udGVudFRvcCArIGl0ZW0uY2xpZW50SGVpZ2h0IC0gaXRlbVBhZGRpbmdUb3AgLSBpdGVtUGFkZGluZ0JvdHRvbTtcbiAgaWYgKGRvd253YXJkICYmIGNvbnRlbnRUb3AgPD0geSB8fCAhZG93bndhcmQgJiYgY29udGVudEJvdHRvbSA+PSB5KSB7XG4gICAgLy8gVGhlIGluZGljYXRlZCBjb29yZGluYXRlIGhpdHMgdGhlIGFjdHVhbCBpdGVtIGNvbnRlbnQuXG4gICAgcmV0dXJuIGl0ZW1JbmRleDtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBUaGUgaW5kaWNhdGVkIGNvb3JkaW5hdGUgZmFsbHMgd2l0aGluIHRoZSBpdGVtJ3MgcGFkZGluZy4gQmFjayB1cCB0b1xuICAgIC8vIHRoZSBpdGVtIGJlbG93L2Fib3ZlIHRoZSBpdGVtIHdlIGZvdW5kIGFuZCByZXR1cm4gdGhhdC5cbiAgICByZXR1cm4gaXRlbUluZGV4IC0gc3RlcDtcbiAgfVxufVxuXG4vLyBNb3ZlIGJ5IG9uZSBwYWdlIGRvd253YXJkIChpZiBkb3dud2FyZCBpcyB0cnVlKSwgb3IgdXB3YXJkIChpZiBmYWxzZSkuXG4vLyBSZXR1cm4gdHJ1ZSBpZiB3ZSBlbmRlZCB1cCBjaGFuZ2luZyB0aGUgc2VsZWN0aW9uLCBmYWxzZSBpZiBub3QuXG4vLyBUT0RPOiBCZXR0ZXIgc3VwcG9ydCBmb3IgaG9yaXpvbnRhbCBsaXN0cy5cbmZ1bmN0aW9uIHNjcm9sbE9uZVBhZ2UoZWxlbWVudCwgZG93bndhcmQpIHtcblxuICAvLyBEZXRlcm1pbmUgdGhlIGl0ZW0gdmlzaWJsZSBqdXN0IGF0IHRoZSBlZGdlIG9mIGRpcmVjdGlvbiB3ZSdyZSBoZWFkaW5nLlxuICAvLyBXZSdsbCBzZWxlY3QgdGhhdCBpdGVtIGlmIGl0J3Mgbm90IGFscmVhZHkgc2VsZWN0ZWQuXG4gIGNvbnN0IHNjcm9sbFRhcmdldCA9IGVsZW1lbnQuc2Nyb2xsVGFyZ2V0O1xuICBjb25zdCBlZGdlID0gc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCArIChkb3dud2FyZCA/IHNjcm9sbFRhcmdldC5jbGllbnRIZWlnaHQgOiAwKTtcbiAgY29uc3QgaW5kZXhPZkl0ZW1BdEVkZ2UgPSBnZXRJbmRleE9mSXRlbUF0WShlbGVtZW50LCBlZGdlLCBkb3dud2FyZCk7XG5cbiAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IGVsZW1lbnQuc2VsZWN0ZWRJbmRleDtcbiAgbGV0IG5ld0luZGV4O1xuICBpZiAoaW5kZXhPZkl0ZW1BdEVkZ2UgJiYgc2VsZWN0ZWRJbmRleCA9PT0gaW5kZXhPZkl0ZW1BdEVkZ2UpIHtcbiAgICAvLyBUaGUgaXRlbSBhdCB0aGUgZWRnZSB3YXMgYWxyZWFkeSBzZWxlY3RlZCwgc28gc2Nyb2xsIGluIHRoZSBpbmRpY2F0ZWRcbiAgICAvLyBkaXJlY3Rpb24gYnkgb25lIHBhZ2UuIExlYXZlIHRoZSBuZXcgaXRlbSBhdCB0aGF0IGVkZ2Ugc2VsZWN0ZWQuXG4gICAgY29uc3QgZGVsdGEgPSAoZG93bndhcmQgPyAxIDogLTEpICogc2Nyb2xsVGFyZ2V0LmNsaWVudEhlaWdodDtcbiAgICBuZXdJbmRleCA9IGdldEluZGV4T2ZJdGVtQXRZKGVsZW1lbnQsIGVkZ2UgKyBkZWx0YSwgZG93bndhcmQpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIFRoZSBpdGVtIGF0IHRoZSBlZGdlIHdhc24ndCBzZWxlY3RlZCB5ZXQuIEluc3RlYWQgb2Ygc2Nyb2xsaW5nLCB3ZSdsbFxuICAgIC8vIGp1c3Qgc2VsZWN0IHRoYXQgaXRlbS4gVGhhdCBpcywgdGhlIGZpcnN0IGF0dGVtcHQgdG8gcGFnZSB1cC9kb3duXG4gICAgLy8gdXN1YWxseSBqdXN0IG1vdmVzIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVkZ2UgaW4gdGhhdCBkaXJlY3Rpb24uXG4gICAgbmV3SW5kZXggPSBpbmRleE9mSXRlbUF0RWRnZTtcbiAgfVxuXG4gIGlmICghbmV3SW5kZXgpIHtcbiAgICAvLyBXZSBjYW4ndCBmaW5kIGFuIGl0ZW0gaW4gdGhlIGRpcmVjdGlvbiB3ZSB3YW50IHRvIHRyYXZlbC4gU2VsZWN0IHRoZVxuICAgIC8vIGxhc3QgaXRlbSAoaWYgbW92aW5nIGRvd253YXJkKSBvciBmaXJzdCBpdGVtIChpZiBtb3ZpbmcgdXB3YXJkKS5cbiAgICBuZXdJbmRleCA9IChkb3dud2FyZCA/IGVsZW1lbnQuaXRlbXMubGVuZ3RoIC0gMSA6IDApO1xuICB9XG5cbiAgaWYgKG5ld0luZGV4ICE9PSBzZWxlY3RlZEluZGV4KSB7XG4gICAgZWxlbWVudC5zZWxlY3RlZEluZGV4ID0gbmV3SW5kZXg7XG4gICAgcmV0dXJuIHRydWU7IC8vIFdlIGhhbmRsZWQgdGhlIHBhZ2UgdXAvZG93biBvdXJzZWx2ZXMuXG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBXZSBkaWRuJ3QgZG8gYW55dGhpbmcuXG4gIH1cbn1cbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi9zeW1ib2xzJztcblxuXG4vLyBTeW1ib2xzIGZvciBwcml2YXRlIGRhdGEgbWVtYmVycyBvbiBhbiBlbGVtZW50LlxuY29uc3QgaXRlbVRleHRDb250ZW50c1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnaXRlbVRleHRDb250ZW50cycpO1xuY29uc3QgdHlwZWRQcmVmaXhTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3R5cGVkUHJlZml4Jyk7XG5jb25zdCBwcmVmaXhUaW1lb3V0U3ltYm9sID0gY3JlYXRlU3ltYm9sKCdwcmVmaXhUaW1lb3V0Jyk7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBLZXlib2FyZFByZWZpeFNlbGVjdGlvbi4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHRoYXQgaGFuZGxlcyBsaXN0IGJveC1zdHlsZSBwcmVmaXggdHlwaW5nLCBpbiB3aGljaCB0aGUgdXNlciBjYW4gdHlwZVxuICAgKiBhIHN0cmluZyB0byBzZWxlY3QgdGhlIGZpcnN0IGl0ZW0gdGhhdCBiZWdpbnMgd2l0aCB0aGF0IHN0cmluZy5cbiAgICpcbiAgICogRXhhbXBsZTogc3VwcG9zZSBhIGNvbXBvbmVudCB1c2luZyB0aGlzIG1peGluIGhhcyB0aGUgZm9sbG93aW5nIGl0ZW1zOlxuICAgKlxuICAgKiAgICAgPHNhbXBsZS1saXN0LWNvbXBvbmVudD5cbiAgICogICAgICAgPGRpdj5BcHBsZTwvZGl2PlxuICAgKiAgICAgICA8ZGl2PkFwcmljb3Q8L2Rpdj5cbiAgICogICAgICAgPGRpdj5CYW5hbmE8L2Rpdj5cbiAgICogICAgICAgPGRpdj5CbGFja2JlcnJ5PC9kaXY+XG4gICAqICAgICAgIDxkaXY+Qmx1ZWJlcnJ5PC9kaXY+XG4gICAqICAgICAgIDxkaXY+Q2FudGFsb3VwZTwvZGl2PlxuICAgKiAgICAgICA8ZGl2PkNoZXJyeTwvZGl2PlxuICAgKiAgICAgICA8ZGl2PkxlbW9uPC9kaXY+XG4gICAqICAgICAgIDxkaXY+TGltZTwvZGl2PlxuICAgKiAgICAgPC9zYW1wbGUtbGlzdC1jb21wb25lbnQ+XG4gICAqXG4gICAqIElmIHRoaXMgY29tcG9uZW50IHJlY2VpdmVzIHRoZSBmb2N1cywgYW5kIHRoZSB1c2VyIHByZXNzZXMgdGhlIFwiYlwiIG9yIFwiQlwiXG4gICAqIGtleSwgdGhlIFwiQmFuYW5hXCIgaXRlbSB3aWxsIGJlIHNlbGVjdGVkLCBiZWNhdXNlIGl0J3MgdGhlIGZpcnN0IGl0ZW0gdGhhdFxuICAgKiBtYXRjaGVzIHRoZSBwcmVmaXggXCJiXCIuIChNYXRjaGluZyBpcyBjYXNlLWluc2Vuc2l0aXZlLikgSWYgdGhlIHVzZXIgbm93XG4gICAqIHByZXNzZXMgdGhlIFwibFwiIG9yIFwiTFwiIGtleSBxdWlja2x5LCB0aGUgcHJlZml4IHRvIG1hdGNoIGJlY29tZXMgXCJibFwiLCBzb1xuICAgKiBcIkJsYWNrYmVycnlcIiB3aWxsIGJlIHNlbGVjdGVkLlxuICAgKlxuICAgKiBUaGUgcHJlZml4IHR5cGluZyBmZWF0dXJlIGhhcyBhIG9uZSBzZWNvbmQgdGltZW91dCDigJTCoHRoZSBwcmVmaXggdG8gbWF0Y2hcbiAgICogd2lsbCBiZSByZXNldCBhZnRlciBhIHNlY29uZCBoYXMgcGFzc2VkIHNpbmNlIHRoZSB1c2VyIGxhc3QgdHlwZWQgYSBrZXkuXG4gICAqIElmLCBpbiB0aGUgYWJvdmUgZXhhbXBsZSwgdGhlIHVzZXIgd2FpdHMgYSBzZWNvbmQgYmV0d2VlbiB0eXBpbmcgXCJiXCIgYW5kXG4gICAqIFwibFwiLCB0aGUgcHJlZml4IHdpbGwgYmVjb21lIFwibFwiLCBzbyBcIkxlbW9uXCIgd291bGQgYmUgc2VsZWN0ZWQuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyB0aGUgY29tcG9uZW50IHRvIGludm9rZSBhIGBrZXlkb3duYCBtZXRob2Qgd2hlbiBhIGtleSBpc1xuICAgKiBwcmVzc2VkLiBZb3UgY2FuIHVzZSBbS2V5Ym9hcmRNaXhpbl0oS2V5Ym9hcmRNaXhpbi5tZCkgZm9yIHRoYXRcbiAgICogcHVycG9zZSwgb3Igd2lyZSB1cCB5b3VyIG93biBrZXlib2FyZCBoYW5kbGluZyBhbmQgY2FsbCBga2V5ZG93bmAgeW91cnNlbGYuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gYWxzbyBleHBlY3RzIHRoZSBjb21wb25lbnQgdG8gcHJvdmlkZSBhbiBgaXRlbXNgIHByb3BlcnR5LiBUaGVcbiAgICogYHRleHRDb250ZW50YCBvZiB0aG9zZSBpdGVtcyB3aWxsIGJlIHVzZWQgZm9yIHB1cnBvc2VzIG9mIHByZWZpeCBtYXRjaGluZy5cbiAgICovXG4gIGNsYXNzIEtleWJvYXJkUHJlZml4U2VsZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICAvLyBUT0RPOiBJZiB0aGUgc2V0IG9mIGl0ZW1zIGlzIGNoYW5nZWQsIHJlc2V0IHRoZSBwcmVmaXguXG4gICAgLy8gW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpIHtcbiAgICAvLyAgIHRoaXNbaXRlbVRleHRDb250ZW50c1N5bWJvbF0gPSBudWxsO1xuICAgIC8vICAgcmVzZXRUeXBlZFByZWZpeCh0aGlzKTtcbiAgICAvLyB9XG5cbiAgICAvLyBUT0RPOiBJZiB0aGUgc2VsZWN0aW9uIGlzIGNoYW5nZWQgYnkgc29tZSBvdGhlciBtZWFucyAoZS5nLiwgYXJyb3cga2V5cylcbiAgICAvLyBvdGhlciB0aGFuIHByZWZpeCB0eXBpbmcsIHRoZW4gdGhhdCBhY3Qgc2hvdWxkIHJlc2V0IHRoZSBwcmVmaXguXG5cbiAgICBbc3ltYm9scy5rZXlkb3duXShldmVudCkge1xuICAgICAgbGV0IGhhbmRsZWQ7XG4gICAgICBsZXQgcmVzZXRQcmVmaXggPSB0cnVlO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSA4OiAvLyBCYWNrc3BhY2VcbiAgICAgICAgICBoYW5kbGVCYWNrc3BhY2UodGhpcyk7XG4gICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzZXRQcmVmaXggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNzogLy8gRXNjYXBlXG4gICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFldmVudC5jdHJsS2V5ICYmICFldmVudC5tZXRhS2V5ICYmICFldmVudC5hbHRLZXkgJiZcbiAgICAgICAgICAgICAgZXZlbnQud2hpY2ggIT09IDMyIC8qIFNwYWNlICovKSB7XG4gICAgICAgICAgICBoYW5kbGVQbGFpbkNoYXJhY3Rlcih0aGlzLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LndoaWNoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc2V0UHJlZml4ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXNldFByZWZpeCkge1xuICAgICAgICByZXNldFR5cGVkUHJlZml4KHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVmZXIgbWl4aW4gcmVzdWx0IGlmIGl0J3MgZGVmaW5lZCwgb3RoZXJ3aXNlIHVzZSBiYXNlIHJlc3VsdC5cbiAgICAgIHJldHVybiBoYW5kbGVkIHx8IChzdXBlcltzeW1ib2xzLmtleWRvd25dICYmIHN1cGVyW3N5bWJvbHMua2V5ZG93bl0oZXZlbnQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIGZpcnN0IGl0ZW0gd2hvc2UgdGV4dCBjb250ZW50IGJlZ2lucyB3aXRoIHRoZSBnaXZlbiBwcmVmaXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJlZml4IFtTdHJpbmddIFRoZSBwcmVmaXggc3RyaW5nIHRvIHNlYXJjaCBmb3JcbiAgICAgKi9cbiAgICBzZWxlY3RJdGVtV2l0aFRleHRQcmVmaXgocHJlZml4KSB7XG4gICAgICBpZiAoc3VwZXIuc2VsZWN0SXRlbVdpdGhUZXh0UHJlZml4KSB7IHN1cGVyLnNlbGVjdEl0ZW1XaXRoVGV4dFByZWZpeChwcmVmaXgpOyB9XG4gICAgICBpZiAocHJlZml4ID09IG51bGwgfHwgcHJlZml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4T2ZJdGVtV2l0aFRleHRQcmVmaXgodGhpcywgcHJlZml4KTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEtleWJvYXJkUHJlZml4U2VsZWN0aW9uO1xufTtcblxuXG4vLyBUaW1lIGluIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCB0aGUgdXNlciBpcyBjb25zaWRlcmVkIHRvIGhhdmUgc3RvcHBlZFxuLy8gdHlwaW5nLlxuY29uc3QgUFJFRklYX1RJTUVPVVRfRFVSQVRJT04gPSAxMDAwO1xuXG5cbi8vIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gd2l0aCB0aGUgZ2l2ZW4gcHJlZml4LCBlbHNlIC0xLlxuZnVuY3Rpb24gZ2V0SW5kZXhPZkl0ZW1XaXRoVGV4dFByZWZpeChlbGVtZW50LCBwcmVmaXgpIHtcbiAgY29uc3QgaXRlbVRleHRDb250ZW50cyA9IGdldEl0ZW1UZXh0Q29udGVudHMoZWxlbWVudCk7XG4gIGNvbnN0IHByZWZpeExlbmd0aCA9IHByZWZpeC5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbVRleHRDb250ZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGl0ZW1UZXh0Q29udGVudCA9IGl0ZW1UZXh0Q29udGVudHNbaV07XG4gICAgaWYgKGl0ZW1UZXh0Q29udGVudC5zdWJzdHIoMCwgcHJlZml4TGVuZ3RoKSA9PT0gcHJlZml4KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vLyBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHRleHQgY29udGVudCAoaW4gbG93ZXJjYXNlKSBvZiBhbGwgaXRlbXMuXG4vLyBDYWNoZSB0aGVzZSByZXN1bHRzLlxuZnVuY3Rpb24gZ2V0SXRlbVRleHRDb250ZW50cyhlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudFtpdGVtVGV4dENvbnRlbnRzU3ltYm9sXSkge1xuICAgIGNvbnN0IGl0ZW1zID0gZWxlbWVudC5pdGVtcztcbiAgICBlbGVtZW50W2l0ZW1UZXh0Q29udGVudHNTeW1ib2xdID0gaXRlbXMubWFwKGNoaWxkID0+IHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaGlsZC50ZXh0Q29udGVudCB8fCBjaGlsZC5hbHQ7XG4gICAgICByZXR1cm4gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlbGVtZW50W2l0ZW1UZXh0Q29udGVudHNTeW1ib2xdO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVCYWNrc3BhY2UoZWxlbWVudCkge1xuICBjb25zdCBsZW5ndGggPSBlbGVtZW50W3R5cGVkUHJlZml4U3ltYm9sXSA/IGVsZW1lbnRbdHlwZWRQcmVmaXhTeW1ib2xdLmxlbmd0aCA6IDA7XG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudFt0eXBlZFByZWZpeFN5bWJvbF0gPSBlbGVtZW50W3R5cGVkUHJlZml4U3ltYm9sXS5zdWJzdHIoMCwgbGVuZ3RoIC0gMSk7XG4gIH1cbiAgZWxlbWVudC5zZWxlY3RJdGVtV2l0aFRleHRQcmVmaXgoZWxlbWVudFt0eXBlZFByZWZpeFN5bWJvbF0pO1xuICBzZXRQcmVmaXhUaW1lb3V0KGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVQbGFpbkNoYXJhY3RlcihlbGVtZW50LCBjaGFyKSB7XG4gIGNvbnN0IHByZWZpeCA9IGVsZW1lbnRbdHlwZWRQcmVmaXhTeW1ib2xdIHx8ICcnO1xuICBlbGVtZW50W3R5cGVkUHJlZml4U3ltYm9sXSA9IHByZWZpeCArIGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgZWxlbWVudC5zZWxlY3RJdGVtV2l0aFRleHRQcmVmaXgoZWxlbWVudFt0eXBlZFByZWZpeFN5bWJvbF0pO1xuICBzZXRQcmVmaXhUaW1lb3V0KGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiByZXNldFByZWZpeFRpbWVvdXQoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudFtwcmVmaXhUaW1lb3V0U3ltYm9sXSkge1xuICAgIGNsZWFyVGltZW91dChlbGVtZW50W3ByZWZpeFRpbWVvdXRTeW1ib2xdKTtcbiAgICBlbGVtZW50W3ByZWZpeFRpbWVvdXRTeW1ib2xdID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRUeXBlZFByZWZpeChlbGVtZW50KSB7XG4gIGVsZW1lbnRbdHlwZWRQcmVmaXhTeW1ib2xdID0gJyc7XG4gIHJlc2V0UHJlZml4VGltZW91dChlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gc2V0UHJlZml4VGltZW91dChlbGVtZW50KSB7XG4gIHJlc2V0UHJlZml4VGltZW91dChlbGVtZW50KTtcbiAgZWxlbWVudFtwcmVmaXhUaW1lb3V0U3ltYm9sXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHJlc2V0VHlwZWRQcmVmaXgoZWxlbWVudCk7XG4gIH0sIFBSRUZJWF9USU1FT1VUX0RVUkFUSU9OKTtcbn1cbiIsImltcG9ydCByZW5kZXJBcnJheUFzRWxlbWVudHMgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvcmVuZGVyQXJyYXlBc0VsZW1lbnRzJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3N5bWJvbHMnO1xuaW1wb3J0IHRvZ2dsZUNsYXNzIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3RvZ2dsZUNsYXNzJztcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIFBhZ2VEb3RzLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogVGVtcGxhdGUgbWl4aW4gd2hpY2ggYWRkcyBzbWFsbCBkb3RzIHRvIHNob3cgdGhlIG51bWJlciBvZiBpdGVtcyBhbmQgbGV0XG4gICAqIHRoZSB1c2VyIHNlbGVjdCBhIHNwZWNpZmljIGl0ZW0uXG4gICAqXG4gICAqIFlvdSBjYW4gc2VlIGFcbiAgICogW2xpdmUgZGVtb10oaHR0cDovL2Jhc2ljd2ViY29tcG9uZW50cy5vcmcvYmFzaWMtd2ViLWNvbXBvbmVudHMvcGFja2FnZXMvZGVtb3MvY2Fyb3VzZWwtd2l0aC1kb3RzLmh0bWwpXG4gICAqIG9mIHRoaXMgbWl4aW4gYXBwbGllZCB0byBhIGNhcm91c2VsLlxuICAgKlxuICAgKiBUaGVyZSB3aWxsIGJlIG9uZSBkb3QgZm9yIGVhY2ggaXRlbSwgYW5kIHRoZSBkb3QgZm9yIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICogaXRlbSB3aWxsIGJlIHNob3duIHNlbGVjdGVkLlxuICAgKlxuICAgKiBUeXBpY2FsIHVzYWdlOlxuICAgKlxuICAgKiAgICAgY2xhc3MgQ2Fyb3VzZWxXaXRoRG90cyBleHRlbmRzIFBhZ2VEb3RzTWl4aW4oQ2Fyb3VzZWwpIHt9XG4gICAqICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ2Nhcm91c2VsLXdpdGgtZG90cycsIENhcm91c2VsV2l0aERvdHMpO1xuICAgKlxuICAgKiBBbHRob3VnaCB0aGUgZG90cyBhcmUgcXVpdGUgc21hbGwgYnkgZGVmYXVsdCwgY2xpY2tpbmcvdGFwcGluZyBhIGRvdCB3aWxsXG4gICAqIHdpbGwgc2VsZWN0IHRoZSBjb3JyZXNwb25kaW5nIGxpc3QgaXRlbS5cbiAgICovXG4gIGNsYXNzIFBhZ2VEb3RzIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG5cbiAgICAgIHRoaXMuJC5kb3RzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBkb3QgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGRvdEluZGV4ID0gdGhpcy5kb3RzLmluZGV4T2YoZG90KTtcbiAgICAgICAgaWYgKGRvdEluZGV4ID49IDApIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBkb3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0IGRvdHMoKSB7XG4gICAgICByZXR1cm4gW10uc2xpY2UuY2FsbCh0aGlzLiQuZG90cy5xdWVyeVNlbGVjdG9yQWxsKCcuZG90JykpO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtc0NoYW5nZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpOyB9XG4gICAgICByZW5kZXJBcnJheUFzRWxlbWVudHModGhpcy5pdGVtcywgdGhpcy4kLmRvdHMsIChpdGVtLCBlbGVtZW50KSA9PiB7XG4gICAgICAgIC8vIFdlIGRvbid0IHVzZSB0aGUgaXRlbSBwYXJhbWV0ZXIsIGJlY2F1c2UgYW55IGl0ZW0gd2lsbCBwcm9kdWNlIGFuXG4gICAgICAgIC8vIGlkZW50aWNhbCBjb3JyZXNwb25kaW5nIGRvdC5cbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZG90Jyk7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzdHlsZS1zY29wZScpO1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYmFzaWMtcGFnZS1kb3RzJyk7XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbm9uZScpO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlZnJlc2hEb3RzKHRoaXMpO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgc2VsZWN0ZWQpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1TZWxlY3RlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIHNlbGVjdGVkKTsgfVxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAvLyBTZWUgaWYgdGhlIGNvcnJlc3BvbmRpbmcgZG90IGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZC5cbiAgICAgIC8vIElmIG5vdCwgdGhlIGNvcnJlY3QgZG90IHdpbGwgYmUgc2VsZWN0ZWQgd2hlbiBpdCBnZXRzIGNyZWF0ZWQuXG4gICAgICBjb25zdCBkb3RzID0gdGhpcy5kb3RzO1xuICAgICAgaWYgKGRvdHMgJiYgZG90cy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgICBjb25zdCBkb3QgPSB0aGlzLmRvdHNbaW5kZXhdO1xuICAgICAgICBpZiAoZG90KSB7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZG90LCAnc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGlzdGFuY2UgdGhlIHVzZXIgaGFzIG1vdmVkIHRoZSBmaXJzdCB0b3VjaHBvaW50IHNpbmNlIHRoZSBiZWdpbm5pbmdcbiAgICAgKiBvZiBhIGRyYWcsIGV4cHJlc3NlZCBhcyBhIGZyYWN0aW9uIG9mIHRoZSBlbGVtZW50J3Mgd2lkdGguXG4gICAgICpcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWRGcmFjdGlvbigpIHtcbiAgICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEZyYWN0aW9uO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWRGcmFjdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCdzZWxlY3RlZEZyYWN0aW9uJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3RlZEZyYWN0aW9uID0gdmFsdWU7IH1cbiAgICAgIHJlbmRlclRyYW5zaXRpb24odGhpcywgdGhpcy5zZWxlY3RlZEluZGV4LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IHNlbGVjdGVkSW5kZXgoKSB7XG4gICAgICByZXR1cm4gc3VwZXIuc2VsZWN0ZWRJbmRleDtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICAgIGlmICgnc2VsZWN0ZWRJbmRleCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRJbmRleCA9IGluZGV4OyB9XG4gICAgICByZWZyZXNoRG90cyh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgW3N5bWJvbHMudGVtcGxhdGVdKCkge1xuICAgICAgY29uc3QgYmFzZVRlbXBsYXRlID0gc3VwZXJbc3ltYm9scy50ZW1wbGF0ZV0gfHwgJyc7XG4gICAgICByZXR1cm4gYFxuICAgICAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cblxuICAgICAgICAjZG90cyB7XG4gICAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIHotaW5kZXg6IDE7XG4gICAgICAgIH1cblxuICAgICAgICAjZG90TmF2aWdhdGlvbkNvbnRhaW5lciB7XG4gICAgICAgICAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgLXdlYmtpdC1mbGV4OiAxO1xuICAgICAgICAgIGZsZXg6IDE7XG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgIHotaW5kZXg6IDA7XG4gICAgICAgIH1cblxuICAgICAgICAjY29udGFpbmVyIDo6c2xvdHRlZCgqKSB7XG4gICAgICAgICAgLXdlYmtpdC1mbGV4OiAxO1xuICAgICAgICAgIGZsZXg6IDE7XG4gICAgICAgIH1cblxuICAgICAgICAuZG90IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2IoMjU1LCAyNTUsIDI1NSk7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogN3B4O1xuICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAxcHggMXB4IHJnYmEoMCwgMCwgMCwgMC41KTtcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICBoZWlnaHQ6IDhweDtcbiAgICAgICAgICBtYXJnaW46IDdweCA1cHg7XG4gICAgICAgICAgb3BhY2l0eTogMC40O1xuICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAwLjJzIGJveC1zaGFkb3cgMC4ycztcbiAgICAgICAgICB3aWR0aDogOHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgLmRvdDpob3ZlciB7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMXB4IDNweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XG4gICAgICAgIH1cblxuICAgICAgICAuZG90LnNlbGVjdGVkIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLjk1O1xuICAgICAgICB9XG5cbiAgICAgICAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XG4gICAgICAgICAgLmRvdCB7XG4gICAgICAgICAgICBoZWlnaHQ6IDEycHg7XG4gICAgICAgICAgICB3aWR0aDogMTJweDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgPC9zdHlsZT5cblxuICAgICAgICA8ZGl2IGlkPVwiZG90c1wiIHJvbGU9XCJub25lXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9XCJkb3ROYXZpZ2F0aW9uQ29udGFpbmVyXCIgcm9sZT1cIm5vbmVcIj5cbiAgICAgICAgICAke2Jhc2VUZW1wbGF0ZX1cbiAgICAgICAgPC9kaXY+XG4gICAgICBgO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFBhZ2VEb3RzO1xufTtcblxuXG4vLyBSZXR1cm4gdGhlIGluZGV4LCBlbnN1cmluZyBpdCBzdGF5cyBiZXR3ZWVuIDAgYW5kIHRoZSBnaXZlbiBsZW5ndGguXG5mdW5jdGlvbiBrZWVwSW5kZXhXaXRoaW5Cb3VuZHMobGVuZ3RoLCBpbmRleCkge1xuICAvLyBIYW5kbGUgcG9zc2liaWxpdHkgb2YgbmVnYXRpdmUgbW9kLlxuICAvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTg2MTgyNTAvNzY0NzJcbiAgcmV0dXJuICgoaW5kZXggJSBsZW5ndGgpICsgbGVuZ3RoKSAlIGxlbmd0aDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVHJhbnNpdGlvbihlbGVtZW50LCBzZWxlY3RlZEluZGV4LCBzZWxlY3RlZEZyYWN0aW9uKSB7XG4gIGNvbnN0IGRvdHMgPSBlbGVtZW50LmRvdHM7XG4gIGlmICghZG90cyB8fCBkb3RzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkb3RDb3VudCA9IGRvdHMubGVuZ3RoO1xuICBjb25zdCBvcGFjaXR5TWluaW11bSA9IDAuNDtcbiAgY29uc3Qgb3BhY2l0eU1heGltdW0gPSAwLjk1O1xuICBjb25zdCBvcGFjaXR5UmFuZ2UgPSBvcGFjaXR5TWF4aW11bSAtIG9wYWNpdHlNaW5pbXVtO1xuICBjb25zdCBmcmFjdGlvbmFsSW5kZXggPSBzZWxlY3RlZEluZGV4ICsgc2VsZWN0ZWRGcmFjdGlvbjtcbiAgY29uc3QgbGVmdEluZGV4ID0gTWF0aC5mbG9vcihmcmFjdGlvbmFsSW5kZXgpO1xuICBjb25zdCByaWdodEluZGV4ID0gTWF0aC5jZWlsKGZyYWN0aW9uYWxJbmRleCk7XG4gIGNvbnN0IHNlbGVjdGlvbldyYXBzID0gZWxlbWVudC5zZWxlY3Rpb25XcmFwcztcbiAgbGV0IGF3YXlJbmRleCA9IHNlbGVjdGVkRnJhY3Rpb24gPj0gMCA/IGxlZnRJbmRleCA6IHJpZ2h0SW5kZXg7XG4gIGxldCB0b3dhcmRJbmRleCA9IHNlbGVjdGVkRnJhY3Rpb24gPj0gMCA/IHJpZ2h0SW5kZXggOiBsZWZ0SW5kZXg7XG4gIGlmIChzZWxlY3Rpb25XcmFwcykge1xuICAgIGF3YXlJbmRleCA9IGtlZXBJbmRleFdpdGhpbkJvdW5kcyhkb3RDb3VudCwgYXdheUluZGV4KTtcbiAgICB0b3dhcmRJbmRleCA9IGtlZXBJbmRleFdpdGhpbkJvdW5kcyhkb3RDb3VudCwgdG93YXJkSW5kZXgpO1xuICB9XG4gIC8vIFN0dXBpZCBJRSBkb2Vzbid0IGhhdmUgTWF0aC50cnVuYy5cbiAgLy8gY29uc3QgdHJ1bmNhdGVkU2VsZWN0ZWRGcmFjdGlvbiA9IE1hdGgudHJ1bmMoc2VsZWN0ZWRGcmFjdGlvbik7XG4gIGNvbnN0IHRydW5jYXRlZFNlbGVjdGVkRnJhY3Rpb24gPSBzZWxlY3RlZEZyYWN0aW9uIDwgMCA/IE1hdGguY2VpbChzZWxlY3RlZEZyYWN0aW9uKSA6IE1hdGguZmxvb3Ioc2VsZWN0ZWRGcmFjdGlvbik7XG4gIGNvbnN0IHByb2dyZXNzID0gc2VsZWN0ZWRGcmFjdGlvbiAtIHRydW5jYXRlZFNlbGVjdGVkRnJhY3Rpb247XG4gIGNvbnN0IG9wYWNpdHlQcm9ncmVzc1Rocm91Z2hSYW5nZSA9IE1hdGguYWJzKHByb2dyZXNzKSAqIG9wYWNpdHlSYW5nZTtcbiAgZG90cy5mb3JFYWNoKChkb3QsIGluZGV4KSA9PiB7XG4gICAgbGV0IGRvdE9wYWNpdHk7XG4gICAgaWYgKHNlbGVjdGVkRnJhY3Rpb24gPT09IDApIHtcbiAgICAgIC8vIFJlbW92ZSBleHBsaWNpdCBvcGFjaXR5IGFuZCByZWx5IG9uIHN0eWxpbmcuXG4gICAgICBkb3RPcGFjaXR5ID0gJyc7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gYXdheUluZGV4KSB7XG4gICAgICBkb3RPcGFjaXR5ID0gb3BhY2l0eU1heGltdW0gLSBvcGFjaXR5UHJvZ3Jlc3NUaHJvdWdoUmFuZ2U7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gdG93YXJkSW5kZXgpIHtcbiAgICAgIGRvdE9wYWNpdHkgPSBvcGFjaXR5TWluaW11bSArIG9wYWNpdHlQcm9ncmVzc1Rocm91Z2hSYW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG90T3BhY2l0eSA9IG9wYWNpdHlNaW5pbXVtO1xuICAgIH1cbiAgICBkb3Quc3R5bGUub3BhY2l0eSA9IGRvdE9wYWNpdHk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWZyZXNoRG90cyhlbGVtZW50KSB7XG4gIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBlbGVtZW50LnNlbGVjdGVkSW5kZXg7XG4gIGVsZW1lbnQuZG90cy5mb3JFYWNoKChkb3QsIGkpID0+IHtcbiAgICB0b2dnbGVDbGFzcyhkb3QsICdzZWxlY3RlZCcsIGkgPT09IHNlbGVjdGVkSW5kZXgpO1xuICB9KTtcbn1cbiIsImltcG9ydCBzYWZlQXR0cmlidXRlcyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zYWZlQXR0cmlidXRlcyc7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zeW1ib2xzJztcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIFBsYXlDb250cm9scy4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIFRlbXBsYXRlIG1peGluIHdoaWNoIGFkZHMgYnV0dG9ucyBmb3IgbWFuYWdpbmcgcGxheWJhY2sgb2YgYSBzbGlkZXNob3csXG4gICAqIGF1ZGlvIHBsYXlsaXN0LCBldGMuXG4gICAqXG4gICAqIFR5cGljYWwgdXNhZ2U6XG4gICAqXG4gICAqICAgICBjbGFzcyBTbGlkZXNob3dXaXRoQ29udHJvbHMgZXh0ZW5kcyBQbGF5Q29udHJvbHNNaXhpbihTbGlkZXNob3cpIHt9XG4gICAqICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ3NsaWRlc2hvdy13aXRoLWNvbnRyb2xzJywgU2xpZGVzaG93V2l0aENvbnRyb2xzKTtcbiAgICpcbiAgICovXG4gIGNsYXNzIFBsYXlDb250cm9scyBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy4kLnByZXZpb3VzQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJC5wbGF5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnBsYXlpbmcgPSAhdGhpcy5wbGF5aW5nO1xuICAgICAgfSk7XG4gICAgICB0aGlzLiQubmV4dEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5zZWxlY3ROZXh0KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgICBzYWZlQXR0cmlidXRlcy5jb25uZWN0ZWQodGhpcyk7XG4gICAgfVxuXG4gICAgW3N5bWJvbHMua2V5ZG93bl0oZXZlbnQpIHtcbiAgICAgIGxldCBoYW5kbGVkO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAzMjogLyogU3BhY2UgKi9cbiAgICAgICAgICB0aGlzLnBsYXlpbmcgPSAhdGhpcy5wbGF5aW5nO1xuICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVmZXIgbWl4aW4gcmVzdWx0IGlmIGl0J3MgZGVmaW5lZCwgb3RoZXJ3aXNlIHVzZSBiYXNlIHJlc3VsdC5cbiAgICAgIHJldHVybiBoYW5kbGVkIHx8IChzdXBlcltzeW1ib2xzLmtleWRvd25dICYmIHN1cGVyW3N5bWJvbHMua2V5ZG93bl0oZXZlbnQpKTtcbiAgICB9XG5cbiAgICBnZXQgcGxheWluZygpIHtcbiAgICAgIHJldHVybiBzdXBlci5wbGF5aW5nO1xuICAgIH1cbiAgICBzZXQgcGxheWluZyh2YWx1ZSkge1xuICAgICAgaWYgKCdwbGF5aW5nJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5wbGF5aW5nID0gdmFsdWU7IH1cbiAgICAgIHNhZmVBdHRyaWJ1dGVzLnRvZ2dsZUNsYXNzKHRoaXMsICdwbGF5aW5nJywgdmFsdWUpO1xuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy50ZW1wbGF0ZV0oKSB7XG4gICAgICBjb25zdCBiYXNlVGVtcGxhdGUgPSBzdXBlcltzeW1ib2xzLnRlbXBsYXRlXSB8fCAnJztcbiAgICAgIHJldHVybiBgXG4gICAgICAgIDxzdHlsZT5cbiAgICAgICAgOmhvc3Qge1xuICAgICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgfVxuXG4gICAgICAgICNidXR0b25zIHtcbiAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgICBwYWRkaW5nOiAwLjVlbTtcbiAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIHotaW5kZXg6IDE7XG4gICAgICAgIH1cblxuICAgICAgICBidXR0b24ge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgICBmaWxsOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XG4gICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBmaWxsIDAuNXM7XG4gICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdCg6aG92ZXIpIGJ1dHRvbiB7XG4gICAgICAgICAgZmlsbDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xuICAgICAgICB9XG4gICAgICAgIGJ1dHRvbjpob3ZlciB7XG4gICAgICAgICAgZmlsbDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjg1KTtcbiAgICAgICAgfVxuICAgICAgICBidXR0b246YWN0aXZlIHtcbiAgICAgICAgICBmaWxsOiB3aGl0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5pY29uIHtcbiAgICAgICAgICBoZWlnaHQ6IDMwcHg7XG4gICAgICAgICAgd2lkdGg6IDMwcHg7XG4gICAgICAgIH1cbiAgICAgICAgI3BsYXlCdXR0b24gLmljb24ge1xuICAgICAgICAgIGhlaWdodDogNDBweDtcbiAgICAgICAgICB3aWR0aDogNDBweDtcbiAgICAgICAgfVxuXG4gICAgICAgIDpob3N0KC5wbGF5aW5nKSAucGF1c2VkQ29udHJvbCB7XG4gICAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdCg6bm90KC5wbGF5aW5nKSkgLnBsYXlpbmdDb250cm9sIHtcbiAgICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgI2NvbnRhaW5lciB7XG4gICAgICAgICAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgLXdlYmtpdC1mbGV4OiAxO1xuICAgICAgICAgIGZsZXg6IDE7XG4gICAgICAgIH1cblxuICAgICAgICAjY29udGFpbmVyIDo6c2xvdHRlZCgqKSB7XG4gICAgICAgICAgLXdlYmtpdC1mbGV4OiAxO1xuICAgICAgICAgIGZsZXg6IDE7XG4gICAgICAgIH1cbiAgICAgICAgPC9zdHlsZT5cblxuICAgICAgICA8ZGl2IGlkPVwiYnV0dG9uc1wiPlxuICAgICAgICAgIDxidXR0b24gaWQ9XCJwcmV2aW91c0J1dHRvblwiPlxuICAgICAgICAgICAgPHN2ZyBjbGFzcz1cImljb25cIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIj5cbiAgICAgICAgICAgICAgPGcgaWQ9XCJza2lwLXByZXZpb3VzXCI+XG4gICAgICAgICAgICAgICAgPHBhdGggZD1cIk02IDZoMnYxMkg2em0zLjUgNmw4LjUgNlY2elwiLz5cbiAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvbiBpZD1cInBsYXlCdXR0b25cIj5cbiAgICAgICAgICAgIDxzdmcgY2xhc3M9XCJpY29uIHBsYXlpbmdDb250cm9sXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCI+XG4gICAgICAgICAgICAgIDxnIGlkPVwicGF1c2UtY2lyY2xlLW91dGxpbmVcIj5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTkgMTZoMlY4SDl2OHptMy0xNEM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDh6bTEtNGgyVjhoLTJ2OHpcIj48L3BhdGg+XG4gICAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgPHN2ZyBjbGFzcz1cImljb24gcGF1c2VkQ29udHJvbFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pZFlNaWQgbWVldFwiPlxuICAgICAgICAgICAgICA8ZyBpZD1cInBsYXktY2lyY2xlLW91dGxpbmVcIj5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTEwIDE2LjVsNi00LjUtNi00LjV2OXpNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDh6XCI+PC9wYXRoPlxuICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8YnV0dG9uIGlkPVwibmV4dEJ1dHRvblwiPlxuICAgICAgICAgICAgPHN2ZyBjbGFzcz1cImljb25cIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIj5cbiAgICAgICAgICAgICAgPGcgaWQ9XCJza2lwLW5leHRcIj5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTYgMThsOC41LTZMNiA2djEyek0xNiA2djEyaDJWNmgtMnpcIi8+XG4gICAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGlkPVwiY29udGFpbmVyXCIgcm9sZT1cIm5vbmVcIj5cbiAgICAgICAgICAke2Jhc2VUZW1wbGF0ZX1cbiAgICAgICAgPC9kaXY+XG4gICAgICBgO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFBsYXlDb250cm9scztcbn07XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCBGcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4gZnJvbSAnLi9GcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi9zeW1ib2xzJztcblxuXG4vLyBTeW1ib2xzIGZvciBwcml2YXRlIGRhdGEgbWVtYmVycyBvbiBhbiBlbGVtZW50LlxuY29uc3QgYW5pbWF0aW9uU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdhbmltYXRpb24nKTtcbmNvbnN0IGRyYWdnaW5nU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdkcmFnZ2luZycpO1xuY29uc3QgbGFzdEFuaW1hdGlvblN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbGFzdEFuaW1hdGlvbicpO1xuY29uc3QgcGxheWluZ0FuaW1hdGlvblN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnYW5pbWF0aW5nU2VsZWN0aW9uJyk7XG5jb25zdCBwcmV2aW91c1NlbGVjdGlvblN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncHJldmlvdXNTZWxlY3Rpb24nKTtcbmNvbnN0IHNlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdzZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvbicpO1xuY29uc3Qgc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0U3ltYm9sID0gY3JlYXRlU3ltYm9sKCdzZWxlY3Rpb25BbmltYXRpb25FZmZlY3QnKTtcbmNvbnN0IHNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lc1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzJyk7XG5jb25zdCByZXNldEFuaW1hdGlvbnNPbk5leHRSZW5kZXJTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3Jlc2V0QW5pbWF0aW9uc09uTmV4dFJlbmRlcicpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggU2VsZWN0aW9uQW5pbWF0aW9uLiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWl4aW4oYmFzZSkge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCB1c2VzIGFuaW1hdGlvbiB0byBzaG93IHRyYW5zaXRpb25zIGJldHdlZW4gc2VsZWN0aW9uIHN0YXRlcy5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBjYW4gYmUgdXNlZCBieSBjb21wb25lbnRzIHRoYXQgd2FudCB0byBwcm92aWRlIHZpc2libGVcbiAgICogYW5pbWF0aW9ucyB3aGVuIGNoYW5naW5nIHRoZSBzZWxlY3Rpb24uIEZvciBleGFtcGxlLCBhIGNhcm91c2VsIGNvbXBvbmVudFxuICAgKiBtYXkgd2FudCB0byBkZWZpbmUgYSBzbGlkaW5nIGFuaW1hdGlvbiBlZmZlY3Qgc2hvd24gd2hlbiBtb3ZpbmcgYmV0d2VlblxuICAgKiBpdGVtcy5cbiAgICpcbiAgICogVGhlIGFuaW1hdGlvbiBpcyBkZWZpbmVkIGJ5IGEgYHNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lc2AgcHJvcGVydHk7IHNlZVxuICAgKiB0aGF0IHByb3BlcnR5IGZvciBkZXRhaWxzIG9uIGhvdyB0byBkZWZpbmUgdGhlc2Uga2V5ZnJhbWVzLiBUaGlzIGFuaW1hdGlvblxuICAgKiB3aWxsIGJlIHVzZWQgaW4gdHdvIHdheXMuIEZpcnN0LCB3aGVuIG1vdmluZyBzdHJpY3RseSBiZXR3ZWVuIGl0ZW1zLCB0aGVcbiAgICogYW5pbWF0aW9uIHdpbGwgcGxheSBzbW9vdGhseSB0byBzaG93IHRoZSBzZWxlY3Rpb24gY2hhbmdpbmcuIFNlY29uZCwgdGhlXG4gICAqIGFuaW1hdGlvbiBjYW4gYmUgdXNlZCB0byByZW5kZXIgdGhlIHNlbGVjdGlvbiBhdCBhIGZpeGVkIHBvaW50IGluIHRoZVxuICAgKiB0cmFuc2l0aW9uIGJldHdlZW4gc3RhdGVzLiBFLmcuLCBpZiB0aGUgdXNlciBwYXVzZXMgaGFsZndheSB0aHJvdWdoXG4gICAqIGRyYWdnaW5nIGFuIGVsZW1lbnQgdXNpbmcgW1N3aXBlRGlyZWN0aW9uTWl4aW5dKFN3aXBlRGlyZWN0aW9uTWl4aW4ubWQpXG4gICAqIG9yIFtUcmFja3BhZERpcmVjdGlvbk1peGluXShUcmFja3BhZERpcmVjdGlvbk1peGluLm1kKXMsIHRoZW4gdGhlIHNlbGVjdGlvblxuICAgKiBhbmltYXRpb24gd2lsbCBiZSBzaG93biBhdCB0aGUgcG9pbnQgZXhhY3RseSBoYWxmd2F5IHRocm91Z2guXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyBhIGNvbXBvbmVudCB0byBwcm92aWRlIGFuIGBpdGVtc2AgYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAqIGluIHRoZSBsaXN0LCB3aGljaCBjYW4gYmUgcHJvdmlkZWQgdmlhXG4gICAqIFtDb250ZW50SXRlbXNNaXhpbl0oQ29udGVudEl0ZW1zTWl4aW4ubWQpLiBUaGlzIG1peGluIGFsc28gZXhwZWN0c1xuICAgKiBgc2VsZWN0ZWRJbmRleGAgYW5kIGBzZWxlY3RlZEl0ZW1gIHByb3BlcnRpZXMsIHdoaWNoIGNhbiBiZSBwcm92aWRlZCB2aWFcbiAgICogW1NpbmdsZVNlbGVjdGlvbk1peGluXShTaW5nbGVTZWxlY3Rpb25NaXhpbi5tZCkuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gc3VwcG9ydHMgYSBgc2VsZWN0aW9uV3JhcHNgIHByb3BlcnR5LiBXaGVuIHRydWUsIHRoZSB1c2VyIGNhblxuICAgKiBuYXZpZ2F0ZSBmb3J3YXJkIGZyb20gdGhlIGxhc3QgaXRlbSBpbiB0aGUgbGlzdCBhbmQgd3JhcCBhcm91bmQgdG8gdGhlXG4gICAqIGZpcnN0IGl0ZW0sIG9yIG5hdmlnYXRlIGJhY2t3YXJkIGZyb20gdGhlIGZpcnN0IGl0ZW0gYW5kIHdyYXAgYXJvdW5kIHRvIHRoZVxuICAgKiBsYXN0IGl0ZW0uXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gdXNlcyB0aGUgV2ViIEFuaW1hdGlvbnMgQVBJLiBGb3IgdXNlIG9uIGJyb3dzZXJzIHdoaWNoXG4gICAqIGRvIG5vdCBzdXBwb3J0IHRoYXQgQVBJIG5hdGl2ZWx5LCB5b3Ugd2lsbCBuZWVkIHRvIGxvYWQgdGhlXG4gICAqIFtXZWIgQW5pbWF0aW9ucyBwb2x5ZmlsbF0oaHR0cHM6Ly9naXRodWIuY29tL3dlYi1hbmltYXRpb25zL3dlYi1hbmltYXRpb25zLWpzKS5cbiAgICovXG4gIGNsYXNzIFNlbGVjdGlvbkFuaW1hdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICAvLyBTZXQgZGVmYXVsdHMuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb24gPSB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnNlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdCA9PT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5zZWxlY3Rpb25BbmltYXRpb25LZXlmcmFtZXMgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdCA9IHRoaXNbc3ltYm9scy5kZWZhdWx0c10uc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0O1xuICAgICAgfVxuXG4gICAgICB0aGlzW3N5bWJvbHMuZHJhZ2dpbmddID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IFtzeW1ib2xzLmRlZmF1bHRzXSgpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRzID0gc3VwZXJbc3ltYm9scy5kZWZhdWx0c10gfHwge307XG4gICAgICBkZWZhdWx0cy5zZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvbiA9IDI1MDtcbiAgICAgIGRlZmF1bHRzLnNlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdCA9ICdzbGlkZSc7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBQcm92aWRlIGJhY2tpbmcgZm9yIHRoZSBkcmFnZ2luZyBwcm9wZXJ0eS5cbiAgICAgKiBBbHNvLCB3aGVuIGEgZHJhZyBiZWdpbnMsIHJlc2V0IHRoZSBhbmltYXRpb25zLlxuICAgICAqL1xuICAgIGdldCBbc3ltYm9scy5kcmFnZ2luZ10oKSB7XG4gICAgICByZXR1cm4gdGhpc1tkcmFnZ2luZ1N5bWJvbF07XG4gICAgfVxuICAgIHNldCBbc3ltYm9scy5kcmFnZ2luZ10odmFsdWUpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzW3N5bWJvbHMuZHJhZ2dpbmddO1xuICAgICAgdGhpc1tkcmFnZ2luZ1N5bWJvbF0gPSB2YWx1ZTtcbiAgICAgIGlmIChzeW1ib2xzLmRyYWdnaW5nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyW3N5bWJvbHMuZHJhZ2dpbmddID0gdmFsdWU7IH1cbiAgICAgIGlmICh2YWx1ZSAmJiAhcHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAvLyBIYXZlIGJlZ3VuIGEgZHJhZy5cbiAgICAgICAgdGhpc1tyZXNldEFuaW1hdGlvbnNPbk5leHRSZW5kZXJTeW1ib2xdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBbc3ltYm9scy5pdGVtQWRkZWRdKGl0ZW0pIHtcbiAgICAgIC8vIFdlIG1hcmsgbmV3IGl0ZW1zIGluIHRoZSBsaXN0IGFzIGV4cGxpY2l0bHkgdmlzaWJsZSB0byBBUklBLiBPdGhlcndpc2UsXG4gICAgICAvLyB3aGVuIGFuIGl0ZW0gaXNuJ3QgdmlzaWJsZSBvbiB0aGUgc2NyZWVuLCBBUklBIHdpbGwgYXNzdW1lIHRoZSBpdGVtIGlzXG4gICAgICAvLyBvZiBubyBpbnRlcmVzdCB0byB0aGUgdXNlciwgYW5kIGxlYXZlIGl0IG91dCBvZiB0aGUgYWNjZXNzaWJpbGl0eSB0cmVlLlxuICAgICAgLy8gSWYgdGhlIGxpc3QgY29udGFpbnMgMTAgaXRlbXMsIGJ1dCBvbmx5IDMgYXJlIHZpc2libGUsIGEgc2NyZWVuIHJlYWRlclxuICAgICAgLy8gbWlnaHQgdGhlbiBhbm5vdW5jZSB0aGUgbGlzdCBvbmx5IGhhcyAzIGl0ZW1zLiBUbyBlbnN1cmUgdGhhdCBzY3JlZW5cbiAgICAgIC8vIHJlYWRlcnMgYW5kIG90aGVyIGFzc2lzdGl2ZSB0ZWNobm9sb2dpZXMgYW5ub3VuY2UgdGhlIGNvcnJlY3QgdG90YWxcbiAgICAgIC8vIG51bWJlciBvZiBpdGVtcywgd2UgZXhwbGljaXRseSBtYXJrIGFsbCBpdGVtcyBhcyBub3QgaGlkZGVuLiBUaGlzIHdpbGxcbiAgICAgIC8vIGV4cG9zZSB0aGVtIGFsbCBpbiB0aGUgYWNjZXNzaWJpbGl0eSB0cmVlLCBldmVuIHRoZSBpdGVtcyB3aGljaCBhcmVcbiAgICAgIC8vIGN1cnJlbnRseSBub3QgcmVuZGVyZWQuXG4gICAgICAvL1xuICAgICAgLy8gVE9ETzogR2VuZXJhbGx5IHNwZWFraW5nLCB0aGlzIGVudGlyZSBtaXhpbiBhc3N1bWVzIHRoYXQgdGhlIHVzZXIgY2FuXG4gICAgICAvLyBuYXZpZ2F0ZSB0aHJvdWdoIGFsbCBpdGVtcyBpbiBhIGxpc3QuIEJ1dCBhbiBhcHAgY291bGQgc3R5bGUgYW4gaXRlbSBhc1xuICAgICAgLy8gZGlzcGxheTpub25lIG9yIHZpc2liaWxpdHk6aGlkZGVuIGJlY2F1c2UgdGhlIHVzZXIgaXMgbm90IGFsbG93ZWQgdG9cbiAgICAgIC8vIGludGVyYWN0IHdpdGggdGhhdCBpdGVtIGF0IHRoZSBtb21lbnQuIFN1cHBvcnQgZm9yIHRoaXMgc2NlbmFyaW8gc2hvdWxkXG4gICAgICAvLyBiZSBhZGRlZC4gVGhpcyB3b3VsZCBlbnRhaWwgY2hhbmdpbmcgYWxsIGxvY2F0aW9ucyB3aGVyZSBhIG1peGluXG4gICAgICAvLyBmdW5jdGlvbiBpcyBjb3VudGluZyBpdGVtcywgaXRlcmF0aW5nIG92ZXIgdGhlICh2aXNpYmxlKSBpdGVtcywgYW5kXG4gICAgICAvLyBzaG93aW5nIG9yIGhpZGluZyBpdGVtcy4gQW1vbmcgb3RoZXIgdGhpbmdzLCB0aGUgY29kZSBiZWxvdyB0byBtYWtlXG4gICAgICAvLyBpdGVtcyB2aXNpYmxlIHRvIEFSSUEgd291bGQgbmVlZCB0byBkaXNjcmltaW5hdGUgYmV0d2VlbiBpdGVtcyB3aGljaFxuICAgICAgLy8gYXJlIGludmlzaWJsZSBiZWNhdXNlIG9mIGFuaW1hdGlvbiBzdGF0ZSwgb3IgaW52aXNpYmxlIGJlY2F1c2UgdGhlIHVzZXJcbiAgICAgIC8vIHNob3VsZG4ndCBpbnRlcmFjdCB3aXRoIHRoZW0uXG4gICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1zQ2hhbmdlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtc0NoYW5nZWRdKCk7IH1cblxuICAgICAgcmVzZXRBbmltYXRpb25zKHRoaXMpO1xuXG4gICAgICAvLyBUT0RPOiBBbHNvIHJlc2V0IG91ciBub3Rpb24gb2YgdGhlIGxhc3QgcmVuZGVyZWQgc2VsZWN0aW9uPyBUaGlzIGNvbWVzXG4gICAgICAvLyB1cCB3aGVuIGEgRE9NIHJlbW92YWwgY2F1c2VzIHRoZSBzZWxlY3RlZCBpdGVtIHRvIGNoYW5nZSBwb3NpdGlvbi5cbiAgICAgIC8vIHRoaXNbcHJldmlvdXNTZWxlY3Rpb25TeW1ib2xdID0gbnVsbDtcblxuICAgICAgcmVuZGVyU2VsZWN0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIHJlc2V0QW5pbWF0aW9ucygpIHtcbiAgICAgIHJlc2V0QW5pbWF0aW9ucyh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZyYWN0aW9uYWwgdmFsdWUgaW5kaWNhdGluZyBob3cgZmFyIHRoZSB1c2VyIGhhcyBjdXJyZW50bHkgYWR2YW5jZWQgdG9cbiAgICAgKiB0aGUgbmV4dC9wcmV2aW91cyBpdGVtLiBFLmcuLCBhIGBzZWxlY3RlZEZyYWN0aW9uYCBvZiAzLjUgaW5kaWNhdGVzIHRoZVxuICAgICAqIHVzZXIgaXMgaGFsZndheSBiZXR3ZWVuIGl0ZW1zIDMgYW5kIDQuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgW0ZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbl0oRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluLm1kKVxuICAgICAqIG1peGluLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWRGcmFjdGlvbigpIHtcbiAgICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEZyYWN0aW9uIHx8IDA7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEZyYWN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoJ3NlbGVjdGVkRnJhY3Rpb24nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGVkRnJhY3Rpb24gPSB2YWx1ZTsgfVxuICAgICAgcmVuZGVyU2VsZWN0aW9uKHRoaXMsIHRoaXMuc2VsZWN0ZWRJbmRleCwgdmFsdWUpO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnNlbGVjdGVkSW5kZXg7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEluZGV4KGluZGV4KSB7XG4gICAgICBpZiAoJ3NlbGVjdGVkSW5kZXgnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGVkSW5kZXggPSBpbmRleDsgfVxuICAgICAgcmVuZGVyU2VsZWN0aW9uKHRoaXMsIGluZGV4LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZHVyYXRpb24gb2YgYSBzZWxlY3Rpb24gYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWVhc3VyZXMgdGhlIGFtb3VudCBvZiB0aW1lIHJlcXVpcmVkIGZvciBhIHNlbGVjdGlvbiBhbmltYXRpb24gdG9cbiAgICAgKiBjb21wbGV0ZS4gVGhpcyBudW1iZXIgcmVtYWlucyBjb25zdGFudCwgZXZlbiBpZiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGJlaW5nXG4gICAgICogYW5pbWF0ZWQgaW5jcmVhc2VzLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgMjUwIG1pbGxpc2Vjb25kcyAoYSBxdWFydGVyIGEgc2Vjb25kKS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMjUwXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNbc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb25TeW1ib2xdO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb24odmFsdWUpIHtcbiAgICAgIHRoaXNbc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb25TeW1ib2xdID0gdmFsdWU7XG4gICAgICBpZiAoJ3NlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvbiA9IHZhbHVlOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgYSBzdGFuZGFyZCBzZWxlY3Rpb24gYW5pbWF0aW9uIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBzaG9ydGhhbmQgZm9yIHNldHRpbmcgdGhlIGBzZWxlY3Rpb25BbmltYXRpb25LZXlmcmFtZXNgXG4gICAgICogcHJvcGVydHkgdG8gc3RhbmRhcmQga2V5ZnJhbWVzLiBTdXBwb3J0ZWQgc3RyaW5nIHZhbHVlczpcbiAgICAgKlxuICAgICAqICogXCJjcm9zc2ZhZGVcIlxuICAgICAqICogXCJyZXZlYWxcIlxuICAgICAqICogXCJyZXZlYWxXaXRoRmFkZVwiXG4gICAgICogKiBcInNob3dBZGphY2VudFwiXG4gICAgICogKiBcInNsaWRlXCJcbiAgICAgKiAqIFwic2xpZGVXaXRoR2FwXCJcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJzbGlkZVwiXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdCgpIHtcbiAgICAgIHJldHVybiB0aGlzW3NlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdFN5bWJvbF07XG4gICAgfVxuICAgIHNldCBzZWxlY3Rpb25BbmltYXRpb25FZmZlY3QodmFsdWUpIHtcbiAgICAgIHRoaXNbc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0U3ltYm9sXSA9IHZhbHVlO1xuICAgICAgaWYgKCdzZWxlY3Rpb25BbmltYXRpb25FZmZlY3QnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdCA9IHZhbHVlOyB9XG4gICAgICB0aGlzLnNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lcyA9IG1peGluLnN0YW5kYXJkRWZmZWN0S2V5ZnJhbWVzW3ZhbHVlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUga2V5ZnJhbWVzIHRoYXQgZGVmaW5lIGFuIGFuaW1hdGlvbiB0aGF0IHBsYXlzIGZvciBhbiBpdGVtIHdoZW4gbW92aW5nXG4gICAgICogZm9yd2FyZCBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGFuIGFycmF5IG9mIENTUyBydWxlcyB0aGF0IHdpbGwgYmUgYXBwbGllZC4gVGhlc2UgYXJlIHVzZWQgYXNcbiAgICAgKiBba2V5ZnJhbWVzXShodHRwOi8vdzNjLmdpdGh1Yi5pby93ZWItYW5pbWF0aW9ucy8ja2V5ZnJhbWVzLXNlY3Rpb24pXG4gICAgICogdG8gYW5pbWF0ZSB0aGUgaXRlbSB3aXRoIHRoZVxuICAgICAqIFtXZWIgQW5pbWF0aW9ucyBBUEldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9hbmltYXRpb24pLlxuICAgICAqXG4gICAgICogVGhlIGFuaW1hdGlvbiByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgbmV4dCBpdGVtIGFzIGl0IG1vdmVzIGZyb21cbiAgICAgKiBjb21wbGV0ZWx5IHVuc2VsZWN0ZWQgKG9mZnN0YWdlLCB1c3VhbGx5IHJpZ2h0KSwgdG8gc2VsZWN0ZWQgKGNlbnRlclxuICAgICAqIHN0YWdlKSwgdG8gY29tcGxldGVseSB1bnNlbGVjdGVkIChvZmZzdGFnZSwgdXN1YWxseSBsZWZ0KS4gVGhlIGNlbnRlciB0aW1lXG4gICAgICogb2YgdGhlIGFuaW1hdGlvbiBzaG91bGQgY29ycmVzcG9uZCB0byB0aGUgaXRlbSdzIHF1aXNjZW50IHNlbGVjdGVkIHN0YXRlLFxuICAgICAqIHR5cGljYWxseSBpbiB0aGUgY2VudGVyIG9mIHRoZSBzdGFnZSBhbmQgYXQgdGhlIGl0ZW0ncyBsYXJnZXN0IHNpemUuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3J3YXJkIGFuaW1hdGlvbiBpcyBhIHNtb290aCBzbGlkZSBhdCBmdWxsIHNpemUgZnJvbSByaWdodCB0b1xuICAgICAqIGxlZnQuXG4gICAgICpcbiAgICAgKiBXaGVuIG1vdmluZyB0aGUgc2VsZWN0aW9uIGJhY2t3YXJkLCB0aGlzIGFuaW1hdGlvbiBpcyBwbGF5ZWQgaW4gcmV2ZXJzZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtjc3NSdWxlc1tdfVxuICAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25BbmltYXRpb25LZXlmcmFtZXMoKSB7XG4gICAgICAvLyBTdGFuZGFyZCBhbmltYXRpb24gc2xpZGVzIGxlZnQvcmlnaHQsIGtlZXBzIGFkamFjZW50IGl0ZW1zIG91dCBvZiB2aWV3LlxuICAgICAgcmV0dXJuIHRoaXNbc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lcyh2YWx1ZSkge1xuICAgICAgdGhpc1tzZWxlY3Rpb25BbmltYXRpb25LZXlmcmFtZXNTeW1ib2xdID0gdmFsdWU7XG4gICAgICBpZiAoJ3NlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lcycgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzID0gdmFsdWU7IH1cbiAgICAgIHJlc2V0QW5pbWF0aW9ucyh0aGlzKTtcbiAgICAgIHJlbmRlclNlbGVjdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0aW9uV3JhcHMoKSB7XG4gICAgICByZXR1cm4gc3VwZXIuc2VsZWN0aW9uV3JhcHM7XG4gICAgfVxuICAgIHNldCBzZWxlY3Rpb25XcmFwcyh2YWx1ZSkge1xuICAgICAgaWYgKCdzZWxlY3Rpb25XcmFwcycgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0aW9uV3JhcHMgPSB2YWx1ZTsgfVxuICAgICAgcmVzZXRBbmltYXRpb25zKHRoaXMpO1xuICAgICAgcmVuZGVyU2VsZWN0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBTZWxlY3Rpb25BbmltYXRpb247XG59XG5cblxuLy8gV2UgZXhwb3NlIGhlbHBlcnMgb24gdGhlIG1peGluIGZ1bmN0aW9uIHRoYXQgd2Ugd2FudCB0byBiZSBhYmxlIHRvIHVuaXQgdGVzdC5cbi8vIFNpbmNlIHRoZXNlIGFyZSBvbiB0aGUgZnVuY3Rpb24sIG5vdCBvbiB0aGUgY2xhc3MgZW1pdHRlZCBieSB0aGUgZnVuY3Rpb24sXG4vLyB0aGV5IGRvbid0IGVuZCB1cCBnZXR0aW5nIGV4cG9zZWQgb24gYWN0dWFsIGVsZW1lbnQgaW5zdGFuY2VzLlxubWl4aW4uaGVscGVycyA9IHtcblxuICAvKlxuICAgKiBDYWxjdWxhdGUgdGhlIGFuaW1hdGlvbiBmcmFjdGlvbnMgZm9yIGFuIGVsZW1lbnQncyBpdGVtcyBhdCB0aGUgZ2l2ZW5cbiAgICogc2VsZWN0aW9uIHBvaW50LiBUaGlzIGlzIHVzZWQgd2hlbiByZW5kZXJpbmcgdGhlIGVsZW1lbnQncyBzZWxlY3Rpb24gc3RhdGVcbiAgICogaW5zdGFudGFuZW91c2x5LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNvbnNpZGVycyB0aGUgc2VsZWN0ZWRJbmRleCBwYXJhbWV0ZXIsIHdoaWNoIGNhbiBiZSBhIHdob2xlXG4gICAqIG9yIGZyYWN0aW9uYWwgbnVtYmVyLCBhbmQgZGV0ZXJtaW5lcyB3aGljaCBpdGVtcyB3aWxsIGJlIHZpc2libGUgYXQgdGhhdFxuICAgKiBpbmRleC4gVGhpcyBmdW5jdGlvbiB0aGVuIGNhbGN1bGF0ZXMgYSBjb3JyZXNwb25kaW5nIGFuaW1hdGlvbiBmcmFjdGlvbjogYVxuICAgKiBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIGluZGljYXRpbmcgaG93IGZhciB0aHJvdWdoIHRoZSBzZWxlY3Rpb24gYW5pbWF0aW9uXG4gICAqIGFuIGl0ZW0gc2hvdWxkIGJlIHNob3duLCBvciBudWxsIGlmIHRoZSBpdGVtIHNob3VsZCBub3QgYmUgdmlzaWJsZSBhdCB0aGF0XG4gICAqIHNlbGVjdGlvbiBpbmRleC4gVGhlc2UgZnJhY3Rpb25zIGFyZSByZXR1cm5lZCBhcyBhbiBhcnJheSwgd2hlcmUgdGhlXG4gICAqIGFuaW1hdGlvbiBmcmFjdGlvbiBhdCBwb3NpdGlvbiBOIGNvcnJlc3BvbmRzIHRvIGhvdyBpdGVtIE4gc2hvdWxkIGJlIHNob3duLlxuICAgKi9cbiAgYW5pbWF0aW9uRnJhY3Rpb25zRm9yU2VsZWN0aW9uKGVsZW1lbnQsIHNlbGVjdGlvbikge1xuXG4gICAgY29uc3QgaXRlbXMgPSBlbGVtZW50Lml0ZW1zO1xuICAgIGlmICghaXRlbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtQ291bnQgPSBpdGVtcy5sZW5ndGg7XG4gICAgY29uc3Qgc2VsZWN0aW9uV3JhcHMgPSBlbGVtZW50LnNlbGVjdGlvbldyYXBzO1xuXG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICAvLyBIb3cgbWFueSBzdGVwcyBmcm9tIHRoZSBzZWxlY3Rpb24gcG9pbnQgdG8gdGhpcyBpdGVtP1xuICAgICAgY29uc3Qgc3RlcHMgPSBzdGVwc1RvSW5kZXgoaXRlbUNvdW50LCBzZWxlY3Rpb25XcmFwcywgc2VsZWN0aW9uLCBpdGVtSW5kZXgpO1xuICAgICAgLy8gVG8gY29udmVydCBzdGVwcyB0byBhbmltYXRpb24gZnJhY3Rpb246XG4gICAgICAvLyBzdGVwcyAgICAgIGFuaW1hdGlvbiBmcmFjdGlvblxuICAgICAgLy8gIDEgICAgICAgICAwICAgICAoc3RhZ2UgcmlnaHQpXG4gICAgICAvLyAgMCAgICAgICAgIDAuNSAgIChjZW50ZXIgc3RhZ2UpXG4gICAgICAvLyAtMSAgICAgICAgIDEgICAgIChzdGFnZSBsZWZ0KVxuICAgICAgY29uc3QgYW5pbWF0aW9uRnJhY3Rpb24gPSAoMSAtIHN0ZXBzKSAvIDI7XG4gICAgICByZXR1cm4gKGFuaW1hdGlvbkZyYWN0aW9uID49IDAgJiYgYW5pbWF0aW9uRnJhY3Rpb24gPD0gMSkgP1xuICAgICAgICBhbmltYXRpb25GcmFjdGlvbiA6XG4gICAgICAgIG51bGw7IC8vIE91dHNpZGUgYW5pbWF0aW9uIHJhbmdlXG4gICAgfSk7XG4gIH0sXG5cbiAgLypcbiAgICogQ2FsY3VsYXRlIHRoZSBhbmltYXRpb24gdGltaW5ncyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHNtb290aGx5IGFuaW1hdGUgdGhlXG4gICAqIGVsZW1lbnQncyBpdGVtcyBmcm9tIG9uZSBzZWxlY3Rpb24gc3RhdGUgdG8gYW5vdGhlci5cbiAgICpcbiAgICogVGhpcyByZXR1cm5zIGFuIGFycmF5IG9mIHRpbWluZ3MsIHdoZXJlIHRoZSB0aW1pbmcgYXQgcG9zaXRpb24gTiBzaG91bGQgYmVcbiAgICogdXNlZCB0byBhbmltYXRlIGl0ZW0gTi4gSWYgYW4gaXRlbSdzIHRpbWluZyBpcyBudWxsLCB0aGVuIHRoYXQgaXRlbSBzaG91bGRcbiAgICogbm90IHRha2UgcGxhY2UgaW4gdGhlIGFuaW1hdGlvbiwgYW5kIHNob3VsZCBiZSBoaWRkZW4gaW5zdGVhZC5cbiAgICovXG4gIGVmZmVjdFRpbWluZ3NGb3JTZWxlY3Rpb25BbmltYXRpb24oZWxlbWVudCwgZnJvbVNlbGVjdGlvbiwgdG9TZWxlY3Rpb24pIHtcblxuICAgIGNvbnN0IGl0ZW1zID0gZWxlbWVudC5pdGVtcztcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1Db3VudCA9IGl0ZW1zLmxlbmd0aDtcbiAgICBjb25zdCBzZWxlY3Rpb25XcmFwcyA9IGVsZW1lbnQuc2VsZWN0aW9uV3JhcHM7XG4gICAgY29uc3QgdG9JbmRleCA9IEZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbi5oZWxwZXJzLndyYXBwZWRTZWxlY3Rpb25QYXJ0cyh0b1NlbGVjdGlvbiwgaXRlbUNvdW50LCBzZWxlY3Rpb25XcmFwcykuaW5kZXg7XG4gICAgY29uc3QgdG90YWxTdGVwcyA9IHN0ZXBzVG9JbmRleChpdGVtQ291bnQsIHNlbGVjdGlvbldyYXBzLCBmcm9tU2VsZWN0aW9uLCB0b1NlbGVjdGlvbik7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdG90YWxTdGVwcyA+PSAwID8gJ25vcm1hbCc6ICdyZXZlcnNlJztcbiAgICBjb25zdCBmaWxsID0gJ2JvdGgnO1xuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBlbGVtZW50LnNlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uO1xuICAgIGNvbnN0IHN0ZXBEdXJhdGlvbiA9IHRvdGFsU3RlcHMgIT09IDAgP1xuICAgICAgdG90YWxEdXJhdGlvbiAqIDIgLyBNYXRoLmNlaWwoTWF0aC5hYnModG90YWxTdGVwcykpIDpcbiAgICAgIDA7ICAvLyBObyBzdGVwcyByZXF1aXJlZCwgYW5pbWF0aW9uIHdpbGwgYmUgaW5zdGFudGVub3VzLlxuXG4gICAgY29uc3QgdGltaW5ncyA9IGl0ZW1zLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzdGVwcyA9IHN0ZXBzVG9JbmRleChpdGVtQ291bnQsIHNlbGVjdGlvbldyYXBzLCBpdGVtSW5kZXgsIHRvU2VsZWN0aW9uKTtcbiAgICAgIC8vIElmIHdlIGluY2x1ZGUgdGhpcyBpdGVtIGluIHRoZSBzdGFnZ2VyZWQgc2VxdWVuY2Ugb2YgYW5pbWF0aW9ucyB3ZSdyZVxuICAgICAgLy8gY3JlYXRpbmcsIHdoZXJlIHdvdWxkIHRoZSBpdGVtIGFwcGVhciBpbiB0aGUgc2VxdWVuY2U/XG4gICAgICBsZXQgcG9zaXRpb25JblNlcXVlbmNlID0gdG90YWxTdGVwcyAtIHN0ZXBzO1xuICAgICAgaWYgKHRvdGFsU3RlcHMgPCAwKSB7XG4gICAgICAgIHBvc2l0aW9uSW5TZXF1ZW5jZSA9IC1wb3NpdGlvbkluU2VxdWVuY2U7XG4gICAgICB9XG4gICAgICAvLyBTbywgaXMgdGhpcyBpdGVtIHJlYWxseSBpbmNsdWRlZCBpbiB0aGUgc2VxdWVuY2U/XG4gICAgICBpZiAoTWF0aC5jZWlsKHBvc2l0aW9uSW5TZXF1ZW5jZSkgPj0gMCAmJiBwb3NpdGlvbkluU2VxdWVuY2UgPD0gTWF0aC5hYnModG90YWxTdGVwcykpIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IGRlbGF5IGZvciBmaXJzdCBpdGVtIHdpbGwgYmUgbmVnYXRpdmUuIFRoYXQgd2lsbCBjYXVzZVxuICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIHRvIHN0YXJ0IGhhbGZ3YXkgdGhyb3VnaCwgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LlxuICAgICAgICBjb25zdCBkZWxheSA9IHN0ZXBEdXJhdGlvbiAqIChwb3NpdGlvbkluU2VxdWVuY2UgLSAxKS8yO1xuICAgICAgICBjb25zdCBlbmREZWxheSA9IGl0ZW1JbmRleCA9PT0gdG9JbmRleCA/XG4gICAgICAgICAgLXN0ZXBEdXJhdGlvbi8yIDogICAvLyBTdG9wIGhhbGZ3YXkgdGhyb3VnaC5cbiAgICAgICAgICAwOyAgICAgICAgICAgICAgLy8gUGxheSBhbmltYXRpb24gdW50aWwgZW5kLlxuICAgICAgICByZXR1cm4geyBkdXJhdGlvbjogc3RlcER1cmF0aW9uLCBkaXJlY3Rpb24sIGZpbGwsIGRlbGF5LCBlbmREZWxheSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGltaW5ncztcbiAgfVxuXG59O1xuXG5cbi8vIEtleWZyYW1lcyBmb3Igc3RhbmRhcmQgc2VsZWN0aW9uIGFuaW1hdGlvbiBlZmZlY3RzLlxubWl4aW4uc3RhbmRhcmRFZmZlY3RLZXlmcmFtZXMgPSB7XG5cbiAgLy8gU2ltcGxlIGNyb3NzZmFkZVxuICBjcm9zc2ZhZGU6IFtcbiAgICB7IG9wYWNpdHk6IDAgfSxcbiAgICB7IG9wYWNpdHk6IDEgfSxcbiAgICB7IG9wYWNpdHk6IDAgfVxuICBdLFxuXG4gIC8vIFJldmVhbCwgYXMgaWYgc2xpZGluZyB0aGUgdG9wIGNhcmQgb2ZmIGEgZGVjayBvZiBjYXJkc1xuICByZXZlYWw6IFtcbiAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCUpJywgekluZGV4OiAwIH0sXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDAlKScsIHpJbmRleDogMSB9LFxuICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtMTAwJSknLCB6SW5kZXg6IDIgfVxuICBdLFxuXG4gIC8vIEdvb2dsZSBQaG90b3Mtc3R5bGUgcmV2ZWFsLXdpdGgtZmFkZSBhbmltYXRpb25cbiAgcmV2ZWFsV2l0aEZhZGU6IFtcbiAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCUpIHNjYWxlKDAuNzUpJywgb3BhY2l0eTogMCwgekluZGV4OiAwIH0sXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDAlKSBzY2FsZSgxLjApJywgb3BhY2l0eTogMSwgekluZGV4OiAxIH0sXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC0xMDAlKSBzY2FsZSgxLjApJywgb3BhY2l0eTogMSwgekluZGV4OiAyIH1cbiAgXSxcblxuICAvLyBDYXJvdXNlbCB2YXJpYW50IHdpdGggYSBiaXQgb2Ygb2ZmLXN0YWdlIGVsZW1lbnRzIHNob3dpbmdcbiAgc2hvd0FkamFjZW50OiBbXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDc4JSkgc2NhbGUoMC43KScsIHpJbmRleDogMCB9LFxuICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwJSkgc2NhbGUoMC44MiknLCB6SW5kZXg6IDEgfSxcbiAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTc4JSkgc2NhbGUoMC43KScsIHpJbmRleDogMCB9XG4gIF0sXG5cbiAgLy8gU2ltcGxlIHNsaWRlXG4gIHNsaWRlOiBbXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDEwMCUpJyB9LFxuICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtMTAwJSknIH1cbiAgXSxcblxuICAvLyBTbGlkZSwgd2l0aCBhIGdhcCBiZXR3ZWVuXG4gIHNsaWRlV2l0aEdhcDogW1xuICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgxMTAlKScgfSxcbiAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTExMCUpJyB9XG4gIF1cblxufTtcblxuXG4vKlxuICogU21vb3RobHkgYW5pbWF0ZSB0aGUgc2VsZWN0aW9uIGJldHdlZW4gdGhlIGluZGljYXRlZCBcImZyb21cIiBhbmQgXCJ0b1wiXG4gKiBpbmRpY2VzLiBUaGUgZm9ybWVyIGNhbiBiZSBhIGZyYWN0aW9uLCBlLmcuLCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEgZmluZ2VyXG4gKiB0byBjb21wbGV0ZSBhIHRvdWNoIGRyYWcsIGFuZCB0aGUgc2VsZWN0aW9uIHdpbGwgc25hcCB0byB0aGUgY2xvc2VzdCB3aG9sZVxuICogaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGVTZWxlY3Rpb24oZWxlbWVudCwgZnJvbVNlbGVjdGlvbiwgdG9TZWxlY3Rpb24pIHtcblxuICByZXNldEFuaW1hdGlvbnMoZWxlbWVudCk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBhbmltYXRpb24gdGltaW5ncy5cbiAgY29uc3QgaXRlbXMgPSBlbGVtZW50Lml0ZW1zO1xuICBjb25zdCBrZXlmcmFtZXMgPSBlbGVtZW50LnNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lcztcbiAgZWxlbWVudFtwbGF5aW5nQW5pbWF0aW9uU3ltYm9sXSA9IHRydWU7XG4gIGNvbnN0IHRpbWluZ3MgPSBtaXhpbi5oZWxwZXJzLmVmZmVjdFRpbWluZ3NGb3JTZWxlY3Rpb25BbmltYXRpb24oZWxlbWVudCwgZnJvbVNlbGVjdGlvbiwgdG9TZWxlY3Rpb24pO1xuXG4gIC8vIEZpZ3VyZSBvdXQgd2hpY2ggaXRlbSB3aWxsIGJlIHRoZSBvbmUgKmFmdGVyKiB0aGUgb25lIHdlJ3JlIHNlbGVjdGluZy5cbiAgY29uc3QgaXRlbUNvdW50ID0gaXRlbXMubGVuZ3RoO1xuICBjb25zdCBzZWxlY3Rpb25XcmFwcyA9IGVsZW1lbnQuc2VsZWN0aW9uV3JhcHM7XG4gIGNvbnN0IHNlbGVjdGlvbkluZGV4ID0gRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluLmhlbHBlcnMuc2VsZWN0aW9uUGFydHModG9TZWxlY3Rpb24sIGl0ZW1Db3VudCwgc2VsZWN0aW9uV3JhcHMpLmluZGV4O1xuICBjb25zdCB0b3RhbFN0ZXBzID0gc3RlcHNUb0luZGV4KGl0ZW1Db3VudCwgc2VsZWN0aW9uV3JhcHMsIGZyb21TZWxlY3Rpb24sIHRvU2VsZWN0aW9uKTtcbiAgY29uc3QgZm9yd2FyZCA9IHRvdGFsU3RlcHMgPj0gMDtcbiAgbGV0IG5leHRVcEluZGV4ID0gc2VsZWN0aW9uSW5kZXggKyAoZm9yd2FyZCA/IDEgOiAtIDEpO1xuICBpZiAoc2VsZWN0aW9uV3JhcHMpIHtcbiAgICBuZXh0VXBJbmRleCA9IEZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbi5oZWxwZXJzLndyYXBwZWRTZWxlY3Rpb24obmV4dFVwSW5kZXgsIGl0ZW1Db3VudCk7XG4gIH0gZWxzZSBpZiAoIWlzSXRlbUluZGV4SW5Cb3VuZHMoZWxlbWVudCwgbmV4dFVwSW5kZXgpKSB7XG4gICAgbmV4dFVwSW5kZXggPSBudWxsOyAvLyBBdCBzdGFydC9lbmQgb2YgbGlzdDsgZG9uJ3QgaGF2ZSBhIG5leHQgaXRlbSB0byBzaG93LlxuICB9XG5cbiAgLy8gUGxheSB0aGUgYW5pbWF0aW9ucyB1c2luZyB0aG9zZSB0aW1pbmdzLlxuICBsZXQgbGFzdEFuaW1hdGlvbkRldGFpbHM7XG4gIHRpbWluZ3MuZm9yRWFjaCgodGltaW5nLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpbmRleF07XG4gICAgaWYgKHRpbWluZykge1xuICAgICAgc2hvd0l0ZW0oaXRlbSwgdHJ1ZSk7XG4gICAgICBjb25zdCBhbmltYXRpb24gPSBpdGVtLmFuaW1hdGUoa2V5ZnJhbWVzLCB0aW1pbmcpO1xuICAgICAgZWxlbWVudFthbmltYXRpb25TeW1ib2xdW2luZGV4XSA9IGFuaW1hdGlvbjtcbiAgICAgIGlmIChpbmRleCA9PT0gbmV4dFVwSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpdGVtIHdpbGwgYmUgYW5pbWF0ZWQsIHNvIHdpbGwgYWxyZWFkeSBiZSBpbiB0aGUgZGVzaXJlZCBzdGF0ZVxuICAgICAgICAvLyBhZnRlciB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgbmV4dFVwSW5kZXggPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWluZy5lbmREZWxheSAhPT0gMCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBhbmltYXRpb24gZm9yIHRoZSBpdGVtIHRoYXQgd2lsbCBiZSBsZWZ0IHNlbGVjdGVkLlxuICAgICAgICAvLyBXZSB3YW50IHRvIGNsZWFuIHVwIHdoZW4gdGhpcyBhbmltYXRpb24gY29tcGxldGVzLlxuICAgICAgICBsYXN0QW5pbWF0aW9uRGV0YWlscyA9IHsgYW5pbWF0aW9uLCBpbmRleCwgdGltaW5nLCBmb3J3YXJkIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXRlbSBkb2Vzbid0IHBhcnRpY2lwYXRlIGluIHRoZSBhbmltYXRpb24uXG4gICAgICBzaG93SXRlbShpdGVtLCBmYWxzZSk7XG4gICAgfVxuICB9KTtcblxuICBpZiAobGFzdEFuaW1hdGlvbkRldGFpbHMgIT0gbnVsbCkge1xuICAgIC8vIEFycmFuZ2UgZm9yIGNsZWFuLXVwIHdvcmsgdG8gYmUgcGVyZm9ybWVkLlxuICAgIGxhc3RBbmltYXRpb25EZXRhaWxzLm5leHRVcEluZGV4ID0gbmV4dFVwSW5kZXg7XG4gICAgbGFzdEFuaW1hdGlvbkRldGFpbHMuYW5pbWF0aW9uLm9uZmluaXNoID0gZXZlbnQgPT4gc2VsZWN0aW9uQW5pbWF0aW9uRmluaXNoZWQoZWxlbWVudCwgbGFzdEFuaW1hdGlvbkRldGFpbHMpO1xuICAgIGVsZW1lbnRbbGFzdEFuaW1hdGlvblN5bWJvbF0gPSBsYXN0QW5pbWF0aW9uRGV0YWlscy5hbmltYXRpb247XG4gIH0gZWxzZSB7XG4gICAgLy8gU2hvdWxkbid0IGhhcHBlbiAtLSB3ZSBzaG91bGQgYWx3YXlzIGhhdmUgYXQgbGVhc3Qgb25lIGFuaW1hdGlvbi5cbiAgICBlbGVtZW50W3BsYXlpbmdBbmltYXRpb25TeW1ib2xdID0gZmFsc2U7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBnZXRBbmltYXRpb25Gb3JJdGVtSW5kZXgoZWxlbWVudCwgaW5kZXgpIHtcbiAgaWYgKGVsZW1lbnRbYW5pbWF0aW9uU3ltYm9sXSA9PSBudWxsKSB7XG4gICAgLy8gTm90IHJlYWR5IHlldDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgYW5pbWF0aW9uID0gZWxlbWVudFthbmltYXRpb25TeW1ib2xdW2luZGV4XTtcbiAgaWYgKCFhbmltYXRpb24pIHtcbiAgICBjb25zdCBpdGVtID0gZWxlbWVudC5pdGVtc1tpbmRleF07XG4gICAgYW5pbWF0aW9uID0gaXRlbS5hbmltYXRlKGVsZW1lbnQuc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzLCB7XG4gICAgICBkdXJhdGlvbjogZWxlbWVudC5zZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvbixcbiAgICAgIGZpbGw6ICdib3RoJ1xuICAgIH0pO1xuICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgIGVsZW1lbnRbYW5pbWF0aW9uU3ltYm9sXVtpbmRleF0gPSBhbmltYXRpb247XG4gIH1cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn1cblxuZnVuY3Rpb24gaXNJdGVtSW5kZXhJbkJvdW5kcyhlbGVtZW50LCBpbmRleCkge1xuICByZXR1cm4gaW5kZXggPj0gMCAmJiBlbGVtZW50Lml0ZW1zICYmIGluZGV4IDwgZWxlbWVudC5pdGVtcy5sZW5ndGg7XG59XG5cbi8qXG4gKiBSZW5kZXIgdGhlIHNlbGVjdGlvbiBzdGF0ZSBvZiB0aGUgZWxlbWVudC5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIHJlLXJlbmRlciBhIHByZXZpb3VzIHNlbGVjdGlvbiBzdGF0ZSAoaWYgdGhlXG4gKiBzZWxlY3RlZEluZGV4IHBhcmFtIGlzIG9taXR0ZWQpLCByZW5kZXIgdGhlIHNlbGVjdGlvbiBpbnN0YW50bHkgYXQgYSBnaXZlblxuICogd2hvbGUgb3IgZnJhY3Rpb25hbCBzZWxlY3Rpb24gaW5kZXgsIG9yIGFuaW1hdGUgdG8gYSBnaXZlbiBzZWxlY3Rpb24gaW5kZXguXG4gKlxuICogVGhlcmUgYXJlIHNldmVyYWwgZGlzdGluY3Qgc2NlbmFyaW9zIHdlIG5lZWQgdG8gY292ZXI6XG4gKlxuICogMS4gSW5pdGlhbCBwb3NpdGlvbmluZywgb3IgcmVwb3NpdGlvbmluZyBhZnRlciBjaGFuZ2luZyBhIHByb3BlcnR5IGxpa2VcbiAqICAgIHNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lcyB0aGF0IGFmZmVjdHMgcmVuZGVyaW5nLlxuICogMi4gQW5pbWF0ZSBvbiBzZWxlY3RlZEluZGV4IGNoYW5nZS4gVGhpcyBzaG91bGQgb3ZlcnJpZGUgYW55IGFuaW1hdGlvbi9zd2lwZVxuICogICAgYWxyZWFkeSBpbiBwcm9ncmVzcy5cbiAqIDMuIEluc3RhbnRseSByZW5kZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgYSBkcmFnIG9wZXJhdGlvbiBpbiBwcm9ncmVzcy5cbiAqIDQuIENvbXBsZXRlIGEgZHJhZyBvcGVyYXRpb24uIElmIHRoZSBkcmFnIHdhc24ndCBmYXIgZW5vdWdoIHRvIGFmZmVjdFxuICogICAgc2VsZWN0aW9uLCB3ZSdsbCBqdXN0IGJlIHJlc3RvcmluZyB0aGUgc2VsZWN0ZWRGcmFjdGlvbiB0byAwLlxuICpcbiAqIElmIHRoZSBsaXN0IGRvZXMgbm90IHdyYXAsIGFueSBzZWxlY3Rpb24gcG9zaXRpb24gb3V0c2lkZSB0aGUgbGlzdCdzIGJvdW5kc1xuICogd2lsbCBiZSBkYW1wZWQgdG8gcHJvZHVjZSBhIHZpc3VhbCBlZmZlY3Qgb2YgdGVuc2lvbi5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2VsZWN0aW9uKGVsZW1lbnQsIHNlbGVjdGVkSW5kZXg9ZWxlbWVudC5zZWxlY3RlZEluZGV4LCBzZWxlY3RlZEZyYWN0aW9uPWVsZW1lbnQuc2VsZWN0ZWRGcmFjdGlvbikge1xuICBjb25zdCBpdGVtQ291bnQgPSBlbGVtZW50Lml0ZW1zID8gZWxlbWVudC5pdGVtcy5sZW5ndGggOiAwO1xuICBpZiAoaXRlbUNvdW50ID09PSAwKSB7XG4gICAgLy8gTm90aGluZyB0byByZW5kZXIuXG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzZWxlY3RlZEluZGV4IDwgMCkge1xuICAgIC8vIFRPRE86IEhhbmRsZSBubyBzZWxlY3Rpb24uXG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzZWxlY3Rpb24gPSBzZWxlY3RlZEluZGV4ICsgc2VsZWN0ZWRGcmFjdGlvbjtcbiAgaWYgKGVsZW1lbnQuc2VsZWN0aW9uV3JhcHMpIHtcbiAgICAvLyBBcHBseSB3cmFwcGluZyB0byBlbnN1cmUgY29uc2lzdGVudCByZXByZXNlbnRhdGlvbiBvZiBzZWxlY3Rpb24uXG4gICAgc2VsZWN0aW9uID0gRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluLmhlbHBlcnMud3JhcHBlZFNlbGVjdGlvbihzZWxlY3Rpb24sIGl0ZW1Db3VudCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXBwbHkgZGFtcGluZyBpZiBuZWNlc3NhcnkuXG4gICAgc2VsZWN0aW9uID0gRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluLmhlbHBlcnMuZGFtcGVkU2VsZWN0aW9uKHNlbGVjdGlvbiwgaXRlbUNvdW50KTtcbiAgfVxuICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbiA9IGVsZW1lbnRbcHJldmlvdXNTZWxlY3Rpb25TeW1ib2xdO1xuICAvLyBUT0RPOiBJZiBhbiBpdGVtIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIERPTSwgd2UgZW5kIHVwIGFuaW1hdGluZyBmcm9tXG4gIC8vIGl0cyBvbGQgaW5kZXggdG8gaXRzIG5ldyBpbmRleCwgYnV0IHdlIHJlYWxseSBkb24ndCB3YW50IHRvIGFuaW1hdGUgYXQgYWxsLlxuICBpZiAoIWVsZW1lbnRbc3ltYm9scy5kcmFnZ2luZ10gJiYgcHJldmlvdXNTZWxlY3Rpb24gIT0gbnVsbCAmJlxuICAgICAgcHJldmlvdXNTZWxlY3Rpb24gIT09IHNlbGVjdGlvbikge1xuICAgIC8vIEFuaW1hdGUgc2VsZWN0aW9uIGZyb20gcHJldmlvdXMgc3RhdGUgdG8gbmV3IHN0YXRlLlxuICAgIGFuaW1hdGVTZWxlY3Rpb24oZWxlbWVudCwgcHJldmlvdXNTZWxlY3Rpb24sIHNlbGVjdGlvbik7XG4gIH0gZWxzZSBpZiAoc2VsZWN0ZWRGcmFjdGlvbiA9PT0gMCAmJiBlbGVtZW50W3BsYXlpbmdBbmltYXRpb25TeW1ib2xdKSB7XG4gICAgLy8gQWxyZWFkeSBpbiBwcm9jZXNzIG9mIGFuaW1hdGluZyB0byBmcmFjdGlvbiAwLiBEdXJpbmcgdGhhdCBwcm9jZXNzLFxuICAgIC8vIGlnbm9yZSBzdWJzZXF1ZW50IGF0dGVtcHRzIHRvIHJlbmRlclNlbGVjdGlvbiB0byBmcmFjdGlvbiAwLlxuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZW5kZXIgY3VycmVudCBzZWxlY3Rpb24gc3RhdGUgaW5zdGFudGx5LlxuICAgIHJlbmRlclNlbGVjdGlvbkluc3RhbnRseShlbGVtZW50LCBzZWxlY3Rpb24pO1xuICB9XG4gIGVsZW1lbnRbcHJldmlvdXNTZWxlY3Rpb25TeW1ib2xdID0gc2VsZWN0aW9uO1xufVxuXG4vKlxuICogSW5zdGFudGx5IHJlbmRlciAoZG9uJ3QgYW5pbWF0ZSkgdGhlIGVsZW1lbnQncyBpdGVtcyBhdCB0aGUgZ2l2ZW4gd2hvbGUgb3JcbiAqIGZyYWN0aW9uYWwgc2VsZWN0aW9uIGluZGV4LlxuICovXG5mdW5jdGlvbiByZW5kZXJTZWxlY3Rpb25JbnN0YW50bHkoZWxlbWVudCwgdG9TZWxlY3Rpb24pIHtcbiAgaWYgKGVsZW1lbnRbcmVzZXRBbmltYXRpb25zT25OZXh0UmVuZGVyU3ltYm9sXSkge1xuICAgIHJlc2V0QW5pbWF0aW9ucyhlbGVtZW50KTtcbiAgICBlbGVtZW50W3Jlc2V0QW5pbWF0aW9uc09uTmV4dFJlbmRlclN5bWJvbF0gPSBmYWxzZTtcbiAgfVxuICBjb25zdCBhbmltYXRpb25GcmFjdGlvbnMgPSBtaXhpbi5oZWxwZXJzLmFuaW1hdGlvbkZyYWN0aW9uc0ZvclNlbGVjdGlvbihlbGVtZW50LCB0b1NlbGVjdGlvbik7XG4gIGFuaW1hdGlvbkZyYWN0aW9ucy5tYXAoKGFuaW1hdGlvbkZyYWN0aW9uLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSBlbGVtZW50Lml0ZW1zW2luZGV4XTtcbiAgICBpZiAoYW5pbWF0aW9uRnJhY3Rpb24gIT0gbnVsbCkge1xuICAgICAgc2hvd0l0ZW0oaXRlbSwgdHJ1ZSk7XG4gICAgICBzZXRBbmltYXRpb25GcmFjdGlvbihlbGVtZW50LCBpbmRleCwgYW5pbWF0aW9uRnJhY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG93SXRlbShpdGVtLCBmYWxzZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLypcbiAqIFdlIG1haW50YWluIGFuIGFycmF5IGNvbnRhaW5pbmcgYW4gYW5pbWF0aW9uIHBlciBpdGVtLiBUaGlzIGlzIHVzZWQgZm9yIHR3b1xuICogcmVhc29uczpcbiAqXG4gKiAqIER1cmluZyBhIGRyYWcgb3BlcmF0aW9uLCB3ZSB3YW50IHRvIGJlIGFibGUgdG8gcmV1c2UgYW5pbWF0aW9ucyBiZXR3ZWVuXG4gKiAgIGRyYWcgdXBkYXRlcy5cbiAqICogV2hlbiBhIHNlbGVjdGlvbiBhbmltYXRpb24gY29tcGxldGVzLCB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gbGVhdmUgdGhlXG4gKiAgIHZpc2liaWxlIGl0ZW1zIGluIGEgcGF1c2VkIHN0YXRlLiBMYXRlciwgd2UnbGwgd2FudCB0byBiZSBhYmxlIHRvIGNsZWFuIHVwXG4gKiAgIHRob3NlIGFuaW1hdGlvbnMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgYXJyYXkgaXMgc3BhcnNlOiBpdCB3aWxsIG9ubHkgaG9sZCB1cCBmcm9tIDDigJMzIGFuaW1hdGlvbnMgYXRcbiAqIGFueSBnaXZlbiBwb2ludC5cbiAqL1xuZnVuY3Rpb24gcmVzZXRBbmltYXRpb25zKGVsZW1lbnQpIHtcbiAgY29uc3QgYW5pbWF0aW9ucyA9IGVsZW1lbnRbYW5pbWF0aW9uU3ltYm9sXTtcbiAgaWYgKGFuaW1hdGlvbnMpIHtcbiAgICAvLyBDYW5jZWwgZXhpc3RpbmcgYW5pbWF0aW9ucyB0byByZW1vdmUgdGhlIGVmZmVjdHMgdGhleSdyZSBhcHBseWluZy5cbiAgICBhbmltYXRpb25zLmZvckVhY2goKGFuaW1hdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICBhbmltYXRpb25zW2luZGV4XSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgaXRlbUNvdW50ID0gZWxlbWVudC5pdGVtcyA/IGVsZW1lbnQuaXRlbXMubGVuZ3RoIDogMDtcbiAgaWYgKCFhbmltYXRpb25zIHx8IGFuaW1hdGlvbnMubGVuZ3RoICE9PSBpdGVtQ291bnQpIHtcbiAgICAvLyBIYXZlbid0IGFuaW1hdGVkIGJlZm9yZSB3aXRoIHRoaXMgbnVtYmVyIG9mIGl0ZW1zOyAocmUpY3JlYXRlIGFycmF5LlxuICAgIGVsZW1lbnRbYW5pbWF0aW9uU3ltYm9sXSA9IG5ldyBBcnJheShpdGVtQ291bnQpO1xuICB9XG59XG5cbi8qXG4gKiBUaGUgbGFzdCBhbmltYXRpb24gaW4gb3VyIHNlbGVjdGlvbiBhbmltYXRpb24gaGFzIGNvbXBsZXRlZC4gQ2xlYW4gdXAuXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdGlvbkFuaW1hdGlvbkZpbmlzaGVkKGVsZW1lbnQsIGRldGFpbHMpIHtcblxuICAvLyBXaGVuIHRoZSBsYXN0IGFuaW1hdGlvbiBjb21wbGV0ZXMsIHNob3cgdGhlIG5leHQgaXRlbSBpbiB0aGUgZGlyZWN0aW9uXG4gIC8vIHdlJ3JlIGdvaW5nLiBXYWl0aW5nIHRvIHRoYXQgdW50aWwgdGhpcyBwb2ludCBpcyBhIGJpdCBvZiBhIGhhY2sgdG8gYXZvaWRcbiAgLy8gaGF2aW5nIGEgbmV4dCBpdGVtIHRoYXQncyBoaWdoZXIgaW4gdGhlIG5hdHVyYWwgei1vcmRlciBvYnNjdXJlIG90aGVyIGl0ZW1zXG4gIC8vIGR1cmluZyBhbmltYXRpb24uXG4gIGNvbnN0IG5leHRVcEluZGV4ID0gZGV0YWlscy5uZXh0VXBJbmRleDtcbiAgaWYgKG5leHRVcEluZGV4ICE9IG51bGwpIHtcbiAgICBpZiAoZWxlbWVudFthbmltYXRpb25TeW1ib2xdW25leHRVcEluZGV4XSkge1xuICAgICAgLy8gQ2FuY2VsIGV4aXN0aW5nIHNlbGVjdGlvbiBhbmltYXRpb24gc28gd2UgY2FuIGNvbnN0cnVjdCBhIG5ldyBvbmUuXG4gICAgICBlbGVtZW50W2FuaW1hdGlvblN5bWJvbF1bbmV4dFVwSW5kZXhdLmNhbmNlbCgpO1xuICAgICAgZWxlbWVudFthbmltYXRpb25TeW1ib2xdW25leHRVcEluZGV4XSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbkZyYWN0aW9uID0gZGV0YWlscy5mb3J3YXJkID8gMCA6IDE7XG4gICAgc2V0QW5pbWF0aW9uRnJhY3Rpb24oZWxlbWVudCwgbmV4dFVwSW5kZXgsIGFuaW1hdGlvbkZyYWN0aW9uKTtcbiAgICBzaG93SXRlbShlbGVtZW50Lml0ZW1zW25leHRVcEluZGV4XSwgdHJ1ZSk7XG4gIH1cblxuICBlbGVtZW50W2xhc3RBbmltYXRpb25TeW1ib2xdLm9uZmluaXNoID0gbnVsbDtcbiAgZWxlbWVudFtwbGF5aW5nQW5pbWF0aW9uU3ltYm9sXSA9IGZhbHNlO1xufVxuXG4vKlxuICogUGF1c2UgdGhlIGluZGljYXRlZCBhbmltYXRpb24gYW5kIGhhdmUgaXQgc2hvdyB0aGUgYW5pbWF0aW9uIGF0IHRoZSBnaXZlblxuICogZnJhY3Rpb24gKGJldHdlZW4gMCBhbmQgMSkgb2YgdGhlIHdheSB0aHJvdWdoIHRoZSBhbmltYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHNldEFuaW1hdGlvbkZyYWN0aW9uKGVsZW1lbnQsIGl0ZW1JbmRleCwgZnJhY3Rpb24pIHtcbiAgY29uc3QgYW5pbWF0aW9uID0gZ2V0QW5pbWF0aW9uRm9ySXRlbUluZGV4KGVsZW1lbnQsIGl0ZW1JbmRleCk7XG4gIGlmIChhbmltYXRpb24pIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IGVsZW1lbnQuc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb247XG4gICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICBhbmltYXRpb24uY3VycmVudFRpbWUgPSBmcmFjdGlvbiAqIGR1cmF0aW9uO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzaG93SXRlbShpdGVtLCBmbGFnKSB7XG4gIGl0ZW0uc3R5bGUudmlzaWJpbGl0eSA9IGZsYWcgPyAndmlzaWJsZScgOiAnaGlkZGVuJztcbn1cblxuLypcbiAqIEZpZ3VyZSBvdXQgaG93IG1hbnkgc3RlcHMgaXQgd2lsbCB0YWtlIHRvIGdvIGZyb20gZnJvbVNlbGVjdGlvbiB0b1xuICogdG9TZWxlY3Rpb24uIFRvIGdvIGZyb20gaXRlbSAzIHRvIGl0ZW0gNCBpcyBvbmUgc3RlcC5cbiAqXG4gKiBJZiB3cmFwcGluZyBpcyBhbGxvd2VkLCB0aGVuIGdvaW5nIGZyb20gdGhlIGxhc3QgaXRlbSB0byB0aGUgZmlyc3Qgd2lsbCB0YWtlXG4gKiBvbmUgc3RlcCAoZm9yd2FyZCksIGFuZCBnb2luZyBmcm9tIHRoZSBmaXJzdCBpdGVtIHRvIHRoZSBsYXN0IHdpbGwgdGFrZSBvbmVcbiAqIHN0ZXAgKGJhY2t3YXJkKS5cbiAqL1xuZnVuY3Rpb24gc3RlcHNUb0luZGV4KGxlbmd0aCwgYWxsb3dXcmFwLCBmcm9tU2VsZWN0aW9uLCB0b1NlbGVjdGlvbikge1xuICBsZXQgc3RlcHMgPSB0b1NlbGVjdGlvbiAtIGZyb21TZWxlY3Rpb247XG4gIC8vIFdyYXBwaW5nIG9ubHkga2lja3MgaW4gd2hlbiBsaXN0IGhhcyBtb3JlIHRoYW4gMSBpdGVtLlxuICBpZiAoYWxsb3dXcmFwICYmIGxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCB3cmFwU3RlcHMgPSBsZW5ndGggLSBNYXRoLmFicyhzdGVwcyk7XG4gICAgaWYgKHdyYXBTdGVwcyA8PSAxKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2VcbiAgICAgIHN0ZXBzID0gc3RlcHMgPCAwID9cbiAgICAgICAgd3JhcFN0ZXBzIDogICAvLyBXcmFwIGZvcndhcmQgZnJvbSBsYXN0IGl0ZW0gdG8gZmlyc3QuXG4gICAgICAgIC13cmFwU3RlcHM7ICAgLy8gV3JhcCBiYWNrd2FyZCBmcm9tIGZpcnN0IGl0ZW0gdG8gbGFzdC5cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0ZXBzO1xufVxuIiwiaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi9zeW1ib2xzJztcblxuXG4vLyBVc2VkIHRvIGFzc2lnbiB1bmlxdWUgSURzIHRvIGl0ZW0gZWxlbWVudHMgd2l0aG91dCBJRHMuXG5sZXQgaWRDb3VudCA9IDA7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTZWxlY3Rpb25BcmlhQWN0aXZlLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gd2hpY2ggdHJlYXRzIHRoZSBzZWxlY3RlZCBpdGVtIGluIGEgbGlzdCBhcyB0aGUgYWN0aXZlIGl0ZW0gaW4gQVJJQVxuICAgKiBhY2Nlc3NpYmlsaXR5IHRlcm1zLlxuICAgKlxuICAgKiBIYW5kbGluZyBBUklBIHNlbGVjdGlvbiBzdGF0ZSBwcm9wZXJseSBpcyBhY3R1YWxseSBxdWl0ZSBjb21wbGV4OlxuICAgKlxuICAgKiAqIFRoZSBpdGVtcyBpbiB0aGUgbGlzdCBuZWVkIHRvIGJlIGluZGljYXRlZCBhcyBwb3NzaWJsZSBpdGVtcyB2aWEgYW4gQVJJQVxuICAgKiAgIGByb2xlYCBhdHRyaWJ1dGUgdmFsdWUgc3VjaCBhcyBcIm9wdGlvblwiLlxuICAgKiAqIFRoZSBzZWxlY3RlZCBpdGVtIG5lZWQgdG8gYmUgbWFya2VkIGFzIHNlbGVjdGVkIGJ5IHNldHRpbmcgdGhlIGl0ZW0nc1xuICAgKiAgIGBhcmlhLXNlbGVjdGVkYCBhdHRyaWJ1dGUgdG8gdHJ1ZSAqYW5kKiB0aGUgb3RoZXIgaXRlbXMgbmVlZCBiZSBtYXJrZWQgYXNcbiAgICogICAqbm90KiBzZWxlY3RlZCBieSBzZXR0aW5nIGBhcmlhLXNlbGVjdGVkYCB0byBmYWxzZS5cbiAgICogKiBUaGUgb3V0ZXJtb3N0IGVsZW1lbnQgd2l0aCB0aGUga2V5Ym9hcmQgZm9jdXMgbmVlZHMgdG8gaGF2ZSBhdHRyaWJ1dGVzXG4gICAqICAgc2V0IG9uIGl0IHNvIHRoYXQgdGhlIHNlbGVjdGlvbiBpcyBrbm93YWJsZSBhdCB0aGUgbGlzdCBsZXZlbCB2aWEgdGhlXG4gICAqICAgYGFyaWEtYWN0aXZlZGVzY2VuZGFudGAgYXR0cmlidXRlLlxuICAgKiAqIFVzZSBvZiBgYXJpYS1hY3RpdmVkZXNjZW5kYW50YCBpbiB0dXJuIHJlcXVpcmVzIHRoYXQgYWxsIGl0ZW1zIGluIHRoZVxuICAgKiAgIGxpc3QgaGF2ZSBJRCBhdHRyaWJ1dGVzIGFzc2lnbmVkIHRvIHRoZW0uXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gdHJpZXMgdG8gYWRkcmVzcyBhbGwgb2YgdGhlIGFib3ZlIHJlcXVpcmVtZW50cy4gVG8gdGhhdCBlbmQsXG4gICAqIHRoaXMgbWl4aW4gd2lsbCBhc3NpZ24gZ2VuZXJhdGVkIElEcyB0byBhbnkgaXRlbSB0aGF0IGRvZXNuJ3QgYWxyZWFkeSBoYXZlXG4gICAqIGFuIElELlxuICAgKlxuICAgKiBBUklBIHJlbGllcyBvbiBlbGVtZW50cyB0byBwcm92aWRlIGByb2xlYCBhdHRyaWJ1dGVzLiBUaGlzIG1peGluIHdpbGwgYXBwbHlcbiAgICogYSBkZWZhdWx0IHJvbGUgb2YgXCJsaXN0Ym94XCIgb24gdGhlIG91dGVyIGxpc3QgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGhhdmUgYW5cbiAgICogZXhwbGljaXQgcm9sZS4gU2ltaWxhcmx5LCB0aGlzIG1peGluIHdpbGwgYXBwbHkgYSBkZWZhdWx0IHJvbGUgb2YgXCJvcHRpb25cIlxuICAgKiB0byBhbnkgbGlzdCBpdGVtIHRoYXQgZG9lcyBub3QgYWxyZWFkeSBoYXZlIGEgcm9sZSBzcGVjaWZpZWQuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyBhIHNldCBvZiBtZW1iZXJzIHRoYXQgbWFuYWdlIHRoZSBzdGF0ZSBvZiB0aGUgc2VsZWN0aW9uOlxuICAgKiBgW3N5bWJvbHMuaXRlbVNlbGVjdGVkXWAsIGBpdGVtQWRkZWRgLCBhbmQgYHNlbGVjdGVkSW5kZXhgLiBZb3UgY2FuXG4gICAqIHN1cHBseSB0aGVzZSB5b3Vyc2VsZiwgb3IgZG8gc28gdmlhXG4gICAqIFtTaW5nbGVTZWxlY3Rpb25NaXhpbl0oU2luZ2xlU2VsZWN0aW9uTWl4aW4ubWQpLlxuICAgKi9cbiAgY2xhc3MgU2VsZWN0aW9uQXJpYUFjdGl2ZSBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBpZiAoc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2spIHsgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTsgfVxuICAgICAgLy8gU2V0IGRlZmF1bHQgQVJJQSByb2xlLlxuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT0gbnVsbCAmJiB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnJvbGUpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnJvbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMucm9sZSA9ICdsaXN0Ym94JztcbiAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICBbc3ltYm9scy5pdGVtQWRkZWRdKGl0ZW0pIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1BZGRlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtQWRkZWRdKGl0ZW0pOyB9XG5cbiAgICAgIGlmICghaXRlbS5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSkge1xuICAgICAgICAvLyBBc3NpZ24gYSBkZWZhdWx0IEFSSUEgcm9sZS5cbiAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnb3B0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSBlYWNoIGl0ZW0gaGFzIGFuIElEIHNvIHdlIGNhbiBzZXQgYXJpYS1hY3RpdmVkZXNjZW5kYW50IG9uIHRoZVxuICAgICAgLy8gb3ZlcmFsbCBsaXN0IHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgSUQgd2lsbCB0YWtlIHRoZSBmb3JtIG9mIGEgYmFzZSBJRCBwbHVzIGEgdW5pcXVlIGludGVnZXIuIFRoZSBiYXNlXG4gICAgICAvLyBJRCB3aWxsIGJlIGluY29ycG9yYXRlIHRoZSBjb21wb25lbnQncyBvd24gSUQuIEUuZy4sIGlmIGEgY29tcG9uZW50IGhhc1xuICAgICAgLy8gSUQgXCJmb29cIiwgdGhlbiBpdHMgaXRlbXMgd2lsbCBoYXZlIElEcyB0aGF0IGxvb2sgbGlrZSBcIl9mb29PcHRpb24xXCIuIElmXG4gICAgICAvLyB0aGUgY29tcG5lbnQgaGFzIG5vIElEIGl0c2VsZiwgaXRzIGl0ZW1zIHdpbGwgZ2V0IElEcyB0aGF0IGxvb2sgbGlrZVxuICAgICAgLy8gXCJfb3B0aW9uMVwiLiBJdGVtIElEcyBhcmUgcHJlZml4ZWQgd2l0aCBhbiB1bmRlcnNjb3JlIHRvIGRpZmZlcmVudGlhdGVcbiAgICAgIC8vIHRoZW0gZnJvbSBtYW51YWxseS1hc3NpZ25lZCBJRHMsIGFuZCB0byBtaW5pbWl6ZSB0aGUgcG90ZW50aWFsIGZvciBJRFxuICAgICAgLy8gY29uZmxpY3RzLlxuICAgICAgaWYgKCFpdGVtLmlkKSB7XG4gICAgICAgIGNvbnN0IGJhc2VJZCA9IHRoaXMuaWQgP1xuICAgICAgICAgICAgXCJfXCIgKyB0aGlzLmlkICsgXCJPcHRpb25cIiA6XG4gICAgICAgICAgICBcIl9vcHRpb25cIjtcbiAgICAgICAgaXRlbS5pZCA9IGJhc2VJZCArIGlkQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIHNlbGVjdGVkKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCk7IH1cbiAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgc2VsZWN0ZWQpO1xuICAgICAgY29uc3QgaXRlbUlkID0gaXRlbS5pZDtcbiAgICAgIGlmIChpdGVtSWQgJiYgc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIGl0ZW1JZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHNlbGVjdGVkSXRlbSgpIHtcbiAgICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEl0ZW07XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEl0ZW0oaXRlbSkge1xuICAgICAgaWYgKCdzZWxlY3RlZEl0ZW0nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGVkSXRlbSA9IGl0ZW07IH1cbiAgICAgIGlmIChpdGVtID09IG51bGwpIHtcbiAgICAgICAgLy8gU2VsZWN0aW9uIHdhcyByZW1vdmVkLlxuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gU2VsZWN0aW9uQXJpYUFjdGl2ZTtcbn07XG4iLCJpbXBvcnQgc3ltYm9scyBmcm9tICcuLi9zcmMvc3ltYm9scyc7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTZWxlY3Rpb25IaWdobGlnaHQuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBUZW1wbGF0ZSBtaXhpbiB3aGljaCBhcHBsaWVzIHN0YW5kYXJkIGhpZ2hsaWdodCBjb2xvcnMgdG8gYSBzZWxlY3RlZCBpdGVtLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGhpZ2hsaWdodHMgdGV4dHVhbCBpdGVtcyAoZS5nLiwgaW4gYSBsaXN0KSBpbiBhIHN0YW5kYXJkIHdheSBieVxuICAgKiB1c2luZyB0aGUgQ1NTIGBoaWdobGlnaHRgIGFuZCBgaGlnaGxpZ2h0dGV4dGAgY29sb3IgdmFsdWVzLiBUaGVzZSB2YWx1ZXNcbiAgICogcmVzcGVjdCBvcGVyYXRpbmcgc3lzdGVtIGRlZmF1bHRzIGFuZCB1c2VyIHByZWZlcmVuY2VzLCBhbmQgaGVuY2UgYXJlIGdvb2RcbiAgICogZGVmYXVsdCB2YWx1ZXMgZm9yIGhpZ2hsaWdodCBjb2xvcnMuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyBhIGBzZWxlY3RlZGAgY2xhc3MgdG8gYmUgYXBwbGllZCB0byBzZWxlY3RlZCBpdGVtcy4gWW91XG4gICAqIGNhbiB1c2UgW0NvbnRlbnRJdGVtc01peGluXShDb250ZW50SXRlbXNNaXhpbi5tZCkgZm9yIHRoYXQgcHVycG9zZS5cbiAgICovXG4gIGNsYXNzIFNlbGVjdGlvbkhpZ2hsaWdodCBleHRlbmRzIGJhc2Uge1xuXG4gICAgZ2V0IFtzeW1ib2xzLnRlbXBsYXRlXSgpIHtcbiAgICAgIGNvbnN0IGJhc2VUZW1wbGF0ZSA9IHN1cGVyW3N5bWJvbHMudGVtcGxhdGVdIHx8ICcnO1xuICAgICAgcmV0dXJuIGBcbiAgICAgICAgPHN0eWxlPlxuICAgICAgICAgIDpob3N0KFtnZW5lcmljPVwiXCJdKSA6OnNsb3R0ZWQoLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBoaWdobGlnaHQ7XG4gICAgICAgICAgICBjb2xvcjogaGlnaGxpZ2h0dGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICAgICR7YmFzZVRlbXBsYXRlfVxuICAgICAgYDtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBTZWxlY3Rpb25IaWdobGlnaHQ7XG59O1xuIiwiLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTZWxlY3Rpb25JblZpZXcuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBzY3JvbGxzIGEgY29udGFpbmVyIHRvIGVuc3VyZSB0aGF0IGEgbmV3bHktc2VsZWN0ZWQgaXRlbSBpc1xuICAgKiB2aXNpYmxlIHRvIHRoZSB1c2VyLlxuICAgKlxuICAgKiBXaGVuIHRoZSBzZWxlY3RlZCBpdGVtIGluIGEgbGlzdC1saWtlIGNvbXBvbmVudCBjaGFuZ2VzLCBpdCdzIGVhc2llciBmb3JcbiAgICogdGhlIHRvIGNvbmZpcm0gdGhhdCB0aGUgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkIHRvIGFuIGFwcHJvcHJpYXRlIGl0ZW0gaWYgdGhlXG4gICAqIHVzZXIgY2FuIGFjdHVhbGx5IHNlZSB0aGF0IGl0ZW0uXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyBhIGBzZWxlY3RlZEl0ZW1gIHByb3BlcnR5IHRvIGJlIHNldCB3aGVuIHRoZSBzZWxlY3Rpb25cbiAgICogY2hhbmdlcy4gWW91IGNhbiBzdXBwbHkgdGhhdCB5b3Vyc2VsZiwgb3IgdXNlXG4gICAqIFtTaW5nbGVTZWxlY3Rpb25NaXhpbl0oU2luZ2xlU2VsZWN0aW9uTWl4aW4ubWQpLlxuICAgKi9cbiAgY2xhc3MgU2VsZWN0aW9uSW5WaWV3IGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgICBjb25zdCBzZWxlY3RlZEl0ZW0gPSB0aGlzLnNlbGVjdGVkSXRlbTtcbiAgICAgIGlmIChzZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgdGhpcy5zY3JvbGxJdGVtSW50b1ZpZXcoc2VsZWN0ZWRJdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRJdGVtKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnNlbGVjdGVkSXRlbTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkSXRlbShpdGVtKSB7XG4gICAgICBpZiAoJ3NlbGVjdGVkSXRlbScgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRJdGVtID0gaXRlbTsgfVxuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgLy8gS2VlcCB0aGUgc2VsZWN0ZWQgaXRlbSBpbiB2aWV3LlxuICAgICAgICB0aGlzLnNjcm9sbEl0ZW1JbnRvVmlldyhpdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGwgdGhlIGdpdmVuIGVsZW1lbnQgY29tcGxldGVseSBpbnRvIHZpZXcsIG1pbmltaXppbmcgdGhlIGRlZ3JlZSBvZlxuICAgICAqIHNjcm9sbGluZyBwZXJmb3JtZWQuXG4gICAgICpcbiAgICAgKiBCbGluayBoYXMgYSBgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCgpYCBmdW5jdGlvbiB0aGF0IGRvZXMgc29tZXRoaW5nXG4gICAgICogc2ltaWxhciwgYnV0IHVuZm9ydHVuYXRlbHkgaXQncyBub24tc3RhbmRhcmQsIGFuZCBpbiBhbnkgZXZlbnQgb2Z0ZW4gZW5kc1xuICAgICAqIHVwIHNjcm9sbGluZyBtb3JlIHRoYW4gaXMgYWJzb2x1dGVseSBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIC0gdGhlIGl0ZW0gdG8gc2Nyb2xsIGludG8gdmlldy5cbiAgICAgKi9cbiAgICBzY3JvbGxJdGVtSW50b1ZpZXcoaXRlbSkge1xuICAgICAgaWYgKHN1cGVyLnNjcm9sbEl0ZW1JbnRvVmlldykgeyBzdXBlci5zY3JvbGxJdGVtSW50b1ZpZXcoKTsgfVxuICAgICAgLy8gR2V0IHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSB3aXRoIHJlc3BlY3QgdG8gdGhlIHRvcCBvZiB0aGVcbiAgICAgIC8vIGxpc3QncyBzY3JvbGxhYmxlIGNhbnZhcy4gQW4gaXRlbSBhdCB0aGUgdG9wIG9mIHRoZSBsaXN0IHdpbGwgaGF2ZSBhXG4gICAgICAvLyBlbGVtZW50VG9wIG9mIDAuXG5cbiAgICAgIGNvbnN0IHNjcm9sbFRhcmdldCA9IHRoaXMuc2Nyb2xsVGFyZ2V0O1xuICAgICAgY29uc3QgZWxlbWVudFRvcCA9IGl0ZW0ub2Zmc2V0VG9wIC0gc2Nyb2xsVGFyZ2V0Lm9mZnNldFRvcCAtIHNjcm9sbFRhcmdldC5jbGllbnRUb3A7XG4gICAgICBjb25zdCBlbGVtZW50Qm90dG9tID0gZWxlbWVudFRvcCArIGl0ZW0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBib3R0b20gb2YgdGhlIHNjcm9sbGFibGUgY2FudmFzLlxuICAgICAgY29uc3Qgc2Nyb2xsQm90dG9tID0gc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCArIHNjcm9sbFRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgICBpZiAoZWxlbWVudEJvdHRvbSA+IHNjcm9sbEJvdHRvbSkge1xuICAgICAgICAvLyBTY3JvbGwgdXAgdW50aWwgaXRlbSBpcyBlbnRpcmVseSB2aXNpYmxlLlxuICAgICAgICBzY3JvbGxUYXJnZXQuc2Nyb2xsVG9wICs9IGVsZW1lbnRCb3R0b20gLSBzY3JvbGxCb3R0b207XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbGVtZW50VG9wIDwgc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCkge1xuICAgICAgICAvLyBTY3JvbGwgZG93biB1bnRpbCBpdGVtIGlzIGVudGlyZWx5IHZpc2libGUuXG4gICAgICAgIHNjcm9sbFRhcmdldC5zY3JvbGxUb3AgPSBlbGVtZW50VG9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHNjcm9sbGVkIHRvIGJyaW5nIGFuIGl0ZW0gaW50byB2aWV3LlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSBpcyB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0IHNjcm9sbFRhcmdldCgpIHtcbiAgICAgIC8vIFByZWZlciBiYXNlIHJlc3VsdC5cbiAgICAgIHJldHVybiAnc2Nyb2xsVGFyZ2V0JyBpbiBiYXNlLnByb3RvdHlwZSA/IHN1cGVyLnNjcm9sbFRhcmdldCA6IHRoaXM7XG4gICAgfVxuICAgIHNldCBzY3JvbGxUYXJnZXQoZWxlbWVudCkge1xuICAgICAgaWYgKCdzY3JvbGxUYXJnZXQnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNjcm9sbFRhcmdldCA9IGVsZW1lbnQ7IH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBTZWxlY3Rpb25JblZpZXc7XG59O1xuIiwiLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTaGFkb3dFbGVtZW50UmVmZXJlbmNlcy4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHRvIGNyZWF0ZSByZWZlcmVuY2VzIHRvIGVsZW1lbnRzIGluIGEgY29tcG9uZW50J3MgU2hhZG93IERPTSBzdWJ0cmVlLlxuICAgKlxuICAgKiBUaGlzIGFkZHMgYSBtZW1iZXIgb24gdGhlIGNvbXBvbmVudCBjYWxsZWQgYHRoaXMuJGAgdGhhdCBjYW4gYmUgdXNlZCB0b1xuICAgKiByZWZlcmVuY2Ugc2hhZG93IGVsZW1lbnRzIHdpdGggSURzLiBFLmcuLCBpZiBjb21wb25lbnQncyBzaGFkb3cgY29udGFpbnMgYW5cbiAgICogZWxlbWVudCBgPGJ1dHRvbiBpZD1cImZvb1wiPmAsIHRoZW4gdGhpcyBtaXhpbiB3aWxsIGNyZWF0ZSBhIG1lbWJlclxuICAgKiBgdGhpcy4kLmZvb2AgdGhhdCBwb2ludHMgdG8gdGhhdCBidXR0b24uXG4gICAqXG4gICAqIFN1Y2ggcmVmZXJlbmNlcyBzaW1wbGlmeSBhIGNvbXBvbmVudCdzIGFjY2VzcyB0byBpdHMgb3duIGVsZW1lbnRzLiBJblxuICAgKiBleGNoYW5nZSwgdGhpcyBtaXhpbiB0cmFkZXMgb2ZmIGEgb25lLXRpbWUgY29zdCBvZiBxdWVyeWluZyBhbGwgZWxlbWVudHMgaW5cbiAgICogdGhlIHNoYWRvdyB0cmVlIGluc3RlYWQgb2YgcGF5aW5nIGFuIG9uZ29pbmcgY29zdCB0byBxdWVyeSBmb3IgYW4gZWxlbWVudFxuICAgKiBlYWNoIHRpbWUgdGhlIGNvbXBvbmVudCB3YW50cyB0byBpbnNwZWN0IG9yIG1hbmlwdWxhdGUgaXQuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyB0aGUgY29tcG9uZW50IHRvIGRlZmluZSBhIFNoYWRvdyBET00gc3VidHJlZS4gWW91IGNhblxuICAgKiBjcmVhdGUgdGhhdCB0cmVlIHlvdXJzZWxmLCBvciBtYWtlIHVzZSBvZlxuICAgKiBbU2hhZG93VGVtcGxhdGVNaXhpbl0oU2hhZG93VGVtcGxhdGVNaXhpbi5tZCkuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gaXMgaW5zcGlyZWQgYnkgUG9seW1lcidzIFthdXRvbWF0aWNcbiAgICogbm9kZSBmaW5kaW5nXShodHRwczovL3d3dy5wb2x5bWVyLXByb2plY3Qub3JnLzEuMC9kb2NzL2Rldmd1aWRlL2xvY2FsLWRvbS5odG1sI25vZGUtZmluZGluZylcbiAgICogZmVhdHVyZS5cbiAgICovXG4gIGNsYXNzIFNoYWRvd0VsZW1lbnRSZWZlcmVuY2VzIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICBpZiAodGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIC8vIExvb2sgZm9yIGVsZW1lbnRzIGluIHRoZSBzaGFkb3cgc3VidHJlZSB0aGF0IGhhdmUgaWQgYXR0cmlidXRlcy5cbiAgICAgICAgLy8gQW4gYWx0ZXJuYXRpdmVseSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1peGluIHdvdWxkIGJlIHRvIGp1c3QgZGVmaW5lXG4gICAgICAgIC8vIGEgdGhpcy4kIGdldHRlciB0aGF0IGxhemlseSBkb2VzIHRoaXMgc2VhcmNoIHRoZSBmaXJzdCB0aW1lIHNvbWVvbmVcbiAgICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIHRoaXMuJC4gVGhhdCBtaWdodCBpbnRyb2R1Y2Ugc29tZSBjb21wbGV4aXR5IOKAkyBpZiB0aGVcbiAgICAgICAgLy8gdGhlIHRyZWUgY2hhbmdlZCBhZnRlciBpdCB3YXMgZmlyc3QgcG9wdWxhdGVkLCB0aGUgcmVzdWx0IG9mXG4gICAgICAgIC8vIHNlYXJjaGluZyBmb3IgYSBub2RlIG1pZ2h0IGJlIHNvbWV3aGF0IHVucHJlZGljdGFibGUuXG4gICAgICAgIHRoaXMuJCA9IHt9O1xuICAgICAgICBjb25zdCBub2Rlc1dpdGhJZHMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnW2lkXScpO1xuICAgICAgICBbXS5mb3JFYWNoLmNhbGwobm9kZXNXaXRoSWRzLCBub2RlID0+IHtcbiAgICAgICAgICBjb25zdCBpZCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgIHRoaXMuJFtpZF0gPSBub2RlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29sbGVjdGlvbiBvZiByZWZlcmVuY2VzIHRvIHRoZSBlbGVtZW50cyB3aXRoIElEcyBpbiBhIGNvbXBvbmVudCdzXG4gICAgICogU2hhZG93IERPTSBzdWJ0cmVlLlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAbWVtYmVyICRcbiAgICAgKi9cbiAgfVxuXG4gIHJldHVybiBTaGFkb3dFbGVtZW50UmVmZXJlbmNlcztcbn07XG4iLCJpbXBvcnQgc3ltYm9scyBmcm9tICcuLi9zcmMvc3ltYm9scyc7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTaGFkb3dUZW1wbGF0ZS4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIGZvciBzdGFtcGluZyBhIHRlbXBsYXRlIGludG8gYSBTaGFkb3cgRE9NIHN1YnRyZWUgdXBvbiBjb21wb25lbnRcbiAgICogaW5zdGFudGlhdGlvbi5cbiAgICpcbiAgICogVG8gdXNlIHRoaXMgbWl4aW4sIGRlZmluZSBhIGB0ZW1wbGF0ZWAgcHJvcGVydHkgYXMgYSBzdHJpbmcgb3IgSFRNTFxuICAgKiBgPHRlbXBsYXRlPmAgZWxlbWVudDpcbiAgICpcbiAgICogICAgIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIFNoYWRvd1RlbXBsYXRlTWl4aW4oSFRNTEVsZW1lbnQpIHtcbiAgICogICAgICAgZ2V0IFtzeW1ib2xzLnRlbXBsYXRlXSgpIHtcbiAgICogICAgICAgICByZXR1cm4gYEhlbGxvLCA8ZW0+d29ybGQ8L2VtPi5gO1xuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqXG4gICAqIFdoZW4geW91ciBjb21wb25lbnQgY2xhc3MgaXMgaW5zdGFudGlhdGVkLCBhIHNoYWRvdyByb290IHdpbGwgYmUgY3JlYXRlZCBvblxuICAgKiB0aGUgaW5zdGFuY2UsIGFuZCB0aGUgY29udGVudHMgb2YgdGhlIHRlbXBsYXRlIHdpbGwgYmUgY2xvbmVkIGludG8gdGhlXG4gICAqIHNoYWRvdyByb290LiBJZiB5b3VyIGNvbXBvbmVudCBkb2VzIG5vdCBkZWZpbmUgYSBgdGVtcGxhdGVgIHByb3BlcnR5LCB0aGlzXG4gICAqIG1peGluIGhhcyBubyBlZmZlY3QuXG4gICAqXG4gICAqIEZvciB0aGUgdGltZSBiZWluZywgdGhpcyBleHRlbnNpb24gcmV0YWlucyBzdXBwb3J0IGZvciBTaGFkb3cgRE9NIHYwLiBUaGF0XG4gICAqIHdpbGwgZXZlbnR1YWxseSBiZSBkZXByZWNhdGVkIGFzIGJyb3dzZXJzIChhbmQgdGhlIFNoYWRvdyBET00gcG9seWZpbGwpXG4gICAqIGltcGxlbWVudCBTaGFkb3cgRE9NIHYxLlxuICAgKi9cbiAgY2xhc3MgU2hhZG93VGVtcGxhdGUgZXh0ZW5kcyBiYXNlIHtcblxuICAgIC8qXG4gICAgICogSWYgdGhlIGNvbXBvbmVudCBkZWZpbmVzIGEgdGVtcGxhdGUsIGEgc2hhZG93IHJvb3Qgd2lsbCBiZSBjcmVhdGVkIG9uIHRoZVxuICAgICAqIGNvbXBvbmVudCBpbnN0YW5jZSwgYW5kIHRoZSB0ZW1wbGF0ZSBzdGFtcGVkIGludG8gaXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgbGV0IHRlbXBsYXRlID0gdGhpc1tzeW1ib2xzLnRlbXBsYXRlXTtcbiAgICAgIC8vIFRPRE86IFNhdmUgdGhlIHByb2Nlc3NlZCB0ZW1wbGF0ZSB3aXRoIHRoZSBjb21wb25lbnQncyBjbGFzcyBwcm90b3R5cGVcbiAgICAgIC8vIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBwcm9jZXNzZWQgd2l0aCBldmVyeSBpbnN0YW50aWF0aW9uLlxuICAgICAgaWYgKHRlbXBsYXRlKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBVcGdyYWRlIHBsYWluIHN0cmluZyB0byByZWFsIHRlbXBsYXRlLlxuICAgICAgICAgIHRlbXBsYXRlID0gY3JlYXRlVGVtcGxhdGVXaXRoSW5uZXJIVE1MKHRlbXBsYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwpIHtcbiAgICAgICAgICBzaGltVGVtcGxhdGVTdHlsZXModGVtcGxhdGUsIHRoaXMubG9jYWxOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBkb2N1bWVudC5pbXBvcnROb2RlKHRlbXBsYXRlLmNvbnRlbnQsIHRydWUpO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBTaGFkb3dUZW1wbGF0ZTtcbn07XG5cblxuLy8gQ29udmVydCBhIHBsYWluIHN0cmluZyBvZiBIVE1MIGludG8gYSByZWFsIHRlbXBsYXRlIGVsZW1lbnQuXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZVdpdGhJbm5lckhUTUwoaW5uZXJIVE1MKSB7XG4gIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgLy8gUkVWSUVXOiBJcyB0aGVyZSBhbiBlYXNpZXIgd2F5IHRvIGRvIHRoaXM/XG4gIC8vIFdlJ2QgbGlrZSB0byBqdXN0IHNldCBpbm5lckhUTUwgb24gdGhlIHRlbXBsYXRlIGNvbnRlbnQsIGJ1dCBzaW5jZSBpdCdzXG4gIC8vIGEgRG9jdW1lbnRGcmFnbWVudCwgdGhhdCBkb2Vzbid0IHdvcmsuXG4gIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuICB3aGlsZSAoZGl2LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgIHRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZGl2LmNoaWxkTm9kZXNbMF0pO1xuICB9XG4gIHJldHVybiB0ZW1wbGF0ZTtcbn1cblxuLy8gSW52b2tlIGJhc2ljIHN0eWxlIHNoaW1taW5nIHdpdGggU2hhZG93Q1NTLlxuZnVuY3Rpb24gc2hpbVRlbXBsYXRlU3R5bGVzKHRlbXBsYXRlLCB0YWcpIHtcbiAgd2luZG93LldlYkNvbXBvbmVudHMuU2hhZG93Q1NTLnNoaW1TdHlsaW5nKHRlbXBsYXRlLmNvbnRlbnQsIHRhZyk7XG59XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IGNhblNlbGVjdE5leHRTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2NhblNlbGVjdE5leHQnKTtcbmNvbnN0IGNhblNlbGVjdFByZXZpb3VzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdjYW5TZWxlY3RQcmV2aW91cycpO1xuY29uc3Qgc2VsZWN0aW9uUmVxdWlyZWRTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3NlbGVjdGlvblJlcXVpcmVkJyk7XG5jb25zdCBzZWxlY3Rpb25XcmFwc1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnc2VsZWN0aW9uV3JhcHMnKTtcblxuLy8gV2Ugd2FudCB0byBleHBvc2UgYm90aCBzZWxlY3RlZEluZGV4IGFuZCBzZWxlY3RlZEl0ZW0gYXMgaW5kZXBlbmRlbnRcbi8vIHByb3BlcnRpZXMgYnV0IGtlZXAgdGhlbSBpbiBzeW5jLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB1c2VyIHRvIHJlZmVyZW5jZVxuLy8gdGhlIHNlbGVjdGlvbiBieSB3aGF0ZXZlciBtZWFucyBpcyBtb3N0IG5hdHVyYWwgZm9yIHRoZWlyIHNpdHVhdGlvbi5cbi8vXG4vLyBUbyBlZmZpY2llbnRseSBrZWVwIHRoZXNlIHByb3BlcnRpZXMgaW4gc3luYywgd2UgdHJhY2sgXCJleHRlcm5hbFwiIGFuZFxuLy8gXCJpbnRlcm5hbFwiIHJlZmVyZW5jZXMgZm9yIGVhY2ggcHJvcGVydHk6XG4vL1xuLy8gVGhlIGV4dGVybmFsIGluZGV4IG9yIGl0ZW0gaXMgdGhlIG9uZSB3ZSByZXBvcnQgdG8gdGhlIG91dHNpZGUgd29ybGQgd2hlblxuLy8gYXNrZWQgZm9yIHNlbGVjdGlvbi4gIFdoZW4gaGFuZGxpbmcgYSBjaGFuZ2UgdG8gaW5kZXggb3IgaXRlbSwgd2UgdXBkYXRlIHRoZVxuLy8gZXh0ZXJuYWwgcmVmZXJlbmNlIGFzIHNvb24gYXMgcG9zc2libGUsIHNvIHRoYXQgaWYgYW55b25lIGltbWVkaWF0ZWx5IGFza3Ncbi8vIGZvciB0aGUgY3VycmVudCBzZWxlY3Rpb24sIHRoZXkgd2lsbCByZWNlaXZlIGEgc3RhYmxlIGFuc3dlci5cbi8vXG4vLyBUaGUgaW50ZXJuYWwgaW5kZXggb3IgaXRlbSB0cmFja3Mgd2hpY2hldmVyIGluZGV4IG9yIGl0ZW0gbGFzdCByZWNlaXZlZCB0aGVcbi8vIGZ1bGwgc2V0IG9mIHByb2Nlc3NpbmcuIFByb2Nlc3NpbmcgaW5jbHVkZXMgcmFpc2luZyBhIGNoYW5nZSBldmVudCBmb3IgdGhlXG4vLyBuZXcgdmFsdWUuIE9uY2Ugd2UndmUgYmVndW4gdGhhdCBwcm9jZXNzaW5nLCB3ZSBzdG9yZSB0aGUgbmV3IHZhbHVlIGFzIHRoZVxuLy8gaW50ZXJuYWwgdmFsdWUgdG8gaW5kaWNhdGUgd2UndmUgaGFuZGxlZCBpdC5cbi8vXG5jb25zdCBleHRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2V4dGVybmFsU2VsZWN0ZWRJbmRleCcpO1xuY29uc3QgZXh0ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2V4dGVybmFsU2VsZWN0ZWRJdGVtJyk7XG5jb25zdCBpbnRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2ludGVybmFsU2VsZWN0ZWRJbmRleCcpO1xuY29uc3QgaW50ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2ludGVybmFsU2VsZWN0ZWRJdGVtJyk7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTaW5nbGVTZWxlY3Rpb24uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYW5hZ2VzIHNpbmdsZS1zZWxlY3Rpb24gc2VtYW50aWNzIGZvciBpdGVtcyBpbiBhIGxpc3QuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyBhIGNvbXBvbmVudCB0byBwcm92aWRlIGFuIGBpdGVtc2AgQXJyYXkgb3IgTm9kZUxpc3Qgb2ZcbiAgICogYWxsIGVsZW1lbnRzIGluIHRoZSBsaXN0LiBBIHN0YW5kYXJkIHdheSB0byBkbyB0aGF0IHdpdGggaXMgdGhlXG4gICAqIFtDb250ZW50SXRlbXNNaXhpbl0oQ29udGVudEl0ZW1zTWl4aW4ubWQpLCB3aGljaCB0YWtlcyBhIGNvbXBvbmVudCdzXG4gICAqIGNvbnRlbnQgKHR5cGljYWxseSBpdHMgZGlzdHJpYnV0ZWQgY2hpbGRyZW4pIGFzIHRoZSBzZXQgb2YgbGlzdCBpdGVtczsgc2VlXG4gICAqIHRoYXQgbWl4aW4gZm9yIGRldGFpbHMuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gdHJhY2tzIGEgc2luZ2xlIHNlbGVjdGVkIGl0ZW0gaW4gdGhlIGxpc3QsIGFuZCBwcm92aWRlcyBtZWFucyB0b1xuICAgKiBnZXQgYW5kIHNldCB0aGF0IHN0YXRlIGJ5IGl0ZW0gcG9zaXRpb24gKGBzZWxlY3RlZEluZGV4YCkgb3IgaXRlbSBpZGVudGl0eVxuICAgKiAoYHNlbGVjdGVkSXRlbWApLiBUaGUgc2VsZWN0aW9uIGNhbiBiZSBtb3ZlZCBpbiB0aGUgbGlzdCB2aWEgdGhlIG1ldGhvZHNcbiAgICogYHNlbGVjdEZpcnN0YCwgYHNlbGVjdExhc3RgLCBgc2VsZWN0TmV4dGAsIGFuZCBgc2VsZWN0UHJldmlvdXNgLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGRvZXMgbm90IHByb2R1Y2UgYW55IHVzZXItdmlzaWJsZSBlZmZlY3RzIHRvIHJlcHJlc2VudFxuICAgKiBzZWxlY3Rpb24uIE90aGVyIG1peGlucywgc3VjaCBhc1xuICAgKiBbU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluXShTZWxlY3Rpb25BcmlhQWN0aXZlTWl4aW4ubWQpLFxuICAgKiBbU2VsZWN0aW9uSGlnaGxpZ2h0TWl4aW5dKFNlbGVjdGlvbkhpZ2hsaWdodE1peGluLm1kKSBhbmRcbiAgICogW1NlbGVjdGlvbkluVmlld01peGluXShTZWxlY3Rpb25JblZpZXdNaXhpbi5tZCksIG1vZGlmeSB0aGUgc2VsZWN0ZWQgaXRlbVxuICAgKiBpbiBjb21tb24gd2F5cyB0byBsZXQgdGhlIHVzZXIga25vdyBhIGdpdmVuIGl0ZW0gaXMgc2VsZWN0ZWQgb3Igbm90XG4gICAqIHNlbGVjdGVkLlxuICAgKi9cbiAgY2xhc3MgU2luZ2xlU2VsZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICAvLyBTZXQgZGVmYXVsdHMuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2VsZWN0aW9uUmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmVxdWlyZWQgPSB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnNlbGVjdGlvblJlcXVpcmVkO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlbGVjdGlvbldyYXBzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbldyYXBzID0gdGhpc1tzeW1ib2xzLmRlZmF1bHRzXS5zZWxlY3Rpb25XcmFwcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBzZWxlY3Rpb24gY2FuIGJlIG1vdmVkIHRvIHRoZSBuZXh0IGl0ZW0sIGZhbHNlIGlmIG5vdCAodGhlXG4gICAgICogc2VsZWN0ZWQgaXRlbSBpcyB0aGUgbGFzdCBpdGVtIGluIHRoZSBsaXN0KS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjYW5TZWxlY3ROZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbY2FuU2VsZWN0TmV4dFN5bWJvbF07XG4gICAgfVxuICAgIHNldCBjYW5TZWxlY3ROZXh0KGNhblNlbGVjdE5leHQpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ2FuU2VsZWN0TmV4dCA9IHRoaXNbY2FuU2VsZWN0TmV4dFN5bWJvbF07XG4gICAgICB0aGlzW2NhblNlbGVjdE5leHRTeW1ib2xdID0gY2FuU2VsZWN0TmV4dDtcbiAgICAgIGlmICgnY2FuU2VsZWN0TmV4dCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuY2FuU2VsZWN0TmV4dCA9IGNhblNlbGVjdE5leHQ7IH1cbiAgICAgIGlmIChjYW5TZWxlY3ROZXh0ICE9PSBwcmV2aW91c0NhblNlbGVjdE5leHQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY2FuLXNlbGVjdC1uZXh0LWNoYW5nZWQnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGNhbiBiZSBtb3ZlZCB0byB0aGUgcHJldmlvdXMgaXRlbSwgZmFsc2UgaWYgbm90XG4gICAgICogKHRoZSBzZWxlY3RlZCBpdGVtIGlzIHRoZSBmaXJzdCBvbmUgaW4gdGhlIGxpc3QpLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNhblNlbGVjdFByZXZpb3VzKCkge1xuICAgICAgcmV0dXJuIHRoaXNbY2FuU2VsZWN0UHJldmlvdXNTeW1ib2xdO1xuICAgIH1cbiAgICBzZXQgY2FuU2VsZWN0UHJldmlvdXMoY2FuU2VsZWN0UHJldmlvdXMpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ2FuU2VsZWN0UHJldmlvdXMgPSB0aGlzW2NhblNlbGVjdFByZXZpb3VzU3ltYm9sXTtcbiAgICAgIHRoaXNbY2FuU2VsZWN0UHJldmlvdXNTeW1ib2xdID0gY2FuU2VsZWN0UHJldmlvdXM7XG4gICAgICBpZiAoJ2NhblNlbGVjdFByZXZpb3VzJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5jYW5TZWxlY3RQcmV2aW91cyA9IGNhblNlbGVjdFByZXZpb3VzOyB9XG4gICAgICBpZiAoY2FuU2VsZWN0UHJldmlvdXMgIT09IHByZXZpb3VzQ2FuU2VsZWN0UHJldmlvdXMpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY2FuLXNlbGVjdC1wcmV2aW91cy1jaGFuZ2VkJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMuc2VsZWN0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgIGRlZmF1bHRzLnNlbGVjdGlvbldyYXBzID0gZmFsc2U7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEgbmV3IGl0ZW0gYmVpbmcgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBzaW1wbHkgc2V0cyB0aGUgaXRlbSdzXG4gICAgICogc2VsZWN0aW9uIHN0YXRlIHRvIGZhbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaXRlbSAtIHRoZSBpdGVtIGJlaW5nIGFkZGVkXG4gICAgICovXG4gICAgW3N5bWJvbHMuaXRlbUFkZGVkXShpdGVtKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtQWRkZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbUFkZGVkXShpdGVtKTsgfVxuICAgICAgdGhpc1tzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgaXRlbSA9PT0gdGhpcy5zZWxlY3RlZEl0ZW0pO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtc0NoYW5nZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpOyB9XG5cbiAgICAgIC8vIEluIGNhc2Ugc2VsZWN0ZWQgaXRlbSBjaGFuZ2VkIHBvc2l0aW9uIG9yIHdhcyByZW1vdmVkLlxuICAgICAgdHJhY2tTZWxlY3RlZEl0ZW0odGhpcyk7XG5cbiAgICAgIC8vIEluIGNhc2UgdGhlIGNoYW5nZSBpbiBpdGVtcyBhZmZlY3RlZCB3aGljaCBuYXZpZ2F0aW9ucyBhcmUgcG9zc2libGUuXG4gICAgICB1cGRhdGVQb3NzaWJsZU5hdmlnYXRpb25zKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBpbmRpY2F0ZSBzZWxlY3Rpb24gc3RhdGUgdG8gdGhlIGl0ZW0uXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuIFVzZXItdmlzaWJsZVxuICAgICAqIGVmZmVjdHMgd2lsbCB0eXBpY2FsbHkgYmUgaGFuZGxlZCBieSBvdGhlciBtaXhpbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIC0gdGhlIGl0ZW0gYmVpbmcgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgLSB0cnVlIGlmIHRoZSBpdGVtIGlzIHNlbGVjdGVkLCBmYWxzZSBpZiBub3RcbiAgICAgKi9cbiAgICBbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIHNlbGVjdGVkKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gd2hpY2ggaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQSBgc2VsZWN0ZWRJbmRleGAgb2YgLTEgaW5kaWNhdGVzIHRoZXJlIGlzIG5vIHNlbGVjdGlvbi4gU2V0dGluZyB0aGlzXG4gICAgICogcHJvcGVydHkgdG8gLTEgd2lsbCByZW1vdmUgYW55IGV4aXN0aW5nIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkSW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpc1tleHRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdICE9IG51bGwgP1xuICAgICAgICB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJbmRleFN5bWJvbF0gOlxuICAgICAgICAtMTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICAgIC8vIFNlZSBub3RlcyBhdCB0b3AgYWJvdXQgaW50ZXJuYWwgdnMuIGV4dGVybmFsIGNvcGllcyBvZiB0aGlzIHByb3BlcnR5LlxuICAgICAgY29uc3QgcHJldmlvdXNTZWxlY3RlZEluZGV4ID0gdGhpc1tpbnRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdO1xuICAgICAgbGV0IGl0ZW07XG4gICAgICBpZiAoaW5kZXggIT09IHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sXSkge1xuICAgICAgICAvLyBTdG9yZSB0aGUgbmV3IGluZGV4IGFuZCB0aGUgY29ycmVzcG9uZGluZyBpdGVtLlxuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIGNvbnN0IGhhc0l0ZW1zID0gaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKCEoaGFzSXRlbXMgJiYgaW5kZXggPj0gMCAmJiBpbmRleCA8IGl0ZW1zLmxlbmd0aCkpIHtcbiAgICAgICAgICBpbmRleCA9IC0xOyAvLyBObyBpdGVtIGF0IHRoYXQgaW5kZXguXG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tleHRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdID0gaW5kZXg7XG4gICAgICAgIGl0ZW0gPSBoYXNJdGVtcyAmJiBpbmRleCA+PSAwID8gaXRlbXNbaW5kZXhdIDogbnVsbDtcbiAgICAgICAgdGhpc1tleHRlcm5hbFNlbGVjdGVkSXRlbVN5bWJvbF0gPSBpdGVtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbSA9IHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2xdO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3cgbGV0IHN1cGVyIGRvIGFueSB3b3JrLlxuICAgICAgaWYgKCdzZWxlY3RlZEluZGV4JyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3RlZEluZGV4ID0gaW5kZXg7IH1cblxuICAgICAgaWYgKGluZGV4ICE9PSBwcmV2aW91c1NlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdGVkIGluZGV4IGNoYW5nZWQuXG4gICAgICAgIHRoaXNbaW50ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sXSA9IGluZGV4O1xuXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzZWxlY3RlZC1pbmRleC1jaGFuZ2VkJywge1xuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleDogaW5kZXgsXG4gICAgICAgICAgICB2YWx1ZTogaW5kZXggLy8gZm9yIFBvbHltZXIgYmluZGluZy4gVE9ETzogVmVyaWZ5IHN0aWxsIG5lY2Vzc2FyeVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2ludGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sXSAhPT0gaXRlbSkge1xuICAgICAgICAvLyBVcGRhdGUgc2VsZWN0ZWRJdGVtIHByb3BlcnR5IHNvIGl0IGNhbiBoYXZlIGl0cyBvd24gZWZmZWN0cy5cbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSwgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gbnVsbCBkZXNlbGVjdHMgYW55IGN1cnJlbnRseS1zZWxlY3RlZCBpdGVtLlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB0byBhbiBvYmplY3QgdGhhdCBpcyBub3QgaW4gdGhlIGxpc3QgaGFzIG5vIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIFRPRE86IEV2ZW4gaWYgc2VsZWN0aW9uUmVxdWlyZWQsIGNhbiBzdGlsbCBleHBsaWNpdGx5IHNldCBzZWxlY3RlZEl0ZW0gdG8gbnVsbC5cbiAgICAgKiBUT0RPOiBJZiBzZWxlY3Rpb25SZXF1aXJlZCwgbGVhdmUgc2VsZWN0aW9uIGFsb25lP1xuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWRJdGVtKCkge1xuICAgICAgcmV0dXJuIHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2xdIHx8IG51bGw7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEl0ZW0oaXRlbSkge1xuICAgICAgLy8gU2VlIG5vdGVzIGF0IHRvcCBhYm91dCBpbnRlcm5hbCB2cy4gZXh0ZXJuYWwgY29waWVzIG9mIHRoaXMgcHJvcGVydHkuXG4gICAgICBjb25zdCBwcmV2aW91c1NlbGVjdGVkSXRlbSA9IHRoaXNbaW50ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2xdO1xuICAgICAgbGV0IGluZGV4O1xuICAgICAgaWYgKGl0ZW0gIT09IHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2xdKSB7XG4gICAgICAgIC8vIFN0b3JlIGl0ZW0gYW5kIGxvb2sgdXAgY29ycmVzcG9uZGluZyBpbmRleC5cbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICBjb25zdCBoYXNJdGVtcyA9IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDA7XG4gICAgICAgIGluZGV4ID0gaGFzSXRlbXMgPyBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGl0ZW1zLCBpdGVtKSA6IC0xO1xuICAgICAgICB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJbmRleFN5bWJvbF0gPSBpbmRleDtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGl0ZW0gPSBudWxsOyAvLyBUaGUgaW5kaWNhdGVkIGl0ZW0gaXNuJ3QgYWN0dWFsbHkgaW4gYGl0ZW1zYC5cbiAgICAgICAgfVxuICAgICAgICB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sXSA9IGl0ZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sXTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93IGxldCBzdXBlciBkbyBhbnkgd29yay5cbiAgICAgIGlmICgnc2VsZWN0ZWRJdGVtJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3RlZEl0ZW0gPSBpdGVtOyB9XG5cbiAgICAgIGlmIChpdGVtICE9PSBwcmV2aW91c1NlbGVjdGVkSXRlbSkge1xuICAgICAgICAvLyBUaGUgc2VsZWN0ZWQgaXRlbSBjaGFuZ2VkLlxuICAgICAgICB0aGlzW2ludGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sXSA9IGl0ZW07XG5cbiAgICAgICAgaWYgKHByZXZpb3VzU2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHNlbGVjdGlvbiBzdGF0ZSBvZiBvbGQgaXRlbS5cbiAgICAgICAgICB0aGlzW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShwcmV2aW91c1NlbGVjdGVkSXRlbSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHNlbGVjdGlvbiBzdGF0ZSB0byBuZXcgaXRlbS5cbiAgICAgICAgICB0aGlzW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZVBvc3NpYmxlTmF2aWdhdGlvbnModGhpcyk7XG5cbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3NlbGVjdGVkLWl0ZW0tY2hhbmdlZCcsIHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIHNlbGVjdGVkSXRlbTogaXRlbSxcbiAgICAgICAgICAgIHZhbHVlOiBpdGVtIC8vIGZvciBQb2x5bWVyIGJpbmRpbmdcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tpbnRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdICE9PSBpbmRleCkge1xuICAgICAgICAvLyBVcGRhdGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eSBzbyBpdCBjYW4gaGF2ZSBpdHMgb3duIGVmZmVjdHMuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBzZWxlY3RGaXJzdCgpIHtcbiAgICAgIGlmIChzdXBlci5zZWxlY3RGaXJzdCkgeyBzdXBlci5zZWxlY3RGaXJzdCgpOyB9XG4gICAgICByZXR1cm4gc2VsZWN0SW5kZXgodGhpcywgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgbGlzdCBzaG91bGQgYWx3YXlzIGhhdmUgYSBzZWxlY3Rpb24gKGlmIGl0IGhhcyBpdGVtcykuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25SZXF1aXJlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzW3NlbGVjdGlvblJlcXVpcmVkU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGlvblJlcXVpcmVkKHNlbGVjdGlvblJlcXVpcmVkKSB7XG4gICAgICB0aGlzW3NlbGVjdGlvblJlcXVpcmVkU3ltYm9sXSA9IHNlbGVjdGlvblJlcXVpcmVkO1xuICAgICAgaWYgKCdzZWxlY3Rpb25SZXF1aXJlZCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0aW9uUmVxdWlyZWQgPSBzZWxlY3Rpb25SZXF1aXJlZDsgfVxuICAgICAgdHJhY2tTZWxlY3RlZEl0ZW0odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBzZWxlY3Rpb24gbmF2aWdhdGlvbnMgd3JhcCBmcm9tIGxhc3QgdG8gZmlyc3QsIGFuZCB2aWNlIHZlcnNhLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uV3JhcHMoKSB7XG4gICAgICByZXR1cm4gdGhpc1tzZWxlY3Rpb25XcmFwc1N5bWJvbF07XG4gICAgfVxuICAgIHNldCBzZWxlY3Rpb25XcmFwcyh2YWx1ZSkge1xuICAgICAgdGhpc1tzZWxlY3Rpb25XcmFwc1N5bWJvbF0gPSBTdHJpbmcodmFsdWUpID09PSAndHJ1ZSc7XG4gICAgICBpZiAoJ3NlbGVjdGlvbldyYXBzJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3Rpb25XcmFwcyA9IHZhbHVlOyB9XG4gICAgICB1cGRhdGVQb3NzaWJsZU5hdmlnYXRpb25zKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgbGFzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIHNlbGVjdExhc3QoKSB7XG4gICAgICBpZiAoc3VwZXIuc2VsZWN0TGFzdCkgeyBzdXBlci5zZWxlY3RMYXN0KCk7IH1cbiAgICAgIHJldHVybiBzZWxlY3RJbmRleCh0aGlzLCB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgbmV4dCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIHNlbGVjdE5leHQoKSB7XG4gICAgICBpZiAoc3VwZXIuc2VsZWN0TmV4dCkgeyBzdXBlci5zZWxlY3ROZXh0KCk7IH1cbiAgICAgIHJldHVybiBzZWxlY3RJbmRleCh0aGlzLCB0aGlzLnNlbGVjdGVkSW5kZXggKyAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIHByZXZpb3VzIGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgbGlzdCBoYXMgbm8gc2VsZWN0aW9uLCB0aGUgbGFzdCBpdGVtIHdpbGwgYmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgc2VsZWN0UHJldmlvdXMoKSB7XG4gICAgICBpZiAoc3VwZXIuc2VsZWN0UHJldmlvdXMpIHsgc3VwZXIuc2VsZWN0UHJldmlvdXMoKTsgfVxuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXggPCAwID9cbiAgICAgICAgdGhpcy5pdGVtcy5sZW5ndGggLSAxIDogICAgIC8vIE5vIHNlbGVjdGlvbiB5ZXQ7IHNlbGVjdCBsYXN0IGl0ZW0uXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCAtIDE7XG4gICAgICByZXR1cm4gc2VsZWN0SW5kZXgodGhpcywgbmV3SW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHNlbGVjdGVkSXRlbSBwcm9wZXJ0eSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFNpbmdsZVNlbGVjdGlvblxuICAgICAqIEBldmVudCBzZWxlY3RlZC1pdGVtLWNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkZXRhaWwuc2VsZWN0ZWRJdGVtIFRoZSBuZXcgc2VsZWN0ZWQgaXRlbS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkZXRhaWwucHJldmlvdXNJdGVtIFRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIGl0ZW0uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgU2luZ2xlU2VsZWN0aW9uXG4gICAgICogQGV2ZW50IHNlbGVjdGVkLWluZGV4LWNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGV0YWlsLnNlbGVjdGVkSW5kZXggVGhlIG5ldyBzZWxlY3RlZCBpbmRleC5cbiAgICAgKi9cblxuICB9XG5cbiAgcmV0dXJuIFNpbmdsZVNlbGVjdGlvbjtcbn07XG5cblxuLy8gRW5zdXJlIHRoZSBnaXZlbiBpbmRleCBpcyB3aXRoaW4gYm91bmRzLCBhbmQgc2VsZWN0IGl0IGlmIGl0J3Mgbm90IGFscmVhZHlcbi8vIHNlbGVjdGVkLlxuZnVuY3Rpb24gc2VsZWN0SW5kZXgoZWxlbWVudCwgaW5kZXgpIHtcbiAgY29uc3QgY291bnQgPSBlbGVtZW50Lml0ZW1zLmxlbmd0aDtcblxuICBjb25zdCBib3VuZGVkSW5kZXggPSAoZWxlbWVudC5zZWxlY3Rpb25XcmFwcykgP1xuICAgIC8vIEphdmFTY3JpcHQgbW9kIGRvZXNuJ3QgaGFuZGxlIG5lZ2F0aXZlIG51bWJlcnMgdGhlIHdheSB3ZSB3YW50IHRvIHdyYXAuXG4gICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE4NjE4MjUwLzc2NDcyXG4gICAgKChpbmRleCAlIGNvdW50KSArIGNvdW50KSAlIGNvdW50IDpcblxuICAgIC8vIEtlZXAgaW5kZXggd2l0aGluIGJvdW5kcyBvZiBhcnJheS5cbiAgICBNYXRoLm1heChNYXRoLm1pbihpbmRleCwgY291bnQgLSAxKSwgMCk7XG5cbiAgY29uc3QgcHJldmlvdXNJbmRleCA9IGVsZW1lbnQuc2VsZWN0ZWRJbmRleDtcbiAgaWYgKHByZXZpb3VzSW5kZXggIT09IGJvdW5kZWRJbmRleCkge1xuICAgIGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA9IGJvdW5kZWRJbmRleDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gRm9sbG93aW5nIGEgY2hhbmdlIGluIHRoZSBzZXQgb2YgaXRlbXMsIG9yIGluIHRoZSB2YWx1ZSBvZiB0aGVcbi8vIGBzZWxlY3Rpb25SZXF1aXJlZGAgcHJvcGVydHksIHJlYWNxdWlyZSB0aGUgc2VsZWN0ZWQgaXRlbS4gSWYgaXQncyBtb3ZlZCxcbi8vIHVwZGF0ZSBgc2VsZWN0ZWRJbmRleGAuIElmIGl0J3MgYmVlbiByZW1vdmVkLCBhbmQgYSBzZWxlY3Rpb24gaXMgcmVxdWlyZWQsXG4vLyB0cnkgdG8gc2VsZWN0IGFub3RoZXIgaXRlbS5cbmZ1bmN0aW9uIHRyYWNrU2VsZWN0ZWRJdGVtKGVsZW1lbnQpIHtcblxuICBjb25zdCBpdGVtcyA9IGVsZW1lbnQuaXRlbXM7XG4gIGNvbnN0IGl0ZW1Db3VudCA9IGl0ZW1zID8gaXRlbXMubGVuZ3RoIDogMDtcblxuICBjb25zdCBwcmV2aW91c1NlbGVjdGVkSXRlbSA9IGVsZW1lbnQuc2VsZWN0ZWRJdGVtO1xuICBpZiAoIXByZXZpb3VzU2VsZWN0ZWRJdGVtKSB7XG4gICAgLy8gTm8gaXRlbSB3YXMgcHJldmlvdXNseSBzZWxlY3RlZC5cbiAgICBpZiAoZWxlbWVudC5zZWxlY3Rpb25SZXF1aXJlZCkge1xuICAgICAgLy8gU2VsZWN0IHRoZSBmaXJzdCBpdGVtIGJ5IGRlZmF1bHQuXG4gICAgICBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSAwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVtQ291bnQgPT09IDApIHtcbiAgICAvLyBXZSd2ZSBsb3N0IHRoZSBzZWxlY3Rpb24sIGFuZCB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBzZWxlY3QuXG4gICAgZWxlbWVudC5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIFRyeSB0byBmaW5kIHRoZSBwcmV2aW91c2x5LXNlbGVjdGVkIGl0ZW0gaW4gdGhlIGN1cnJlbnQgc2V0IG9mIGl0ZW1zLlxuICAgIGNvbnN0IGluZGV4SW5DdXJyZW50SXRlbXMgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGl0ZW1zLCBwcmV2aW91c1NlbGVjdGVkSXRlbSk7XG4gICAgY29uc3QgcHJldmlvdXNTZWxlY3RlZEluZGV4ID0gZWxlbWVudC5zZWxlY3RlZEluZGV4O1xuICAgIGlmIChpbmRleEluQ3VycmVudEl0ZW1zIDwgMCkge1xuICAgICAgLy8gUHJldmlvdXNseS1zZWxlY3RlZCBpdGVtIHdhcyByZW1vdmVkIGZyb20gdGhlIGl0ZW1zLlxuICAgICAgLy8gU2VsZWN0IHRoZSBpdGVtIGF0IHRoZSBzYW1lIGluZGV4IChpZiBpdCBleGlzdHMpIG9yIGFzIGNsb3NlIGFzIHBvc3NpYmxlLlxuICAgICAgY29uc3QgbmV3U2VsZWN0ZWRJbmRleCA9IE1hdGgubWluKHByZXZpb3VzU2VsZWN0ZWRJbmRleCwgaXRlbUNvdW50IC0gMSk7XG4gICAgICAvLyBTZWxlY3QgYnkgaXRlbSwgc2luY2UgaW5kZXggbWF5IGJlIHRoZSBzYW1lLCBhbmQgd2Ugd2FudCB0byByYWlzZSB0aGVcbiAgICAgIC8vIHNlbGVjdGVkLWl0ZW0tY2hhbmdlZCBldmVudC5cbiAgICAgIGVsZW1lbnQuc2VsZWN0ZWRJdGVtID0gaXRlbXNbbmV3U2VsZWN0ZWRJbmRleF07XG4gICAgfSBlbHNlIGlmIChpbmRleEluQ3VycmVudEl0ZW1zICE9PSBwcmV2aW91c1NlbGVjdGVkSW5kZXgpIHtcbiAgICAgIC8vIFByZXZpb3VzbHktc2VsZWN0ZWQgaXRlbSBzdGlsbCB0aGVyZSwgYnV0IGNoYW5nZWQgcG9zaXRpb24uXG4gICAgICBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSBpbmRleEluQ3VycmVudEl0ZW1zO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGb2xsb3dpbmcgYSBjaGFuZ2UgaW4gc2VsZWN0aW9uLCByZXBvcnQgd2hldGhlciBpdCdzIG5vdyBwb3NzaWJsZSB0b1xuLy8gZ28gbmV4dC9wcmV2aW91cyBmcm9tIHRoZSBnaXZlbiBpbmRleC5cbmZ1bmN0aW9uIHVwZGF0ZVBvc3NpYmxlTmF2aWdhdGlvbnMoZWxlbWVudCkge1xuICBsZXQgY2FuU2VsZWN0TmV4dDtcbiAgbGV0IGNhblNlbGVjdFByZXZpb3VzO1xuICBjb25zdCBpdGVtcyA9IGVsZW1lbnQuaXRlbXM7XG4gIGlmIChpdGVtcyA9PSBudWxsIHx8IGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIE5vIGl0ZW1zIHRvIHNlbGVjdC5cbiAgICBjYW5TZWxlY3ROZXh0ID0gZmFsc2U7XG4gICAgY2FuU2VsZWN0UHJldmlvdXMgPSBmYWxzZTtcbiAgfSBpZiAoZWxlbWVudC5zZWxlY3Rpb25XcmFwcykge1xuICAgIC8vIFNpbmNlIHRoZXJlIGFyZSBpdGVtcywgY2FuIGFsd2F5cyBnbyBuZXh0L3ByZXZpb3VzLlxuICAgIGNhblNlbGVjdE5leHQgPSB0cnVlO1xuICAgIGNhblNlbGVjdFByZXZpb3VzID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpbmRleCA9IGVsZW1lbnQuc2VsZWN0ZWRJbmRleDtcbiAgICBpZiAoaW5kZXggPCAwICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZS4gSWYgdGhlcmUgYXJlIGl0ZW1zIGJ1dCBubyBzZWxlY3Rpb24sIGRlY2xhcmUgdGhhdCBpdCdzXG4gICAgICAvLyBhbHdheXMgcG9zc2libGUgdG8gZ28gbmV4dC9wcmV2aW91cyB0byBjcmVhdGUgYSBzZWxlY3Rpb24uXG4gICAgICBjYW5TZWxlY3ROZXh0ID0gdHJ1ZTtcbiAgICAgIGNhblNlbGVjdFByZXZpb3VzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9ybWFsIGNhc2U6IHdlIGhhdmUgYW4gaW5kZXggaW4gYSBsaXN0IHRoYXQgaGFzIGl0ZW1zLlxuICAgICAgY2FuU2VsZWN0UHJldmlvdXMgPSAoaW5kZXggPiAwKTtcbiAgICAgIGNhblNlbGVjdE5leHQgPSAoaW5kZXggPCBpdGVtcy5sZW5ndGggLSAxKTtcbiAgICB9XG4gIH1cbiAgaWYgKGVsZW1lbnQuY2FuU2VsZWN0TmV4dCAhPT0gY2FuU2VsZWN0TmV4dCkge1xuICAgIGVsZW1lbnQuY2FuU2VsZWN0TmV4dCA9IGNhblNlbGVjdE5leHQ7XG4gIH1cbiAgaWYgKGVsZW1lbnQuY2FuU2VsZWN0UHJldmlvdXMgIT09IGNhblNlbGVjdFByZXZpb3VzKSB7XG4gICAgZWxlbWVudC5jYW5TZWxlY3RQcmV2aW91cyA9IGNhblNlbGVjdFByZXZpb3VzO1xuICB9XG59XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IGRlbHRhWFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnZGVsdGFYJyk7XG5jb25zdCBkZWx0YVlTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2RlbHRhWScpO1xuY29uc3QgbXVsdGlUb3VjaFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbXVsdGlUb3VjaCcpO1xuY29uc3QgcHJldmlvdXNYU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdwcmV2aW91c1gnKTtcbmNvbnN0IHByZXZpb3VzWVN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncHJldmlvdXNZJyk7XG5jb25zdCBzdGFydFhTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3N0YXJ0WCcpO1xuY29uc3QgdHJhdmVsRnJhY3Rpb25TeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3RyYXZlbEZyYWN0aW9uJyk7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTd2lwZURpcmVjdGlvbi4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIG1hcHMgdG91Y2ggZ2VzdHVyZXMgKHN3aXBlIGxlZnQsIHN3aXBlIHJpZ2h0KSB0byBkaXJlY3Rpb25cbiAgICogc2VtYW50aWNzIChnbyByaWdodCwgZ28gbGVmdCkuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgbWl4aW4gcHJlc2VudHMgbm8gdXNlci12aXNpYmxlIGVmZmVjdHM7IGl0IGp1c3QgaW5kaWNhdGVzXG4gICAqIGEgZGlyZWN0aW9uIGluIHdoaWNoIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBzd2lwaW5nIG9yIGhhcyBmaW5pc2hlZCBzd2lwaW5nLlxuICAgKiBUbyBtYXAgdGhlIGRpcmVjdGlvbiB0byBhIGNoYW5nZSBpbiBzZWxlY3Rpb24sIHVzZVxuICAgKiBbRGlyZWN0aW9uU2VsZWN0aW9uTWl4aW5dKERpcmVjdGlvblNlbGVjdGlvbk1peGluLm1kKS5cbiAgICovXG4gIGNsYXNzIFN3aXBlRGlyZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG5cbiAgICAgIHRoaXMudHJhdmVsRnJhY3Rpb24gPSAwO1xuXG4gICAgICAvLyBJbiBhbGwgdG91Y2ggZXZlbnRzLCBvbmx5IGhhbmRsZSBzaW5nbGUgdG91Y2hlcy4gV2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gaW5hZHZlcnRlbnRseSBkbyB3b3JrIHdoZW4gdGhlIHVzZXIncyB0cnlpbmcgdG8gcGluY2gtem9vbSBmb3IgZXhhbXBsZS5cbiAgICAgIC8vIFRPRE86IEV2ZW4gYmV0dGVyIGFwcHJvYWNoIHRoYW4gYmVsb3cgd291bGQgYmUgdG8gaWdub3JlIHRvdWNoZXMgYWZ0ZXJcbiAgICAgIC8vIHRoZSBmaXJzdCBpZiB0aGUgdXNlciBoYXMgYWxyZWFkeSBiZWd1biBhIHN3aXBlLlxuICAgICAgLy8gVE9ETzogVG91Y2ggZXZlbnRzIHNob3VsZCBwcm9iYWJseSBiZSBmYWN0b3JlZCBvdXQgaW50byBpdHMgb3duIG1peGluLlxuICAgICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICAgICAgLy8gUHJlZmVyIGxpc3RlbmluZyB0byBzdGFuZGFyZCBwb2ludGVyIGV2ZW50cy5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoaXNFdmVudEZvclBlbk9yUHJpbWFyeVRvdWNoKGV2ZW50KSkge1xuICAgICAgICAgICAgdG91Y2hTdGFydCh0aGlzLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChpc0V2ZW50Rm9yUGVuT3JQcmltYXJ5VG91Y2goZXZlbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVkID0gdG91Y2hNb3ZlKHRoaXMsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoaXNFdmVudEZvclBlbk9yUHJpbWFyeVRvdWNoKGV2ZW50KSkge1xuICAgICAgICAgICAgdG91Y2hFbmQodGhpcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBvaW50ZXIgZXZlbnRzIG5vdCBzdXBwb3J0ZWQgLS0gbGlzdGVuIHRvIG9sZGVyIHRvdWNoIGV2ZW50cy5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmICh0aGlzW211bHRpVG91Y2hTeW1ib2xdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50WCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRZID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgICAgIHRvdWNoU3RhcnQodGhpcywgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbbXVsdGlUb3VjaFN5bWJvbF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmICghdGhpc1ttdWx0aVRvdWNoU3ltYm9sXSAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50WCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRZID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZWQgPSB0b3VjaE1vdmUodGhpcywgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBBbGwgdG91Y2hlcyByZW1vdmVkOyBnZXN0dXJlIGlzIGNvbXBsZXRlLlxuICAgICAgICAgICAgaWYgKCF0aGlzW211bHRpVG91Y2hTeW1ib2xdKSB7XG4gICAgICAgICAgICAgIC8vIFNpbmdsZS10b3VjaCBzd2lwZSBoYXMgZmluaXNoZWQuXG4gICAgICAgICAgICAgIGNvbnN0IGNsaWVudFggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgICAgICBjb25zdCBjbGllbnRZID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgICAgICAgdG91Y2hFbmQodGhpcywgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW211bHRpVG91Y2hTeW1ib2xdID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG5cbiAgICAgIC8vIEZvciB0aGUgY29tcG9uZW50IHRvIHJlY2VpdmUgUG9pbnRlckV2ZW50cyBpbiBJRS9FZGdlLCB3ZSBuZWVkIHRvIHNldFxuICAgICAgLy8gdG91Y2gtYWN0aW9uOiBub25lLiBPbmx5IG1ha2UgdGhpcyBjaGFuZ2UgaWYgdG91Y2gtYWN0aW9uIGlzIGN1cnJlbnRseVxuICAgICAgLy8gdGhlIGRlZmF1bHQgdmFsdWUgKFwiYXV0b1wiKSwgaW4gY2FzZSB0aGUgZGV2ZWxvcGVyIGtub3dzIGJldHRlciB0aGFuIHdlXG4gICAgICAvLyBkbyB3aGF0IHRoZXkgd2FudCBpbiB0aGVpciBwYXJ0aWN1bGFyIGNvbnRleHQuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS50b3VjaEFjdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHRoaXMuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbi5cbiAgICBnZXQgW3N5bWJvbHMuZHJhZ2dpbmddKCkge1xuICAgICAgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZHJhZ2dpbmddO1xuICAgIH1cbiAgICBzZXQgW3N5bWJvbHMuZHJhZ2dpbmddKHZhbHVlKSB7XG4gICAgICBpZiAoc3ltYm9scy5kcmFnZ2luZyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlcltzeW1ib2xzLmRyYWdnaW5nXSA9IHZhbHVlOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIGxlZnQuXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgICAqL1xuICAgIFtzeW1ib2xzLmdvTGVmdF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0xlZnRdKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvTGVmdF0oKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSByaWdodC5cbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICovXG4gICAgW3N5bWJvbHMuZ29SaWdodF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb1JpZ2h0XSkgeyByZXR1cm4gc3VwZXJbc3ltYm9scy5nb1JpZ2h0XSgpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIHRoZSBmaXJzdCB0b3VjaHBvaW50IGhhcyB0cmF2ZWxlZCBzaW5jZSB0aGUgYmVnaW5uaW5nIG9mIGFcbiAgICAgKiBkcmFnLCBleHByZXNzZWQgYXMgYSBmcmFjdGlvbiBvZiB0aGUgZWxlbWVudCdzIHdpZHRoLlxuICAgICAqXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IHRyYXZlbEZyYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNbdHJhdmVsRnJhY3Rpb25TeW1ib2xdO1xuICAgIH1cbiAgICBzZXQgdHJhdmVsRnJhY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXNbdHJhdmVsRnJhY3Rpb25TeW1ib2xdID0gdmFsdWU7XG4gICAgICBpZiAoJ3RyYXZlbEZyYWN0aW9uJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci50cmF2ZWxGcmFjdGlvbiA9IHZhbHVlOyB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gU3dpcGVEaXJlY3Rpb247XG59O1xuXG5cbi8vIFJldHVybiB0cnVlIGlmIHRoZSBwb2ludGVyIGV2ZW50IGlzIGZvciB0aGUgcGVuLCBvciB0aGUgcHJpbWFyeSB0b3VjaCBwb2ludC5cbmZ1bmN0aW9uIGlzRXZlbnRGb3JQZW5PclByaW1hcnlUb3VjaChldmVudCkge1xuICByZXR1cm4gZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nIHx8XG4gICAgICAoZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgJiYgZXZlbnQuaXNQcmltYXJ5KTtcbn1cblxuLypcbiAqIEludm9rZWQgd2hlbiB0aGUgdXNlciBoYXMgZmluaXNoZWQgYSB0b3VjaCBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHRvdWNoRW5kKGVsZW1lbnQsIGNsaWVudFgsIGNsaWVudFkpIHtcbiAgZWxlbWVudFtzeW1ib2xzLmRyYWdnaW5nXSA9IGZhbHNlO1xuICBpZiAoZWxlbWVudFtkZWx0YVhTeW1ib2xdID49IDIwKSB7XG4gICAgLy8gRmluaXNoZWQgZ29pbmcgcmlnaHQgYXQgaGlnaCBzcGVlZC5cbiAgICBlbGVtZW50W3N5bWJvbHMuZ29MZWZ0XSgpO1xuICB9IGVsc2UgaWYgKGVsZW1lbnRbZGVsdGFYU3ltYm9sXSA8PSAtMjApIHtcbiAgICAvLyBGaW5pc2hlZCBnb2luZyBsZWZ0IGF0IGhpZ2ggc3BlZWQuXG4gICAgZWxlbWVudFtzeW1ib2xzLmdvUmlnaHRdKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmluaXNoZWQgYXQgbG93IHNwZWVkLlxuICAgIHRyYWNrVG8oZWxlbWVudCwgY2xpZW50WCk7XG4gICAgY29uc3QgdHJhdmVsRnJhY3Rpb24gPSBlbGVtZW50LnRyYXZlbEZyYWN0aW9uO1xuICAgIGlmICh0cmF2ZWxGcmFjdGlvbiA+PSAwLjUpIHtcbiAgICAgIGVsZW1lbnRbc3ltYm9scy5nb1JpZ2h0XSgpO1xuICAgIH0gZWxzZSBpZiAodHJhdmVsRnJhY3Rpb24gPD0gLTAuNSkge1xuICAgICAgZWxlbWVudFtzeW1ib2xzLmdvTGVmdF0oKTtcbiAgICB9XG4gIH1cbiAgZWxlbWVudC50cmF2ZWxGcmFjdGlvbiA9IDA7XG4gIGVsZW1lbnRbZGVsdGFYU3ltYm9sXSA9IG51bGw7XG4gIGVsZW1lbnRbZGVsdGFZU3ltYm9sXSA9IG51bGw7XG59XG5cbi8qXG4gKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgaGFzIG1vdmVkIGR1cmluZyBhIHRvdWNoIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG91Y2hNb3ZlKGVsZW1lbnQsIGNsaWVudFgsIGNsaWVudFkpIHtcblxuICBlbGVtZW50W2RlbHRhWFN5bWJvbF0gPSBjbGllbnRYIC0gZWxlbWVudFtwcmV2aW91c1hTeW1ib2xdO1xuICBlbGVtZW50W2RlbHRhWVN5bWJvbF0gPSBjbGllbnRZIC0gZWxlbWVudFtwcmV2aW91c1lTeW1ib2xdO1xuICBlbGVtZW50W3ByZXZpb3VzWFN5bWJvbF0gPSBjbGllbnRYO1xuICBlbGVtZW50W3ByZXZpb3VzWVN5bWJvbF0gPSBjbGllbnRZO1xuICBpZiAoTWF0aC5hYnMoZWxlbWVudFtkZWx0YVhTeW1ib2xdKSA+IE1hdGguYWJzKGVsZW1lbnRbZGVsdGFZU3ltYm9sXSkpIHtcbiAgICAvLyBNb3ZlIHdhcyBtb3N0bHkgaG9yaXpvbnRhbC5cbiAgICB0cmFja1RvKGVsZW1lbnQsIGNsaWVudFgpO1xuICAgIC8vIEluZGljYXRlIHRoYXQgdGhlIGV2ZW50IHdhcyBoYW5kbGVkLiBJdCdkIGJlIG5pY2VyIGlmIHdlIGRpZG4ndCBoYXZlXG4gICAgLy8gdG8gZG8gdGhpcyBzbyB0aGF0LCBlLmcuLCBhIHVzZXIgY291bGQgYmUgc3dpcGluZyBsZWZ0IGFuZCByaWdodFxuICAgIC8vIHdoaWxlIHNpbXVsdGFuZW91c2x5IHNjcm9sbGluZyB1cCBhbmQgZG93bi4gKE5hdGl2ZSB0b3VjaCBhcHBzIGNhbiBkb1xuICAgIC8vIHRoYXQuKSBIb3dldmVyLCBNb2JpbGUgU2FmYXJpIHdhbnRzIHRvIGhhbmRsZSBzd2lwZSBldmVudHMgbmVhciB0aGVcbiAgICAvLyBwYWdlIGFuZCBpbnRlcnByZXQgdGhlbSBhcyBuYXZpZ2F0aW9ucy4gVG8gYXZvaWQgaGF2aW5nIGEgaG9yaXppb250YWxcbiAgICAvLyBzd2lwZSBtaXNpbnRlcHJldGVkIGFzIGEgbmF2aWdhdGlvbiwgd2UgaW5kaWNhdGUgdGhhdCB3ZSd2ZSBoYW5kbGVkXG4gICAgLy8gdGhlIGV2ZW50LCBhbmQgcHJldmVudCBkZWZhdWx0IGJlaGF2aW9yLlxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIC8vIE1vdmUgd2FzIG1vc3RseSB2ZXJ0aWNhbC5cbiAgICByZXR1cm4gZmFsc2U7IC8vIE5vdCBoYW5kbGVkXG4gIH1cbn1cblxuLypcbiAqIEludm9rZWQgd2hlbiB0aGUgdXNlciBoYXMgYmVndW4gYSB0b3VjaCBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHRvdWNoU3RhcnQoZWxlbWVudCwgY2xpZW50WCwgY2xpZW50WSkge1xuICBlbGVtZW50W3N5bWJvbHMuZHJhZ2dpbmddID0gdHJ1ZTtcbiAgZWxlbWVudFtzdGFydFhTeW1ib2xdID0gY2xpZW50WDtcbiAgZWxlbWVudFtwcmV2aW91c1hTeW1ib2xdID0gY2xpZW50WDtcbiAgZWxlbWVudFtwcmV2aW91c1lTeW1ib2xdID0gY2xpZW50WTtcbiAgZWxlbWVudFtkZWx0YVhTeW1ib2xdID0gMDtcbiAgZWxlbWVudFtkZWx0YVlTeW1ib2xdID0gMDtcbn1cblxuZnVuY3Rpb24gdHJhY2tUbyhlbGVtZW50LCB4KSB7XG4gIGNvbnN0IHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgY29uc3QgZHJhZ0Rpc3RhbmNlID0gZWxlbWVudFtzdGFydFhTeW1ib2xdIC0geDtcbiAgY29uc3QgZnJhY3Rpb24gPSB3aWR0aCA+IDAgP1xuICAgIGRyYWdEaXN0YW5jZSAvIHdpZHRoIDpcbiAgICAwO1xuICBlbGVtZW50LnRyYXZlbEZyYWN0aW9uID0gZnJhY3Rpb247XG59XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuY29uc3QgcGxheWluZ1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncGxheWluZycpO1xuY29uc3Qgc2VsZWN0aW9uVGltZXJEdXJhdGlvblN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnc2VsZWN0aW9uVGltZXJEdXJhdGlvbicpO1xuY29uc3QgdGltZXJUaW1lb3V0U3ltYm9sID0gY3JlYXRlU3ltYm9sKCd0aW1lclRpbWVvdXQnKTtcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIFRpbWVyU2VsZWN0aW9uLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gd2hpY2ggcHJvdmlkZXMgZm9yIGF1dG9tYXRpYyB0aW1lZCBjaGFuZ2VzIGluIHNlbGVjdGlvbi5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIHNsaWRlc2hvdy1saWtlIGVsZW1lbnRzIHN1Y2ggYXNcbiAgICogW2Jhc2ljLXNsaWRlc2hvd10oLi4vLi4vYmFzaWMtc2xpZGVzaG93KSBhbmRcbiAgICogW2Jhc2ljLXNsaWRlc2hvdy13aXRoLWNvbnRyb2xzXSguLi8uLi9iYXNpYy1zbGlkZXNob3ctd2l0aC1jb250cm9scykuXG4gICAqXG4gICAqIFR5cGljYWwgdXNhZ2U6XG4gICAqXG4gICAqICAgICBjbGFzcyBDYXJvdXNlbFdpdGhUaW1lciBleHRlbmRzIFRpbWVyU2VsZWN0aW9uTWl4aW4oQ2Fyb3VzZWwpIHt9XG4gICAqICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ2Nhcm91c2VsLXdpdGgtYXJyb3dzJywgQ2Fyb3VzZWxXaXRoVGltZXIpO1xuICAgKlxuICAgKiBUaGlzIG1peGluIGV4cGVjdHMgdGhlIGNvbXBvbmVudCB0byBkZWZpbmUgYW4gYGl0ZW1zYCBwcm9wZXJ0eSwgYXMgd2VsbCBhc1xuICAgKiBgc2VsZWN0Rmlyc3RgIGFuZCBgc2VsZWN0TmV4dGAgbWV0aG9kcy4gWW91IGNhbiBpbXBsZW1lbnQgdGhvc2UgeW91cnNlbGYsXG4gICAqIG9yIHVzZSBbQ29udGVudEl0ZW1zTWl4aW5dKENvbnRlbnRJdGVtc01peGluLm1kKSBhbmRcbiAgICogW1NpbmdsZVNlbGVjdGlvbk1peGluXShTaW5nbGVTZWxlY3Rpb25NaXhpbi5tZCkuXG4gICAqL1xuICBjbGFzcyBUaW1lclNlbGVjdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgLy8gU2V0IGRlZmF1bHRzLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnBsYXlpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMucGxheWluZyA9IHRoaXNbc3ltYm9scy5kZWZhdWx0c10ucGxheWluZztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zZWxlY3Rpb25UaW1lckR1cmF0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblRpbWVyRHVyYXRpb24gPSB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnNlbGVjdGlvblRpbWVyRHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGVudENoYW5nZWQoKSB7XG4gICAgICBpZiAoc3VwZXIuY29udGVudENoYW5nZWQpIHsgc3VwZXIuY29udGVudENoYW5nZWQoKTsgfVxuICAgICAgcmVzdGFydFRpbWVyKHRoaXMpO1xuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMucGxheWluZyA9IGZhbHNlO1xuICAgICAgZGVmYXVsdHMuc2VsZWN0aW9uVGltZXJEdXJhdGlvbiA9IDEwMDA7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmVnaW4gYXV0b21hdGljIHByb2dyZXNzaW9uIG9mIHRoZSBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgcGxheSgpIHtcbiAgICAgIGlmIChzdXBlci5wbGF5KSB7IHN1cGVyLnBsYXkoKTsgfVxuICAgICAgc3RhcnRUaW1lcih0aGlzKTtcbiAgICAgIHRoaXNbcGxheWluZ1N5bWJvbF0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdXNlIGF1dG9tYXRpYyBwcm9ncmVzc2lvbiBvZiB0aGUgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgaWYgKHN1cGVyLnBhdXNlKSB7IHN1cGVyLnBhdXNlKCk7IH1cbiAgICAgIGNsZWFyVGltZXIodGhpcyk7XG4gICAgICB0aGlzW3BsYXlpbmdTeW1ib2xdID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGlzIGJlaW5nIGF1dG9tYXRpY2FsbHkgYWR2YW5jZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGdldCBwbGF5aW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXNbcGxheWluZ1N5bWJvbF07XG4gICAgfVxuICAgIHNldCBwbGF5aW5nKHBsYXlpbmcpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzUGxheWluZyA9IHRoaXNbcGxheWluZ1N5bWJvbF07XG4gICAgICBjb25zdCBwYXJzZWQgPSBTdHJpbmcocGxheWluZykgPT09ICd0cnVlJzsgLy8gQ2FzdCB0byBib29sZWFuXG4gICAgICBpZiAoJ3BsYXlpbmcnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnBsYXlpbmcgPSBwbGF5aW5nOyB9XG4gICAgICBpZiAocGFyc2VkICE9PSBwcmV2aW91c1BsYXlpbmcpIHtcbiAgICAgICAgaWYgKHBsYXlpbmcpIHtcbiAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFdoZW4gdGhlIHNlbGVjdGVkIGl0ZW0gY2hhbmdlcyAoYmVjYXVzZSBvZiBzb21ldGhpbmcgdGhpcyBtaXhpbiBkaWQsIG9yXG4gICAgICogd2FzIGNoYW5nZWQgYnkgYW4gb3V0c2lkZSBhZ2VudCBsaWtlIHRoZSB1c2VyKSwgd2Ugd2FpdCBiZWZvcmUgYWR2YW5jaW5nXG4gICAgICogdG8gdGhlIG5leHQgaXRlbS4gQnkgdHJpZ2dlcmluZyB0aGUgbmV4dCBpdGVtIHRoaXMgd2F5LCB3ZSBpbXBsaWNpdGx5IGdldFxuICAgICAqIGEgZGVzaXJhYmxlIGJlaGF2aW9yOiBpZiB0aGUgdXNlciBjaGFuZ2VzIHRoZSBzZWxlY3Rpb24gKGUuZy4sIGluIGFcbiAgICAgKiBjYXJvdXNlbCksIHdlIGxldCB0aGVtIHNlZSB0aGF0IHNlbGVjdGlvbiBzdGF0ZSBmb3IgYSB3aGlsZSBiZWZvcmVcbiAgICAgKiBhZHZhbmNpbmcgdGhlIHNlbGVjdGlvbiBvdXJzZWx2ZXMuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkSXRlbSgpIHtcbiAgICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEl0ZW07XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEl0ZW0oaXRlbSkge1xuICAgICAgaWYgKCdzZWxlY3RlZEl0ZW0nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGVkSXRlbSA9IGl0ZW07IH1cbiAgICAgIHJlc3RhcnRUaW1lcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCB3aWxsIGVsYXBzZSBhZnRlciB0aGUgc2VsZWN0aW9uIGNoYW5nZXNcbiAgICAgKiBiZWZvcmUgdGhlIHNlbGVjdGlvbiB3aWxsIGJlIGFkdmFuY2VkIHRvIHRoZSBuZXh0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSAtIFRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogQGRlZmF1bHQgMTAwMCAoMSBzZWNvbmQpXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblRpbWVyRHVyYXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpc1tzZWxlY3Rpb25UaW1lckR1cmF0aW9uU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGlvblRpbWVyRHVyYXRpb24odmFsdWUpIHtcbiAgICAgIHRoaXNbc2VsZWN0aW9uVGltZXJEdXJhdGlvblN5bWJvbF0gPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICBpZiAoJ3NlbGVjdGlvblRpbWVyRHVyYXRpb24nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGlvblRpbWVyRHVyYXRpb24gPSB2YWx1ZTsgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFRpbWVyU2VsZWN0aW9uO1xufTtcblxuXG5mdW5jdGlvbiBjbGVhclRpbWVyKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnRbdGltZXJUaW1lb3V0U3ltYm9sXSkge1xuICAgIGNsZWFyVGltZW91dChlbGVtZW50W3RpbWVyVGltZW91dFN5bWJvbF0pO1xuICAgIGVsZW1lbnRbdGltZXJUaW1lb3V0U3ltYm9sXSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdGFydFRpbWVyKGVsZW1lbnQpIHtcbiAgY2xlYXJUaW1lcihlbGVtZW50KTtcbiAgaWYgKGVsZW1lbnQucGxheWluZyAmJiBlbGVtZW50Lml0ZW1zICYmIGVsZW1lbnQuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgIHN0YXJ0VGltZXIoZWxlbWVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRUaW1lcihlbGVtZW50KSB7XG4gIC8vIElmIHBsYXkoKSBpcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2UsIGNhbmNlbCBhbnkgZXhpc3RpbmcgdGltZXIuXG4gIGNsZWFyVGltZXIoZWxlbWVudCk7XG4gIGVsZW1lbnRbdGltZXJUaW1lb3V0U3ltYm9sXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHNlbGVjdE5leHRXaXRoV3JhcChlbGVtZW50KTtcbiAgfSwgZWxlbWVudC5zZWxlY3Rpb25UaW1lckR1cmF0aW9uKTtcbn1cblxuLy8gU2VsZWN0IHRoZSBuZXh0IGl0ZW0sIHdyYXBwaW5nIHRvIGZpcnN0IGl0ZW0gaWYgbmVjZXNzYXJ5LlxuZnVuY3Rpb24gc2VsZWN0TmV4dFdpdGhXcmFwKGVsZW1lbnQpIHtcbiAgY29uc3QgaXRlbXMgPSBlbGVtZW50Lml0ZW1zO1xuICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMCkge1xuICAgIGlmIChlbGVtZW50LnNlbGVjdGVkSW5kZXggPT0gbnVsbCB8fCBlbGVtZW50LnNlbGVjdGVkSW5kZXggPT09IGl0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgIGVsZW1lbnQuc2VsZWN0Rmlyc3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZWxlY3ROZXh0KCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL2NyZWF0ZVN5bWJvbCc7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuL3N5bWJvbHMnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBhYnNvcmJEZWNlbGVyYXRpb25TeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2Fic29yYkRlY2VsZXJhdGlvbicpO1xuY29uc3QgbGFzdERlbHRhWFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbGFzdERlbHRhWCcpO1xuY29uc3QgbGFzdFdoZWVsVGltZW91dFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbGFzdFdoZWVsVGltZW91dCcpO1xuY29uc3QgcG9zdE5hdmlnYXRlRGVsYXlDb21wbGV0ZVN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncG9zdE5hdmlnYXRlRGVsYXlDb21wbGV0ZScpO1xuY29uc3Qgd2hlZWxEaXN0YW5jZVN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnd2hlZWxEaXN0YW5jZScpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggVHJhY2twYWREaXJlY3Rpb24uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYXBzIGEgaG9yaXpvbnRhbCB0cmFja3BhZCBzd2lwZSBnZXN0dXJlcyAob3IgaG9yaXpvbnRhbCBtb3VzZVxuICAgKiB3aGVlbCBhY3Rpb25zKSB0byBkaXJlY3Rpb24gc2VtYW50aWNzLlxuICAgKlxuICAgKiBZb3UgY2FuIHVzZSB0aGlzIG1peGluIHdpdGggYSBtaXhpbiBsaWtlXG4gICAqIFtEaXJlY3Rpb25TZWxlY3Rpb25NaXhpbl0oRGlyZWN0aW9uU2VsZWN0aW9uTWl4aW4ubWQpIHRvIGxldCB0aGUgdXNlclxuICAgKiBjaGFuZ2UgdGhlIHNlbGVjdGlvbiB3aXRoIHRoZSB0cmFja3BhZCBvciBtb3VzZSB3aGVlbC5cbiAgICpcbiAgICogVG8gcmVzcG9uZCB0byB0aGUgdHJhY2twYWQsIHdlIGNhbiBsaXN0ZW4gdG8gdGhlIERPTSdzIFwid2hlZWxcIiBldmVudHMuXG4gICAqIFRoZXNlIGV2ZW50cyBhcmUgZmlyZWQgYXMgdGhlIHVzZXIgZHJhZ3MgdGhlaXIgZmluZ2VycyBhY3Jvc3MgYSB0cmFja3BhZC5cbiAgICogVW5mb3J0dW5hdGVseSwgYnJvd3NlcnMgYXJlIG1pc3NpbmcgYSBjcml0aWNhbCBldmVudCDigJTCoHRoZXJlIGlzIG5vIGV2ZW50XG4gICAqIHdoZW4gdGhlIHVzZXIgKnN0b3BzKiBhIGdlc3R1cmVkIG9uIHRoZSB0cmFja3BhZCBvciBtb3VzZSB3aGVlbC5cbiAgICpcbiAgICogVG8gbWFrZSB0aGluZ3Mgd29yc2UsIHRoZSBtYWluc3RyZWFtIGJyb3dzZXJzIGNvbnRpbnVlIHRvIGdlbmVyYXRlIGZha2VcbiAgICogd2hlZWwgZXZlbnRzIGV2ZW4gYWZ0ZXIgdGhlIHVzZXIgaGFzIHN0b3BwZWQgZHJhZ2dpbmcgdGhlaXIgZmluZ2Vycy4gVGhlc2VcbiAgICogZmFrZSBldmVudHMgc2ltdWxhdGUgdGhlIHVzZXIgZ3JhZHVhbGx5IHNsb3dpbmcgZG93biB0aGUgZHJhZyB1bnRpbCB0aGV5XG4gICAqIGNvbWUgdG8gYSBzbW9vdGggc3RvcC4gSW4gc29tZSBjb250ZXh0cywgdGhlc2UgZmFrZSB3aGVlbCBldmVudHMgbWlnaHQgYmVcbiAgICogaGVscGZ1bCwgYnV0IGluIHRyeWluZyB0byBzdXBwbHkgdHlwaWNhbCB0cmFja3BhZCBzd2lwZSBuYXZpZ2F0aW9uLCB0aGVzZVxuICAgKiBmYWtlIGV2ZW50cyBnZXQgaW4gdGhlIHdheS5cbiAgICpcbiAgICogVGhpcyBjb21wb25lbnQgdXNlcyBoZXVyaXN0aWNzIHRvIHdvcmsgYXJvdW5kIHRoZXNlIHByb2JsZW1zLCBidXQgdGhlXG4gICAqIGNvbXBsZXggbmF0dXJlIG9mIHRoZSBwcm9ibGVtIG1ha2UgaXQgZXh0cmVtZWx5IGRpZmZpY3VsdCB0byBhY2hpZXZlIHRoZVxuICAgKiBzYW1lIGRlZ3JlZSBvZiB0cmFja3BhZCByZXNwb25zaXZlbmVzcyBwb3NzaWJsZSB3aXRoIG5hdGl2ZSBhcHBsaWNhdGlvbnMuXG4gICAqL1xuICBjbGFzcyBUcmFja3BhZERpcmVjdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlZCA9IHdoZWVsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlc2V0V2hlZWxUcmFja2luZyh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uLlxuICAgIGdldCBbc3ltYm9scy5kcmFnZ2luZ10oKSB7XG4gICAgICByZXR1cm4gc3VwZXJbc3ltYm9scy5kcmFnZ2luZ107XG4gICAgfVxuICAgIHNldCBbc3ltYm9scy5kcmFnZ2luZ10odmFsdWUpIHtcbiAgICAgIGlmIChzeW1ib2xzLmRyYWdnaW5nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyW3N5bWJvbHMuZHJhZ2dpbmddID0gdmFsdWU7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgbGVmdC5cbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICovXG4gICAgW3N5bWJvbHMuZ29MZWZ0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvTGVmdF0pIHsgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZ29MZWZ0XSgpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIHJpZ2h0LlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBbc3ltYm9scy5nb1JpZ2h0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvUmlnaHRdKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvUmlnaHRdKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGlzdGFuY2UgdGhlIHVzZXIgaGFzIG1vdmVkIHRoZSBmaXJzdCB0b3VjaHBvaW50IHNpbmNlIHRoZSBiZWdpbm5pbmdcbiAgICAgKiBvZiBhIHRyYWNrcGFkL3doZWVsIG9wZXJhdGlvbiwgZXhwcmVzc2VkIGFzIGEgZnJhY3Rpb24gb2YgdGhlIGVsZW1lbnQnc1xuICAgICAqIHdpZHRoLlxuICAgICAqXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IHRyYXZlbEZyYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnRyYXZlbEZyYWN0aW9uO1xuICAgIH1cbiAgICBzZXQgdHJhdmVsRnJhY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICgndHJhdmVsRnJhY3Rpb24nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnRyYXZlbEZyYWN0aW9uID0gdmFsdWU7IH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBUcmFja3BhZERpcmVjdGlvbjtcbn07XG5cblxuLy8gVGltZSB3ZSB3YWl0IGZvbGxvd2luZyBhIG5hdmlnYXRpb24gYmVmb3JlIHBheWluZyBhdHRlbnRpb24gdG8gd2hlZWxcbi8vIGV2ZW50cyBhZ2Fpbi5cbmNvbnN0IFBPU1RfTkFWSUdBVEVfVElNRSA9IDI1MDtcblxuLy8gVGltZSB3ZSB3YWl0IGFmdGVyIHRoZSBsYXN0IHdoZWVsIGV2ZW50IGJlZm9yZSB3ZSByZXNldCB0aGluZ3MuXG5jb25zdCBXSEVFTF9USU1FID0gMTAwO1xuXG5cbi8vIEZvbGxvd2luZyBhIG5hdmlnYXRpb24sIHBhcnRpYWxseSByZXNldCBvdXIgd2hlZWwgdHJhY2tpbmcuXG5mdW5jdGlvbiBwb3N0TmF2aWdhdGUoZWxlbWVudCkge1xuICBlbGVtZW50LnRyYXZlbEZyYWN0aW9uID0gMDtcbiAgZWxlbWVudFt3aGVlbERpc3RhbmNlU3ltYm9sXSA9IDA7XG4gIGVsZW1lbnRbcG9zdE5hdmlnYXRlRGVsYXlDb21wbGV0ZVN5bWJvbF0gPSB0cnVlO1xuICBlbGVtZW50W2Fic29yYkRlY2VsZXJhdGlvblN5bWJvbF0gPSB0cnVlO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBlbGVtZW50W3Bvc3ROYXZpZ2F0ZURlbGF5Q29tcGxldGVTeW1ib2xdID0gZmFsc2U7XG4gIH0sIFBPU1RfTkFWSUdBVEVfVElNRSk7XG59XG5cbi8vIFJlc2V0IGFsbCBzdGF0ZSByZWxhdGVkIHRvIHRoZSB0cmFja2luZyBvZiB0aGUgd2hlZWwuXG5mdW5jdGlvbiByZXNldFdoZWVsVHJhY2tpbmcoZWxlbWVudCkge1xuICBlbGVtZW50LnRyYXZlbEZyYWN0aW9uID0gMDtcbiAgZWxlbWVudFt3aGVlbERpc3RhbmNlU3ltYm9sXSA9IDA7XG4gIGVsZW1lbnRbbGFzdERlbHRhWFN5bWJvbF0gPSAwO1xuICBlbGVtZW50W2Fic29yYkRlY2VsZXJhdGlvblN5bWJvbF0gPSBmYWxzZTtcbiAgZWxlbWVudFtwb3N0TmF2aWdhdGVEZWxheUNvbXBsZXRlU3ltYm9sXSA9IGZhbHNlO1xuICBpZiAoZWxlbWVudFtsYXN0V2hlZWxUaW1lb3V0U3ltYm9sXSkge1xuICAgIGNsZWFyVGltZW91dChlbGVtZW50W2xhc3RXaGVlbFRpbWVvdXRTeW1ib2xdKTtcbiAgICBlbGVtZW50W2xhc3RXaGVlbFRpbWVvdXRTeW1ib2xdID0gbnVsbDtcbiAgfVxufVxuXG4vLyBEZWZpbmUgb3VyIG93biBzaWduIGZ1bmN0aW9uLCBzaW5jZSAoYXMgb2YgTWF5IDIwMTUpLCBTYWZhcmkgYW5kIElFIGRvbid0XG4vLyBzdXBwbHkgTWF0aC5zaWduKCkuXG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgcmV0dXJuICh4ID09PSAwKSA/XG4gICAgMCA6XG4gICAgKHggPiAwKSA/XG4gICAgICAxIDpcbiAgICAgIC0xO1xufVxuXG4vLyBUT0RPOiBEYW1waW5nLCBvciBzb21lIG90aGVyIHRyZWF0bWVudCBmb3IgZ29pbmcgcGFzdCB0aGUgZW5kcy5cblxuLypcbiAqIEEgd2hlZWwgZXZlbnQgaGFzIGJlZW4gZ2VuZXJhdGVkLiBUaGlzIGNvdWxkIGJlIGEgcmVhbCB3aGVlbCBldmVudCwgb3IgaXRcbiAqIGNvdWxkIGJlIGZha2UgKHNlZSBub3RlcyBpbiB0aGUgaGVhZGVyKS5cbiAqXG4gKiBUaGlzIGhhbmRsZXIgdXNlcyBzZXZlcmFsIHN0cmF0ZWdpZXMgdG8gdHJ5IHRvIGFwcHJveGltYXRlIG5hdGl2ZSB0cmFja3BhZFxuICogc3dpcGUgbmF2aWdhdGlvbi5cbiAqXG4gKiBJZiB0aGUgdXNlciBoYXMgZHJhZ2dlZCBlbm91Z2ggdG8gY2F1c2UgYSBuYXZpZ2F0aW9uLCB0aGVuIGZvciBhIHNob3J0XG4gKiBkZWxheSBmb2xsb3dpbmcgdGhhdCBuYXZpZ2F0aW9uLCBzdWJzZXF1ZW50IHdoZWVsIGV2ZW50cyB3aWxsIGJlIGlnbm9yZWQuXG4gKlxuICogRnVydGhlcm1vcmUsIGZvbGx3b3dpbmcgYSBuYXZpZ2F0aW9uLCB3ZSBpZ25vcmUgYWxsIHdoZWVsIGV2ZW50cyB1bnRpbCB3ZVxuICogcmVjZWl2ZSBhdCBsZWFzdCBvbmUgZXZlbnQgd2hlcmUgdGhlIGV2ZW50J3MgZGVsdGFYIChkaXN0YW5jZSB0cmF2ZWxlZCkgaXNcbiAqICpncmVhdGVyKiB0aGFuIHRoZSBwcmV2aW91cyBldmVudCdzIGRlbHRhWC4gVGhpcyBoZWxwcyB1cyBmaWx0ZXIgb3V0IHRoZVxuICogZmFrZSB3aGVlbCBldmVudHMgZ2VuZXJhdGVkIGJ5IHRoZSBicm93c2VyIHRvIHNpbXVsYXRlIGRlY2VsZXJhdGlvbi5cbiAqXG4gKi9cbmZ1bmN0aW9uIHdoZWVsKGVsZW1lbnQsIGV2ZW50KSB7XG5cbiAgLy8gU2luY2Ugd2UgaGF2ZSBhIG5ldyB3aGVlbCBldmVudCwgcmVzZXQgb3VyIHRpbWVyIHdhaXRpbmcgZm9yIHRoZSBsYXN0XG4gIC8vIHdoZWVsIGV2ZW50IHRvIHBhc3MuXG4gIGlmIChlbGVtZW50W2xhc3RXaGVlbFRpbWVvdXRTeW1ib2xdKSB7XG4gICAgY2xlYXJUaW1lb3V0KGVsZW1lbnRbbGFzdFdoZWVsVGltZW91dFN5bWJvbF0pO1xuICB9XG4gIGVsZW1lbnRbbGFzdFdoZWVsVGltZW91dFN5bWJvbF0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB3aGVlbFRpbWVkT3V0KGVsZW1lbnQpO1xuICB9LCBXSEVFTF9USU1FKTtcblxuICBjb25zdCBkZWx0YVggPSBldmVudC5kZWx0YVg7XG4gIGNvbnN0IGRlbHRhWSA9IGV2ZW50LmRlbHRhWTtcblxuICAvLyBTZWUgaWYgZWxlbWVudCBldmVudCByZXByZXNlbnRzIGFjY2VsZXJhdGlvbiBvciBkZWNlbGVyYXRpb24uXG4gIGNvbnN0IGFjY2VsZXJhdGlvbiA9IHNpZ24oZGVsdGFYKSAqIChkZWx0YVggLSBlbGVtZW50W2xhc3REZWx0YVhTeW1ib2xdKTtcbiAgZWxlbWVudFtsYXN0RGVsdGFYU3ltYm9sXSA9IGRlbHRhWDtcblxuICBpZiAoTWF0aC5hYnMoZGVsdGFYKSA8IE1hdGguYWJzKGRlbHRhWSkpIHtcbiAgICAvLyBNb3ZlIHdhcyBtb3N0bHkgdmVydGljYWwuIFRoZSB1c2VyIG1heSBiZSB0cnlpbmcgc2Nyb2xsIHdpdGggdGhlXG4gICAgLy8gdHJhY2twYWQvd2hlZWwuIFRvIGJlIG9uIHRoZSBzYWZlLCB3ZSBpZ25vcmUgc3VjaCBldmVudHMuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGVsZW1lbnRbcG9zdE5hdmlnYXRlRGVsYXlDb21wbGV0ZVN5bWJvbF0pIHtcbiAgICAvLyBJdCdzIHRvbyBzb29uIGFmdGVyIGEgbmF2aWdhdGlvbjsgaWdub3JlIHRoZSBldmVudC5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhY2NlbGVyYXRpb24gPiAwKSB7XG4gICAgLy8gVGhlIGV2ZW50cyBhcmUgbm90IChvciBhcmUgbm8gbG9uZ2VyKSBkZWNlbGVyYXRpbmcsIHNvIHdlIGNhbiBzdGFydFxuICAgIC8vIHBheWluZyBhdHRlbnRpb24gdG8gdGhlbSBhZ2Fpbi5cbiAgICBlbGVtZW50W2Fic29yYkRlY2VsZXJhdGlvblN5bWJvbF0gPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChlbGVtZW50W2Fic29yYkRlY2VsZXJhdGlvblN5bWJvbF0pIHtcbiAgICAvLyBUaGUgd2hlZWwgZXZlbnQgd2FzIGxpa2VseSBmYWtlZCB0byBzaW11bGF0ZSBkZWNlbGVyYXRpb247IGlnbm9yZSBpdC5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGVsZW1lbnRbd2hlZWxEaXN0YW5jZVN5bWJvbF0gKz0gZGVsdGFYO1xuXG4gIC8vIFVwZGF0ZSB0aGUgdHJhdmVsIGZyYWN0aW9uIG9mIHRoZSBlbGVtZW50IGJlaW5nIG5hdmlnYXRlZC5cbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICBsZXQgdHJhdmVsRnJhY3Rpb24gPSB3aWR0aCA+IDAgP1xuICAgIGVsZW1lbnRbd2hlZWxEaXN0YW5jZVN5bWJvbF0gLyB3aWR0aCA6XG4gICAgMDtcbiAgZWxlbWVudFtzeW1ib2xzLmRyYWdnaW5nXSA9IHRydWU7XG4gIHRyYXZlbEZyYWN0aW9uID0gc2lnbih0cmF2ZWxGcmFjdGlvbikgKiBNYXRoLm1pbihNYXRoLmFicyh0cmF2ZWxGcmFjdGlvbiksIDEpO1xuICBlbGVtZW50LnRyYXZlbEZyYWN0aW9uID0gdHJhdmVsRnJhY3Rpb247XG5cbiAgLy8gSWYgdGhlIHVzZXIgaGFzIGRyYWdnZWQgZW5vdWdoIHRvIHJlYWNoIHRoZSBwcmV2aW91cy9uZXh0IGl0ZW0sIHRoZW5cbiAgLy8gY29tcGxldGUgYSBuYXZpZ2F0aW9uIHRvIHRoYXQgaXRlbS5cbiAgaWYgKHRyYXZlbEZyYWN0aW9uID09PSAxKSB7XG4gICAgZWxlbWVudFtzeW1ib2xzLmRyYWdnaW5nXSA9IGZhbHNlO1xuICAgIGVsZW1lbnRbc3ltYm9scy5nb1JpZ2h0XSgpO1xuICAgIHBvc3ROYXZpZ2F0ZShlbGVtZW50KTtcbiAgfSBlbHNlIGlmICh0cmF2ZWxGcmFjdGlvbiA9PT0gLTEpIHtcbiAgICBlbGVtZW50W3N5bWJvbHMuZHJhZ2dpbmddID0gZmFsc2U7XG4gICAgZWxlbWVudFtzeW1ib2xzLmdvTGVmdF0oKTtcbiAgICBwb3N0TmF2aWdhdGUoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gQSBzdWZmaWNpZW50bHkgbG9uZyBwZXJpb2Qgb2YgdGltZSBoYXMgcGFzc2VkIHNpbmNlIHRoZSBsYXN0IHdoZWVsIGV2ZW50LlxuLy8gV2Ugc25hcCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBjbG9zZXN0IGl0ZW0sIHRoZW4gcmVzZXQgb3VyIHN0YXRlLlxuZnVuY3Rpb24gd2hlZWxUaW1lZE91dChlbGVtZW50KSB7XG5cbiAgLy8gU25hcCB0byB0aGUgY2xvc2VzdCBpdGVtLlxuICBlbGVtZW50W3N5bWJvbHMuZHJhZ2dpbmddID0gZmFsc2U7XG4gIGNvbnN0IHRyYXZlbEZyYWN0aW9uID0gZWxlbWVudC50cmF2ZWxGcmFjdGlvbjtcbiAgaWYgKHRyYXZlbEZyYWN0aW9uID49IDAuNSkge1xuICAgIGVsZW1lbnRbc3ltYm9scy5nb1JpZ2h0XSgpO1xuICB9IGVsc2UgaWYgKHRyYXZlbEZyYWN0aW9uIDw9IC0wLjUpIHtcbiAgICBlbGVtZW50W3N5bWJvbHMuZ29MZWZ0XSgpO1xuICB9XG5cbiAgLy8gVE9ETzogTGlzdGVuIGZvciB0aGUgdHJhbnNpdGlvbiB0byBjb21wbGV0ZSwgYW5kIHRoZW4gcmVzdG9yZVxuICAvLyBkcmFnZ2luZyB0byBmYWxzZSAob3IgdGhlIHByZXZpb3VzIHZhbHVlKS5cblxuICByZXNldFdoZWVsVHJhY2tpbmcoZWxlbWVudCk7XG59XG4iLCIvKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzeW1ib2wgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYXNzb2NpYXRpbmcgcHJpdmF0ZVxuICogZGF0YSB3aXRoIGFuIGVsZW1lbnQuXG4gKlxuICogTWl4aW5zIGFuZCBjb21wb25lbnQgY2xhc3NlcyBvZnRlbiB3YW50IHRvIGFzc29jaWF0ZSBwcml2YXRlIGRhdGEgd2l0aCBhblxuICogZWxlbWVudCBpbnN0YW5jZSwgYnV0IEphdmFTY3JpcHQgZG9lcyBub3QgaGF2ZSBkaXJlY3Qgc3VwcG9ydCBmb3IgdHJ1ZVxuICogcHJpdmF0ZSBwcm9wZXJ0aWVzLiBPbmUgYXBwcm9hY2ggaXMgdG8gdXNlIHRoZVxuICogW1N5bWJvbF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3ltYm9sKVxuICogZGF0YSB0eXBlIHRvIHNldCBhbmQgcmV0cmlldmUgZGF0YSBvbiBhbiBlbGVtZW50LlxuICpcbiAqIFVuZm9ydHVuYXRlbHksIHRoZSBTeW1ib2wgdHlwZSBpcyBub3QgYXZhaWxhYmxlIGluIEludGVybmV0IEV4cGxvcmVyIDExLiBUaGVcbiAqIGBjcmVhdGVTeW1ib2xgIGhlbHBlciBmdW5jdGlvbiBleGlzdHMgYXMgYSB3b3JrYXJvdW5kIGZvciBJRSAxMS4gUmF0aGVyIHRoYW5cbiAqIHJldHVybmluZyBhIHRydWUgU3ltYm9sLCBpdCBzaW1wbHkgcmV0dXJucyBhbiB1bmRlcnNjb3JlLXByZWZpeGVkIHN0cmluZy5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgICAgY29uc3QgZm9vU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdmb28nKTtcbiAqXG4gKiAgICAgY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICogICAgICAgZ2V0IGZvbygpIHtcbiAqICAgICAgICAgcmV0dXJuIHRoaXNbZm9vU3ltYm9sXTtcbiAqICAgICAgIH1cbiAqICAgICAgIHNldCBmb28odmFsdWUpIHtcbiAqICAgICAgICAgdGhpc1tmb29TeW1ib2xdID0gdmFsdWU7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIEluIElFIDExLCB0aGlzIHNhbXBsZSB3aWxsIFwiaGlkZVwiIGRhdGEgYmVoaW5kIGFuIGluc3RhbmNlIHByb3BlcnR5IHRoaXMuX2Zvby5cbiAqIFRoZSB1c2Ugb2YgdGhlIHVuZGVyc2NvcmUgaXMgbWVhbnQgdG8gcmVkdWNlIChub3QgZWxpbWluYXRlKSB0aGUgcG90ZW50aWFsXG4gKiBmb3IgbmFtZSBjb25mbGljdHMsIGFuZCBkaXNjb3VyYWdlIChub3QgcHJldmVudCkgZXh0ZXJuYWwgYWNjZXNzIHRvIHRoaXNcbiAqIGRhdGEuIEluIG1vZGVybiBicm93c2VycywgdGhlIGFib3ZlIGNvZGUgd2lsbCBlbGltaW5hdGUgdGhlIHBvdGVudGlhbCBvZlxuICogbmFtaW5nIGNvbmZsaWN0cywgYW5kIGJldHRlciBoaWRlIHRoZSBkYXRhIGJlaGluZCBhIHJlYWwgU3ltYm9sLlxuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVTeW1ib2xcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgc3RyaW5nIHRvIGlkZW50aWZ5IHRoZSBzeW1ib2wgd2hlbiBkZWJ1Z2dpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nID9cbiAgICBTeW1ib2woZGVzY3JpcHRpb24pIDpcbiAgICBgXyR7ZGVzY3JpcHRpb259YDtcbn1cbiIsIi8qXG4gKiBNaWNyb3Rhc2sgaGVscGVyIGZvciBJRSAxMS5cbiAqXG4gKiBFeGVjdXRpbmcgYSBmdW5jdGlvbiBhcyBhIG1pY3JvdGFzayBpcyB0cml2aWFsIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydFxuICogcHJvbWlzZXMsIHdob3NlIHRoZW4oKSBjbGF1c2VzIHVzZSBtaWNyb3Rhc2sgdGltaW5nLiBJRSAxMSBkb2Vzbid0IHN1cHBvcnRcbiAqIHByb21pc2VzLCBidXQgZG9lcyBzdXBwb3J0IE11dGF0aW9uT2JzZXJ2ZXJzLCB3aGljaCBhcmUgYWxzbyBleGVjdXRlZCBhc1xuICogbWljcm90YXNrcy4gU28gdGhpcyBoZWxwZXIgdXNlcyBhbiBNdXRhdGlvbk9ic2VydmVyIHRvIGFjaGlldmUgbWljcm90YXNrXG4gKiB0aW1pbmcuXG4gKlxuICogU2VlIGh0dHBzOi8vamFrZWFyY2hpYmFsZC5jb20vMjAxNS90YXNrcy1taWNyb3Rhc2tzLXF1ZXVlcy1hbmQtc2NoZWR1bGVzL1xuICpcbiAqIEluc3BpcmVkIGJ5IFBvbHltZXIncyBhc3luYygpIGZ1bmN0aW9uLlxuICovXG5cblxuLy8gVGhlIHF1ZXVlIG9mIHBlbmRpbmcgY2FsbGJhY2tzIHRvIGJlIGV4ZWN1dGVkIGFzIG1pY3JvdGFza3MuXG5jb25zdCBjYWxsYmFja3MgPSBbXTtcblxuLy8gQ3JlYXRlIGFuIGVsZW1lbnQgdGhhdCB3ZSB3aWxsIG1vZGlmeSB0byBmb3JjZSBvYnNlcnZhYmxlIG11dGF0aW9ucy5cbmNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG5cbi8vIEEgbW9ub3RvbmljYWxseS1pbmNyZWFzaW5nIHZhbHVlLlxubGV0IGNvdW50ZXIgPSAwO1xuXG5cbi8qKlxuICogQWRkIGEgY2FsbGJhY2sgdG8gdGhlIG1pY3JvdGFzayBxdWV1ZS5cbiAqXG4gKiBUaGlzIHVzZXMgYSBNdXRhdGlvbk9ic2VydmVyIHNvIHRoYXQgaXQgd29ya3Mgb24gSUUgMTEuXG4gKlxuICogTk9URTogSUUgMTEgbWF5IGFjdHVhbGx5IHVzZSB0aW1lb3V0IHRpbWluZyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJzLiBUaGlzXG4gKiBuZWVkcyBtb3JlIGludmVzdGlnYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uIG1pY3JvdGFza1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWljcm90YXNrKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgLy8gRm9yY2UgYSBtdXRhdGlvbi5cbiAgZWxlbWVudC50ZXh0Q29udGVudCA9ICsrY291bnRlcjtcbn1cblxuXG4vLyBFeGVjdXRlIGFueSBwZW5kaW5nIGNhbGxiYWNrcy5cbmZ1bmN0aW9uIGV4ZWN1dGVDYWxsYmFja3MoKSB7XG4gIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzLnNoaWZ0KCk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG5cbi8vIENyZWF0ZSB0aGUgb2JzZXJ2ZXIuXG5jb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGV4ZWN1dGVDYWxsYmFja3MpO1xub2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gIGNoYXJhY3RlckRhdGE6IHRydWVcbn0pO1xuIiwiLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHJlbmRlcmluZyBhbiBhcnJheSBvZiBpdGVtcyBhcyBlbGVtZW50cy5cbiAqXG4gKiBUaGlzIGlzIG5vdCBhIG1peGluLCBidXQgYSBmdW5jdGlvbiBjb21wb25lbnRzIGNhbiB1c2UgaWYgdGhleSBuZWVkIHRvXG4gKiBnZW5lcmF0ZSBhIHNldCBvZiBlbGVtZW50cyBmb3IgdGhlIGl0ZW1zIGluIGFuIGFycmF5LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZXVzZSBleGlzdGluZyBlbGVtZW50cyBpZiBwb3NzaWJsZS4gRS5nLiwgaWYgaXQgaXMgY2FsbGVkXG4gKiB0byByZW5kZXIgYW4gYXJyYXkgb2YgNCBpdGVtcywgYW5kIGxhdGVyIGNhbGxlZCB0byByZW5kZXIgYW4gYXJyYXkgb2YgNVxuICogaXRlbXMsIGl0IGNhbiByZXVzZSB0aGUgZXhpc3RpbmcgNCBpdGVtcywgY3JlYXRpbmcganVzdCBvbmUgbmV3IGVsZW1lbnQuXG4gKiBOb3RlLCBob3dldmVyLCB0aGF0IHRoaXMgcmUtcmVuZGVyaW5nIGlzIG5vdCBhdXRvbWF0aWMuIElmLCBhZnRlciBjYWxsaW5nXG4gKiB0aGlzIGZ1bmN0aW9uLCB5b3UgbWFuaXB1bGF0ZSB0aGUgYXJyYXkgeW91IHVzZWQsIHlvdSBtdXN0IHN0aWxsIGNhbGwgdGhpc1xuICogZnVuY3Rpb24gYWdhaW4gdG8gcmUtcmVuZGVyIHRoZSBhcnJheS5cbiAqXG4gKiBUaGUgYHJlbmRlckl0ZW1gIHBhcmFtZXRlciB0YWtlcyBhIGZ1bmN0aW9uIG9mIHR3byBhcmd1bWVudHM6IGFuIGl0ZW0gdG9cbiAqIHRvIHJlbmRlciwgYW5kIGFuIGV4aXN0aW5nIGVsZW1lbnQgKGlmIG9uZSBleGlzdHMpIHdoaWNoIGNhbiBiZSByZXB1cnBvc2VkIHRvXG4gKiByZW5kZXIgdGhhdCBpdGVtLiBJZiB0aGUgbGF0dGVyIGFyZ3VtZW50IGlzIG51bGwsIHRoZSBgcmVuZGVySXRlbSgpYCBmdW5jdGlvblxuICogc2hvdWxkIGNyZWF0ZSBhIG5ldyBlbGVtZW50IGFuZCByZXR1cm4gaXQuIFRoZSBmdW5jdGlvbiBzaG91bGQgZG8gdGhlIHNhbWVcbiAqIGlmIHRoZSBzdXBwbGllZCBleGlzdGluZyBlbGVtZW50IGlzIG5vdCBzdWl0YWJsZSBmb3IgcmVuZGVyaW5nIHRoZSBnaXZlblxuICogaXRlbTsgdGhlIHJldHVybmVkIGVsZW1lbnQgd2lsbCBiZSB1c2VkIHRvIHJlcGxhY2UgdGhlIGV4aXN0aW5nIG9uZS4gSWYgdGhlXG4gKiBleGlzdGluZyBlbGVtZW50ICppcyogc3VpdGFibGUsIHRoZSBmdW5jdGlvbiBjYW4gc2ltcGx5IHVwZGF0ZSBpdCBhbmQgcmV0dXJuXG4gKiBpdCBhcyBpcy5cbiAqXG4gKiBFeGFtcGxlOiBUaGUgZm9sbG93aW5nIHdpbGwgcmVuZGVyIGFuIGFycmF5IG9mIHN0cmluZ3MgaW4gZGl2cyBhcyBjaGlsZHJlblxuICogb2YgdGhlIGBjb250YWluZXJgIGVsZW1lbnQ6XG4gKlxuICogICAgIGxldCBzdHJpbmdzID0gWydhJywgJ2InLCAnYycsIC4uLl07XG4gKiAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMucXVlcnlTZWxlY3RvciguLi4pO1xuICogICAgIHJlbmRlckFycmF5QXNFbGVtZW50cyhzdHJpbmdzLCBjb250YWluZXIsIChzdHJpbmcsIGVsZW1lbnQpID0+IHtcbiAqICAgICAgIGlmICghZWxlbWVudCkge1xuICogICAgICAgICAvLyBObyBlbGVtZW50IGV4aXN0cyB5ZXQsIHNvIGNyZWF0ZSBhIG5ldyBvbmUuXG4gKiAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAqICAgICAgIH1cbiAqICAgICAgIC8vIFNldC91cGRhdGUgdGhlIHRleHQgY29udGVudCBvZiB0aGUgZWxlbWVudC5cbiAqICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBzdHJpbmc7XG4gKiAgICAgICByZXR1cm4gZWxlbWVudDtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtcyAtIHRoZSBpdGVtcyB0byByZW5kZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIHRoZSBwYXJlbnQgdGhhdCB3aWxsIGhvbGQgdGhlIGVsZW1lbnRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJJdGVtIC0gcmV0dXJucyBhIG5ldyBlbGVtZW50IGZvciBhbiBpdGVtLCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcHVycG9zZXMgYW4gZXhpc3RpbmcgZWxlbWVudCBmb3IgYW4gaXRlbVxuICovXG5mdW5jdGlvbiByZW5kZXJBcnJheUFzRWxlbWVudHMoaXRlbXMsIGNvbnRhaW5lciwgcmVuZGVySXRlbSkge1xuICAvLyBDcmVhdGUgYSBuZXcgc2V0IG9mIGVsZW1lbnRzIGZvciB0aGUgY3VycmVudCBpdGVtcy5cbiAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBvbGRFbGVtZW50ID0gY29udGFpbmVyLmNoaWxkTm9kZXNbaW5kZXhdO1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSByZW5kZXJJdGVtKGl0ZW0sIG9sZEVsZW1lbnQpO1xuICAgIGlmIChuZXdFbGVtZW50KSB7XG4gICAgICBpZiAoIW9sZEVsZW1lbnQpIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChuZXdFbGVtZW50ICE9PSBvbGRFbGVtZW50KSB7XG4gICAgICAgIGNvbnRhaW5lci5yZXBsYWNlQ2hpbGQobmV3RWxlbWVudCwgb2xkRWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB0aGUgYXJyYXkgc2hyYW5rLCByZW1vdmUgdGhlIGV4dHJhIGVsZW1lbnRzIHdoaWNoIGFyZSBubyBsb25nZXIgbmVlZGVkLlxuICB3aGlsZSAoY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoID4gaXRlbXMubGVuZ3RoKSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5jaGlsZE5vZGVzW2l0ZW1zLmxlbmd0aF0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlckFycmF5QXNFbGVtZW50cztcbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IHRvZ2dsZUNsYXNzIGZyb20gJy4vdG9nZ2xlQ2xhc3MnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBzYWZlVG9TZXRBdHRyaWJ1dGVzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdzYWZlVG9TZXRBdHRyaWJ1dGVzJyk7XG5jb25zdCBwZW5kaW5nQXR0cmlidXRlc1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncGVuZGluZ0F0dHJpYnV0ZXMnKTtcbmNvbnN0IHBlbmRpbmdDbGFzc2VzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdwZW5kaW5nQ2xhc3NlcycpO1xuXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgdXBkYXRpbmcgYXR0cmlidXRlcywgaW5jbHVkaW5nIHRoZSBgY2xhc3NgIGF0dHJpYnV0ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFueSBwZW5kaW5nIHVwZGF0ZXMgdG8gYXR0cmlidXRlcyBhbmQgY2xhc3Nlcy5cbiAgICpcbiAgICogVGhpcyB3cml0ZXMgYW55IGBzZXRBdHRyaWJ1dGVgIG9yIGB0b2dnbGVDbGFzc2AgdmFsdWVzIHRoYXQgd2VyZSBwZXJmb3JtZWRcbiAgICogYmVmb3JlIGFuIGVsZW1lbnQgd2FzIGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgYnkgbWl4aW5zL2NvbXBvbmVudHMgaW4gdGhlaXJcbiAgICogYGNvbm5lY3RlZENhbGxiYWNrYC4gSWYgbXVsaXRwbGUgbWl4aW5zL2NvbXBvbmVudHMgaW52b2tlIHRoaXMgZHVyaW5nIHRoZVxuICAgKiBzYW1lIGBjb25uZWN0ZWRDYWxsYmFja2AsIG9ubHkgdGhlIGZpcnN0IGNhbGwgd2lsbCBoYXZlIGFueSBlZmZlY3QuIFRoZVxuICAgKiBzdWJzZXF1ZW50IGNhbGxzIHdpbGwgYmUgaGFybWxlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBiZWluZyBhZGRlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAqL1xuICBjb25uZWN0ZWQoZWxlbWVudCkge1xuICAgIGVsZW1lbnRbc2FmZVRvU2V0QXR0cmlidXRlc1N5bWJvbF0gPSB0cnVlO1xuXG4gICAgLy8gU2V0IGFueSBwZW5kaW5nIGF0dHJpYnV0ZXMuXG4gICAgaWYgKGVsZW1lbnRbcGVuZGluZ0F0dHJpYnV0ZXNTeW1ib2xdKSB7XG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gZWxlbWVudFtwZW5kaW5nQXR0cmlidXRlc1N5bWJvbF0pIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50W3BlbmRpbmdBdHRyaWJ1dGVzU3ltYm9sXVthdHRyaWJ1dGVdO1xuICAgICAgICBzZXRBdHRyaWJ1dGVUb0VsZW1lbnQoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbGVtZW50W3BlbmRpbmdBdHRyaWJ1dGVzU3ltYm9sXSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2V0IGFueSBwZW5kaW5nIGNsYXNzZXMuXG4gICAgaWYgKGVsZW1lbnRbcGVuZGluZ0NsYXNzZXNTeW1ib2xdKSB7XG4gICAgICBmb3IgKGxldCBjbGFzc05hbWUgaW4gZWxlbWVudFtwZW5kaW5nQ2xhc3Nlc1N5bWJvbF0pIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50W3BlbmRpbmdDbGFzc2VzU3ltYm9sXVtjbGFzc05hbWVdO1xuICAgICAgICB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRbcGVuZGluZ0NsYXNzZXNTeW1ib2xdID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldC91bnNldCB0aGUgYXR0cmlidXRlIHdpdGggdGhlIGluZGljYXRlZCBuYW1lLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBleGlzdHMgcHJpbWFyaWx5IHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbiBlbGVtZW50IHdhbnRzIHRvXG4gICAqIHNldCBhIGRlZmF1bHQgcHJvcGVydHkgdmFsdWUgdGhhdCBzaG91bGQgYmUgcmVmbGVjdGVkIGFzIGFuIGF0dHJpYnV0ZS4gQW5cbiAgICogaW1wb3J0YW50IGxpbWl0YXRpb24gb2YgY3VzdG9tIGVsZW1lbnQgY29uc3R1cmN0b3JzIGlzIHRoYXQgdGhleSBjYW5ub3RcbiAgICogc2V0IGF0dHJpYnV0ZXMuIEEgY2FsbCB0byBgc2V0QXR0cmlidXRlYCBkdXJpbmcgdGhlIGNvbnN0cnVjdG9yIHdpbGxcbiAgICogYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVsZW1lbnQgaXMgY29ubmVjdGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSAtIFRoZSBuYW1lIG9mIHRoZSAqYXR0cmlidXRlKiAobm90IHByb3BlcnR5KSB0byBzZXQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQuIElmIG51bGwsIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZW1vdmVkLlxuICAgKi9cbiAgc2V0QXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAoZWxlbWVudFtzYWZlVG9TZXRBdHRyaWJ1dGVzU3ltYm9sXSkge1xuICAgICAgLy8gU2FmZSB0byBzZXQgYXR0cmlidXRlcyBpbW1lZGlhdGVseS5cbiAgICAgIHNldEF0dHJpYnV0ZVRvRWxlbWVudChlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVmZXIgc2V0dGluZyBhdHRyaWJ1dGVzIHVudGlsIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RlZC5cbiAgICAgIGlmICghZWxlbWVudFtwZW5kaW5nQXR0cmlidXRlc1N5bWJvbF0pIHtcbiAgICAgICAgZWxlbWVudFtwZW5kaW5nQXR0cmlidXRlc1N5bWJvbF0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRbcGVuZGluZ0F0dHJpYnV0ZXNTeW1ib2xdW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldC91bnNldCB0aGUgY2xhc3Mgd2l0aCB0aGUgaW5kaWNhdGVkIG5hbWUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGV4aXN0cyBwcmltYXJpbHkgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFuIGVsZW1lbnQgd2FudHMgdG9cbiAgICogc2V0IGEgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZSB0aGF0IHNob3VsZCBiZSByZWZsZWN0ZWQgYXMgYXMgY2xhc3MuIEFuXG4gICAqIGltcG9ydGFudCBsaW1pdGF0aW9uIG9mIGN1c3RvbSBlbGVtZW50IGNvbnN0dXJjdG9ycyBpcyB0aGF0IHRoZXkgY2Fubm90XG4gICAqIHNldCBhdHRyaWJ1dGVzLCBpbmNsdWRpbmcgdGhlIGBjbGFzc2AgYXR0cmlidXRlLiBBIGNhbGwgdG9cbiAgICogYHRvZ2dsZUNsYXNzYCBkdXJpbmcgdGhlIGNvbnN0cnVjdG9yIHdpbGwgYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVsZW1lbnRcbiAgICogaXMgY29ubmVjdGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjbGFzcyB0byBzZXQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZSAtIFRydWUgdG8gc2V0IHRoZSBjbGFzcywgZmFsc2UgdG8gcmVtb3ZlIGl0LlxuICAgKi9cbiAgdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCB2YWx1ZSkge1xuICAgIGlmIChlbGVtZW50W3NhZmVUb1NldEF0dHJpYnV0ZXNTeW1ib2xdKSB7XG4gICAgICAvLyBTYWZlIHRvIHNldCBjbGFzcyBpbW1lZGlhdGVseS5cbiAgICAgIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZlciBzZXR0aW5nIGNsYXNzIHVudGlsIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RlZC5cbiAgICAgIGlmICghZWxlbWVudFtwZW5kaW5nQ2xhc3Nlc1N5bWJvbF0pIHtcbiAgICAgICAgZWxlbWVudFtwZW5kaW5nQ2xhc3Nlc1N5bWJvbF0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRbcGVuZGluZ0NsYXNzZXNTeW1ib2xdW2NsYXNzTmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxufTtcblxuXG4vLyBSZWZsZWN0IHRoZSBhdHRyaWJ1dGUgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXG4vLyBJZiB0aGUgdmFsdWUgaXMgbnVsbCwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVUb0VsZW1lbnQoZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0ZXh0ID0gU3RyaW5nKHZhbHVlKTtcbiAgICAvLyBBdm9pZCByZWN1cnNpdmUgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIGNhbGxzLlxuICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSAhPT0gdGV4dCkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuL2NyZWF0ZVN5bWJvbCc7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIFN5bWJvbCBvYmplY3RzIGZvciBzdGFuZGFyZCBjb21wb25lbnQgcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAqXG4gKiBUaGVzZSBTeW1ib2wgb2JqZWN0cyBhcmUgdXNlZCB0byBhbGxvdyBtaXhpbnMgYW5kIGEgY29tcG9uZW50IHRvIGludGVybmFsbHlcbiAqIGNvbW11bmljYXRlLCB3aXRob3V0IGV4cG9zaW5nIHRoZXNlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlIGNvbXBvbmVudCdzXG4gKiBwdWJsaWMgQVBJLlxuICpcbiAqIFRvIHVzZSB0aGVzZSBTeW1ib2wgb2JqZWN0cyBpbiB5b3VyIG93biBjb21wb25lbnQsIGluY2x1ZGUgdGhpcyBtb2R1bGUgYW5kXG4gKiB0aGVuIGNyZWF0ZSBhIHByb3BlcnR5IG9yIG1ldGhvZCB3aG9zZSBrZXkgaXMgdGhlIGRlc2lyZWQgU3ltYm9sLlxuICpcbiAqICAgICBpbXBvcnQgJ1NpbmdsZVNlbGVjdGlvbk1peGluJyBmcm9tICdiYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TaW5nbGVTZWxlY3Rpb25NaXhpbic7XG4gKiAgICAgaW1wb3J0ICdzeW1ib2xzJyBmcm9tICdiYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zeW1ib2xzJztcbiAqXG4gKiAgICAgY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgU2luZ2xlU2VsZWN0aW9uTWl4aW4oSFRNTEVsZW1lbnQpIHtcbiAqICAgICAgIFtzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgc2VsZWN0ZWQpIHtcbiAqICAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGludm9rZWQgd2hlbmV2ZXIgYW4gaXRlbSBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkLlxuICogICAgICAgfVxuICogICAgIH1cbiAqXG4gKiBAbW9kdWxlIHN5bWJvbHNcbiAqL1xuY29uc3Qgc3ltYm9scyA9IHtcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGRlZmF1bHRzYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBzZXQgb3Igb3ZlcnJpZGUgZGVmYXVsdHMgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAgICogdG8gYSBuZXcgY29tcG9uZW50IGluc3RhbmNlLiBXaGVuIGltcGxlbWVudGluZyB0aGlzIHByb3BlcnR5LCB0YWtlIGNhcmUgdG9cbiAgICogZmlyc3QgYWNxdWlyZSBhbnkgZGVmYXVsdHMgZGVmaW5lZCBieSB0aGUgc3VwZXJjbGFzcy4gVGhlIHN0YW5kYXJkIGlkaW9tIGlzXG4gICAqIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqICAgICBnZXQgW3N5bWJvbHMuZGVmYXVsdHNdKCkge1xuICAgKiAgICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgKiAgICAgICAvLyBTZXQgb3Igb3ZlcnJpZGUgZGVmYXVsdCB2YWx1ZXMgaGVyZVxuICAgKiAgICAgICBkZWZhdWx0cy5jdXN0b21Qcm9wZXJ0eSA9IGZhbHNlO1xuICAgKiAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEB2YXIge29iamVjdH0gZGVmYXVsdHNcbiAgICovXG4gIGRlZmF1bHRzOiBjcmVhdGVTeW1ib2woJ2RlZmF1bHRzJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBkcmFnZ2luZ2AgcHJvcGVydHkuXG4gICAqXG4gICAqIENvbXBvbmVudHMgbGlrZSBjYXJvdXNlbHMgb2Z0ZW4gZGVmaW5lIGFuaW1hdGVkIENTUyB0cmFuc2l0aW9ucyBmb3JcbiAgICogc2xpZGluZyBlZmZlY3RzLiBTdWNoIGEgdHJhbnNpdGlvbiBzaG91bGQgdXN1YWxseSAqbm90KiBiZSBhcHBsaWVkIHdoaWxlXG4gICAqIHRoZSB1c2VyIGlzIGRyYWdnaW5nLCBiZWNhdXNlIGEgQ1NTIGFuaW1hdGlvbiB3aWxsIGludHJvZHVjZSBhIGxhZyB0aGF0XG4gICAqIG1ha2VzIHRoZSBzd2lwZSBmZWVsIHNsdWdnaXNoLiBJbnN0ZWFkLCBhcyBsb25nIGFzIHRoZSB1c2VyIGlzIGRyYWdnaW5nXG4gICAqIHdpdGggdGhlaXIgZmluZ2VyIGRvd24sIHRoZSB0cmFuc2l0aW9uIHNob3VsZCBiZSBzdXBwcmVzc2VkLiBXaGVuIHRoZVxuICAgKiB1c2VyIHJlbGVhc2VzIHRoZWlyIGZpbmdlciwgdGhlIHRyYW5zaXRpb24gY2FuIGJlIHJlc3RvcmVkLCBhbGxvd2luZyB0aGVcbiAgICogYW5pbWF0aW9uIHRvIHNob3cgdGhlIGNhcm91c2VsIHNsaWRpbmcgaW50byBpdHMgZmluYWwgcG9zaXRpb24uXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufSB0cnVlIGlmIGEgZHJhZyBpcyBpbiBwcm9ncmVzcywgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgZHJhZ2dpbmc6IGNyZWF0ZVN5bWJvbCgnZHJhZ2dpbmcnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGdvRG93bmAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgZG93bi5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGdvRG93blxuICAgKi9cbiAgZ29Eb3duOiBjcmVhdGVTeW1ib2woJ2dvRG93bicpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgZ29FbmRgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIHRvIHRoZSBlbmQgKGUuZy4sXG4gICAqIG9mIGEgbGlzdCkuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBnb0VuZFxuICAgKi9cbiAgZ29FbmQ6IGNyZWF0ZVN5bWJvbCgnZ29FbmQnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGdvTGVmdGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgbGVmdC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGdvTGVmdFxuICAgKi9cbiAgZ29MZWZ0OiBjcmVhdGVTeW1ib2woJ2dvTGVmdCcpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgZ29SaWdodGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgcmlnaHQuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBnb1JpZ2h0XG4gICAqL1xuICBnb1JpZ2h0OiBjcmVhdGVTeW1ib2woJ2dvUmlnaHQnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGdvU3RhcnRgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIHRvIHRoZSBzdGFydFxuICAgKiAoZS5nLiwgb2YgYSBsaXN0KS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGdvU3RhcnRcbiAgICovXG4gIGdvU3RhcnQ6IGNyZWF0ZVN5bWJvbCgnZ29TdGFydCcpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgZ29VcGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgdXAuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBnb1VwXG4gICAqL1xuICBnb1VwOiBjcmVhdGVTeW1ib2woJ2dvVXAnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGl0ZW1BZGRlZGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gYSBuZXcgaXRlbSBpcyBhZGRlZCB0byBhIGxpc3QuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBpdGVtQWRkZWRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaXRlbSAtIHRoZSBpdGVtIGJlaW5nIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgICovXG4gIGl0ZW1BZGRlZDogY3JlYXRlU3ltYm9sKCdpdGVtQWRkZWQnKSxcblxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgaXRlbXNDaGFuZ2VkYCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdW5kZXJseWluZyBjb250ZW50cyBjaGFuZ2UuIEl0IGlzIGFsc29cbiAgICogaW52b2tlZCBvbiBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24g4oCTIHNpbmNlIHRoZSBpdGVtcyBoYXZlIFwiY2hhbmdlZFwiIGZyb21cbiAgICogYmVpbmcgbm90aGluZy5cbiAgICovXG4gIGl0ZW1zQ2hhbmdlZDogY3JlYXRlU3ltYm9sKCdpdGVtc0NoYW5nZWQnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGl0ZW1TZWxlY3RlZGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gYW4gaXRlbSBiZWNvbWVzIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBpdGVtU2VsZWN0ZWRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaXRlbSAtIHRoZSBpdGVtIGJlaW5nIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZCAtIHRydWUgaWYgdGhlIGl0ZW0gaXMgc2VsZWN0ZWQsIGZhbHNlIGlmIG5vdFxuICAgKi9cbiAgaXRlbVNlbGVjdGVkOiBjcmVhdGVTeW1ib2woJ2l0ZW1TZWxlY3RlZCcpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBga2V5ZG93bmAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gYW4gZWxlbWVudCByZWNlaXZlcyBhIGBrZXlkb3duYCBldmVudC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGtleWRvd25cbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIHRoZSBldmVudCBiZWluZyBwcm9jZXNzZWRcbiAgICovXG4gIGtleWRvd246IGNyZWF0ZVN5bWJvbCgna2V5ZG93bicpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgdGVtcGxhdGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBUaGlzIHByb3BlcnR5IHJldHVybnMgYSBjb21wb25lbnQncyB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ3xIVE1MRWxlbWVudH1cbiAgICovXG4gIHRlbXBsYXRlOiBjcmVhdGVTeW1ib2woJ3RlbXBsYXRlJylcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN5bWJvbHM7XG4iLCIvKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3Igc3RhbmRhcmQgY2xhc3NMaXN0LnRvZ2dsZSgpIGJlaGF2aW9yIG9uIG9sZCBicm93c2VycyxcbiAqIG5hbWVseSBJRSAxMS5cbiAqXG4gKiBUaGUgc3RhbmRhcmRcbiAqIFtjbGFzc2xpc3RdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2NsYXNzTGlzdClcbiAqIG9iamVjdCBoYXMgYSBgdG9nZ2xlKClgIGZ1bmN0aW9uIHRoYXQgc3VwcG9ydHMgYSBzZWNvbmQgQm9vbGVhbiBwYXJhbWV0ZXJcbiAqIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3VjY2luY3RseSB0dXJuIGEgY2xhc3Mgb24gb3Igb2ZmLiBUaGlzIGZlYXR1cmUgaXMgb2Z0ZW5cbiAqIHVzZWZ1bCBpbiBkZXNpZ25pbmcgY3VzdG9tIGVsZW1lbnRzLCB3aGljaCBtYXkgd2FudCB0byBleHRlcm5hbGx5IHJlZmxlY3RcbiAqIGNvbXBvbmVudCBzdGF0ZSBpbiBhIENTUyBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBzdHlsaW5nIHB1cnBvc2VzLlxuICpcbiAqIFVuZm9ydHVuYXRlbHksIElFIDExIGRvZXMgbm90IHN1cHBvcnQgdGhlIEJvb2xlYW4gcGFyYW1ldGVyIHRvXG4gKiBgY2xhc3NMaXN0LnRvZ2dsZSgpYC4gVGhpcyBoZWxwZXIgZnVuY3Rpb24gYmVoYXZlcyBsaWtlIHRoZSBzdGFuZGFyZFxuICogYHRvZ2dsZSgpYCwgaW5jbHVkaW5nIHN1cHBvcnQgZm9yIHRoZSBCb29sZWFuIHBhcmFtZXRlciwgc28gdGhhdCBpdCBjYW4gYmVcbiAqIHVzZWQgZXZlbiBvbiBJRSAxMS5cbiAqXG4gKiBAZnVuY3Rpb24gdG9nZ2xlQ2xhc3NcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgLSBUaGUgY2xhc3MgdG8gYWRkL3JlbW92ZVxuICogQHBhcmFtIHtib29sZWFufSBbZm9yY2VdIC0gRm9yY2UgdGhlIGNsYXNzIHRvIGJlIGFkZGVkIChpZiB0cnVlKSBvciByZW1vdmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaWYgZmFsc2UpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgZm9yY2UpIHtcbiAgY29uc3QgY2xhc3NMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XG4gIGNvbnN0IGFkZENsYXNzID0gKHR5cGVvZiBmb3JjZSA9PT0gJ3VuZGVmaW5lZCcpID9cbiAgICAhY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkgOlxuICAgIGZvcmNlO1xuICBpZiAoYWRkQ2xhc3MpIHtcbiAgICBjbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICB9XG4gIHJldHVybiBhZGRDbGFzcztcbn1cbiJdfQ=="}