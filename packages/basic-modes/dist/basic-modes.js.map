{"version":3,"sources":["node_modules/browser-pack/_prelude.js","packages/basic-component-mixins/src/AttributeMarshallingMixin.js","packages/basic-component-mixins/src/ComposableMixin.js","packages/basic-component-mixins/src/ContentItemsMixin.js","packages/basic-component-mixins/src/DistributedChildrenContentMixin.js","packages/basic-component-mixins/src/DistributedChildrenMixin.js","packages/basic-component-mixins/src/ShadowElementReferencesMixin.js","packages/basic-component-mixins/src/ShadowTemplateMixin.js","packages/basic-component-mixins/src/SingleSelectionMixin.js","packages/basic-component-mixins/src/createSymbol.js","packages/basic-component-mixins/src/microtask.js","packages/basic-component-mixins/src/safeAttributes.js","packages/basic-component-mixins/src/symbols.js","packages/basic-component-mixins/src/toggleClass.js","packages/basic-element-base/src/ElementBase.js","packages/basic-modes/globals.js","packages/basic-modes/src/Modes.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;ACAA;;;;;;;;;;;;AAGA;AACA,IAAM,2BAA2B,EAAjC;AACA,IAAM,4BAA4B,EAAlC;;AAGA;;kBACe,UAAC,IAAD,EAAU;;AAEvB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAFuB,MAqCjB,oBArCiB;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;AAuCrB;;;AAvCqB,+CA0CI,aA1CJ,EA0CmB,QA1CnB,EA0C6B,QA1C7B,EA0CuC;AAC1D,uJAAoC;AAAE;AAAmC;AACzE,YAAM,eAAe,wBAAwB,aAAxB,CAArB;AACA;AACA;AACA,YAAI,gBAAgB,IAAhB,IAAwB,EAAE,gBAAgB,YAAY,SAA9B,CAA5B,EAAsE;AACpE,eAAK,YAAL,IAAqB,QAArB;AACD;AACF;AAlDoB;AAAA;AAAA,0CAoDD;AAClB,gJAA6B;AAAE;AAA4B;AAC3D,iCAAe,SAAf,CAAyB,IAAzB;AACD;AAvDoB;AAAA;;;AA6DrB;;;;;;;;;;;;AA7DqB,uCAyEJ,SAzEI,EAyEO,KAzEP,EAyEc;AACjC,eAAO,yBAAe,YAAf,CAA4B,IAA5B,EAAkC,SAAlC,EAA6C,KAA7C,CAAP;AACD;;AAED;;;;;;;;;;;;;;AA7EqB;AAAA;AAAA,mCA0FR,SA1FQ,EA0FG,KA1FH,EA0FU;AAC7B,eAAO,yBAAe,WAAf,CAA2B,IAA3B,EAAiC,SAAjC,EAA4C,KAA5C,CAAP;AACD;AA5FoB;AAAA;AAAA,0BAyDW;AAC9B,eAAO,mBAAmB,IAAnB,CAAP;AACD;AA3DoB;;AAAA;AAAA,IAqCY,IArCZ;;AAgGvB,SAAO,oBAAP;AACD,C;;AAGD;;;AACA,SAAS,uBAAT,CAAiC,aAAjC,EAAgD;AAC9C,MAAI,eAAe,yBAAyB,aAAzB,CAAnB;AACA,MAAI,CAAC,YAAL,EAAmB;AACjB;AACA,QAAM,aAAa,WAAnB;AACA,mBAAe,cAAc,OAAd,CAAsB,UAAtB,EACX;AAAA,aAAS,MAAM,CAAN,EAAS,WAAT,EAAT;AAAA,KADW,CAAf;AAEA,6BAAyB,aAAzB,IAA0C,YAA1C;AACD;AACD,SAAO,YAAP;AACD;;AAED,SAAS,kBAAT,CAA4B,OAA5B,EAAqC;;AAEnC;AACA;AACA,MAAI,YAAY,WAAZ,IAA2B,YAAY,MAA3C,EAAmD;AACjD,WAAO,EAAP;AACD;;AAED;AACA,MAAM,YAAY,OAAO,cAAP,CAAsB,QAAQ,SAA9B,EAAyC,WAA3D;AACA,MAAM,iBAAiB,mBAAmB,SAAnB,CAAvB;;AAEA;AACA,MAAM,gBAAgB,OAAO,mBAAP,CAA2B,QAAQ,SAAnC,CAAtB;AACA,MAAM,cAAc,cAAc,MAAd,CAAqB;AAAA,WACvC,OAAO,OAAO,wBAAP,CACH,QAAQ,SADL,EACgB,YADhB,EAC8B,GADrC,KAC6C,UAFN;AAAA,GAArB,CAApB;AAGA,MAAM,aAAa,YAAY,GAAZ,CAAgB;AAAA,WAC/B,wBAAwB,UAAxB,CAD+B;AAAA,GAAhB,CAAnB;;AAGA;AACA,MAAM,OAAO,WAAW,MAAX,CAAkB;AAAA,WAC3B,eAAe,OAAf,CAAuB,SAAvB,IAAoC,CADT;AAAA,GAAlB,CAAb;AAEA,SAAO,eAAe,MAAf,CAAsB,IAAtB,CAAP;AACD;;AAED;AACA,SAAS,uBAAT,CAAiC,YAAjC,EAA+C;AAC7C,MAAI,YAAY,0BAA0B,YAA1B,CAAhB;AACA,MAAI,CAAC,SAAL,EAAgB;AACd;AACA,QAAM,iBAAiB,UAAvB;AACA,gBAAY,aAAa,OAAb,CAAqB,cAArB,EAAqC,KAArC,EAA4C,WAA5C,EAAZ;AACD;AACD,SAAO,SAAP;AACD;;;;;;;;;;;;;;;;;AC7JD;kBACe,UAAC,IAAD,EAAU;;AAEvB;;;;;;;AAFuB,MASjB,UATiB;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;AAWrB;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAXqB,gCAuCK;AAAA,0CAAR,MAAQ;AAAR,gBAAQ;AAAA;;AACxB;AACA;AACA;AACA;AACA,eAAO,OAAO,MAAP,CAAc,YAAd,EAA4B,IAA5B,CAAP;AACD;AA7CoB;;AAAA;AAAA,IASE,IATF;;AAiDvB,SAAO,UAAP;AACD,C;;AAGD;;;AACA,IAAM,gCAAgC,CACpC,aADoC,CAAtC;;AAIA;;;;;AAKA,SAAS,YAAT,CAAsB,IAAtB,EAA4B,KAA5B,EAAmC;AACjC,MAAI,OAAO,KAAP,KAAiB,UAArB,EAAiC;AAC/B;AACA,WAAO,MAAM,IAAN,CAAP;AACD,GAHD,MAGO;AACL;AADK,QAEC,QAFD;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA,MAEkB,IAFlB;;AAGL,sBAAkB,KAAlB,EAAyB,SAAS,SAAlC,EAA6C,6BAA7C;AACA,WAAO,QAAP;AACD;AACF;;AAGD;;;;AAIA,SAAS,iBAAT,CAA2B,MAA3B,EAAmC,MAAnC,EAAqE;AAAA,MAA1B,mBAA0B,uEAAJ,EAAI;;AACnE,SAAO,mBAAP,CAA2B,MAA3B,EAAmC,OAAnC,CAA2C,gBAAQ;AACjD,QAAI,oBAAoB,OAApB,CAA4B,IAA5B,IAAoC,CAAxC,EAA2C;AACzC,UAAM,aAAa,OAAO,wBAAP,CAAgC,MAAhC,EAAwC,IAAxC,CAAnB;AACA,aAAO,cAAP,CAAsB,MAAtB,EAA8B,IAA9B,EAAoC,UAApC;AACD;AACF,GALD;AAMA,SAAO,MAAP;AACD;;;;;;;;;;;;;ACzFD;;;;AACA;;;;AACA;;;;;;;;;;;;AAGA;AACA,IAAM,cAAc,4BAAa,OAAb,CAApB;AACA,IAAM,wBAAwB,4BAAa,iBAAb,CAA9B;;AAGA;;kBACe,UAAC,IAAD,EAAU;;AAEvB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAFuB,MAgCjB,YAhCiB;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA,uCAkCJ;AACf,6HAA0B;AAAE;AAAyB;;AAErD;AACA;AACA;AACA;AACA,aAAK,WAAL,IAAoB,IAApB;;AAEA,aAAK,kBAAQ,YAAb;AACD;;AAED;;;;;;;;;AA9CqB;AAAA,WAsDpB,kBAAQ,SAtDY;AAAA,4BAsDD,IAtDC,EAsDK;AACxB,oGAAU,kBAAQ,SAAlB,SAA8B;AAAE,kGAAM,kBAAQ,SAAd,mBAAyB,IAAzB;AAAiC;AAClE;;AAED;;;;;;;;;;;AA1DqB;AAAA,WAoEpB,kBAAQ,YApEY;AAAA,4BAoEE,IApEF,EAoEQ,QApER,EAoEkB;AACrC,oGAAU,kBAAQ,YAAlB,SAAiC;AAAE,kGAAM,kBAAQ,YAAd,mBAA4B,IAA5B,EAAkC,QAAlC;AAA8C;AACjF,mCAAY,IAAZ,EAAkB,UAAlB,EAA8B,QAA9B;AACD;;AAED;;;;;;;AAzEqB;AAAA,WAoGpB,kBAAQ,YApGY;;;AA+FrB;;;;;AA/FqB,8BAoGI;AAAA;;AACvB,oGAAU,kBAAQ,YAAlB,SAAiC;AAAE,kGAAM,kBAAQ,YAAd;AAAgC;;AAEnE;AACA,cAAM,SAAN,CAAgB,OAAhB,CAAwB,IAAxB,CAA6B,KAAK,KAAlC,EAAyC,gBAAQ;AAC/C,cAAI,CAAC,KAAK,qBAAL,CAAL,EAAkC;AAChC,mBAAK,kBAAQ,SAAb,EAAwB,IAAxB;AACA,iBAAK,qBAAL,IAA8B,IAA9B;AACD;AACF,SALD;;AAOA,aAAK,aAAL,CAAmB,IAAI,WAAJ,CAAgB,eAAhB,CAAnB;AACD;;AAED;;;;;;;AAlHqB;AAAA;AAAA,0BA+ET;AACV,YAAI,cAAJ;AACA,YAAI,KAAK,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,kBAAQ,wBAAwB,KAAK,OAA7B,CAAR;AACA;AACA,cAAI,KAAK,WAAL,MAAsB,IAA1B,EAAgC;AAC9B;AACA,iBAAK,WAAL,IAAoB,KAApB;AACD;AACF,SAPD,MAOO;AACL;AACA,kBAAQ,KAAK,WAAL,CAAR;AACD;AACD,eAAO,KAAP;AACD;AA7FoB;;AAAA;AAAA,IAgCI,IAhCJ;;AA0HvB,SAAO,YAAP;AACD,C;;AAGD;AACA;;;AACA,SAAS,uBAAT,CAAiC,KAAjC,EAAwC;AACtC,MAAM,gBAAgB,CACpB,MADoB,EAEpB,QAFoB,EAGpB,OAHoB,EAIpB,UAJoB,CAAtB;AAMA,SAAO,GAAG,MAAH,CAAU,IAAV,CAAe,KAAf,EAAsB,UAAS,IAAT,EAAe;AAC1C,WAAO,CAAC,KAAK,SAAN,IAAmB,cAAc,OAAd,CAAsB,KAAK,SAA3B,IAAwC,CAAlE;AACD,GAFM,CAAP;AAGD;;;;;;;;;;;;;;;ACrJD;;;;;;;;;;;;AAGA;kBACe,UAAC,IAAD,EAAU;;AAEvB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAFuB,MA2CjB,0BA3CiB;AAAA;;AA6CrB,0CAAc;AAAA;;AAAA;;AAGZ,UAAI,MAAK,UAAT,EAAqB;AACnB;AACA,YAAM,QAAQ,MAAK,UAAL,CAAgB,gBAAhB,CAAiC,MAAjC,CAAd;AACA,cAAM,OAAN,CAAc;AAAA,iBAAQ,KAAK,gBAAL,CAAsB,YAAtB,EAAoC,iBAAS;AACjE,kBAAK,cAAL;AACD,WAFqB,CAAR;AAAA,SAAd;AAGD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,+BAAU;AAAA,eAAM,MAAK,cAAL,EAAN;AAAA,OAAV;AAjBY;AAkBb;;AAED;;;;;;;;;;AAjEqB;AAAA;AAAA,uCAyEJ;AACf,yJAA0B;AAAE;AAAyB;AACrD,YAAM,QAAQ,IAAI,WAAJ,CAAgB,iBAAhB,CAAd;AACA,aAAK,aAAL,CAAmB,KAAnB;AACD;;AAED;;;;;;;AA/EqB;AAAA;AAAA,0BAqFP;AACZ,YAAM,sBAAsB,KAAK,mBAAjC;AACA,YAAI,OAAO,mBAAP,KAA+B,WAAnC,EAAgD;AAC9C,kBAAQ,IAAR;AACD;AACD,eAAO,mBAAP;AACD,OA3FoB;AAAA,wBA4FT,KA5FS,EA4FF;AACjB,YAAI,aAAa,KAAK,SAAtB,EAAiC;AAAE,yIAAgB,KAAhB;AAAwB;AAC3D;AACA;AACD;;AAED;;;;;;;;AAlGqB;;AAAA;AAAA,IA2CkB,IA3ClB;;AA2GvB,SAAO,0BAAP;AACD,C;;;;;;;;;;;;;;;;;;;AChHD;kBACe,UAAC,IAAD,EAAU;;AAEvB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAFuB,MA6CjB,mBA7CiB;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;AA+CrB;;;;;;AA/CqB,0BAqDK;AACxB,eAAO,sBAAsB,KAAK,QAA3B,EAAqC,KAArC,CAAP;AACD;;AAED;;;;;;;;AAzDqB;AAAA;AAAA,0BAgEO;AAC1B,eAAO,sBAAsB,KAAK,UAA3B,EAAuC,IAAvC,CAAP;AACD;;AAED;;;;;;;AApEqB;AAAA;AAAA,0BA0EQ;AAC3B,YAAM,UAAU,KAAK,qBAAL,CAA2B,GAA3B,CAA+B,UAAS,KAAT,EAAgB;AAC7D,iBAAO,MAAM,WAAb;AACD,SAFe,CAAhB;AAGA,eAAO,QAAQ,IAAR,CAAa,EAAb,CAAP;AACD;AA/EoB;;AAAA;AAAA,IA6CW,IA7CX;;AAmFvB,SAAO,mBAAP;AACD,C;;AAGD;;;;;;;;;;;AASA,SAAS,qBAAT,CAA+B,KAA/B,EAAsC,gBAAtC,EAAwD;AAAA;;AACtD,MAAM,WAAW,MAAM,SAAN,CAAgB,GAAhB,CAAoB,IAApB,CAAyB,KAAzB,EAAgC,gBAAQ;AACvD;AACA;AACA;AACA;AACA,QAAM,SAAS,OAAO,eAAP,KAA2B,WAA3B,GACb,gBAAgB,eADH,GAEb,KAAK,SAAL,KAAmB,MAFrB;AAGA,QAAI,MAAJ,EAAY;AACV;AACA,UAAM,gBAAgB,KAAK,aAAL,CAAmB,EAAE,SAAS,IAAX,EAAnB,CAAtB;AACA,aAAO,gBACL,sBAAsB,aAAtB,EAAqC,gBAArC,CADK,GAEL,EAFF;AAGD,KAND,MAMO,IAAI,gBAAgB,WAApB,EAAiC;AACtC;AACA,aAAO,CAAC,IAAD,CAAP;AACD,KAHM,MAGA,IAAI,gBAAgB,IAAhB,IAAwB,gBAA5B,EAA8C;AACnD;AACA,aAAO,CAAC,IAAD,CAAP;AACD,KAHM,MAGA;AACL;AACA,aAAO,EAAP;AACD;AACF,GAxBgB,CAAjB;AAyBA,MAAM,YAAY,YAAG,MAAH,gCAAa,QAAb,EAAlB;AACA,SAAO,SAAP;AACD;;;;;;;;;;;;;;;AC7HD;kBACe,UAAC,IAAD,EAAU;;AAEvB;;;;;;;;;;;;;;;;;;;;;AAFuB,MAuBjB,uBAvBiB;AAAA;;AAyBrB,uCAAc;AAAA;;AAAA;;AAEZ,UAAI,MAAK,UAAT,EAAqB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,cAAK,CAAL,GAAS,EAAT;AACA,YAAM,eAAe,MAAK,UAAL,CAAgB,gBAAhB,CAAiC,MAAjC,CAArB;AACA,WAAG,OAAH,CAAW,IAAX,CAAgB,YAAhB,EAA8B,gBAAQ;AACpC,cAAM,KAAK,KAAK,YAAL,CAAkB,IAAlB,CAAX;AACA,gBAAK,CAAL,CAAO,EAAP,IAAa,IAAb;AACD,SAHD;AAID;AAfW;AAgBb;;AAED;;;;;;;;;AA3CqB;AAAA,IAuBe,IAvBf;;AAoDvB,SAAO,uBAAP;AACD,C;;;;;;;;;ACtDD;;;;;;;;;;;;AAGA;kBACe,UAAC,IAAD,EAAU;;AAEvB;;;;;;;;;;;;;;;;;;;;;;AAFuB,MAwBjB,cAxBiB;AAAA;;AA0BrB;;;;AAIA,8BAAc;AAAA;;AAAA;;AAEZ,UAAI,WAAW,MAAK,kBAAQ,QAAb,CAAf;AACA;AACA;AACA,UAAI,QAAJ,EAAc;;AAEZ,YAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAChC;AACA,qBAAW,4BAA4B,QAA5B,CAAX;AACD;;AAED,YAAI,OAAO,iBAAX,EAA8B;AAC5B,6BAAmB,QAAnB,EAA6B,MAAK,SAAlC;AACD;;AAED,YAAM,OAAO,MAAK,YAAL,CAAkB,EAAE,MAAM,MAAR,EAAlB,CAAb;AACA,YAAM,QAAQ,SAAS,UAAT,CAAoB,SAAS,OAA7B,EAAsC,IAAtC,CAAd;AACA,aAAK,WAAL,CAAiB,KAAjB;AACD;AAnBW;AAoBb;;AAlDoB;AAAA,IAwBM,IAxBN;;AAsDvB,SAAO,cAAP;AACD,C;;AAGD;;;AACA,SAAS,2BAAT,CAAqC,SAArC,EAAgD;AAC9C,MAAM,WAAW,SAAS,aAAT,CAAuB,UAAvB,CAAjB;AACA;AACA;AACA;AACA,MAAM,MAAM,SAAS,aAAT,CAAuB,KAAvB,CAAZ;AACA,MAAI,SAAJ,GAAgB,SAAhB;AACA,SAAO,IAAI,UAAJ,CAAe,MAAf,GAAwB,CAA/B,EAAkC;AAChC,aAAS,OAAT,CAAiB,WAAjB,CAA6B,IAAI,UAAJ,CAAe,CAAf,CAA7B;AACD;AACD,SAAO,QAAP;AACD;;AAED;AACA,SAAS,kBAAT,CAA4B,QAA5B,EAAsC,GAAtC,EAA2C;AACzC,SAAO,aAAP,CAAqB,SAArB,CAA+B,WAA/B,CAA2C,SAAS,OAApD,EAA6D,GAA7D;AACD;;;;;;;;;;;;;;;AC/ED;;;;AACA;;;;;;;;;;;;AAGA;AACA,IAAM,sBAAsB,4BAAa,eAAb,CAA5B;AACA,IAAM,0BAA0B,4BAAa,mBAAb,CAAhC;AACA,IAAM,0BAA0B,4BAAa,mBAAb,CAAhC;AACA,IAAM,uBAAuB,4BAAa,gBAAb,CAA7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAM,8BAA8B,4BAAa,uBAAb,CAApC;AACA,IAAM,6BAA6B,4BAAa,sBAAb,CAAnC;AACA,IAAM,8BAA8B,4BAAa,uBAAb,CAApC;AACA,IAAM,6BAA6B,4BAAa,sBAAb,CAAnC;;AAGA;;kBACe,UAAC,IAAD,EAAU;;AAEvB;;;;;;;;;;;;;;;;;;;;;;AAFuB,MAwBjB,eAxBiB;AAAA;;AA0BrB,+BAAc;AAAA;;AAEZ;AAFY;;AAGZ,UAAI,OAAO,MAAK,iBAAZ,KAAkC,WAAtC,EAAmD;AACjD,cAAK,iBAAL,GAAyB,MAAK,kBAAQ,QAAb,EAAuB,iBAAhD;AACD;AACD,UAAI,OAAO,MAAK,cAAZ,KAA+B,WAAnC,EAAgD;AAC9C,cAAK,cAAL,GAAsB,MAAK,kBAAQ,QAAb,EAAuB,cAA7C;AACD;AARW;AASb;;AAED;;;;;;;;AArCqB;AAAA,WAwFpB,kBAAQ,SAxFY;;;AAgFrB;;;;;;;;AAhFqB,4BAwFD,IAxFC,EAwFK;AACxB,0GAAU,kBAAQ,SAAlB,SAA8B;AAAE,wGAAM,kBAAQ,SAAd,mBAAyB,IAAzB;AAAiC;AACjE,aAAK,kBAAQ,YAAb,EAA2B,IAA3B,EAAiC,SAAS,KAAK,YAA/C;AACD;AA3FoB;AAAA,WA6FpB,kBAAQ,YA7FY;AAAA,8BA6FI;AACvB,0GAAU,kBAAQ,YAAlB,SAAiC;AAAE,wGAAM,kBAAQ,YAAd;AAAgC;;AAEnE;AACA,0BAAkB,IAAlB;;AAEA;AACA,kCAA0B,IAA1B;AACD;;AAED;;;;;;;;;;AAvGqB;AAAA,WAgHpB,kBAAQ,YAhHY;AAAA,4BAgHE,IAhHF,EAgHQ,QAhHR,EAgHkB;AACrC,0GAAU,kBAAQ,YAAlB,SAAiC;AAAE,wGAAM,kBAAQ,YAAd,mBAA4B,IAA5B,EAAkC,QAAlC;AAA8C;AAClF;;AAED;;;;;;;;;AApHqB;AAAA;;;AA0OrB;;;AA1OqB,oCA6OP;AACZ,gIAAuB;AAAE;AAAsB;AAC/C,eAAO,YAAY,IAAZ,EAAkB,CAAlB,CAAP;AACD;;AAED;;;;;;;AAlPqB;AAAA;;;AAgRrB;;;AAhRqB,mCAmRR;AACX,+HAAsB;AAAE;AAAqB;AAC7C,eAAO,YAAY,IAAZ,EAAkB,KAAK,KAAL,CAAW,MAAX,GAAoB,CAAtC,CAAP;AACD;;AAED;;;;AAxRqB;AAAA;AAAA,mCA2RR;AACX,+HAAsB;AAAE;AAAqB;AAC7C,eAAO,YAAY,IAAZ,EAAkB,KAAK,aAAL,GAAqB,CAAvC,CAAP;AACD;;AAED;;;;;;AAhSqB;AAAA;AAAA,uCAqSJ;AACf,mIAA0B;AAAE;AAAyB;AACrD,YAAM,WAAW,KAAK,aAAL,GAAqB,CAArB,GACf,KAAK,KAAL,CAAW,MAAX,GAAoB,CADL,GACa;AAC5B,aAAK,aAAL,GAAqB,CAFvB;AAGA,eAAO,YAAY,IAAZ,EAAkB,QAAlB,CAAP;AACD;;AAED;;;;;;;;;AASA;;;;;;;;AAtTqB;AAAA;AAAA,0BA2CD;AAClB,eAAO,KAAK,mBAAL,CAAP;AACD,OA7CoB;AAAA,wBA8CH,aA9CG,EA8CY;AAC/B,YAAM,wBAAwB,KAAK,mBAAL,CAA9B;AACA,aAAK,mBAAL,IAA4B,aAA5B;AACA,YAAI,mBAAmB,KAAK,SAA5B,EAAuC;AAAE,yHAAsB,aAAtB;AAAsC;AAC/E,YAAI,kBAAkB,qBAAtB,EAA6C;AAC3C,eAAK,aAAL,CAAmB,IAAI,WAAJ,CAAgB,yBAAhB,CAAnB;AACD;AACF;;AAED;;;;;;;AAvDqB;AAAA;AAAA,0BA6DG;AACtB,eAAO,KAAK,uBAAL,CAAP;AACD,OA/DoB;AAAA,wBAgEC,iBAhED,EAgEoB;AACvC,YAAM,4BAA4B,KAAK,uBAAL,CAAlC;AACA,aAAK,uBAAL,IAAgC,iBAAhC;AACA,YAAI,uBAAuB,KAAK,SAAhC,EAA2C;AAAE,6HAA0B,iBAA1B;AAA8C;AAC3F,YAAI,sBAAsB,yBAA1B,EAAqD;AACnD,eAAK,aAAL,CAAmB,IAAI,WAAJ,CAAgB,6BAAhB,CAAnB;AACD;AACF;AAvEoB;AAAA,WAyEhB,kBAAQ,QAzEQ;AAAA,0BAyEI;AACvB,YAAM,WAAW,8FAAM,kBAAQ,QAAd,WAA2B,EAA5C;AACA,iBAAS,iBAAT,GAA6B,KAA7B;AACA,iBAAS,cAAT,GAA0B,KAA1B;AACA,eAAO,QAAP;AACD;AA9EoB;AAAA;AAAA,0BA4HD;AAClB,eAAO,KAAK,2BAAL,KAAqC,IAArC,GACL,KAAK,2BAAL,CADK,GAEL,CAAC,CAFH;AAGD,OAhIoB;AAAA,wBAiIH,KAjIG,EAiII;AACvB;AACA,YAAM,wBAAwB,KAAK,2BAAL,CAA9B;AACA,YAAI,aAAJ;AACA,YAAI,UAAU,KAAK,2BAAL,CAAd,EAAiD;AAC/C;AACA,cAAM,QAAQ,KAAK,KAAnB;AACA,cAAM,WAAW,SAAS,MAAM,MAAN,GAAe,CAAzC;AACA,cAAI,EAAE,YAAY,SAAS,CAArB,IAA0B,QAAQ,MAAM,MAA1C,CAAJ,EAAuD;AACrD,oBAAQ,CAAC,CAAT,CADqD,CACzC;AACb;AACD,eAAK,2BAAL,IAAoC,KAApC;AACA,iBAAO,YAAY,SAAS,CAArB,GAAyB,MAAM,KAAN,CAAzB,GAAwC,IAA/C;AACA,eAAK,0BAAL,IAAmC,IAAnC;AACD,SAVD,MAUO;AACL,iBAAO,KAAK,0BAAL,CAAP;AACD;;AAED;AACA,YAAI,mBAAmB,KAAK,SAA5B,EAAuC;AAAE,yHAAsB,KAAtB;AAA8B;;AAEvE,YAAI,UAAU,qBAAd,EAAqC;AACnC;AACA,eAAK,2BAAL,IAAoC,KAApC;;AAEA,cAAM,QAAQ,IAAI,WAAJ,CAAgB,wBAAhB,EAA0C;AACtD,oBAAQ;AACN,6BAAe,KADT;AAEN,qBAAO,KAFD,CAEO;AAFP;AAD8C,WAA1C,CAAd;AAMA,eAAK,aAAL,CAAmB,KAAnB;AACD;;AAED,YAAI,KAAK,0BAAL,MAAqC,IAAzC,EAA+C;AAC7C;AACA,eAAK,YAAL,GAAoB,IAApB;AACD;AACF;;AAED;;;;;;;;;;;;AAzKqB;AAAA;AAAA,0BAoLF;AACjB,eAAO,KAAK,0BAAL,KAAoC,IAA3C;AACD,OAtLoB;AAAA,wBAuLJ,IAvLI,EAuLE;AACrB;AACA,YAAM,uBAAuB,KAAK,0BAAL,CAA7B;AACA,YAAI,cAAJ;AACA,YAAI,SAAS,KAAK,0BAAL,CAAb,EAA+C;AAC7C;AACA,cAAM,QAAQ,KAAK,KAAnB;AACA,cAAM,WAAW,SAAS,MAAM,MAAN,GAAe,CAAzC;AACA,kBAAQ,WAAW,MAAM,SAAN,CAAgB,OAAhB,CAAwB,IAAxB,CAA6B,KAA7B,EAAoC,IAApC,CAAX,GAAuD,CAAC,CAAhE;AACA,eAAK,2BAAL,IAAoC,KAApC;AACA,cAAI,QAAQ,CAAZ,EAAe;AACb,mBAAO,IAAP,CADa,CACA;AACd;AACD,eAAK,0BAAL,IAAmC,IAAnC;AACD,SAVD,MAUO;AACL,kBAAQ,KAAK,2BAAL,CAAR;AACD;;AAED;AACA,YAAI,kBAAkB,KAAK,SAA3B,EAAsC;AAAE,wHAAqB,IAArB;AAA4B;;AAEpE,YAAI,SAAS,oBAAb,EAAmC;AACjC;AACA,eAAK,0BAAL,IAAmC,IAAnC;;AAEA,cAAI,oBAAJ,EAA0B;AACxB;AACA,iBAAK,kBAAQ,YAAb,EAA2B,oBAA3B,EAAiD,KAAjD;AACD;AACD,cAAI,IAAJ,EAAU;AACR;AACA,iBAAK,kBAAQ,YAAb,EAA2B,IAA3B,EAAiC,IAAjC;AACD;;AAED,oCAA0B,IAA1B;;AAEA,cAAM,QAAQ,IAAI,WAAJ,CAAgB,uBAAhB,EAAyC;AACrD,oBAAQ;AACN,4BAAc,IADR;AAEN,qBAAO,IAFD,CAEM;AAFN;AAD6C,WAAzC,CAAd;AAMA,eAAK,aAAL,CAAmB,KAAnB;AACD;;AAED,YAAI,KAAK,2BAAL,MAAsC,KAA1C,EAAiD;AAC/C;AACA,eAAK,aAAL,GAAqB,KAArB;AACD;AACF;AAxOoB;AAAA;AAAA,0BAwPG;AACtB,eAAO,KAAK,uBAAL,CAAP;AACD,OA1PoB;AAAA,wBA2PC,iBA3PD,EA2PoB;AACvC,aAAK,uBAAL,IAAgC,iBAAhC;AACA,YAAI,uBAAuB,KAAK,SAAhC,EAA2C;AAAE,6HAA0B,iBAA1B;AAA8C;AAC3F,0BAAkB,IAAlB;AACD;;AAED;;;;;;;AAjQqB;AAAA;AAAA,0BAuQA;AACnB,eAAO,KAAK,oBAAL,CAAP;AACD,OAzQoB;AAAA,wBA0QF,KA1QE,EA0QK;AACxB,aAAK,oBAAL,IAA6B,OAAO,KAAP,MAAkB,MAA/C;AACA,YAAI,oBAAoB,KAAK,SAA7B,EAAwC;AAAE,0HAAuB,KAAvB;AAA+B;AACzE,kCAA0B,IAA1B;AACD;AA9QoB;;AAAA;AAAA,IAwBO,IAxBP;;AAgUvB,SAAO,eAAP;AACD,C;;AAGD;AACA;;;AACA,SAAS,WAAT,CAAqB,OAArB,EAA8B,KAA9B,EAAqC;AACnC,MAAM,QAAQ,QAAQ,KAAR,CAAc,MAA5B;;AAEA,MAAM,eAAgB,QAAQ,cAAT;AACnB;AACA;AACA,GAAE,QAAQ,KAAT,GAAkB,KAAnB,IAA4B,KAHT;;AAKnB;AACA,OAAK,GAAL,CAAS,KAAK,GAAL,CAAS,KAAT,EAAgB,QAAQ,CAAxB,CAAT,EAAqC,CAArC,CANF;;AAQA,MAAM,gBAAgB,QAAQ,aAA9B;AACA,MAAI,kBAAkB,YAAtB,EAAoC;AAClC,YAAQ,aAAR,GAAwB,YAAxB;AACA,WAAO,IAAP;AACD,GAHD,MAGO;AACL,WAAO,KAAP;AACD;AACF;;AAED;AACA;AACA;AACA;AACA,SAAS,iBAAT,CAA2B,OAA3B,EAAoC;;AAElC,MAAM,QAAQ,QAAQ,KAAtB;AACA,MAAM,YAAY,QAAQ,MAAM,MAAd,GAAuB,CAAzC;;AAEA,MAAM,uBAAuB,QAAQ,YAArC;AACA,MAAI,CAAC,oBAAL,EAA2B;AACzB;AACA,QAAI,QAAQ,iBAAZ,EAA+B;AAC7B;AACA,cAAQ,aAAR,GAAwB,CAAxB;AACD;AACF,GAND,MAMO,IAAI,cAAc,CAAlB,EAAqB;AAC1B;AACA,YAAQ,YAAR,GAAuB,IAAvB;AACD,GAHM,MAGA;AACL;AACA,QAAM,sBAAsB,MAAM,SAAN,CAAgB,OAAhB,CAAwB,IAAxB,CAA6B,KAA7B,EAAoC,oBAApC,CAA5B;AACA,QAAM,wBAAwB,QAAQ,aAAtC;AACA,QAAI,sBAAsB,CAA1B,EAA6B;AAC3B;AACA;AACA,UAAM,mBAAmB,KAAK,GAAL,CAAS,qBAAT,EAAgC,YAAY,CAA5C,CAAzB;AACA;AACA;AACA,cAAQ,YAAR,GAAuB,MAAM,gBAAN,CAAvB;AACD,KAPD,MAOO,IAAI,wBAAwB,qBAA5B,EAAmD;AACxD;AACA,cAAQ,aAAR,GAAwB,mBAAxB;AACD;AACF;AACF;;AAED;AACA;AACA,SAAS,yBAAT,CAAmC,OAAnC,EAA4C;AAC1C,MAAI,sBAAJ;AACA,MAAI,0BAAJ;AACA,MAAM,QAAQ,QAAQ,KAAtB;AACA,MAAI,SAAS,IAAT,IAAiB,MAAM,MAAN,KAAiB,CAAtC,EAAyC;AACvC;AACA,oBAAgB,KAAhB;AACA,wBAAoB,KAApB;AACD,GAAC,IAAI,QAAQ,cAAZ,EAA4B;AAC5B;AACA,oBAAgB,IAAhB;AACA,wBAAoB,IAApB;AACD,GAJC,MAIK;AACL,QAAM,QAAQ,QAAQ,aAAtB;AACA,QAAI,QAAQ,CAAR,IAAa,MAAM,MAAN,GAAe,CAAhC,EAAmC;AACjC;AACA;AACA,sBAAgB,IAAhB;AACA,0BAAoB,IAApB;AACD,KALD,MAKO;AACL;AACA,0BAAqB,QAAQ,CAA7B;AACA,sBAAiB,QAAQ,MAAM,MAAN,GAAe,CAAxC;AACD;AACF;AACD,MAAI,QAAQ,aAAR,KAA0B,aAA9B,EAA6C;AAC3C,YAAQ,aAAR,GAAwB,aAAxB;AACD;AACD,MAAI,QAAQ,iBAAR,KAA8B,iBAAlC,EAAqD;AACnD,YAAQ,iBAAR,GAA4B,iBAA5B;AACD;AACF;;;;;;;;kBC9ZuB,Y;AApCxB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCe,SAAS,YAAT,CAAsB,WAAtB,EAAmC;AAChD,SAAO,OAAO,MAAP,KAAkB,UAAlB,GACL,OAAO,WAAP,CADK,SAED,WAFN;AAGD;;;;;;;;kBCJuB,S;AApCxB;;;;;;;;;;;;;;AAeA;AACA,IAAM,YAAY,EAAlB;;AAEA;AACA,IAAM,UAAU,SAAS,cAAT,CAAwB,EAAxB,CAAhB;;AAEA;AACA,IAAI,UAAU,CAAd;;AAGA;;;;;;;;;;;AAWe,SAAS,SAAT,CAAmB,QAAnB,EAA6B;AAC1C,YAAU,IAAV,CAAe,QAAf;AACA;AACA,UAAQ,WAAR,GAAsB,EAAE,OAAxB;AACD;;AAGD;AACA,SAAS,gBAAT,GAA4B;AAC1B,SAAO,UAAU,MAAV,GAAmB,CAA1B,EAA6B;AAC3B,QAAM,WAAW,UAAU,KAAV,EAAjB;AACA;AACD;AACF;;AAGD;AACA,IAAM,WAAW,IAAI,gBAAJ,CAAqB,gBAArB,CAAjB;AACA,SAAS,OAAT,CAAiB,OAAjB,EAA0B;AACxB,iBAAe;AADS,CAA1B;;;;;;;;;ACtDA;;;;AACA;;;;;;AAGA;AACA,IAAM,4BAA4B,4BAAa,qBAAb,CAAlC;AACA,IAAM,0BAA0B,4BAAa,mBAAb,CAAhC;AACA,IAAM,uBAAuB,4BAAa,gBAAb,CAA7B;;AAGA;;;kBAGe;;AAEb;;;;;;;;;;;;;AAaA,WAfa,qBAeH,OAfG,EAeM;AACjB,YAAQ,yBAAR,IAAqC,IAArC;;AAEA;AACA,QAAI,QAAQ,uBAAR,CAAJ,EAAsC;AACpC,WAAK,IAAI,SAAT,IAAsB,QAAQ,uBAAR,CAAtB,EAAwD;AACtD,YAAM,QAAQ,QAAQ,uBAAR,EAAiC,SAAjC,CAAd;AACA,8BAAsB,OAAtB,EAA+B,SAA/B,EAA0C,KAA1C;AACD;AACD,cAAQ,uBAAR,IAAmC,IAAnC;AACD;;AAED;AACA,QAAI,QAAQ,oBAAR,CAAJ,EAAmC;AACjC,WAAK,IAAI,SAAT,IAAsB,QAAQ,oBAAR,CAAtB,EAAqD;AACnD,YAAM,SAAQ,QAAQ,oBAAR,EAA8B,SAA9B,CAAd;AACA,mCAAY,OAAZ,EAAqB,SAArB,EAAgC,MAAhC;AACD;AACD,cAAQ,oBAAR,IAAgC,IAAhC;AACD;AACF,GAnCY;;;AAqCb;;;;;;;;;;;;AAYA,cAjDa,wBAiDA,OAjDA,EAiDS,SAjDT,EAiDoB,KAjDpB,EAiD2B;AACtC,QAAI,QAAQ,yBAAR,CAAJ,EAAwC;AACtC;AACA,4BAAsB,OAAtB,EAA+B,SAA/B,EAA0C,KAA1C;AACD,KAHD,MAGO;AACL;AACA,UAAI,CAAC,QAAQ,uBAAR,CAAL,EAAuC;AACrC,gBAAQ,uBAAR,IAAmC,EAAnC;AACD;AACD,cAAQ,uBAAR,EAAiC,SAAjC,IAA8C,KAA9C;AACD;AACF,GA5DY;;;AA8Db;;;;;;;;;;;;;AAaA,aA3Ea,uBA2ED,OA3EC,EA2EQ,SA3ER,EA2EmB,KA3EnB,EA2E0B;AACrC,QAAI,QAAQ,yBAAR,CAAJ,EAAwC;AACtC;AACA,iCAAY,OAAZ,EAAqB,SAArB,EAAgC,KAAhC;AACD,KAHD,MAGO;AACL;AACA,UAAI,CAAC,QAAQ,oBAAR,CAAL,EAAoC;AAClC,gBAAQ,oBAAR,IAAgC,EAAhC;AACD;AACD,cAAQ,oBAAR,EAA8B,SAA9B,IAA2C,KAA3C;AACD;AACF;AAtFY,C;;AA2Ff;AACA;;AACA,SAAS,qBAAT,CAA+B,OAA/B,EAAwC,aAAxC,EAAuD,KAAvD,EAA8D;AAC5D,MAAI,UAAU,IAAV,IAAkB,OAAO,KAAP,KAAiB,WAAvC,EAAoD;AAClD,YAAQ,eAAR,CAAwB,aAAxB;AACD,GAFD,MAEO;AACL,QAAM,OAAO,OAAO,KAAP,CAAb;AACA;AACA,QAAI,QAAQ,YAAR,CAAqB,aAArB,MAAwC,IAA5C,EAAkD;AAChD,cAAQ,YAAR,CAAqB,aAArB,EAAoC,KAApC;AACD;AACF;AACF;;;;;;;;;ACpHD;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA,IAAM,UAAU;;AAEd;;;;;;;;;;;;;;;;;AAiBA,YAAU,4BAAa,UAAb,CAnBI;;AAqBd;;;;;;;;;;;;;AAaA,YAAU,4BAAa,UAAb,CAlCI;;AAoCd;;;;;;;AAOA,UAAQ,4BAAa,QAAb,CA3CM;;AA6Cd;;;;;;;;AAQA,SAAO,4BAAa,OAAb,CArDO;;AAuDd;;;;;;;AAOA,UAAQ,4BAAa,QAAb,CA9DM;;AAgEd;;;;;;;AAOA,WAAS,4BAAa,SAAb,CAvEK;;AAyEd;;;;;;;;AAQA,WAAS,4BAAa,SAAb,CAjFK;;AAmFd;;;;;;;AAOA,QAAM,4BAAa,MAAb,CA1FQ;;AA4Fd;;;;;;;;AAQA,aAAW,4BAAa,WAAb,CApGG;;AAuGd;;;;;;;AAOA,gBAAc,4BAAa,cAAb,CA9GA;;AAgHd;;;;;;;;;AASA,gBAAc,4BAAa,cAAb,CAzHA;;AA2Hd;;;;;;;;AAQA,WAAS,4BAAa,SAAb,CAnIK;;AAqId;;;;;;;AAOA,YAAU,4BAAa,UAAb;AA5II,CAAhB;;kBA+Ie,O;;;;;;;;kBChJS,W;AAtBxB;;;;;;;;;;;;;;;;;;;;;;AAsBe,SAAS,WAAT,CAAqB,OAArB,EAA8B,SAA9B,EAAyC,KAAzC,EAAgD;AAC7D,MAAM,YAAY,QAAQ,SAA1B;AACA,MAAM,WAAY,OAAO,KAAP,KAAiB,WAAlB,GACf,CAAC,UAAU,QAAV,CAAmB,SAAnB,CADc,GAEf,KAFF;AAGA,MAAI,QAAJ,EAAc;AACZ,cAAU,GAAV,CAAc,SAAd;AACD,GAFD,MAEO;AACL,cAAU,MAAV,CAAiB,SAAjB;AACD;AACD,SAAO,QAAP;AACD;;;;;;;;;ACjCD;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;IAoBM,W;;;;;;;;;;EAAoB,+BAAgB,WAAhB,EAA6B,OAA7B,gCACM;AADN,wCAEM;AAFN,wE;;kBAOX,W;;;;;AC3Bf;;;;;;AAEA,OAAO,KAAP,GAAe,OAAO,KAAP,IAAgB,EAA/B,C,CATA;;;;;;;AAUA,OAAO,KAAP,CAAa,KAAb;;;;;;;;;;;;;ACVA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;AAEA,IAAM,OAAO,sBAAY,OAAZ,wGAAb;;AAOA;;;;;;;;;;;;;;;;;IAgBM,K;;;;;;;;;;SAQH,kBAAQ,Y;0BAAc,I,EAAM,Q,EAAU;AACrC,oFAAU,kBAAQ,YAAlB,SAAiC;AAAE,kFAAM,kBAAQ,YAAd,mBAA4B,IAA5B,EAAkC,QAAlC;AAA8C;AACjF,WAAK,KAAL,CAAW,OAAX,GAAqB,WAAW,EAAX,GAAgB,MAArC;AACA,WAAK,YAAL,CAAkB,aAAlB,EAAiC,CAAC,QAAlC;AACD;;SAVI,kBAAQ,Q;wBAAY;AACvB,UAAM,WAAW,0EAAM,kBAAQ,QAAd,WAA2B,EAA5C;AACA,eAAS,iBAAT,GAA6B,IAA7B;AACA,aAAO,QAAP;AACD;;SAQI,kBAAQ,Q;wBAAY;AACvB;AACD;;;;EAhBiB,I;;AAqBpB,eAAe,MAAf,CAAsB,aAAtB,EAAqC,KAArC;kBACe,K","file":"basic-modes.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import safeAttributes from './safeAttributes';\n\n\n// Memoized maps of attribute to property names and vice versa.\nconst attributeToPropertyNames = {};\nconst propertyNamesToAttributes = {};\n\n\n/* Exported function extends a base class with AttributeMarshalling. */\nexport default (base) => {\n\n  /**\n   * Mixin which marshalls attributes to properties and vice versa.\n   *\n   * If your component exposes a setter for a property, it's generally a good\n   * idea to let devs using your component be able to set that property in HTML\n   * via an element attribute. You can code that yourself by writing an\n   * `attributeChangedCallback`, or you can use this mixin to get a degree of\n   * automatic support.\n   *\n   * This mixin implements an `attributeChangedCallback` that will attempt to\n   * convert a change in an element attribute into a call to the corresponding\n   * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n   * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n   * respects that convention, automatically mapping the hyphenated attribute\n   * name to the corresponding camelCase property name.\n   *\n   * Example: You define a component using this mixin:\n   *\n   *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n   *       get fooBar() { return this._fooBar; }\n   *       set fooBar(value) { this._fooBar = value; }\n   *     }\n   *     customElements.define('my-element', MyElement);\n   *\n   * If someone then instantiates your component in HTML:\n   *\n   *     <my-element foo-bar=\"Hello\"></my-element>\n   *\n   * Then, after the element has been upgraded, the `fooBar` setter will\n   * automatically be invoked with the initial value \"Hello\".\n   *\n   * For the time being, this mixin only supports string-valued properties.\n   * If you'd like to convert string attributes to other types (numbers,\n   * booleans), you need to implement `attributeChangedCallback` yourself.\n   */\n  class AttributeMarshalling extends base {\n\n    /*\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n      const propertyName = attributeToPropertyName(attributeName);\n      // If the attribute name corresponds to a property name, set the property.\n      // Ignore standard HTMLElement properties handled by the DOM.\n      if (propertyName in this && !(propertyName in HTMLElement.prototype)) {\n        this[propertyName] = newValue;\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    static get observedAttributes() {\n      return attributesForClass(this);\n    }\n\n    /**\n     * Set/unset the attribute with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as an attribute. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes. A call to `reflectAttribute` during the constructor will\n     * be deferred until the element is connected to the document.\n     *\n     * @param {string} attribute - The name of the *attribute* (not property) to set.\n     * @param {object} value - The value to set. If null, the attribute will be removed.\n     */\n    reflectAttribute(attribute, value) {\n      return safeAttributes.setAttribute(this, attribute, value);\n    }\n\n    /**\n     * Set/unset the class with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as as class. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes, including the `class` attribute. A call to\n     * `reflectClass` during the constructor will be deferred until the element\n     * is connected to the document.\n     *\n     * @param {string} className - The name of the class to set.\n     * @param {object} value - True to set the class, false to remove it.\n     */\n    reflectClass(className, value) {\n      return safeAttributes.toggleClass(this, className, value);\n    }\n\n  }\n\n  return AttributeMarshalling;\n};\n\n\n// Convert hyphenated foo-bar attribute name to camel case fooBar property name.\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hypenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hypenRegEx,\n        match => match[1].toUpperCase());\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\nfunction attributesForClass(classFn) {\n\n  // We treat the element base classes as if they have no attributes, since we\n  // don't want to receive attributeChangedCallback for them.\n  if (classFn === HTMLElement || classFn === Object) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n  const baseAttributes = attributesForClass(baseClass);\n\n  // Get attributes for this class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter(propertyName =>\n    typeof Object.getOwnPropertyDescriptor(\n        classFn.prototype, propertyName).set === 'function');\n  const attributes = setterNames.map(setterName =>\n      propertyNameToAttribute(setterName));\n\n  // Merge.\n  const diff = attributes.filter(attribute =>\n      baseAttributes.indexOf(attribute) < 0);\n  return baseAttributes.concat(diff);\n}\n\n// Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, '-$1').toLowerCase();\n  }\n  return attribute;\n}\n","/* Exported function extends a base class with Composable. */\nexport default (base) => {\n\n  /**\n   * Mixin to make a class more easily composable with other mixins.\n   *\n   * This mixin contributes a `compose` method that applies a set of mixin\n   * functions and returns the resulting new class. This sugar can make the\n   * application of many mixins at once easier to read.\n   */\n  class Composable extends base {\n\n    /**\n     * Apply a set of mixin functions or mixin objects to the present class and\n     * return the new class.\n     *\n     * Instead of writing:\n     *\n     *     let MyClass = Mixin1(Mixin2(Mixin3(Mixin4(Mixin5(BaseClass)))));\n     *\n     * You can write:\n     *\n     *     let MyClass = ComposableMixin(BaseClass).compose(\n     *       Mixin1,\n     *       Mixin2,\n     *       Mixin3,\n     *       Mixin4,\n     *       Mixin5\n     *     );\n     *\n     * This function can also take mixin objects. A mixin object is just a\n     * shorthand for a mixin function that creates a new subclass with the given\n     * members. The mixin object's members are *not* copied directly onto the\n     * prototype of the base class, as with traditional mixins.\n     *\n     * In addition to providing syntactic sugar, this mixin can be used to\n     * define a class in ES5, which lacks ES6's `class` keyword.\n     *\n     * @param {...mixins} mixins - A set of mixin functions or objects to apply.\n     */\n    static compose(...mixins) {\n      // We create a new subclass for each mixin in turn. The result becomes\n      // the base class extended by any subsequent mixins. It turns out that\n      // we can use Array.reduce() to concisely express this, using the current\n      // object as the seed for reduce().\n      return mixins.reduce(composeClass, this);\n    }\n\n  }\n\n  return Composable;\n};\n\n\n// Properties defined by Object that we don't want to mixin.\nconst NON_MIXABLE_OBJECT_PROPERTIES = [\n  'constructor'\n];\n\n/*\n * Apply the mixin to the given base class to return a new class.\n * The mixin can either be a function that returns the modified class, or a\n * plain object whose members will be copied to the new class' prototype.\n */\nfunction composeClass(base, mixin) {\n  if (typeof mixin === 'function') {\n    // Mixin function\n    return mixin(base);\n  } else {\n    // Mixin object\n    class Subclass extends base {}\n    copyOwnProperties(mixin, Subclass.prototype, NON_MIXABLE_OBJECT_PROPERTIES);\n    return Subclass;\n  }\n}\n\n\n/*\n * Copy the given properties/methods to the target.\n * Return the updated target.\n */\nfunction copyOwnProperties(source, target, ignorePropertyNames = []) {\n  Object.getOwnPropertyNames(source).forEach(name => {\n    if (ignorePropertyNames.indexOf(name) < 0) {\n      const descriptor = Object.getOwnPropertyDescriptor(source, name);\n      Object.defineProperty(target, name, descriptor);\n    }\n  });\n  return target;\n}\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemsSymbol = createSymbol('items');\nconst itemInitializedSymbol = createSymbol('itemInitialized');\n\n\n/* Exported function extends a base class with ContentItems. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps content semantics (elements) to list item semantics.\n   *\n   * Items differ from element contents in several ways:\n   *\n   * * They are often referenced via index.\n   * * They may have a selection state.\n   * * It's common to do work to initialize the appearance or state of a new\n   *   item.\n   * * Auxiliary invisible child elements are filtered out and not counted as\n   *   items. Auxiliary elements include link, script, style, and template\n   *   elements. This filtering ensures that those auxiliary elements can be\n   *   used in markup inside of a list without being treated as list items.\n   *\n   * This mixin expects a component to provide a `content` property returning a\n   * raw set of elements. You can provide that yourself, or use\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md).\n   *\n   * The most commonly referenced property defined by this mixin is the `items`\n   * property. To avoid having to do work each time that property is requested,\n   * this mixin supports an optimized mode. If you invoke the `contentChanged`\n   * method when the set of items changes, the mixin concludes that you'll take\n   * care of notifying it of future changes, and turns on the optimization. With\n   * that on, the mixin saves a reference to the computed set of items, and will\n   * return that immediately on subsequent calls to the `items` property. If you\n   * use this mixin in conjunction with\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md), the\n   * `contentChanged` method will be invoked for you when the element's children\n   * change, turning on the optimization automatically.\n   */\n  class ContentItems extends base {\n\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n\n      // Since we got the contentChanged call, we'll assume we'll be notified if\n      // the set of items changes later. We turn on memoization of the items\n      // property by setting our internal property to null (instead of\n      // undefined).\n      this[itemsSymbol] = null;\n\n      this[symbols.itemsChanged]();\n    }\n\n    /**\n     * This method is invoked whenever a new item is added to the list.\n     *\n     * The default implementation of this method does nothing. You can override\n     * this to perform per-item initialization.\n     *\n     * @param {HTMLElement} item - The item that was added.\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n    }\n\n    /**\n     * The selection state for a single item has changed.\n     *\n     * Invoke this method to signal that the selected state of the indicated item\n     * has changed. By default, this applies a `selected` CSS class if the item\n     * is selected, and removed it if not selected.\n     *\n     * @param {HTMLElement} item - The item whose selection state has changed.\n     * @param {boolean} selected - True if the item is selected, false if not.\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      toggleClass(item, 'selected', selected);\n    }\n\n    /**\n     * The current set of items in the list. See the top-level documentation for\n     * mixin for a description of how items differ from plain content.\n     *\n     * @type {HTMLElement[]}\n     */\n    get items() {\n      let items;\n      if (this[itemsSymbol] == null) {\n        items = filterAuxiliaryElements(this.content);\n        // Note: test for *equality* with null; don't treat undefined as a match.\n        if (this[itemsSymbol] === null) {\n          // Memoize the set of items.\n          this[itemsSymbol] = items;\n        }\n      } else {\n        // Return the memoized items.\n        items = this[itemsSymbol];\n      }\n      return items;\n    }\n\n    /**\n     * This method is invoked when the underlying contents change. It is also\n     * invoked on component initialization – since the items have \"changed\" from\n     * being nothing.\n     */\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // Perform per-item initialization.\n      Array.prototype.forEach.call(this.items, item => {\n        if (!item[itemInitializedSymbol]) {\n          this[symbols.itemAdded](item);\n          item[itemInitializedSymbol] = true;\n        }\n      });\n\n      this.dispatchEvent(new CustomEvent('items-changed'));\n    }\n\n    /**\n     * Fires when the items in the list change.\n     *\n     * @memberof ContentItems\n     * @event items-changed\n     */\n  }\n\n  return ContentItems;\n};\n\n\n// Return the given elements, filtering out auxiliary elements that aren't\n// typically visible. Items which are not elements are returned as is.\nfunction filterAuxiliaryElements(items) {\n  const auxiliaryTags = [\n    'link',\n    'script',\n    'style',\n    'template'\n  ];\n  return [].filter.call(items, function(item) {\n    return !item.localName || auxiliaryTags.indexOf(item.localName) < 0;\n  });\n}\n","import microtask from './microtask';\n\n\n/* Exported function extends a base class with DistributedChildrenContent. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines a component's content as its children, expanding any\n   * nodes distributed to the component's slots.\n   *\n   * This also provides notification of changes to a component's content. It\n   * will invoke a `contentChanged` method when the component is first\n   * instantiated, and whenever its distributed children change. This is an\n   * easy way to satisfy the Gold Standard checklist item for monitoring\n   * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n   *\n   * Example:\n   *\n   * ```\n   * let base = DistributedChildrenContentMixin(DistributedChildrenMixin(HTMLElement));\n   * class CountingElement extends base {\n   *\n   *   constructor() {\n   *     super();\n   *     let root = this.attachShadow({ mode: 'open' });\n   *     root.innerHTML = `<slot></slot>`;\n   *   }\n   *\n   *   contentChanged() {\n   *     // Count the component's children, both initially and when changed.\n   *     this.count = this.distributedChildren.length;\n   *   }\n   *\n   * }\n   * ```\n   *\n   * Note that content change detection depends upon the element having at least\n   * one `slot` element in its shadow subtree.\n   *\n   * This mixin is intended for use with the\n   * [DistributedChildrenMixin](DistributedChildrenMixin.md). See that mixin for\n   * a discussion of how that works. This DistributedChildrenContentMixin\n   * provides an easy way of defining the \"content\" of a component as the\n   * component's distributed children. That in turn lets mixins like\n   * [ContentItemsMixin](ContentItemsMixin.md) manipulate the children as list\n   * items.\n   */\n  class DistributedChildrenContent extends base {\n\n    constructor() {\n      super();\n\n      if (this.shadowRoot) {\n        // Listen to changes on all slots.\n        const slots = this.shadowRoot.querySelectorAll('slot');\n        slots.forEach(slot => slot.addEventListener('slotchange', event => {\n          this.contentChanged();\n        }));\n      }\n\n      // Make an initial call to contentChanged() so that the component can do\n      // initialization that it normally does when content changes.\n      //\n      // This will invoke contentChanged() handlers in other mixins. In order\n      // that those mixins have a chance to complete their own initialization,\n      // we add the contentChanged() call to the microtask queue.\n      microtask(() => this.contentChanged());\n    }\n\n    /**\n     * Invoked when the contents of the component (including distributed\n     * children) have changed.\n     *\n     * This method is also invoked when a component is first instantiated; the\n     * contents have essentially \"changed\" from being nothing. This allows the\n     * component to perform initial processing of its children.\n     */\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n      const event = new CustomEvent('content-changed');\n      this.dispatchEvent(event);\n    }\n\n    /**\n     * The content of this component, defined to be the flattened array of\n     * children distributed to the component.\n     *\n     * @type {HTMLElement[]}\n     */\n    get content() {\n      const distributedChildren = this.distributedChildren;\n      if (typeof distributedChildren === 'undefined') {\n        console.warn(`DistributedChildrenContentMixin expects the component to define a \"distributedChildren\" property.`);\n      }\n      return distributedChildren;\n    }\n    set content(value) {\n      if ('content' in base.prototype) { super.content = value; }\n      // TODO: Set the children to the given value (which should be an array of\n      // elements)?\n    }\n\n    /**\n     * This event is raised when the component's contents (including distributed\n     * children) have changed.\n     *\n     * @memberof DistributedChildrenContent\n     * @event content-changed\n     */\n  }\n\n  return DistributedChildrenContent;\n};\n","/* Exported function extends a base class with DistributedChildren. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines helpers for accessing a component's distributed\n   * children as a flattened array or string.\n   *\n   * The standard DOM API provides several ways of accessing child content:\n   * `children`, `childNodes`, and `textContent`. None of these functions are\n   * Shadow DOM aware. This mixin defines variations of those functions that\n   * *are* Shadow DOM aware.\n   *\n   * Example: you create a component `<count-children>` that displays a number\n   * equal to the number of children placed inside that component. If someone\n   * instantiates your component like:\n   *\n   *     <count-children>\n   *       <div></div>\n   *       <div></div>\n   *       <div></div>\n   *     </count-children>\n   *\n   * Then the component should show \"3\", because there are three children. To\n   * calculate the number of children, the component can just calculate\n   * `this.children.length`. However, suppose someone instantiates your\n   * component inside one of their own components, and puts a `<slot>` element\n   * inside your component:\n   *\n   *     <count-children>\n   *       <slot></slot>\n   *     </count-children>\n   *\n   * If your component only looks at `this.children`, it will always see exactly\n   * one child — the `<slot>` element. But the user looking at the page will\n   * *see* any nodes distributed to that slot. To match what the user sees, your\n   * component should expand any `<slot>` elements it contains.\n   *\n   * That is the problem this mixin solves. After applying this mixin, your\n   * component code has access to `this.distributedChildren`, whose `length`\n   * will return the total number of all children distributed to your component\n   * in the composed tree.\n   *\n   * Note: The latest Custom Elements API design calls for a new function,\n   * `getAssignedNodes` that takes an optional `deep` parameter, that will solve\n   * this problem at the API level.\n   */\n  class DistributedChildren extends base {\n\n    /**\n     * An in-order collection of distributed children, expanding any slot\n     * elements. Like the standard children property, this skips text nodes.\n     *\n     * @type {HTMLElement[]}\n     */\n    get distributedChildren() {\n      return expandContentElements(this.children, false);\n    }\n\n    /**\n     * An in-order collection of distributed child nodes, expanding any slot\n     * elements. Like the standard childNodes property, this includes text\n     * nodes.\n     *\n     * @type {Node[]}\n     */\n    get distributedChildNodes() {\n      return expandContentElements(this.childNodes, true);\n    }\n\n    /**\n     * The concatenated text content of all distributed child nodes, expanding\n     * any slot elements.\n     *\n     * @type {string}\n     */\n    get distributedTextContent() {\n      const strings = this.distributedChildNodes.map(function(child) {\n        return child.textContent;\n      });\n      return strings.join('');\n    }\n\n  }\n\n  return DistributedChildren;\n};\n\n\n/*\n * Given a array of nodes, return a new array with any content elements expanded\n * to the nodes distributed to that content element. This rule is applied\n * recursively.\n *\n * If includeTextNodes is true, text nodes will be included, as in the\n * standard childNodes property; by default, this skips text nodes, like the\n * standard children property.\n */\nfunction expandContentElements(nodes, includeTextNodes) {\n  const expanded = Array.prototype.map.call(nodes, node => {\n    // We want to see if the node is an instanceof HTMLSlotELement, but\n    // that class won't exist if the browser that doesn't support native\n    // Shadow DOM and if the Shadow DOM polyfill hasn't been loaded. Instead,\n    // we do a simplistic check to see if the tag name is \"slot\".\n    const isSlot = typeof HTMLSlotElement !== 'undefined' ?\n      node instanceof HTMLSlotElement :\n      node.localName === 'slot';\n    if (isSlot) {\n      // Use the nodes assigned to this node instead.\n      const assignedNodes = node.assignedNodes({ flatten: true });\n      return assignedNodes ?\n        expandContentElements(assignedNodes, includeTextNodes) :\n        [];\n    } else if (node instanceof HTMLElement) {\n      // Plain element; use as is.\n      return [node];\n    } else if (node instanceof Text && includeTextNodes) {\n      // Text node.\n      return [node];\n    } else {\n      // Comment, processing instruction, etc.; skip.\n      return [];\n    }\n  });\n  const flattened = [].concat(...expanded);\n  return flattened;\n}\n","/* Exported function extends a base class with ShadowElementReferences. */\nexport default (base) => {\n\n  /**\n   * Mixin to create references to elements in a component's Shadow DOM subtree.\n   *\n   * This adds a member on the component called `this.$` that can be used to\n   * reference shadow elements with IDs. E.g., if component's shadow contains an\n   * element `<button id=\"foo\">`, then this mixin will create a member\n   * `this.$.foo` that points to that button.\n   *\n   * Such references simplify a component's access to its own elements. In\n   * exchange, this mixin trades off a one-time cost of querying all elements in\n   * the shadow tree instead of paying an ongoing cost to query for an element\n   * each time the component wants to inspect or manipulate it.\n   *\n   * This mixin expects the component to define a Shadow DOM subtree. You can\n   * create that tree yourself, or make use of\n   * [ShadowTemplateMixin](ShadowTemplateMixin.md).\n   *\n   * This mixin is inspired by Polymer's [automatic\n   * node finding](https://www.polymer-project.org/1.0/docs/devguide/local-dom.html#node-finding)\n   * feature.\n   */\n  class ShadowElementReferences extends base {\n\n    constructor() {\n      super();\n      if (this.shadowRoot) {\n        // Look for elements in the shadow subtree that have id attributes.\n        // An alternatively implementation of this mixin would be to just define\n        // a this.$ getter that lazily does this search the first time someone\n        // tries to access this.$. That might introduce some complexity – if the\n        // the tree changed after it was first populated, the result of\n        // searching for a node might be somewhat unpredictable.\n        this.$ = {};\n        const nodesWithIds = this.shadowRoot.querySelectorAll('[id]');\n        [].forEach.call(nodesWithIds, node => {\n          const id = node.getAttribute('id');\n          this.$[id] = node;\n        });\n      }\n    }\n\n    /**\n     * The collection of references to the elements with IDs in a component's\n     * Shadow DOM subtree.\n     *\n     * @type {object}\n     * @member $\n     */\n  }\n\n  return ShadowElementReferences;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with ShadowTemplate. */\nexport default (base) => {\n\n  /**\n   * Mixin for stamping a template into a Shadow DOM subtree upon component\n   * instantiation.\n   *\n   * To use this mixin, define a `template` property as a string or HTML\n   * `<template>` element:\n   *\n   *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n   *       get [symbols.template]() {\n   *         return `Hello, <em>world</em>.`;\n   *       }\n   *     }\n   *\n   * When your component class is instantiated, a shadow root will be created on\n   * the instance, and the contents of the template will be cloned into the\n   * shadow root. If your component does not define a `template` property, this\n   * mixin has no effect.\n   *\n   * For the time being, this extension retains support for Shadow DOM v0. That\n   * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n   * implement Shadow DOM v1.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n      let template = this[symbols.template];\n      // TODO: Save the processed template with the component's class prototype\n      // so it doesn't need to be processed with every instantiation.\n      if (template) {\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          template = createTemplateWithInnerHTML(template);\n        }\n\n        if (window.ShadowDOMPolyfill) {\n          shimTemplateStyles(template, this.localName);\n        }\n\n        const root = this.attachShadow({ mode: 'open' });\n        const clone = document.importNode(template.content, true);\n        root.appendChild(clone);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n};\n\n\n// Convert a plain string of HTML into a real template element.\nfunction createTemplateWithInnerHTML(innerHTML) {\n  const template = document.createElement('template');\n  // REVIEW: Is there an easier way to do this?\n  // We'd like to just set innerHTML on the template content, but since it's\n  // a DocumentFragment, that doesn't work.\n  const div = document.createElement('div');\n  div.innerHTML = innerHTML;\n  while (div.childNodes.length > 0) {\n    template.content.appendChild(div.childNodes[0]);\n  }\n  return template;\n}\n\n// Invoke basic style shimming with ShadowCSS.\nfunction shimTemplateStyles(template, tag) {\n  window.WebComponents.ShadowCSS.shimStyling(template.content, tag);\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = createSymbol('canSelectNext');\nconst canSelectPreviousSymbol = createSymbol('canSelectPrevious');\nconst selectionRequiredSymbol = createSymbol('selectionRequired');\nconst selectionWrapsSymbol = createSymbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = createSymbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = createSymbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = createSymbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = createSymbol('internalSelectedItem');\n\n\n/* Exported function extends a base class with SingleSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages single-selection semantics for items in a list.\n   *\n   * This mixin expects a component to provide an `items` Array or NodeList of\n   * all elements in the list. A standard way to do that with is the\n   * [ContentItemsMixin](ContentItemsMixin.md), which takes a component's\n   * content (typically its distributed children) as the set of list items; see\n   * that mixin for details.\n   *\n   * This mixin tracks a single selected item in the list, and provides means to\n   * get and set that state by item position (`selectedIndex`) or item identity\n   * (`selectedItem`). The selection can be moved in the list via the methods\n   * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n   *\n   * This mixin does not produce any user-visible effects to represent\n   * selection. Other mixins, such as\n   * [SelectionAriaActiveMixin](SelectionAriaActiveMixin.md),\n   * [SelectionHighlightMixin](SelectionHighlightMixin.md) and\n   * [SelectionInViewMixin](SelectionInViewMixin.md), modify the selected item\n   * in common ways to let the user know a given item is selected or not\n   * selected.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const previousCanSelectNext = this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (canSelectNext !== previousCanSelectNext) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const previousCanSelectPrevious = this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (canSelectPrevious !== previousCanSelectPrevious) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedIndex = this[internalSelectedIndexSymbol];\n      let item;\n      if (index !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && index >= 0 && index < items.length)) {\n          index = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = index;\n        item = hasItems && index >= 0 ? items[index] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (index !== previousSelectedIndex) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = index;\n\n        const event = new CustomEvent('selected-index-changed', {\n          detail: {\n            selectedIndex: index,\n            value: index // for Polymer binding. TODO: Verify still necessary\n          }\n        });\n        this.dispatchEvent(event);\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (item !== previousSelectedItem) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        const event = new CustomEvent('selected-item-changed', {\n          detail: {\n            selectedItem: item,\n            value: item // for Polymer binding\n          }\n        });\n        this.dispatchEvent(event);\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      this[selectionRequiredSymbol] = selectionRequired;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      trackSelectedItem(this);\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(value) {\n      this[selectionWrapsSymbol] = String(value) === 'true';\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Select the last item in the list.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the selectedItem property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     * @param {HTMLElement} detail.previousItem The previously selected item.\n     */\n\n    /**\n     * Fires when the selectedIndex property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n  }\n\n  return SingleSelection;\n};\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n  const count = element.items.length;\n\n  const boundedIndex = (element.selectionWraps) ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n","/*\n * Microtask helper for IE 11.\n *\n * Executing a function as a microtask is trivial in browsers that support\n * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n * promises, but does support MutationObservers, which are also executed as\n * microtasks. So this helper uses an MutationObserver to achieve microtask\n * timing.\n *\n * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * Inspired by Polymer's async() function.\n */\n\n\n// The queue of pending callbacks to be executed as microtasks.\nconst callbacks = [];\n\n// Create an element that we will modify to force observable mutations.\nconst element = document.createTextNode('');\n\n// A monotonically-increasing value.\nlet counter = 0;\n\n\n/**\n * Add a callback to the microtask queue.\n *\n * This uses a MutationObserver so that it works on IE 11.\n *\n * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n * needs more investigation.\n *\n * @function microtask\n * @param {function} callback\n */\nexport default function microtask(callback) {\n  callbacks.push(callback);\n  // Force a mutation.\n  element.textContent = ++counter;\n}\n\n\n// Execute any pending callbacks.\nfunction executeCallbacks() {\n  while (callbacks.length > 0) {\n    const callback = callbacks.shift();\n    callback();\n  }\n}\n\n\n// Create the observer.\nconst observer = new MutationObserver(executeCallbacks);\nobserver.observe(element, {\n  characterData: true\n});\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\n\n\n// Symbols for private data members on an element.\nconst safeToSetAttributesSymbol = createSymbol('safeToSetAttributes');\nconst pendingAttributesSymbol = createSymbol('pendingAttributes');\nconst pendingClassesSymbol = createSymbol('pendingClasses');\n\n\n/**\n * Helper functions for updating attributes, including the `class` attribute.\n */\nexport default {\n\n  /**\n   * Perform any pending updates to attributes and classes.\n   *\n   * This writes any `setAttribute` or `toggleClass` values that were performed\n   * before an element was attached to the document for the first time.\n   *\n   * This method should be called by mixins/components in their\n   * `connectedCallback`. If mulitple mixins/components invoke this during the\n   * same `connectedCallback`, only the first call will have any effect. The\n   * subsequent calls will be harmless.\n   *\n   * @param {HTMLElement} element - The element being added to the document.\n   */\n  connected(element) {\n    element[safeToSetAttributesSymbol] = true;\n\n    // Set any pending attributes.\n    if (element[pendingAttributesSymbol]) {\n      for (let attribute in element[pendingAttributesSymbol]) {\n        const value = element[pendingAttributesSymbol][attribute];\n        setAttributeToElement(element, attribute, value);\n      }\n      element[pendingAttributesSymbol] = null;\n    }\n\n    // Set any pending classes.\n    if (element[pendingClassesSymbol]) {\n      for (let className in element[pendingClassesSymbol]) {\n        const value = element[pendingClassesSymbol][className];\n        toggleClass(element, className, value);\n      }\n      element[pendingClassesSymbol] = null;\n    }\n  },\n\n  /**\n   * Set/unset the attribute with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as an attribute. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes. A call to `setAttribute` during the constructor will\n   * be deferred until the element is connected to the document.\n   *\n   * @param {string} attribute - The name of the *attribute* (not property) to set.\n   * @param {object} value - The value to set. If null, the attribute will be removed.\n   */\n  setAttribute(element, attribute, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set attributes immediately.\n      setAttributeToElement(element, attribute, value);\n    } else {\n      // Defer setting attributes until the first time we're connected.\n      if (!element[pendingAttributesSymbol]) {\n        element[pendingAttributesSymbol] = {};\n      }\n      element[pendingAttributesSymbol][attribute] = value;\n    }\n  },\n\n  /**\n   * Set/unset the class with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as as class. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes, including the `class` attribute. A call to\n   * `toggleClass` during the constructor will be deferred until the element\n   * is connected to the document.\n   *\n   * @param {string} className - The name of the class to set.\n   * @param {object} value - True to set the class, false to remove it.\n   */\n  toggleClass(element, className, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set class immediately.\n      toggleClass(element, className, value);\n    } else {\n      // Defer setting class until the first time we're connected.\n      if (!element[pendingClassesSymbol]) {\n        element[pendingClassesSymbol] = {};\n      }\n      element[pendingClassesSymbol][className] = value;\n    }\n  }\n\n};\n\n\n// Reflect the attribute to the given element.\n// If the value is null, remove the attribute.\nfunction setAttributeToElement(element, attributeName, value) {\n  if (value === null || typeof value === 'undefined') {\n    element.removeAttribute(attributeName);\n  } else {\n    const text = String(value);\n    // Avoid recursive attributeChangedCallback calls.\n    if (element.getAttribute(attributeName) !== text) {\n      element.setAttribute(attributeName, value);\n    }\n  }\n}\n","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'basic-component-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'basic-component-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `dragging` property.\n   *\n   * Components like carousels often define animated CSS transitions for\n   * sliding effects. Such a transition should usually *not* be applied while\n   * the user is dragging, because a CSS animation will introduce a lag that\n   * makes the swipe feel sluggish. Instead, as long as the user is dragging\n   * with their finger down, the transition should be suppressed. When the\n   * user releases their finger, the transition can be restored, allowing the\n   * animation to show the carousel sliding into its final position.\n   *\n   * @type {boolean} true if a drag is in progress, false if not.\n   */\n  dragging: createSymbol('dragging'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: createSymbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: createSymbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: createSymbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: createSymbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: createSymbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: createSymbol('goUp'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: createSymbol('keydown'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLElement}\n   */\n  template: createSymbol('template')\n};\n\nexport default symbols;\n","/**\n * Helper function for standard classList.toggle() behavior on old browsers,\n * namely IE 11.\n *\n * The standard\n * [classlist](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)\n * object has a `toggle()` function that supports a second Boolean parameter\n * that can be used to succinctly turn a class on or off. This feature is often\n * useful in designing custom elements, which may want to externally reflect\n * component state in a CSS class that can be used for styling purposes.\n *\n * Unfortunately, IE 11 does not support the Boolean parameter to\n * `classList.toggle()`. This helper function behaves like the standard\n * `toggle()`, including support for the Boolean parameter, so that it can be\n * used even on IE 11.\n *\n * @function toggleClass\n * @param {HTMLElement} element - The element to modify\n * @param {string} className - The class to add/remove\n * @param {boolean} [force] - Force the class to be added (if true) or removed\n *                            (if false)\n */\nexport default function toggleClass(element, className, force) {\n  const classList = element.classList;\n  const addClass = (typeof force === 'undefined') ?\n    !classList.contains(className) :\n    force;\n  if (addClass) {\n    classList.add(className);\n  } else {\n    classList.remove(className);\n  }\n  return addClass;\n}\n","import AttributeMarshallingMixin from '../../basic-component-mixins/src/AttributeMarshallingMixin';\nimport ComposableMixin from '../../basic-component-mixins/src/ComposableMixin';\nimport DistributedChildrenMixin from '../../basic-component-mixins/src/DistributedChildrenMixin';\nimport ShadowElementReferencesMixin from '../../basic-component-mixins/src/ShadowElementReferencesMixin';\nimport ShadowTemplateMixin from '../../basic-component-mixins/src/ShadowTemplateMixin';\n\n\n/**\n * A sample general-purpose base class for defining custom elements that mixes\n * in some common features: template stamping into a shadow root, shadow element\n * references, marshalling attributes to properties, and retrieving the children\n * distributed to a component.\n *\n * This base class is not special in any way, and is defined only as a\n * convenient shorthand for applying the mixins listed above. You can use this\n * class as a base class for your own elements, or easily create your own base\n * class by applying the same set of mixins.\n *\n * The ElementBase base class does not register itself as a custom element with\n * the browser, and hence cannot be independently instantiated.\n *\n * @mixes AttributeMarshallingMixin\n * @mixes ComposableMixin\n * @mixes DistributedChildrenMixin\n * @mixes ShadowElementReferencesMixin\n * @mixes ShadowTemplateMixin\n */\nclass ElementBase extends ComposableMixin(HTMLElement).compose(\n  ShadowTemplateMixin,          // before node finding, so shadow root is populated\n  ShadowElementReferencesMixin, // before marshalling, so properties can use refs\n  AttributeMarshallingMixin,\n  DistributedChildrenMixin\n) {}\n\nexport default ElementBase;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport Modes from './src/Modes';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.Modes = Modes;\n","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport ContentItemsMixin from '../../basic-component-mixins/src/ContentItemsMixin';\nimport SingleSelectionMixin from '../../basic-component-mixins/src/SingleSelectionMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\nconst base = ElementBase.compose(\n  ContentItemsMixin,\n  DistributedChildrenContentMixin,\n  SingleSelectionMixin\n);\n\n\n/**\n * Shows exactly one child element at a time. This can be useful, for example,\n * if a given UI element has multiple modes that present substantially different\n * elements.\n *\n * The transition between child elements is instantenous. If you'd like the\n * transition to be accompanied by visible animated effects, see\n * [basic-animation-stage](../basic-animation-stage).\n *\n * This component doesn't provide any UI for changing which mode is shown.\n *\n * @extends ElementBase\n * @mixes ContentItemsMixin\n * @mixes DistributedChildrenContentMixin\n * @mixes SingleSelectionMixin\n */\nclass Modes extends base {\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.selectionRequired = true;\n    return defaults;\n  }\n\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.style.display = selected ? '' : 'none';\n    item.setAttribute('aria-hidden', !selected);\n  }\n\n  get [symbols.template]() {\n    return `<slot></slot>`;\n  }\n\n}\n\n\ncustomElements.define('basic-modes', Modes);\nexport default Modes;\n"],"preExisting":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9BdHRyaWJ1dGVNYXJzaGFsbGluZ01peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQ29tcG9zYWJsZU1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQ29udGVudEl0ZW1zTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9EaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvRGlzdHJpYnV0ZWRDaGlsZHJlbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2hhZG93RWxlbWVudFJlZmVyZW5jZXNNaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NoYWRvd1RlbXBsYXRlTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TaW5nbGVTZWxlY3Rpb25NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL2NyZWF0ZVN5bWJvbC5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL21pY3JvdGFzay5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3NhZmVBdHRyaWJ1dGVzLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc3ltYm9scy5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3RvZ2dsZUNsYXNzLmpzIiwicGFja2FnZXMvYmFzaWMtZWxlbWVudC1iYXNlL3NyYy9FbGVtZW50QmFzZS5qcyIsInBhY2thZ2VzL2Jhc2ljLW1vZGVzL2dsb2JhbHMuanMiLCJwYWNrYWdlcy9iYXNpYy1tb2Rlcy9zcmMvTW9kZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7OztBQUdBO0FBQ0EsSUFBTSwyQkFBMkIsRUFBakM7QUFDQSxJQUFNLDRCQUE0QixFQUFsQzs7QUFHQTs7a0JBQ2UsVUFBQyxJQUFELEVBQVU7O0FBRXZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUZ1QixNQXFDakIsb0JBckNpQjtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOzs7QUF1Q3JCOzs7QUF2Q3FCLCtDQTBDSSxhQTFDSixFQTBDbUIsUUExQ25CLEVBMEM2QixRQTFDN0IsRUEwQ3VDO0FBQzFELHVKQUFvQztBQUFFO0FBQW1DO0FBQ3pFLFlBQU0sZUFBZSx3QkFBd0IsYUFBeEIsQ0FBckI7QUFDQTtBQUNBO0FBQ0EsWUFBSSxnQkFBZ0IsSUFBaEIsSUFBd0IsRUFBRSxnQkFBZ0IsWUFBWSxTQUE5QixDQUE1QixFQUFzRTtBQUNwRSxlQUFLLFlBQUwsSUFBcUIsUUFBckI7QUFDRDtBQUNGO0FBbERvQjtBQUFBO0FBQUEsMENBb0REO0FBQ2xCLGdKQUE2QjtBQUFFO0FBQTRCO0FBQzNELGlDQUFlLFNBQWYsQ0FBeUIsSUFBekI7QUFDRDtBQXZEb0I7QUFBQTs7O0FBNkRyQjs7Ozs7Ozs7Ozs7O0FBN0RxQix1Q0F5RUosU0F6RUksRUF5RU8sS0F6RVAsRUF5RWM7QUFDakMsZUFBTyx5QkFBZSxZQUFmLENBQTRCLElBQTVCLEVBQWtDLFNBQWxDLEVBQTZDLEtBQTdDLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7QUE3RXFCO0FBQUE7QUFBQSxtQ0EwRlIsU0ExRlEsRUEwRkcsS0ExRkgsRUEwRlU7QUFDN0IsZUFBTyx5QkFBZSxXQUFmLENBQTJCLElBQTNCLEVBQWlDLFNBQWpDLEVBQTRDLEtBQTVDLENBQVA7QUFDRDtBQTVGb0I7QUFBQTtB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akYsV0FBSyxLQUFMLENBQVcsT0FBWCxHQUFxQixXQUFXLEVBQVgsR0FBZ0IsTUFBckM7QUFDQSxXQUFLLFlBQUwsQ0FBa0IsYUFBbEIsRUFBaUMsQ0FBQyxRQUFsQztBQUNEOztTQVZJLGtCQUFRLFE7d0JBQVk7QUFDdkIsVUFBTSxXQUFXLDBFQUFNLGtCQUFRLFFBQWQsV0FBMkIsRUFBNUM7QUFDQSxlQUFTLGlCQUFULEdBQTZCLElBQTdCO0FBQ0EsYUFBTyxRQUFQO0FBQ0Q7O1NBUUksa0JBQVEsUTt3QkFBWTtBQUN2QjtBQUNEOzs7O0VBaEJpQixJOztBQXFCcEIsZUFBZSxNQUFmLENBQXNCLGFBQXRCLEVBQXFDLEtBQXJDO2tCQUNlLEsiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiaW1wb3J0IHNhZmVBdHRyaWJ1dGVzIGZyb20gJy4vc2FmZUF0dHJpYnV0ZXMnO1xuXG5cbi8vIE1lbW9pemVkIG1hcHMgb2YgYXR0cmlidXRlIHRvIHByb3BlcnR5IG5hbWVzIGFuZCB2aWNlIHZlcnNhLlxuY29uc3QgYXR0cmlidXRlVG9Qcm9wZXJ0eU5hbWVzID0ge307XG5jb25zdCBwcm9wZXJ0eU5hbWVzVG9BdHRyaWJ1dGVzID0ge307XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBBdHRyaWJ1dGVNYXJzaGFsbGluZy4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIG1hcnNoYWxscyBhdHRyaWJ1dGVzIHRvIHByb3BlcnRpZXMgYW5kIHZpY2UgdmVyc2EuXG4gICAqXG4gICAqIElmIHlvdXIgY29tcG9uZW50IGV4cG9zZXMgYSBzZXR0ZXIgZm9yIGEgcHJvcGVydHksIGl0J3MgZ2VuZXJhbGx5IGEgZ29vZFxuICAgKiBpZGVhIHRvIGxldCBkZXZzIHVzaW5nIHlvdXIgY29tcG9uZW50IGJlIGFibGUgdG8gc2V0IHRoYXQgcHJvcGVydHkgaW4gSFRNTFxuICAgKiB2aWEgYW4gZWxlbWVudCBhdHRyaWJ1dGUuIFlvdSBjYW4gY29kZSB0aGF0IHlvdXJzZWxmIGJ5IHdyaXRpbmcgYW5cbiAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AsIG9yIHlvdSBjYW4gdXNlIHRoaXMgbWl4aW4gdG8gZ2V0IGEgZGVncmVlIG9mXG4gICAqIGF1dG9tYXRpYyBzdXBwb3J0LlxuICAgKlxuICAgKiBUaGlzIG1peGluIGltcGxlbWVudHMgYW4gYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgdGhhdCB3aWxsIGF0dGVtcHQgdG9cbiAgICogY29udmVydCBhIGNoYW5nZSBpbiBhbiBlbGVtZW50IGF0dHJpYnV0ZSBpbnRvIGEgY2FsbCB0byB0aGUgY29ycmVzcG9uZGluZ1xuICAgKiBwcm9wZXJ0eSBzZXR0ZXIuIEF0dHJpYnV0ZXMgdHlwaWNhbGx5IGZvbGxvdyBoeXBoZW5hdGVkIG5hbWVzIChcImZvby1iYXJcIiksXG4gICAqIHdoZXJlYXMgcHJvcGVydGllcyB0eXBpY2FsbHkgdXNlIGNhbWVsQ2FzZSBuYW1lcyAoXCJmb29CYXJcIikuIFRoaXMgbWl4aW5cbiAgICogcmVzcGVjdHMgdGhhdCBjb252ZW50aW9uLCBhdXRvbWF0aWNhbGx5IG1hcHBpbmcgdGhlIGh5cGhlbmF0ZWQgYXR0cmlidXRlXG4gICAqIG5hbWUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2FtZWxDYXNlIHByb3BlcnR5IG5hbWUuXG4gICAqXG4gICAqIEV4YW1wbGU6IFlvdSBkZWZpbmUgYSBjb21wb25lbnQgdXNpbmcgdGhpcyBtaXhpbjpcbiAgICpcbiAgICogICAgIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIEF0dHJpYnV0ZU1hcnNoYWxsaW5nTWl4aW4oSFRNTEVsZW1lbnQpIHtcbiAgICogICAgICAgZ2V0IGZvb0JhcigpIHsgcmV0dXJuIHRoaXMuX2Zvb0JhcjsgfVxuICAgKiAgICAgICBzZXQgZm9vQmFyKHZhbHVlKSB7IHRoaXMuX2Zvb0JhciA9IHZhbHVlOyB9XG4gICAqICAgICB9XG4gICAqICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ215LWVsZW1lbnQnLCBNeUVsZW1lbnQpO1xuICAgKlxuICAgKiBJZiBzb21lb25lIHRoZW4gaW5zdGFudGlhdGVzIHlvdXIgY29tcG9uZW50IGluIEhUTUw6XG4gICAqXG4gICAqICAgICA8bXktZWxlbWVudCBmb28tYmFyPVwiSGVsbG9cIj48L215LWVsZW1lbnQ+XG4gICAqXG4gICAqIFRoZW4sIGFmdGVyIHRoZSBlbGVtZW50IGhhcyBiZWVuIHVwZ3JhZGVkLCB0aGUgYGZvb0JhcmAgc2V0dGVyIHdpbGxcbiAgICogYXV0b21hdGljYWxseSBiZSBpbnZva2VkIHdpdGggdGhlIGluaXRpYWwgdmFsdWUgXCJIZWxsb1wiLlxuICAgKlxuICAgKiBGb3IgdGhlIHRpbWUgYmVpbmcsIHRoaXMgbWl4aW4gb25seSBzdXBwb3J0cyBzdHJpbmctdmFsdWVkIHByb3BlcnRpZXMuXG4gICAqIElmIHlvdSdkIGxpa2UgdG8gY29udmVydCBzdHJpbmcgYXR0cmlidXRlcyB0byBvdGhlciB0eXBlcyAobnVtYmVycyxcbiAgICogYm9vbGVhbnMpLCB5b3UgbmVlZCB0byBpbXBsZW1lbnQgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgeW91cnNlbGYuXG4gICAqL1xuICBjbGFzcyBBdHRyaWJ1dGVNYXJzaGFsbGluZyBleHRlbmRzIGJhc2Uge1xuXG4gICAgLypcbiAgICAgKiBIYW5kbGUgYSBjaGFuZ2UgdG8gdGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyaWJ1dGVOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgIGlmIChzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spIHsgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCk7IH1cbiAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGF0dHJpYnV0ZVRvUHJvcGVydHlOYW1lKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgLy8gSWYgdGhlIGF0dHJpYnV0ZSBuYW1lIGNvcnJlc3BvbmRzIHRvIGEgcHJvcGVydHkgbmFtZSwgc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICAgIC8vIElnbm9yZSBzdGFuZGFyZCBIVE1MRWxlbWVudCBwcm9wZXJ0aWVzIGhhbmRsZWQgYnkgdGhlIERPTS5cbiAgICAgIGlmIChwcm9wZXJ0eU5hbWUgaW4gdGhpcyAmJiAhKHByb3BlcnR5TmFtZSBpbiBIVE1MRWxlbWVudC5wcm90b3R5cGUpKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgaWYgKHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKSB7IHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7IH1cbiAgICAgIHNhZmVBdHRyaWJ1dGVzLmNvbm5lY3RlZCh0aGlzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzRm9yQ2xhc3ModGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0L3Vuc2V0IHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgaW5kaWNhdGVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBleGlzdHMgcHJpbWFyaWx5IHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbiBlbGVtZW50IHdhbnRzIHRvXG4gICAgICogc2V0IGEgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZSB0aGF0IHNob3VsZCBiZSByZWZsZWN0ZWQgYXMgYW4gYXR0cmlidXRlLiBBblxuICAgICAqIGltcG9ydGFudCBsaW1pdGF0aW9uIG9mIGN1c3RvbSBlbGVtZW50IGNvbnN0dXJjdG9ycyBpcyB0aGF0IHRoZXkgY2Fubm90XG4gICAgICogc2V0IGF0dHJpYnV0ZXMuIEEgY2FsbCB0byBgcmVmbGVjdEF0dHJpYnV0ZWAgZHVyaW5nIHRoZSBjb25zdHJ1Y3RvciB3aWxsXG4gICAgICogYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVsZW1lbnQgaXMgY29ubmVjdGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgLSBUaGUgbmFtZSBvZiB0aGUgKmF0dHJpYnV0ZSogKG5vdCBwcm9wZXJ0eSkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQuIElmIG51bGwsIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlZmxlY3RBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNhZmVBdHRyaWJ1dGVzLnNldEF0dHJpYnV0ZSh0aGlzLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQvdW5zZXQgdGhlIGNsYXNzIHdpdGggdGhlIGluZGljYXRlZCBuYW1lLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZXhpc3RzIHByaW1hcmlseSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYW4gZWxlbWVudCB3YW50cyB0b1xuICAgICAqIHNldCBhIGRlZmF1bHQgcHJvcGVydHkgdmFsdWUgdGhhdCBzaG91bGQgYmUgcmVmbGVjdGVkIGFzIGFzIGNsYXNzLiBBblxuICAgICAqIGltcG9ydGFudCBsaW1pdGF0aW9uIG9mIGN1c3RvbSBlbGVtZW50IGNvbnN0dXJjdG9ycyBpcyB0aGF0IHRoZXkgY2Fubm90XG4gICAgICogc2V0IGF0dHJpYnV0ZXMsIGluY2x1ZGluZyB0aGUgYGNsYXNzYCBhdHRyaWJ1dGUuIEEgY2FsbCB0b1xuICAgICAqIGByZWZsZWN0Q2xhc3NgIGR1cmluZyB0aGUgY29uc3RydWN0b3Igd2lsbCBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgZWxlbWVudFxuICAgICAqIGlzIGNvbm5lY3RlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNsYXNzIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgLSBUcnVlIHRvIHNldCB0aGUgY2xhc3MsIGZhbHNlIHRvIHJlbW92ZSBpdC5cbiAgICAgKi9cbiAgICByZWZsZWN0Q2xhc3MoY2xhc3NOYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNhZmVBdHRyaWJ1dGVzLnRvZ2dsZUNsYXNzKHRoaXMsIGNsYXNzTmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEF0dHJpYnV0ZU1hcnNoYWxsaW5nO1xufTtcblxuXG4vLyBDb252ZXJ0IGh5cGhlbmF0ZWQgZm9vLWJhciBhdHRyaWJ1dGUgbmFtZSB0byBjYW1lbCBjYXNlIGZvb0JhciBwcm9wZXJ0eSBuYW1lLlxuZnVuY3Rpb24gYXR0cmlidXRlVG9Qcm9wZXJ0eU5hbWUoYXR0cmlidXRlTmFtZSkge1xuICBsZXQgcHJvcGVydHlOYW1lID0gYXR0cmlidXRlVG9Qcm9wZXJ0eU5hbWVzW2F0dHJpYnV0ZU5hbWVdO1xuICBpZiAoIXByb3BlcnR5TmFtZSkge1xuICAgIC8vIENvbnZlcnQgYW5kIG1lbW9pemUuXG4gICAgY29uc3QgaHlwZW5SZWdFeCA9IC8tKFthLXpdKS9nO1xuICAgIHByb3BlcnR5TmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShoeXBlblJlZ0V4LFxuICAgICAgICBtYXRjaCA9PiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpKTtcbiAgICBhdHRyaWJ1dGVUb1Byb3BlcnR5TmFtZXNbYXR0cmlidXRlTmFtZV0gPSBwcm9wZXJ0eU5hbWU7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5TmFtZTtcbn1cblxuZnVuY3Rpb24gYXR0cmlidXRlc0ZvckNsYXNzKGNsYXNzRm4pIHtcblxuICAvLyBXZSB0cmVhdCB0aGUgZWxlbWVudCBiYXNlIGNsYXNzZXMgYXMgaWYgdGhleSBoYXZlIG5vIGF0dHJpYnV0ZXMsIHNpbmNlIHdlXG4gIC8vIGRvbid0IHdhbnQgdG8gcmVjZWl2ZSBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgZm9yIHRoZW0uXG4gIGlmIChjbGFzc0ZuID09PSBIVE1MRWxlbWVudCB8fCBjbGFzc0ZuID09PSBPYmplY3QpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyBHZXQgYXR0cmlidXRlcyBmb3IgcGFyZW50IGNsYXNzLlxuICBjb25zdCBiYXNlQ2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2xhc3NGbi5wcm90b3R5cGUpLmNvbnN0cnVjdG9yO1xuICBjb25zdCBiYXNlQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXNGb3JDbGFzcyhiYXNlQ2xhc3MpO1xuXG4gIC8vIEdldCBhdHRyaWJ1dGVzIGZvciB0aGlzIGNsYXNzLlxuICBjb25zdCBwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2xhc3NGbi5wcm90b3R5cGUpO1xuICBjb25zdCBzZXR0ZXJOYW1lcyA9IHByb3BlcnR5TmFtZXMuZmlsdGVyKHByb3BlcnR5TmFtZSA9PlxuICAgIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICBjbGFzc0ZuLnByb3RvdHlwZSwgcHJvcGVydHlOYW1lKS5zZXQgPT09ICdmdW5jdGlvbicpO1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc2V0dGVyTmFtZXMubWFwKHNldHRlck5hbWUgPT5cbiAgICAgIHByb3BlcnR5TmFtZVRvQXR0cmlidXRlKHNldHRlck5hbWUpKTtcblxuICAvLyBNZXJnZS5cbiAgY29uc3QgZGlmZiA9IGF0dHJpYnV0ZXMuZmlsdGVyKGF0dHJpYnV0ZSA9PlxuICAgICAgYmFzZUF0dHJpYnV0ZXMuaW5kZXhPZihhdHRyaWJ1dGUpIDwgMCk7XG4gIHJldHVybiBiYXNlQXR0cmlidXRlcy5jb25jYXQoZGlmZik7XG59XG5cbi8vIENvbnZlcnQgYSBjYW1lbCBjYXNlIGZvb0JhciBwcm9wZXJ0eSBuYW1lIHRvIGEgaHlwaGVuYXRlZCBmb28tYmFyIGF0dHJpYnV0ZS5cbmZ1bmN0aW9uIHByb3BlcnR5TmFtZVRvQXR0cmlidXRlKHByb3BlcnR5TmFtZSkge1xuICBsZXQgYXR0cmlidXRlID0gcHJvcGVydHlOYW1lc1RvQXR0cmlidXRlc1twcm9wZXJ0eU5hbWVdO1xuICBpZiAoIWF0dHJpYnV0ZSkge1xuICAgIC8vIENvbnZlcnQgYW5kIG1lbW9pemUuXG4gICAgY29uc3QgdXBwZXJjYXNlUmVnRXggPSAvKFtBLVpdKS9nO1xuICAgIGF0dHJpYnV0ZSA9IHByb3BlcnR5TmFtZS5yZXBsYWNlKHVwcGVyY2FzZVJlZ0V4LCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuICByZXR1cm4gYXR0cmlidXRlO1xufVxuIiwiLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBDb21wb3NhYmxlLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gdG8gbWFrZSBhIGNsYXNzIG1vcmUgZWFzaWx5IGNvbXBvc2FibGUgd2l0aCBvdGhlciBtaXhpbnMuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gY29udHJpYnV0ZXMgYSBgY29tcG9zZWAgbWV0aG9kIHRoYXQgYXBwbGllcyBhIHNldCBvZiBtaXhpblxuICAgKiBmdW5jdGlvbnMgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBuZXcgY2xhc3MuIFRoaXMgc3VnYXIgY2FuIG1ha2UgdGhlXG4gICAqIGFwcGxpY2F0aW9uIG9mIG1hbnkgbWl4aW5zIGF0IG9uY2UgZWFzaWVyIHRvIHJlYWQuXG4gICAqL1xuICBjbGFzcyBDb21wb3NhYmxlIGV4dGVuZHMgYmFzZSB7XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBhIHNldCBvZiBtaXhpbiBmdW5jdGlvbnMgb3IgbWl4aW4gb2JqZWN0cyB0byB0aGUgcHJlc2VudCBjbGFzcyBhbmRcbiAgICAgKiByZXR1cm4gdGhlIG5ldyBjbGFzcy5cbiAgICAgKlxuICAgICAqIEluc3RlYWQgb2Ygd3JpdGluZzpcbiAgICAgKlxuICAgICAqICAgICBsZXQgTXlDbGFzcyA9IE1peGluMShNaXhpbjIoTWl4aW4zKE1peGluNChNaXhpbjUoQmFzZUNsYXNzKSkpKSk7XG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHdyaXRlOlxuICAgICAqXG4gICAgICogICAgIGxldCBNeUNsYXNzID0gQ29tcG9zYWJsZU1peGluKEJhc2VDbGFzcykuY29tcG9zZShcbiAgICAgKiAgICAgICBNaXhpbjEsXG4gICAgICogICAgICAgTWl4aW4yLFxuICAgICAqICAgICAgIE1peGluMyxcbiAgICAgKiAgICAgICBNaXhpbjQsXG4gICAgICogICAgICAgTWl4aW41XG4gICAgICogICAgICk7XG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBhbHNvIHRha2UgbWl4aW4gb2JqZWN0cy4gQSBtaXhpbiBvYmplY3QgaXMganVzdCBhXG4gICAgICogc2hvcnRoYW5kIGZvciBhIG1peGluIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBzdWJjbGFzcyB3aXRoIHRoZSBnaXZlblxuICAgICAqIG1lbWJlcnMuIFRoZSBtaXhpbiBvYmplY3QncyBtZW1iZXJzIGFyZSAqbm90KiBjb3BpZWQgZGlyZWN0bHkgb250byB0aGVcbiAgICAgKiBwcm90b3R5cGUgb2YgdGhlIGJhc2UgY2xhc3MsIGFzIHdpdGggdHJhZGl0aW9uYWwgbWl4aW5zLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gcHJvdmlkaW5nIHN5bnRhY3RpYyBzdWdhciwgdGhpcyBtaXhpbiBjYW4gYmUgdXNlZCB0b1xuICAgICAqIGRlZmluZSBhIGNsYXNzIGluIEVTNSwgd2hpY2ggbGFja3MgRVM2J3MgYGNsYXNzYCBrZXl3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi5taXhpbnN9IG1peGlucyAtIEEgc2V0IG9mIG1peGluIGZ1bmN0aW9ucyBvciBvYmplY3RzIHRvIGFwcGx5LlxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wb3NlKC4uLm1peGlucykge1xuICAgICAgLy8gV2UgY3JlYXRlIGEgbmV3IHN1YmNsYXNzIGZvciBlYWNoIG1peGluIGluIHR1cm4uIFRoZSByZXN1bHQgYmVjb21lc1xuICAgICAgLy8gdGhlIGJhc2UgY2xhc3MgZXh0ZW5kZWQgYnkgYW55IHN1YnNlcXVlbnQgbWl4aW5zLiBJdCB0dXJucyBvdXQgdGhhdFxuICAgICAgLy8gd2UgY2FuIHVzZSBBcnJheS5yZWR1Y2UoKSB0byBjb25jaXNlbHkgZXhwcmVzcyB0aGlzLCB1c2luZyB0aGUgY3VycmVudFxuICAgICAgLy8gb2JqZWN0IGFzIHRoZSBzZWVkIGZvciByZWR1Y2UoKS5cbiAgICAgIHJldHVybiBtaXhpbnMucmVkdWNlKGNvbXBvc2VDbGFzcywgdGhpcyk7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQ29tcG9zYWJsZTtcbn07XG5cblxuLy8gUHJvcGVydGllcyBkZWZpbmVkIGJ5IE9iamVjdCB0aGF0IHdlIGRvbid0IHdhbnQgdG8gbWl4aW4uXG5jb25zdCBOT05fTUlYQUJMRV9PQkpFQ1RfUFJPUEVSVElFUyA9IFtcbiAgJ2NvbnN0cnVjdG9yJ1xuXTtcblxuLypcbiAqIEFwcGx5IHRoZSBtaXhpbiB0byB0aGUgZ2l2ZW4gYmFzZSBjbGFzcyB0byByZXR1cm4gYSBuZXcgY2xhc3MuXG4gKiBUaGUgbWl4aW4gY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbW9kaWZpZWQgY2xhc3MsIG9yIGFcbiAqIHBsYWluIG9iamVjdCB3aG9zZSBtZW1iZXJzIHdpbGwgYmUgY29waWVkIHRvIHRoZSBuZXcgY2xhc3MnIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gY29tcG9zZUNsYXNzKGJhc2UsIG1peGluKSB7XG4gIGlmICh0eXBlb2YgbWl4aW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBNaXhpbiBmdW5jdGlvblxuICAgIHJldHVybiBtaXhpbihiYXNlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBNaXhpbiBvYmplY3RcbiAgICBjbGFzcyBTdWJjbGFzcyBleHRlbmRzIGJhc2Uge31cbiAgICBjb3B5T3duUHJvcGVydGllcyhtaXhpbiwgU3ViY2xhc3MucHJvdG90eXBlLCBOT05fTUlYQUJMRV9PQkpFQ1RfUFJPUEVSVElFUyk7XG4gICAgcmV0dXJuIFN1YmNsYXNzO1xuICB9XG59XG5cblxuLypcbiAqIENvcHkgdGhlIGdpdmVuIHByb3BlcnRpZXMvbWV0aG9kcyB0byB0aGUgdGFyZ2V0LlxuICogUmV0dXJuIHRoZSB1cGRhdGVkIHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gY29weU93blByb3BlcnRpZXMoc291cmNlLCB0YXJnZXQsIGlnbm9yZVByb3BlcnR5TmFtZXMgPSBbXSkge1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgaWYgKGlnbm9yZVByb3BlcnR5TmFtZXMuaW5kZXhPZihuYW1lKSA8IDApIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgbmFtZSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuL2NyZWF0ZVN5bWJvbCc7XG5pbXBvcnQgdG9nZ2xlQ2xhc3MgZnJvbSAnLi90b2dnbGVDbGFzcyc7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuL3N5bWJvbHMnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBpdGVtc1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnaXRlbXMnKTtcbmNvbnN0IGl0ZW1Jbml0aWFsaXplZFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnaXRlbUluaXRpYWxpemVkJyk7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBDb250ZW50SXRlbXMuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYXBzIGNvbnRlbnQgc2VtYW50aWNzIChlbGVtZW50cykgdG8gbGlzdCBpdGVtIHNlbWFudGljcy5cbiAgICpcbiAgICogSXRlbXMgZGlmZmVyIGZyb20gZWxlbWVudCBjb250ZW50cyBpbiBzZXZlcmFsIHdheXM6XG4gICAqXG4gICAqICogVGhleSBhcmUgb2Z0ZW4gcmVmZXJlbmNlZCB2aWEgaW5kZXguXG4gICAqICogVGhleSBtYXkgaGF2ZSBhIHNlbGVjdGlvbiBzdGF0ZS5cbiAgICogKiBJdCdzIGNvbW1vbiB0byBkbyB3b3JrIHRvIGluaXRpYWxpemUgdGhlIGFwcGVhcmFuY2Ugb3Igc3RhdGUgb2YgYSBuZXdcbiAgICogICBpdGVtLlxuICAgKiAqIEF1eGlsaWFyeSBpbnZpc2libGUgY2hpbGQgZWxlbWVudHMgYXJlIGZpbHRlcmVkIG91dCBhbmQgbm90IGNvdW50ZWQgYXNcbiAgICogICBpdGVtcy4gQXV4aWxpYXJ5IGVsZW1lbnRzIGluY2x1ZGUgbGluaywgc2NyaXB0LCBzdHlsZSwgYW5kIHRlbXBsYXRlXG4gICAqICAgZWxlbWVudHMuIFRoaXMgZmlsdGVyaW5nIGVuc3VyZXMgdGhhdCB0aG9zZSBhdXhpbGlhcnkgZWxlbWVudHMgY2FuIGJlXG4gICAqICAgdXNlZCBpbiBtYXJrdXAgaW5zaWRlIG9mIGEgbGlzdCB3aXRob3V0IGJlaW5nIHRyZWF0ZWQgYXMgbGlzdCBpdGVtcy5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBleHBlY3RzIGEgY29tcG9uZW50IHRvIHByb3ZpZGUgYSBgY29udGVudGAgcHJvcGVydHkgcmV0dXJuaW5nIGFcbiAgICogcmF3IHNldCBvZiBlbGVtZW50cy4gWW91IGNhbiBwcm92aWRlIHRoYXQgeW91cnNlbGYsIG9yIHVzZVxuICAgKiBbRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbl0oRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbi5tZCkuXG4gICAqXG4gICAqIFRoZSBtb3N0IGNvbW1vbmx5IHJlZmVyZW5jZWQgcHJvcGVydHkgZGVmaW5lZCBieSB0aGlzIG1peGluIGlzIHRoZSBgaXRlbXNgXG4gICAqIHByb3BlcnR5LiBUbyBhdm9pZCBoYXZpbmcgdG8gZG8gd29yayBlYWNoIHRpbWUgdGhhdCBwcm9wZXJ0eSBpcyByZXF1ZXN0ZWQsXG4gICAqIHRoaXMgbWl4aW4gc3VwcG9ydHMgYW4gb3B0aW1pemVkIG1vZGUuIElmIHlvdSBpbnZva2UgdGhlIGBjb250ZW50Q2hhbmdlZGBcbiAgICogbWV0aG9kIHdoZW4gdGhlIHNldCBvZiBpdGVtcyBjaGFuZ2VzLCB0aGUgbWl4aW4gY29uY2x1ZGVzIHRoYXQgeW91J2xsIHRha2VcbiAgICogY2FyZSBvZiBub3RpZnlpbmcgaXQgb2YgZnV0dXJlIGNoYW5nZXMsIGFuZCB0dXJucyBvbiB0aGUgb3B0aW1pemF0aW9uLiBXaXRoXG4gICAqIHRoYXQgb24sIHRoZSBtaXhpbiBzYXZlcyBhIHJlZmVyZW5jZSB0byB0aGUgY29tcHV0ZWQgc2V0IG9mIGl0ZW1zLCBhbmQgd2lsbFxuICAgKiByZXR1cm4gdGhhdCBpbW1lZGlhdGVseSBvbiBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSBgaXRlbXNgIHByb3BlcnR5LiBJZiB5b3VcbiAgICogdXNlIHRoaXMgbWl4aW4gaW4gY29uanVuY3Rpb24gd2l0aFxuICAgKiBbRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbl0oRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbi5tZCksIHRoZVxuICAgKiBgY29udGVudENoYW5nZWRgIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgZm9yIHlvdSB3aGVuIHRoZSBlbGVtZW50J3MgY2hpbGRyZW5cbiAgICogY2hhbmdlLCB0dXJuaW5nIG9uIHRoZSBvcHRpbWl6YXRpb24gYXV0b21hdGljYWxseS5cbiAgICovXG4gIGNsYXNzIENvbnRlbnRJdGVtcyBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29udGVudENoYW5nZWQoKSB7XG4gICAgICBpZiAoc3VwZXIuY29udGVudENoYW5nZWQpIHsgc3VwZXIuY29udGVudENoYW5nZWQoKTsgfVxuXG4gICAgICAvLyBTaW5jZSB3ZSBnb3QgdGhlIGNvbnRlbnRDaGFuZ2VkIGNhbGwsIHdlJ2xsIGFzc3VtZSB3ZSdsbCBiZSBub3RpZmllZCBpZlxuICAgICAgLy8gdGhlIHNldCBvZiBpdGVtcyBjaGFuZ2VzIGxhdGVyLiBXZSB0dXJuIG9uIG1lbW9pemF0aW9uIG9mIHRoZSBpdGVtc1xuICAgICAgLy8gcHJvcGVydHkgYnkgc2V0dGluZyBvdXIgaW50ZXJuYWwgcHJvcGVydHkgdG8gbnVsbCAoaW5zdGVhZCBvZlxuICAgICAgLy8gdW5kZWZpbmVkKS5cbiAgICAgIHRoaXNbaXRlbXNTeW1ib2xdID0gbnVsbDtcblxuICAgICAgdGhpc1tzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW5ldmVyIGEgbmV3IGl0ZW0gaXMgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuIFlvdSBjYW4gb3ZlcnJpZGVcbiAgICAgKiB0aGlzIHRvIHBlcmZvcm0gcGVyLWl0ZW0gaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIC0gVGhlIGl0ZW0gdGhhdCB3YXMgYWRkZWQuXG4gICAgICovXG4gICAgW3N5bWJvbHMuaXRlbUFkZGVkXShpdGVtKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtQWRkZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbUFkZGVkXShpdGVtKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3Rpb24gc3RhdGUgZm9yIGEgc2luZ2xlIGl0ZW0gaGFzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBJbnZva2UgdGhpcyBtZXRob2QgdG8gc2lnbmFsIHRoYXQgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIHRoZSBpbmRpY2F0ZWQgaXRlbVxuICAgICAqIGhhcyBjaGFuZ2VkLiBCeSBkZWZhdWx0LCB0aGlzIGFwcGxpZXMgYSBgc2VsZWN0ZWRgIENTUyBjbGFzcyBpZiB0aGUgaXRlbVxuICAgICAqIGlzIHNlbGVjdGVkLCBhbmQgcmVtb3ZlZCBpdCBpZiBub3Qgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIC0gVGhlIGl0ZW0gd2hvc2Ugc2VsZWN0aW9uIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgLSBUcnVlIGlmIHRoZSBpdGVtIGlzIHNlbGVjdGVkLCBmYWxzZSBpZiBub3QuXG4gICAgICovXG4gICAgW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuaXRlbVNlbGVjdGVkXSkgeyBzdXBlcltzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgc2VsZWN0ZWQpOyB9XG4gICAgICB0b2dnbGVDbGFzcyhpdGVtLCAnc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc2V0IG9mIGl0ZW1zIGluIHRoZSBsaXN0LiBTZWUgdGhlIHRvcC1sZXZlbCBkb2N1bWVudGF0aW9uIGZvclxuICAgICAqIG1peGluIGZvciBhIGRlc2NyaXB0aW9uIG9mIGhvdyBpdGVtcyBkaWZmZXIgZnJvbSBwbGFpbiBjb250ZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XG4gICAgICovXG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgbGV0IGl0ZW1zO1xuICAgICAgaWYgKHRoaXNbaXRlbXNTeW1ib2xdID09IG51bGwpIHtcbiAgICAgICAgaXRlbXMgPSBmaWx0ZXJBdXhpbGlhcnlFbGVtZW50cyh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAvLyBOb3RlOiB0ZXN0IGZvciAqZXF1YWxpdHkqIHdpdGggbnVsbDsgZG9uJ3QgdHJlYXQgdW5kZWZpbmVkIGFzIGEgbWF0Y2guXG4gICAgICAgIGlmICh0aGlzW2l0ZW1zU3ltYm9sXSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIE1lbW9pemUgdGhlIHNldCBvZiBpdGVtcy5cbiAgICAgICAgICB0aGlzW2l0ZW1zU3ltYm9sXSA9IGl0ZW1zO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIG1lbW9pemVkIGl0ZW1zLlxuICAgICAgICBpdGVtcyA9IHRoaXNbaXRlbXNTeW1ib2xdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdW5kZXJseWluZyBjb250ZW50cyBjaGFuZ2UuIEl0IGlzIGFsc29cbiAgICAgKiBpbnZva2VkIG9uIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbiDigJMgc2luY2UgdGhlIGl0ZW1zIGhhdmUgXCJjaGFuZ2VkXCIgZnJvbVxuICAgICAqIGJlaW5nIG5vdGhpbmcuXG4gICAgICovXG4gICAgW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1zQ2hhbmdlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtc0NoYW5nZWRdKCk7IH1cblxuICAgICAgLy8gUGVyZm9ybSBwZXItaXRlbSBpbml0aWFsaXphdGlvbi5cbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodGhpcy5pdGVtcywgaXRlbSA9PiB7XG4gICAgICAgIGlmICghaXRlbVtpdGVtSW5pdGlhbGl6ZWRTeW1ib2xdKSB7XG4gICAgICAgICAgdGhpc1tzeW1ib2xzLml0ZW1BZGRlZF0oaXRlbSk7XG4gICAgICAgICAgaXRlbVtpdGVtSW5pdGlhbGl6ZWRTeW1ib2xdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2l0ZW1zLWNoYW5nZWQnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgaXRlbXMgaW4gdGhlIGxpc3QgY2hhbmdlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvbnRlbnRJdGVtc1xuICAgICAqIEBldmVudCBpdGVtcy1jaGFuZ2VkXG4gICAgICovXG4gIH1cblxuICByZXR1cm4gQ29udGVudEl0ZW1zO1xufTtcblxuXG4vLyBSZXR1cm4gdGhlIGdpdmVuIGVsZW1lbnRzLCBmaWx0ZXJpbmcgb3V0IGF1eGlsaWFyeSBlbGVtZW50cyB0aGF0IGFyZW4ndFxuLy8gdHlwaWNhbGx5IHZpc2libGUuIEl0ZW1zIHdoaWNoIGFyZSBub3QgZWxlbWVudHMgYXJlIHJldHVybmVkIGFzIGlzLlxuZnVuY3Rpb24gZmlsdGVyQXV4aWxpYXJ5RWxlbWVudHMoaXRlbXMpIHtcbiAgY29uc3QgYXV4aWxpYXJ5VGFncyA9IFtcbiAgICAnbGluaycsXG4gICAgJ3NjcmlwdCcsXG4gICAgJ3N0eWxlJyxcbiAgICAndGVtcGxhdGUnXG4gIF07XG4gIHJldHVybiBbXS5maWx0ZXIuY2FsbChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiAhaXRlbS5sb2NhbE5hbWUgfHwgYXV4aWxpYXJ5VGFncy5pbmRleE9mKGl0ZW0ubG9jYWxOYW1lKSA8IDA7XG4gIH0pO1xufVxuIiwiaW1wb3J0IG1pY3JvdGFzayBmcm9tICcuL21pY3JvdGFzayc7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudC4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIGRlZmluZXMgYSBjb21wb25lbnQncyBjb250ZW50IGFzIGl0cyBjaGlsZHJlbiwgZXhwYW5kaW5nIGFueVxuICAgKiBub2RlcyBkaXN0cmlidXRlZCB0byB0aGUgY29tcG9uZW50J3Mgc2xvdHMuXG4gICAqXG4gICAqIFRoaXMgYWxzbyBwcm92aWRlcyBub3RpZmljYXRpb24gb2YgY2hhbmdlcyB0byBhIGNvbXBvbmVudCdzIGNvbnRlbnQuIEl0XG4gICAqIHdpbGwgaW52b2tlIGEgYGNvbnRlbnRDaGFuZ2VkYCBtZXRob2Qgd2hlbiB0aGUgY29tcG9uZW50IGlzIGZpcnN0XG4gICAqIGluc3RhbnRpYXRlZCwgYW5kIHdoZW5ldmVyIGl0cyBkaXN0cmlidXRlZCBjaGlsZHJlbiBjaGFuZ2UuIFRoaXMgaXMgYW5cbiAgICogZWFzeSB3YXkgdG8gc2F0aXNmeSB0aGUgR29sZCBTdGFuZGFyZCBjaGVja2xpc3QgaXRlbSBmb3IgbW9uaXRvcmluZ1xuICAgKiBbQ29udGVudCBDaGFuZ2VzXShodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy9nb2xkLXN0YW5kYXJkL3dpa2kvQ29udGVudC1DaGFuZ2VzKS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBgXG4gICAqIGxldCBiYXNlID0gRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbihEaXN0cmlidXRlZENoaWxkcmVuTWl4aW4oSFRNTEVsZW1lbnQpKTtcbiAgICogY2xhc3MgQ291bnRpbmdFbGVtZW50IGV4dGVuZHMgYmFzZSB7XG4gICAqXG4gICAqICAgY29uc3RydWN0b3IoKSB7XG4gICAqICAgICBzdXBlcigpO1xuICAgKiAgICAgbGV0IHJvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICogICAgIHJvb3QuaW5uZXJIVE1MID0gYDxzbG90Pjwvc2xvdD5gO1xuICAgKiAgIH1cbiAgICpcbiAgICogICBjb250ZW50Q2hhbmdlZCgpIHtcbiAgICogICAgIC8vIENvdW50IHRoZSBjb21wb25lbnQncyBjaGlsZHJlbiwgYm90aCBpbml0aWFsbHkgYW5kIHdoZW4gY2hhbmdlZC5cbiAgICogICAgIHRoaXMuY291bnQgPSB0aGlzLmRpc3RyaWJ1dGVkQ2hpbGRyZW4ubGVuZ3RoO1xuICAgKiAgIH1cbiAgICpcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogTm90ZSB0aGF0IGNvbnRlbnQgY2hhbmdlIGRldGVjdGlvbiBkZXBlbmRzIHVwb24gdGhlIGVsZW1lbnQgaGF2aW5nIGF0IGxlYXN0XG4gICAqIG9uZSBgc2xvdGAgZWxlbWVudCBpbiBpdHMgc2hhZG93IHN1YnRyZWUuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gaXMgaW50ZW5kZWQgZm9yIHVzZSB3aXRoIHRoZVxuICAgKiBbRGlzdHJpYnV0ZWRDaGlsZHJlbk1peGluXShEaXN0cmlidXRlZENoaWxkcmVuTWl4aW4ubWQpLiBTZWUgdGhhdCBtaXhpbiBmb3JcbiAgICogYSBkaXNjdXNzaW9uIG9mIGhvdyB0aGF0IHdvcmtzLiBUaGlzIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW5cbiAgICogcHJvdmlkZXMgYW4gZWFzeSB3YXkgb2YgZGVmaW5pbmcgdGhlIFwiY29udGVudFwiIG9mIGEgY29tcG9uZW50IGFzIHRoZVxuICAgKiBjb21wb25lbnQncyBkaXN0cmlidXRlZCBjaGlsZHJlbi4gVGhhdCBpbiB0dXJuIGxldHMgbWl4aW5zIGxpa2VcbiAgICogW0NvbnRlbnRJdGVtc01peGluXShDb250ZW50SXRlbXNNaXhpbi5tZCkgbWFuaXB1bGF0ZSB0aGUgY2hpbGRyZW4gYXMgbGlzdFxuICAgKiBpdGVtcy5cbiAgICovXG4gIGNsYXNzIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50IGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG5cbiAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgLy8gTGlzdGVuIHRvIGNoYW5nZXMgb24gYWxsIHNsb3RzLlxuICAgICAgICBjb25zdCBzbG90cyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdzbG90Jyk7XG4gICAgICAgIHNsb3RzLmZvckVhY2goc2xvdCA9PiBzbG90LmFkZEV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCBldmVudCA9PiB7XG4gICAgICAgICAgdGhpcy5jb250ZW50Q2hhbmdlZCgpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2UgYW4gaW5pdGlhbCBjYWxsIHRvIGNvbnRlbnRDaGFuZ2VkKCkgc28gdGhhdCB0aGUgY29tcG9uZW50IGNhbiBkb1xuICAgICAgLy8gaW5pdGlhbGl6YXRpb24gdGhhdCBpdCBub3JtYWxseSBkb2VzIHdoZW4gY29udGVudCBjaGFuZ2VzLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgd2lsbCBpbnZva2UgY29udGVudENoYW5nZWQoKSBoYW5kbGVycyBpbiBvdGhlciBtaXhpbnMuIEluIG9yZGVyXG4gICAgICAvLyB0aGF0IHRob3NlIG1peGlucyBoYXZlIGEgY2hhbmNlIHRvIGNvbXBsZXRlIHRoZWlyIG93biBpbml0aWFsaXphdGlvbixcbiAgICAgIC8vIHdlIGFkZCB0aGUgY29udGVudENoYW5nZWQoKSBjYWxsIHRvIHRoZSBtaWNyb3Rhc2sgcXVldWUuXG4gICAgICBtaWNyb3Rhc2soKCkgPT4gdGhpcy5jb250ZW50Q2hhbmdlZCgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbnRlbnRzIG9mIHRoZSBjb21wb25lbnQgKGluY2x1ZGluZyBkaXN0cmlidXRlZFxuICAgICAqIGNoaWxkcmVuKSBoYXZlIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhbHNvIGludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyBmaXJzdCBpbnN0YW50aWF0ZWQ7IHRoZVxuICAgICAqIGNvbnRlbnRzIGhhdmUgZXNzZW50aWFsbHkgXCJjaGFuZ2VkXCIgZnJvbSBiZWluZyBub3RoaW5nLiBUaGlzIGFsbG93cyB0aGVcbiAgICAgKiBjb21wb25lbnQgdG8gcGVyZm9ybSBpbml0aWFsIHByb2Nlc3Npbmcgb2YgaXRzIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGNvbnRlbnRDaGFuZ2VkKCkge1xuICAgICAgaWYgKHN1cGVyLmNvbnRlbnRDaGFuZ2VkKSB7IHN1cGVyLmNvbnRlbnRDaGFuZ2VkKCk7IH1cbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjb250ZW50LWNoYW5nZWQnKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRlbnQgb2YgdGhpcyBjb21wb25lbnQsIGRlZmluZWQgdG8gYmUgdGhlIGZsYXR0ZW5lZCBhcnJheSBvZlxuICAgICAqIGNoaWxkcmVuIGRpc3RyaWJ1dGVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX1cbiAgICAgKi9cbiAgICBnZXQgY29udGVudCgpIHtcbiAgICAgIGNvbnN0IGRpc3RyaWJ1dGVkQ2hpbGRyZW4gPSB0aGlzLmRpc3RyaWJ1dGVkQ2hpbGRyZW47XG4gICAgICBpZiAodHlwZW9mIGRpc3RyaWJ1dGVkQ2hpbGRyZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbiBleHBlY3RzIHRoZSBjb21wb25lbnQgdG8gZGVmaW5lIGEgXCJkaXN0cmlidXRlZENoaWxkcmVuXCIgcHJvcGVydHkuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlzdHJpYnV0ZWRDaGlsZHJlbjtcbiAgICB9XG4gICAgc2V0IGNvbnRlbnQodmFsdWUpIHtcbiAgICAgIGlmICgnY29udGVudCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuY29udGVudCA9IHZhbHVlOyB9XG4gICAgICAvLyBUT0RPOiBTZXQgdGhlIGNoaWxkcmVuIHRvIHRoZSBnaXZlbiB2YWx1ZSAod2hpY2ggc2hvdWxkIGJlIGFuIGFycmF5IG9mXG4gICAgICAvLyBlbGVtZW50cyk/XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyByYWlzZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgY29udGVudHMgKGluY2x1ZGluZyBkaXN0cmlidXRlZFxuICAgICAqIGNoaWxkcmVuKSBoYXZlIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRcbiAgICAgKiBAZXZlbnQgY29udGVudC1jaGFuZ2VkXG4gICAgICovXG4gIH1cblxuICByZXR1cm4gRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnQ7XG59O1xuIiwiLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBEaXN0cmlidXRlZENoaWxkcmVuLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gd2hpY2ggZGVmaW5lcyBoZWxwZXJzIGZvciBhY2Nlc3NpbmcgYSBjb21wb25lbnQncyBkaXN0cmlidXRlZFxuICAgKiBjaGlsZHJlbiBhcyBhIGZsYXR0ZW5lZCBhcnJheSBvciBzdHJpbmcuXG4gICAqXG4gICAqIFRoZSBzdGFuZGFyZCBET00gQVBJIHByb3ZpZGVzIHNldmVyYWwgd2F5cyBvZiBhY2Nlc3NpbmcgY2hpbGQgY29udGVudDpcbiAgICogYGNoaWxkcmVuYCwgYGNoaWxkTm9kZXNgLCBhbmQgYHRleHRDb250ZW50YC4gTm9uZSBvZiB0aGVzZSBmdW5jdGlvbnMgYXJlXG4gICAqIFNoYWRvdyBET00gYXdhcmUuIFRoaXMgbWl4aW4gZGVmaW5lcyB2YXJpYXRpb25zIG9mIHRob3NlIGZ1bmN0aW9ucyB0aGF0XG4gICAqICphcmUqIFNoYWRvdyBET00gYXdhcmUuXG4gICAqXG4gICAqIEV4YW1wbGU6IHlvdSBjcmVhdGUgYSBjb21wb25lbnQgYDxjb3VudC1jaGlsZHJlbj5gIHRoYXQgZGlzcGxheXMgYSBudW1iZXJcbiAgICogZXF1YWwgdG8gdGhlIG51bWJlciBvZiBjaGlsZHJlbiBwbGFjZWQgaW5zaWRlIHRoYXQgY29tcG9uZW50LiBJZiBzb21lb25lXG4gICAqIGluc3RhbnRpYXRlcyB5b3VyIGNvbXBvbmVudCBsaWtlOlxuICAgKlxuICAgKiAgICAgPGNvdW50LWNoaWxkcmVuPlxuICAgKiAgICAgICA8ZGl2PjwvZGl2PlxuICAgKiAgICAgICA8ZGl2PjwvZGl2PlxuICAgKiAgICAgICA8ZGl2PjwvZGl2PlxuICAgKiAgICAgPC9jb3VudC1jaGlsZHJlbj5cbiAgICpcbiAgICogVGhlbiB0aGUgY29tcG9uZW50IHNob3VsZCBzaG93IFwiM1wiLCBiZWNhdXNlIHRoZXJlIGFyZSB0aHJlZSBjaGlsZHJlbi4gVG9cbiAgICogY2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4sIHRoZSBjb21wb25lbnQgY2FuIGp1c3QgY2FsY3VsYXRlXG4gICAqIGB0aGlzLmNoaWxkcmVuLmxlbmd0aGAuIEhvd2V2ZXIsIHN1cHBvc2Ugc29tZW9uZSBpbnN0YW50aWF0ZXMgeW91clxuICAgKiBjb21wb25lbnQgaW5zaWRlIG9uZSBvZiB0aGVpciBvd24gY29tcG9uZW50cywgYW5kIHB1dHMgYSBgPHNsb3Q+YCBlbGVtZW50XG4gICAqIGluc2lkZSB5b3VyIGNvbXBvbmVudDpcbiAgICpcbiAgICogICAgIDxjb3VudC1jaGlsZHJlbj5cbiAgICogICAgICAgPHNsb3Q+PC9zbG90PlxuICAgKiAgICAgPC9jb3VudC1jaGlsZHJlbj5cbiAgICpcbiAgICogSWYgeW91ciBjb21wb25lbnQgb25seSBsb29rcyBhdCBgdGhpcy5jaGlsZHJlbmAsIGl0IHdpbGwgYWx3YXlzIHNlZSBleGFjdGx5XG4gICAqIG9uZSBjaGlsZCDigJTCoHRoZSBgPHNsb3Q+YCBlbGVtZW50LiBCdXQgdGhlIHVzZXIgbG9va2luZyBhdCB0aGUgcGFnZSB3aWxsXG4gICAqICpzZWUqIGFueSBub2RlcyBkaXN0cmlidXRlZCB0byB0aGF0IHNsb3QuIFRvIG1hdGNoIHdoYXQgdGhlIHVzZXIgc2VlcywgeW91clxuICAgKiBjb21wb25lbnQgc2hvdWxkIGV4cGFuZCBhbnkgYDxzbG90PmAgZWxlbWVudHMgaXQgY29udGFpbnMuXG4gICAqXG4gICAqIFRoYXQgaXMgdGhlIHByb2JsZW0gdGhpcyBtaXhpbiBzb2x2ZXMuIEFmdGVyIGFwcGx5aW5nIHRoaXMgbWl4aW4sIHlvdXJcbiAgICogY29tcG9uZW50IGNvZGUgaGFzIGFjY2VzcyB0byBgdGhpcy5kaXN0cmlidXRlZENoaWxkcmVuYCwgd2hvc2UgYGxlbmd0aGBcbiAgICogd2lsbCByZXR1cm4gdGhlIHRvdGFsIG51bWJlciBvZiBhbGwgY2hpbGRyZW4gZGlzdHJpYnV0ZWQgdG8geW91ciBjb21wb25lbnRcbiAgICogaW4gdGhlIGNvbXBvc2VkIHRyZWUuXG4gICAqXG4gICAqIE5vdGU6IFRoZSBsYXRlc3QgQ3VzdG9tIEVsZW1lbnRzIEFQSSBkZXNpZ24gY2FsbHMgZm9yIGEgbmV3IGZ1bmN0aW9uLFxuICAgKiBgZ2V0QXNzaWduZWROb2Rlc2AgdGhhdCB0YWtlcyBhbiBvcHRpb25hbCBgZGVlcGAgcGFyYW1ldGVyLCB0aGF0IHdpbGwgc29sdmVcbiAgICogdGhpcyBwcm9ibGVtIGF0IHRoZSBBUEkgbGV2ZWwuXG4gICAqL1xuICBjbGFzcyBEaXN0cmlidXRlZENoaWxkcmVuIGV4dGVuZHMgYmFzZSB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbi1vcmRlciBjb2xsZWN0aW9uIG9mIGRpc3RyaWJ1dGVkIGNoaWxkcmVuLCBleHBhbmRpbmcgYW55IHNsb3RcbiAgICAgKiBlbGVtZW50cy4gTGlrZSB0aGUgc3RhbmRhcmQgY2hpbGRyZW4gcHJvcGVydHksIHRoaXMgc2tpcHMgdGV4dCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudFtdfVxuICAgICAqL1xuICAgIGdldCBkaXN0cmlidXRlZENoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIGV4cGFuZENvbnRlbnRFbGVtZW50cyh0aGlzLmNoaWxkcmVuLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gaW4tb3JkZXIgY29sbGVjdGlvbiBvZiBkaXN0cmlidXRlZCBjaGlsZCBub2RlcywgZXhwYW5kaW5nIGFueSBzbG90XG4gICAgICogZWxlbWVudHMuIExpa2UgdGhlIHN0YW5kYXJkIGNoaWxkTm9kZXMgcHJvcGVydHksIHRoaXMgaW5jbHVkZXMgdGV4dFxuICAgICAqIG5vZGVzLlxuICAgICAqXG4gICAgICogQHR5cGUge05vZGVbXX1cbiAgICAgKi9cbiAgICBnZXQgZGlzdHJpYnV0ZWRDaGlsZE5vZGVzKCkge1xuICAgICAgcmV0dXJuIGV4cGFuZENvbnRlbnRFbGVtZW50cyh0aGlzLmNoaWxkTm9kZXMsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25jYXRlbmF0ZWQgdGV4dCBjb250ZW50IG9mIGFsbCBkaXN0cmlidXRlZCBjaGlsZCBub2RlcywgZXhwYW5kaW5nXG4gICAgICogYW55IHNsb3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBkaXN0cmlidXRlZFRleHRDb250ZW50KCkge1xuICAgICAgY29uc3Qgc3RyaW5ncyA9IHRoaXMuZGlzdHJpYnV0ZWRDaGlsZE5vZGVzLm1hcChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQudGV4dENvbnRlbnQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdHJpbmdzLmpvaW4oJycpO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIERpc3RyaWJ1dGVkQ2hpbGRyZW47XG59O1xuXG5cbi8qXG4gKiBHaXZlbiBhIGFycmF5IG9mIG5vZGVzLCByZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCBhbnkgY29udGVudCBlbGVtZW50cyBleHBhbmRlZFxuICogdG8gdGhlIG5vZGVzIGRpc3RyaWJ1dGVkIHRvIHRoYXQgY29udGVudCBlbGVtZW50LiBUaGlzIHJ1bGUgaXMgYXBwbGllZFxuICogcmVjdXJzaXZlbHkuXG4gKlxuICogSWYgaW5jbHVkZVRleHROb2RlcyBpcyB0cnVlLCB0ZXh0IG5vZGVzIHdpbGwgYmUgaW5jbHVkZWQsIGFzIGluIHRoZVxuICogc3RhbmRhcmQgY2hpbGROb2RlcyBwcm9wZXJ0eTsgYnkgZGVmYXVsdCwgdGhpcyBza2lwcyB0ZXh0IG5vZGVzLCBsaWtlIHRoZVxuICogc3RhbmRhcmQgY2hpbGRyZW4gcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZENvbnRlbnRFbGVtZW50cyhub2RlcywgaW5jbHVkZVRleHROb2Rlcykge1xuICBjb25zdCBleHBhbmRlZCA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChub2Rlcywgbm9kZSA9PiB7XG4gICAgLy8gV2Ugd2FudCB0byBzZWUgaWYgdGhlIG5vZGUgaXMgYW4gaW5zdGFuY2VvZiBIVE1MU2xvdEVMZW1lbnQsIGJ1dFxuICAgIC8vIHRoYXQgY2xhc3Mgd29uJ3QgZXhpc3QgaWYgdGhlIGJyb3dzZXIgdGhhdCBkb2Vzbid0IHN1cHBvcnQgbmF0aXZlXG4gICAgLy8gU2hhZG93IERPTSBhbmQgaWYgdGhlIFNoYWRvdyBET00gcG9seWZpbGwgaGFzbid0IGJlZW4gbG9hZGVkLiBJbnN0ZWFkLFxuICAgIC8vIHdlIGRvIGEgc2ltcGxpc3RpYyBjaGVjayB0byBzZWUgaWYgdGhlIHRhZyBuYW1lIGlzIFwic2xvdFwiLlxuICAgIGNvbnN0IGlzU2xvdCA9IHR5cGVvZiBIVE1MU2xvdEVsZW1lbnQgIT09ICd1bmRlZmluZWQnID9cbiAgICAgIG5vZGUgaW5zdGFuY2VvZiBIVE1MU2xvdEVsZW1lbnQgOlxuICAgICAgbm9kZS5sb2NhbE5hbWUgPT09ICdzbG90JztcbiAgICBpZiAoaXNTbG90KSB7XG4gICAgICAvLyBVc2UgdGhlIG5vZGVzIGFzc2lnbmVkIHRvIHRoaXMgbm9kZSBpbnN0ZWFkLlxuICAgICAgY29uc3QgYXNzaWduZWROb2RlcyA9IG5vZGUuYXNzaWduZWROb2Rlcyh7IGZsYXR0ZW46IHRydWUgfSk7XG4gICAgICByZXR1cm4gYXNzaWduZWROb2RlcyA/XG4gICAgICAgIGV4cGFuZENvbnRlbnRFbGVtZW50cyhhc3NpZ25lZE5vZGVzLCBpbmNsdWRlVGV4dE5vZGVzKSA6XG4gICAgICAgIFtdO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAvLyBQbGFpbiBlbGVtZW50OyB1c2UgYXMgaXMuXG4gICAgICByZXR1cm4gW25vZGVdO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRleHQgJiYgaW5jbHVkZVRleHROb2Rlcykge1xuICAgICAgLy8gVGV4dCBub2RlLlxuICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29tbWVudCwgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiwgZXRjLjsgc2tpcC5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBmbGF0dGVuZWQgPSBbXS5jb25jYXQoLi4uZXhwYW5kZWQpO1xuICByZXR1cm4gZmxhdHRlbmVkO1xufVxuIiwiLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTaGFkb3dFbGVtZW50UmVmZXJlbmNlcy4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHRvIGNyZWF0ZSByZWZlcmVuY2VzIHRvIGVsZW1lbnRzIGluIGEgY29tcG9uZW50J3MgU2hhZG93IERPTSBzdWJ0cmVlLlxuICAgKlxuICAgKiBUaGlzIGFkZHMgYSBtZW1iZXIgb24gdGhlIGNvbXBvbmVudCBjYWxsZWQgYHRoaXMuJGAgdGhhdCBjYW4gYmUgdXNlZCB0b1xuICAgKiByZWZlcmVuY2Ugc2hhZG93IGVsZW1lbnRzIHdpdGggSURzLiBFLmcuLCBpZiBjb21wb25lbnQncyBzaGFkb3cgY29udGFpbnMgYW5cbiAgICogZWxlbWVudCBgPGJ1dHRvbiBpZD1cImZvb1wiPmAsIHRoZW4gdGhpcyBtaXhpbiB3aWxsIGNyZWF0ZSBhIG1lbWJlclxuICAgKiBgdGhpcy4kLmZvb2AgdGhhdCBwb2ludHMgdG8gdGhhdCBidXR0b24uXG4gICAqXG4gICAqIFN1Y2ggcmVmZXJlbmNlcyBzaW1wbGlmeSBhIGNvbXBvbmVudCdzIGFjY2VzcyB0byBpdHMgb3duIGVsZW1lbnRzLiBJblxuICAgKiBleGNoYW5nZSwgdGhpcyBtaXhpbiB0cmFkZXMgb2ZmIGEgb25lLXRpbWUgY29zdCBvZiBxdWVyeWluZyBhbGwgZWxlbWVudHMgaW5cbiAgICogdGhlIHNoYWRvdyB0cmVlIGluc3RlYWQgb2YgcGF5aW5nIGFuIG9uZ29pbmcgY29zdCB0byBxdWVyeSBmb3IgYW4gZWxlbWVudFxuICAgKiBlYWNoIHRpbWUgdGhlIGNvbXBvbmVudCB3YW50cyB0byBpbnNwZWN0IG9yIG1hbmlwdWxhdGUgaXQuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyB0aGUgY29tcG9uZW50IHRvIGRlZmluZSBhIFNoYWRvdyBET00gc3VidHJlZS4gWW91IGNhblxuICAgKiBjcmVhdGUgdGhhdCB0cmVlIHlvdXJzZWxmLCBvciBtYWtlIHVzZSBvZlxuICAgKiBbU2hhZG93VGVtcGxhdGVNaXhpbl0oU2hhZG93VGVtcGxhdGVNaXhpbi5tZCkuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gaXMgaW5zcGlyZWQgYnkgUG9seW1lcidzIFthdXRvbWF0aWNcbiAgICogbm9kZSBmaW5kaW5nXShodHRwczovL3d3dy5wb2x5bWVyLXByb2plY3Qub3JnLzEuMC9kb2NzL2Rldmd1aWRlL2xvY2FsLWRvbS5odG1sI25vZGUtZmluZGluZylcbiAgICogZmVhdHVyZS5cbiAgICovXG4gIGNsYXNzIFNoYWRvd0VsZW1lbnRSZWZlcmVuY2VzIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICBpZiAodGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIC8vIExvb2sgZm9yIGVsZW1lbnRzIGluIHRoZSBzaGFkb3cgc3VidHJlZSB0aGF0IGhhdmUgaWQgYXR0cmlidXRlcy5cbiAgICAgICAgLy8gQW4gYWx0ZXJuYXRpdmVseSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1peGluIHdvdWxkIGJlIHRvIGp1c3QgZGVmaW5lXG4gICAgICAgIC8vIGEgdGhpcy4kIGdldHRlciB0aGF0IGxhemlseSBkb2VzIHRoaXMgc2VhcmNoIHRoZSBmaXJzdCB0aW1lIHNvbWVvbmVcbiAgICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIHRoaXMuJC4gVGhhdCBtaWdodCBpbnRyb2R1Y2Ugc29tZSBjb21wbGV4aXR5IOKAkyBpZiB0aGVcbiAgICAgICAgLy8gdGhlIHRyZWUgY2hhbmdlZCBhZnRlciBpdCB3YXMgZmlyc3QgcG9wdWxhdGVkLCB0aGUgcmVzdWx0IG9mXG4gICAgICAgIC8vIHNlYXJjaGluZyBmb3IgYSBub2RlIG1pZ2h0IGJlIHNvbWV3aGF0IHVucHJlZGljdGFibGUuXG4gICAgICAgIHRoaXMuJCA9IHt9O1xuICAgICAgICBjb25zdCBub2Rlc1dpdGhJZHMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnW2lkXScpO1xuICAgICAgICBbXS5mb3JFYWNoLmNhbGwobm9kZXNXaXRoSWRzLCBub2RlID0+IHtcbiAgICAgICAgICBjb25zdCBpZCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgIHRoaXMuJFtpZF0gPSBub2RlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29sbGVjdGlvbiBvZiByZWZlcmVuY2VzIHRvIHRoZSBlbGVtZW50cyB3aXRoIElEcyBpbiBhIGNvbXBvbmVudCdzXG4gICAgICogU2hhZG93IERPTSBzdWJ0cmVlLlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAbWVtYmVyICRcbiAgICAgKi9cbiAgfVxuXG4gIHJldHVybiBTaGFkb3dFbGVtZW50UmVmZXJlbmNlcztcbn07XG4iLCJpbXBvcnQgc3ltYm9scyBmcm9tICcuLi9zcmMvc3ltYm9scyc7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTaGFkb3dUZW1wbGF0ZS4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIGZvciBzdGFtcGluZyBhIHRlbXBsYXRlIGludG8gYSBTaGFkb3cgRE9NIHN1YnRyZWUgdXBvbiBjb21wb25lbnRcbiAgICogaW5zdGFudGlhdGlvbi5cbiAgICpcbiAgICogVG8gdXNlIHRoaXMgbWl4aW4sIGRlZmluZSBhIGB0ZW1wbGF0ZWAgcHJvcGVydHkgYXMgYSBzdHJpbmcgb3IgSFRNTFxuICAgKiBgPHRlbXBsYXRlPmAgZWxlbWVudDpcbiAgICpcbiAgICogICAgIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIFNoYWRvd1RlbXBsYXRlTWl4aW4oSFRNTEVsZW1lbnQpIHtcbiAgICogICAgICAgZ2V0IFtzeW1ib2xzLnRlbXBsYXRlXSgpIHtcbiAgICogICAgICAgICByZXR1cm4gYEhlbGxvLCA8ZW0+d29ybGQ8L2VtPi5gO1xuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqXG4gICAqIFdoZW4geW91ciBjb21wb25lbnQgY2xhc3MgaXMgaW5zdGFudGlhdGVkLCBhIHNoYWRvdyByb290IHdpbGwgYmUgY3JlYXRlZCBvblxuICAgKiB0aGUgaW5zdGFuY2UsIGFuZCB0aGUgY29udGVudHMgb2YgdGhlIHRlbXBsYXRlIHdpbGwgYmUgY2xvbmVkIGludG8gdGhlXG4gICAqIHNoYWRvdyByb290LiBJZiB5b3VyIGNvbXBvbmVudCBkb2VzIG5vdCBkZWZpbmUgYSBgdGVtcGxhdGVgIHByb3BlcnR5LCB0aGlzXG4gICAqIG1peGluIGhhcyBubyBlZmZlY3QuXG4gICAqXG4gICAqIEZvciB0aGUgdGltZSBiZWluZywgdGhpcyBleHRlbnNpb24gcmV0YWlucyBzdXBwb3J0IGZvciBTaGFkb3cgRE9NIHYwLiBUaGF0XG4gICAqIHdpbGwgZXZlbnR1YWxseSBiZSBkZXByZWNhdGVkIGFzIGJyb3dzZXJzIChhbmQgdGhlIFNoYWRvdyBET00gcG9seWZpbGwpXG4gICAqIGltcGxlbWVudCBTaGFkb3cgRE9NIHYxLlxuICAgKi9cbiAgY2xhc3MgU2hhZG93VGVtcGxhdGUgZXh0ZW5kcyBiYXNlIHtcblxuICAgIC8qXG4gICAgICogSWYgdGhlIGNvbXBvbmVudCBkZWZpbmVzIGEgdGVtcGxhdGUsIGEgc2hhZG93IHJvb3Qgd2lsbCBiZSBjcmVhdGVkIG9uIHRoZVxuICAgICAqIGNvbXBvbmVudCBpbnN0YW5jZSwgYW5kIHRoZSB0ZW1wbGF0ZSBzdGFtcGVkIGludG8gaXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgbGV0IHRlbXBsYXRlID0gdGhpc1tzeW1ib2xzLnRlbXBsYXRlXTtcbiAgICAgIC8vIFRPRE86IFNhdmUgdGhlIHByb2Nlc3NlZCB0ZW1wbGF0ZSB3aXRoIHRoZSBjb21wb25lbnQncyBjbGFzcyBwcm90b3R5cGVcbiAgICAgIC8vIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBwcm9jZXNzZWQgd2l0aCBldmVyeSBpbnN0YW50aWF0aW9uLlxuICAgICAgaWYgKHRlbXBsYXRlKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBVcGdyYWRlIHBsYWluIHN0cmluZyB0byByZWFsIHRlbXBsYXRlLlxuICAgICAgICAgIHRlbXBsYXRlID0gY3JlYXRlVGVtcGxhdGVXaXRoSW5uZXJIVE1MKHRlbXBsYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwpIHtcbiAgICAgICAgICBzaGltVGVtcGxhdGVTdHlsZXModGVtcGxhdGUsIHRoaXMubG9jYWxOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBkb2N1bWVudC5pbXBvcnROb2RlKHRlbXBsYXRlLmNvbnRlbnQsIHRydWUpO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBTaGFkb3dUZW1wbGF0ZTtcbn07XG5cblxuLy8gQ29udmVydCBhIHBsYWluIHN0cmluZyBvZiBIVE1MIGludG8gYSByZWFsIHRlbXBsYXRlIGVsZW1lbnQuXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZVdpdGhJbm5lckhUTUwoaW5uZXJIVE1MKSB7XG4gIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgLy8gUkVWSUVXOiBJcyB0aGVyZSBhbiBlYXNpZXIgd2F5IHRvIGRvIHRoaXM/XG4gIC8vIFdlJ2QgbGlrZSB0byBqdXN0IHNldCBpbm5lckhUTUwgb24gdGhlIHRlbXBsYXRlIGNvbnRlbnQsIGJ1dCBzaW5jZSBpdCdzXG4gIC8vIGEgRG9jdW1lbnRGcmFnbWVudCwgdGhhdCBkb2Vzbid0IHdvcmsuXG4gIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuICB3aGlsZSAoZGl2LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgIHRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZGl2LmNoaWxkTm9kZXNbMF0pO1xuICB9XG4gIHJldHVybiB0ZW1wbGF0ZTtcbn1cblxuLy8gSW52b2tlIGJhc2ljIHN0eWxlIHNoaW1taW5nIHdpdGggU2hhZG93Q1NTLlxuZnVuY3Rpb24gc2hpbVRlbXBsYXRlU3R5bGVzKHRlbXBsYXRlLCB0YWcpIHtcbiAgd2luZG93LldlYkNvbXBvbmVudHMuU2hhZG93Q1NTLnNoaW1TdHlsaW5nKHRlbXBsYXRlLmNvbnRlbnQsIHRhZyk7XG59XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IGNhblNlbGVjdE5leHRTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2NhblNlbGVjdE5leHQnKTtcbmNvbnN0IGNhblNlbGVjdFByZXZpb3VzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdjYW5TZWxlY3RQcmV2aW91cycpO1xuY29uc3Qgc2VsZWN0aW9uUmVxdWlyZWRTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3NlbGVjdGlvblJlcXVpcmVkJyk7XG5jb25zdCBzZWxlY3Rpb25XcmFwc1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnc2VsZWN0aW9uV3JhcHMnKTtcblxuLy8gV2Ugd2FudCB0byBleHBvc2UgYm90aCBzZWxlY3RlZEluZGV4IGFuZCBzZWxlY3RlZEl0ZW0gYXMgaW5kZXBlbmRlbnRcbi8vIHByb3BlcnRpZXMgYnV0IGtlZXAgdGhlbSBpbiBzeW5jLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB1c2VyIHRvIHJlZmVyZW5jZVxuLy8gdGhlIHNlbGVjdGlvbiBieSB3aGF0ZXZlciBtZWFucyBpcyBtb3N0IG5hdHVyYWwgZm9yIHRoZWlyIHNpdHVhdGlvbi5cbi8vXG4vLyBUbyBlZmZpY2llbnRseSBrZWVwIHRoZXNlIHByb3BlcnRpZXMgaW4gc3luYywgd2UgdHJhY2sgXCJleHRlcm5hbFwiIGFuZFxuLy8gXCJpbnRlcm5hbFwiIHJlZmVyZW5jZXMgZm9yIGVhY2ggcHJvcGVydHk6XG4vL1xuLy8gVGhlIGV4dGVybmFsIGluZGV4IG9yIGl0ZW0gaXMgdGhlIG9uZSB3ZSByZXBvcnQgdG8gdGhlIG91dHNpZGUgd29ybGQgd2hlblxuLy8gYXNrZWQgZm9yIHNlbGVjdGlvbi4gIFdoZW4gaGFuZGxpbmcgYSBjaGFuZ2UgdG8gaW5kZXggb3IgaXRlbSwgd2UgdXBkYXRlIHRoZVxuLy8gZXh0ZXJuYWwgcmVmZXJlbmNlIGFzIHNvb24gYXMgcG9zc2libGUsIHNvIHRoYXQgaWYgYW55b25lIGltbWVkaWF0ZWx5IGFza3Ncbi8vIGZvciB0aGUgY3VycmVudCBzZWxlY3Rpb24sIHRoZXkgd2lsbCByZWNlaXZlIGEgc3RhYmxlIGFuc3dlci5cbi8vXG4vLyBUaGUgaW50ZXJuYWwgaW5kZXggb3IgaXRlbSB0cmFja3Mgd2hpY2hldmVyIGluZGV4IG9yIGl0ZW0gbGFzdCByZWNlaXZlZCB0aGVcbi8vIGZ1bGwgc2V0IG9mIHByb2Nlc3NpbmcuIFByb2Nlc3NpbmcgaW5jbHVkZXMgcmFpc2luZyBhIGNoYW5nZSBldmVudCBmb3IgdGhlXG4vLyBuZXcgdmFsdWUuIE9uY2Ugd2UndmUgYmVndW4gdGhhdCBwcm9jZXNzaW5nLCB3ZSBzdG9yZSB0aGUgbmV3IHZhbHVlIGFzIHRoZVxuLy8gaW50ZXJuYWwgdmFsdWUgdG8gaW5kaWNhdGUgd2UndmUgaGFuZGxlZCBpdC5cbi8vXG5jb25zdCBleHRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2V4dGVybmFsU2VsZWN0ZWRJbmRleCcpO1xuY29uc3QgZXh0ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2V4dGVybmFsU2VsZWN0ZWRJdGVtJyk7XG5jb25zdCBpbnRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2ludGVybmFsU2VsZWN0ZWRJbmRleCcpO1xuY29uc3QgaW50ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2ludGVybmFsU2VsZWN0ZWRJdGVtJyk7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTaW5nbGVTZWxlY3Rpb24uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYW5hZ2VzIHNpbmdsZS1zZWxlY3Rpb24gc2VtYW50aWNzIGZvciBpdGVtcyBpbiBhIGxpc3QuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyBhIGNvbXBvbmVudCB0byBwcm92aWRlIGFuIGBpdGVtc2AgQXJyYXkgb3IgTm9kZUxpc3Qgb2ZcbiAgICogYWxsIGVsZW1lbnRzIGluIHRoZSBsaXN0LiBBIHN0YW5kYXJkIHdheSB0byBkbyB0aGF0IHdpdGggaXMgdGhlXG4gICAqIFtDb250ZW50SXRlbXNNaXhpbl0oQ29udGVudEl0ZW1zTWl4aW4ubWQpLCB3aGljaCB0YWtlcyBhIGNvbXBvbmVudCdzXG4gICAqIGNvbnRlbnQgKHR5cGljYWxseSBpdHMgZGlzdHJpYnV0ZWQgY2hpbGRyZW4pIGFzIHRoZSBzZXQgb2YgbGlzdCBpdGVtczsgc2VlXG4gICAqIHRoYXQgbWl4aW4gZm9yIGRldGFpbHMuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gdHJhY2tzIGEgc2luZ2xlIHNlbGVjdGVkIGl0ZW0gaW4gdGhlIGxpc3QsIGFuZCBwcm92aWRlcyBtZWFucyB0b1xuICAgKiBnZXQgYW5kIHNldCB0aGF0IHN0YXRlIGJ5IGl0ZW0gcG9zaXRpb24gKGBzZWxlY3RlZEluZGV4YCkgb3IgaXRlbSBpZGVudGl0eVxuICAgKiAoYHNlbGVjdGVkSXRlbWApLiBUaGUgc2VsZWN0aW9uIGNhbiBiZSBtb3ZlZCBpbiB0aGUgbGlzdCB2aWEgdGhlIG1ldGhvZHNcbiAgICogYHNlbGVjdEZpcnN0YCwgYHNlbGVjdExhc3RgLCBgc2VsZWN0TmV4dGAsIGFuZCBgc2VsZWN0UHJldmlvdXNgLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGRvZXMgbm90IHByb2R1Y2UgYW55IHVzZXItdmlzaWJsZSBlZmZlY3RzIHRvIHJlcHJlc2VudFxuICAgKiBzZWxlY3Rpb24uIE90aGVyIG1peGlucywgc3VjaCBhc1xuICAgKiBbU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluXShTZWxlY3Rpb25BcmlhQWN0aXZlTWl4aW4ubWQpLFxuICAgKiBbU2VsZWN0aW9uSGlnaGxpZ2h0TWl4aW5dKFNlbGVjdGlvbkhpZ2hsaWdodE1peGluLm1kKSBhbmRcbiAgICogW1NlbGVjdGlvbkluVmlld01peGluXShTZWxlY3Rpb25JblZpZXdNaXhpbi5tZCksIG1vZGlmeSB0aGUgc2VsZWN0ZWQgaXRlbVxuICAgKiBpbiBjb21tb24gd2F5cyB0byBsZXQgdGhlIHVzZXIga25vdyBhIGdpdmVuIGl0ZW0gaXMgc2VsZWN0ZWQgb3Igbm90XG4gICAqIHNlbGVjdGVkLlxuICAgKi9cbiAgY2xhc3MgU2luZ2xlU2VsZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICAvLyBTZXQgZGVmYXVsdHMuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2VsZWN0aW9uUmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmVxdWlyZWQgPSB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnNlbGVjdGlvblJlcXVpcmVkO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlbGVjdGlvbldyYXBzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbldyYXBzID0gdGhpc1tzeW1ib2xzLmRlZmF1bHRzXS5zZWxlY3Rpb25XcmFwcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBzZWxlY3Rpb24gY2FuIGJlIG1vdmVkIHRvIHRoZSBuZXh0IGl0ZW0sIGZhbHNlIGlmIG5vdCAodGhlXG4gICAgICogc2VsZWN0ZWQgaXRlbSBpcyB0aGUgbGFzdCBpdGVtIGluIHRoZSBsaXN0KS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjYW5TZWxlY3ROZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbY2FuU2VsZWN0TmV4dFN5bWJvbF07XG4gICAgfVxuICAgIHNldCBjYW5TZWxlY3ROZXh0KGNhblNlbGVjdE5leHQpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ2FuU2VsZWN0TmV4dCA9IHRoaXNbY2FuU2VsZWN0TmV4dFN5bWJvbF07XG4gICAgICB0aGlzW2NhblNlbGVjdE5leHRTeW1ib2xdID0gY2FuU2VsZWN0TmV4dDtcbiAgICAgIGlmICgnY2FuU2VsZWN0TmV4dCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuY2FuU2VsZWN0TmV4dCA9IGNhblNlbGVjdE5leHQ7IH1cbiAgICAgIGlmIChjYW5TZWxlY3ROZXh0ICE9PSBwcmV2aW91c0NhblNlbGVjdE5leHQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY2FuLXNlbGVjdC1uZXh0LWNoYW5nZWQnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGNhbiBiZSBtb3ZlZCB0byB0aGUgcHJldmlvdXMgaXRlbSwgZmFsc2UgaWYgbm90XG4gICAgICogKHRoZSBzZWxlY3RlZCBpdGVtIGlzIHRoZSBmaXJzdCBvbmUgaW4gdGhlIGxpc3QpLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNhblNlbGVjdFByZXZpb3VzKCkge1xuICAgICAgcmV0dXJuIHRoaXNbY2FuU2VsZWN0UHJldmlvdXNTeW1ib2xdO1xuICAgIH1cbiAgICBzZXQgY2FuU2VsZWN0UHJldmlvdXMoY2FuU2VsZWN0UHJldmlvdXMpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ2FuU2VsZWN0UHJldmlvdXMgPSB0aGlzW2NhblNlbGVjdFByZXZpb3VzU3ltYm9sXTtcbiAgICAgIHRoaXNbY2FuU2VsZWN0UHJldmlvdXNTeW1ib2xdID0gY2FuU2VsZWN0UHJldmlvdXM7XG4gICAgICBpZiAoJ2NhblNlbGVjdFByZXZpb3VzJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5jYW5TZWxlY3RQcmV2aW91cyA9IGNhblNlbGVjdFByZXZpb3VzOyB9XG4gICAgICBpZiAoY2FuU2VsZWN0UHJldmlvdXMgIT09IHByZXZpb3VzQ2FuU2VsZWN0UHJldmlvdXMpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY2FuLXNlbGVjdC1wcmV2aW91cy1jaGFuZ2VkJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMuc2VsZWN0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgIGRlZmF1bHRzLnNlbGVjdGlvbldyYXBzID0gZmFsc2U7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEgbmV3IGl0ZW0gYmVpbmcgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBzaW1wbHkgc2V0cyB0aGUgaXRlbSdzXG4gICAgICogc2VsZWN0aW9uIHN0YXRlIHRvIGZhbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaXRlbSAtIHRoZSBpdGVtIGJlaW5nIGFkZGVkXG4gICAgICovXG4gICAgW3N5bWJvbHMuaXRlbUFkZGVkXShpdGVtKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtQWRkZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbUFkZGVkXShpdGVtKTsgfVxuICAgICAgdGhpc1tzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgaXRlbSA9PT0gdGhpcy5zZWxlY3RlZEl0ZW0pO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtc0NoYW5nZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpOyB9XG5cbiAgICAgIC8vIEluIGNhc2Ugc2VsZWN0ZWQgaXRlbSBjaGFuZ2VkIHBvc2l0aW9uIG9yIHdhcyByZW1vdmVkLlxuICAgICAgdHJhY2tTZWxlY3RlZEl0ZW0odGhpcyk7XG5cbiAgICAgIC8vIEluIGNhc2UgdGhlIGNoYW5nZSBpbiBpdGVtcyBhZmZlY3RlZCB3aGljaCBuYXZpZ2F0aW9ucyBhcmUgcG9zc2libGUuXG4gICAgICB1cGRhdGVQb3NzaWJsZU5hdmlnYXRpb25zKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBpbmRpY2F0ZSBzZWxlY3Rpb24gc3RhdGUgdG8gdGhlIGl0ZW0uXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuIFVzZXItdmlzaWJsZVxuICAgICAqIGVmZmVjdHMgd2lsbCB0eXBpY2FsbHkgYmUgaGFuZGxlZCBieSBvdGhlciBtaXhpbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIC0gdGhlIGl0ZW0gYmVpbmcgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgLSB0cnVlIGlmIHRoZSBpdGVtIGlzIHNlbGVjdGVkLCBmYWxzZSBpZiBub3RcbiAgICAgKi9cbiAgICBbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIHNlbGVjdGVkKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gd2hpY2ggaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQSBgc2VsZWN0ZWRJbmRleGAgb2YgLTEgaW5kaWNhdGVzIHRoZXJlIGlzIG5vIHNlbGVjdGlvbi4gU2V0dGluZyB0aGlzXG4gICAgICogcHJvcGVydHkgdG8gLTEgd2lsbCByZW1vdmUgYW55IGV4aXN0aW5nIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkSW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpc1tleHRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdICE9IG51bGwgP1xuICAgICAgICB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJbmRleFN5bWJvbF0gOlxuICAgICAgICAtMTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICAgIC8vIFNlZSBub3RlcyBhdCB0b3AgYWJvdXQgaW50ZXJuYWwgdnMuIGV4dGVybmFsIGNvcGllcyBvZiB0aGlzIHByb3BlcnR5LlxuICAgICAgY29uc3QgcHJldmlvdXNTZWxlY3RlZEluZGV4ID0gdGhpc1tpbnRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdO1xuICAgICAgbGV0IGl0ZW07XG4gICAgICBpZiAoaW5kZXggIT09IHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sXSkge1xuICAgICAgICAvLyBTdG9yZSB0aGUgbmV3IGluZGV4IGFuZCB0aGUgY29ycmVzcG9uZGluZyBpdGVtLlxuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIGNvbnN0IGhhc0l0ZW1zID0gaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKCEoaGFzSXRlbXMgJiYgaW5kZXggPj0gMCAmJiBpbmRleCA8IGl0ZW1zLmxlbmd0aCkpIHtcbiAgICAgICAgICBpbmRleCA9IC0xOyAvLyBObyBpdGVtIGF0IHRoYXQgaW5kZXguXG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tleHRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdID0gaW5kZXg7XG4gICAgICAgIGl0ZW0gPSBoYXNJdGVtcyAmJiBpbmRleCA+PSAwID8gaXRlbXNbaW5kZXhdIDogbnVsbDtcbiAgICAgICAgdGhpc1tleHRlcm5hbFNlbGVjdGVkSXRlbVN5bWJvbF0gPSBpdGVtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbSA9IHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2xdO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3cgbGV0IHN1cGVyIGRvIGFueSB3b3JrLlxuICAgICAgaWYgKCdzZWxlY3RlZEluZGV4JyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3RlZEluZGV4ID0gaW5kZXg7IH1cblxuICAgICAgaWYgKGluZGV4ICE9PSBwcmV2aW91c1NlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdGVkIGluZGV4IGNoYW5nZWQuXG4gICAgICAgIHRoaXNbaW50ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sXSA9IGluZGV4O1xuXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzZWxlY3RlZC1pbmRleC1jaGFuZ2VkJywge1xuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleDogaW5kZXgsXG4gICAgICAgICAgICB2YWx1ZTogaW5kZXggLy8gZm9yIFBvbHltZXIgYmluZGluZy4gVE9ETzogVmVyaWZ5IHN0aWxsIG5lY2Vzc2FyeVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2ludGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sXSAhPT0gaXRlbSkge1xuICAgICAgICAvLyBVcGRhdGUgc2VsZWN0ZWRJdGVtIHByb3BlcnR5IHNvIGl0IGNhbiBoYXZlIGl0cyBvd24gZWZmZWN0cy5cbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSwgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gbnVsbCBkZXNlbGVjdHMgYW55IGN1cnJlbnRseS1zZWxlY3RlZCBpdGVtLlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB0byBhbiBvYmplY3QgdGhhdCBpcyBub3QgaW4gdGhlIGxpc3QgaGFzIG5vIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIFRPRE86IEV2ZW4gaWYgc2VsZWN0aW9uUmVxdWlyZWQsIGNhbiBzdGlsbCBleHBsaWNpdGx5IHNldCBzZWxlY3RlZEl0ZW0gdG8gbnVsbC5cbiAgICAgKiBUT0RPOiBJZiBzZWxlY3Rpb25SZXF1aXJlZCwgbGVhdmUgc2VsZWN0aW9uIGFsb25lP1xuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWRJdGVtKCkge1xuICAgICAgcmV0dXJuIHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2xdIHx8IG51bGw7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEl0ZW0oaXRlbSkge1xuICAgICAgLy8gU2VlIG5vdGVzIGF0IHRvcCBhYm91dCBpbnRlcm5hbCB2cy4gZXh0ZXJuYWwgY29waWVzIG9mIHRoaXMgcHJvcGVydHkuXG4gICAgICBjb25zdCBwcmV2aW91c1NlbGVjdGVkSXRlbSA9IHRoaXNbaW50ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2xdO1xuICAgICAgbGV0IGluZGV4O1xuICAgICAgaWYgKGl0ZW0gIT09IHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2xdKSB7XG4gICAgICAgIC8vIFN0b3JlIGl0ZW0gYW5kIGxvb2sgdXAgY29ycmVzcG9uZGluZyBpbmRleC5cbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICBjb25zdCBoYXNJdGVtcyA9IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDA7XG4gICAgICAgIGluZGV4ID0gaGFzSXRlbXMgPyBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGl0ZW1zLCBpdGVtKSA6IC0xO1xuICAgICAgICB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJbmRleFN5bWJvbF0gPSBpbmRleDtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGl0ZW0gPSBudWxsOyAvLyBUaGUgaW5kaWNhdGVkIGl0ZW0gaXNuJ3QgYWN0dWFsbHkgaW4gYGl0ZW1zYC5cbiAgICAgICAgfVxuICAgICAgICB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sXSA9IGl0ZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sXTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93IGxldCBzdXBlciBkbyBhbnkgd29yay5cbiAgICAgIGlmICgnc2VsZWN0ZWRJdGVtJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3RlZEl0ZW0gPSBpdGVtOyB9XG5cbiAgICAgIGlmIChpdGVtICE9PSBwcmV2aW91c1NlbGVjdGVkSXRlbSkge1xuICAgICAgICAvLyBUaGUgc2VsZWN0ZWQgaXRlbSBjaGFuZ2VkLlxuICAgICAgICB0aGlzW2ludGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sXSA9IGl0ZW07XG5cbiAgICAgICAgaWYgKHByZXZpb3VzU2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHNlbGVjdGlvbiBzdGF0ZSBvZiBvbGQgaXRlbS5cbiAgICAgICAgICB0aGlzW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShwcmV2aW91c1NlbGVjdGVkSXRlbSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHNlbGVjdGlvbiBzdGF0ZSB0byBuZXcgaXRlbS5cbiAgICAgICAgICB0aGlzW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZVBvc3NpYmxlTmF2aWdhdGlvbnModGhpcyk7XG5cbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3NlbGVjdGVkLWl0ZW0tY2hhbmdlZCcsIHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIHNlbGVjdGVkSXRlbTogaXRlbSxcbiAgICAgICAgICAgIHZhbHVlOiBpdGVtIC8vIGZvciBQb2x5bWVyIGJpbmRpbmdcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tpbnRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdICE9PSBpbmRleCkge1xuICAgICAgICAvLyBVcGRhdGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eSBzbyBpdCBjYW4gaGF2ZSBpdHMgb3duIGVmZmVjdHMuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBzZWxlY3RGaXJzdCgpIHtcbiAgICAgIGlmIChzdXBlci5zZWxlY3RGaXJzdCkgeyBzdXBlci5zZWxlY3RGaXJzdCgpOyB9XG4gICAgICByZXR1cm4gc2VsZWN0SW5kZXgodGhpcywgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgbGlzdCBzaG91bGQgYWx3YXlzIGhhdmUgYSBzZWxlY3Rpb24gKGlmIGl0IGhhcyBpdGVtcykuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25SZXF1aXJlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzW3NlbGVjdGlvblJlcXVpcmVkU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGlvblJlcXVpcmVkKHNlbGVjdGlvblJlcXVpcmVkKSB7XG4gICAgICB0aGlzW3NlbGVjdGlvblJlcXVpcmVkU3ltYm9sXSA9IHNlbGVjdGlvblJlcXVpcmVkO1xuICAgICAgaWYgKCdzZWxlY3Rpb25SZXF1aXJlZCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0aW9uUmVxdWlyZWQgPSBzZWxlY3Rpb25SZXF1aXJlZDsgfVxuICAgICAgdHJhY2tTZWxlY3RlZEl0ZW0odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBzZWxlY3Rpb24gbmF2aWdhdGlvbnMgd3JhcCBmcm9tIGxhc3QgdG8gZmlyc3QsIGFuZCB2aWNlIHZlcnNhLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uV3JhcHMoKSB7XG4gICAgICByZXR1cm4gdGhpc1tzZWxlY3Rpb25XcmFwc1N5bWJvbF07XG4gICAgfVxuICAgIHNldCBzZWxlY3Rpb25XcmFwcyh2YWx1ZSkge1xuICAgICAgdGhpc1tzZWxlY3Rpb25XcmFwc1N5bWJvbF0gPSBTdHJpbmcodmFsdWUpID09PSAndHJ1ZSc7XG4gICAgICBpZiAoJ3NlbGVjdGlvbldyYXBzJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3Rpb25XcmFwcyA9IHZhbHVlOyB9XG4gICAgICB1cGRhdGVQb3NzaWJsZU5hdmlnYXRpb25zKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgbGFzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIHNlbGVjdExhc3QoKSB7XG4gICAgICBpZiAoc3VwZXIuc2VsZWN0TGFzdCkgeyBzdXBlci5zZWxlY3RMYXN0KCk7IH1cbiAgICAgIHJldHVybiBzZWxlY3RJbmRleCh0aGlzLCB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgbmV4dCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIHNlbGVjdE5leHQoKSB7XG4gICAgICBpZiAoc3VwZXIuc2VsZWN0TmV4dCkgeyBzdXBlci5zZWxlY3ROZXh0KCk7IH1cbiAgICAgIHJldHVybiBzZWxlY3RJbmRleCh0aGlzLCB0aGlzLnNlbGVjdGVkSW5kZXggKyAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIHByZXZpb3VzIGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgbGlzdCBoYXMgbm8gc2VsZWN0aW9uLCB0aGUgbGFzdCBpdGVtIHdpbGwgYmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgc2VsZWN0UHJldmlvdXMoKSB7XG4gICAgICBpZiAoc3VwZXIuc2VsZWN0UHJldmlvdXMpIHsgc3VwZXIuc2VsZWN0UHJldmlvdXMoKTsgfVxuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXggPCAwID9cbiAgICAgICAgdGhpcy5pdGVtcy5sZW5ndGggLSAxIDogICAgIC8vIE5vIHNlbGVjdGlvbiB5ZXQ7IHNlbGVjdCBsYXN0IGl0ZW0uXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCAtIDE7XG4gICAgICByZXR1cm4gc2VsZWN0SW5kZXgodGhpcywgbmV3SW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHNlbGVjdGVkSXRlbSBwcm9wZXJ0eSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFNpbmdsZVNlbGVjdGlvblxuICAgICAqIEBldmVudCBzZWxlY3RlZC1pdGVtLWNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkZXRhaWwuc2VsZWN0ZWRJdGVtIFRoZSBuZXcgc2VsZWN0ZWQgaXRlbS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkZXRhaWwucHJldmlvdXNJdGVtIFRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIGl0ZW0uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgU2luZ2xlU2VsZWN0aW9uXG4gICAgICogQGV2ZW50IHNlbGVjdGVkLWluZGV4LWNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGV0YWlsLnNlbGVjdGVkSW5kZXggVGhlIG5ldyBzZWxlY3RlZCBpbmRleC5cbiAgICAgKi9cblxuICB9XG5cbiAgcmV0dXJuIFNpbmdsZVNlbGVjdGlvbjtcbn07XG5cblxuLy8gRW5zdXJlIHRoZSBnaXZlbiBpbmRleCBpcyB3aXRoaW4gYm91bmRzLCBhbmQgc2VsZWN0IGl0IGlmIGl0J3Mgbm90IGFscmVhZHlcbi8vIHNlbGVjdGVkLlxuZnVuY3Rpb24gc2VsZWN0SW5kZXgoZWxlbWVudCwgaW5kZXgpIHtcbiAgY29uc3QgY291bnQgPSBlbGVtZW50Lml0ZW1zLmxlbmd0aDtcblxuICBjb25zdCBib3VuZGVkSW5kZXggPSAoZWxlbWVudC5zZWxlY3Rpb25XcmFwcykgP1xuICAgIC8vIEphdmFTY3JpcHQgbW9kIGRvZXNuJ3QgaGFuZGxlIG5lZ2F0aXZlIG51bWJlcnMgdGhlIHdheSB3ZSB3YW50IHRvIHdyYXAuXG4gICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE4NjE4MjUwLzc2NDcyXG4gICAgKChpbmRleCAlIGNvdW50KSArIGNvdW50KSAlIGNvdW50IDpcblxuICAgIC8vIEtlZXAgaW5kZXggd2l0aGluIGJvdW5kcyBvZiBhcnJheS5cbiAgICBNYXRoLm1heChNYXRoLm1pbihpbmRleCwgY291bnQgLSAxKSwgMCk7XG5cbiAgY29uc3QgcHJldmlvdXNJbmRleCA9IGVsZW1lbnQuc2VsZWN0ZWRJbmRleDtcbiAgaWYgKHByZXZpb3VzSW5kZXggIT09IGJvdW5kZWRJbmRleCkge1xuICAgIGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA9IGJvdW5kZWRJbmRleDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gRm9sbG93aW5nIGEgY2hhbmdlIGluIHRoZSBzZXQgb2YgaXRlbXMsIG9yIGluIHRoZSB2YWx1ZSBvZiB0aGVcbi8vIGBzZWxlY3Rpb25SZXF1aXJlZGAgcHJvcGVydHksIHJlYWNxdWlyZSB0aGUgc2VsZWN0ZWQgaXRlbS4gSWYgaXQncyBtb3ZlZCxcbi8vIHVwZGF0ZSBgc2VsZWN0ZWRJbmRleGAuIElmIGl0J3MgYmVlbiByZW1vdmVkLCBhbmQgYSBzZWxlY3Rpb24gaXMgcmVxdWlyZWQsXG4vLyB0cnkgdG8gc2VsZWN0IGFub3RoZXIgaXRlbS5cbmZ1bmN0aW9uIHRyYWNrU2VsZWN0ZWRJdGVtKGVsZW1lbnQpIHtcblxuICBjb25zdCBpdGVtcyA9IGVsZW1lbnQuaXRlbXM7XG4gIGNvbnN0IGl0ZW1Db3VudCA9IGl0ZW1zID8gaXRlbXMubGVuZ3RoIDogMDtcblxuICBjb25zdCBwcmV2aW91c1NlbGVjdGVkSXRlbSA9IGVsZW1lbnQuc2VsZWN0ZWRJdGVtO1xuICBpZiAoIXByZXZpb3VzU2VsZWN0ZWRJdGVtKSB7XG4gICAgLy8gTm8gaXRlbSB3YXMgcHJldmlvdXNseSBzZWxlY3RlZC5cbiAgICBpZiAoZWxlbWVudC5zZWxlY3Rpb25SZXF1aXJlZCkge1xuICAgICAgLy8gU2VsZWN0IHRoZSBmaXJzdCBpdGVtIGJ5IGRlZmF1bHQuXG4gICAgICBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSAwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVtQ291bnQgPT09IDApIHtcbiAgICAvLyBXZSd2ZSBsb3N0IHRoZSBzZWxlY3Rpb24sIGFuZCB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBzZWxlY3QuXG4gICAgZWxlbWVudC5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIFRyeSB0byBmaW5kIHRoZSBwcmV2aW91c2x5LXNlbGVjdGVkIGl0ZW0gaW4gdGhlIGN1cnJlbnQgc2V0IG9mIGl0ZW1zLlxuICAgIGNvbnN0IGluZGV4SW5DdXJyZW50SXRlbXMgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGl0ZW1zLCBwcmV2aW91c1NlbGVjdGVkSXRlbSk7XG4gICAgY29uc3QgcHJldmlvdXNTZWxlY3RlZEluZGV4ID0gZWxlbWVudC5zZWxlY3RlZEluZGV4O1xuICAgIGlmIChpbmRleEluQ3VycmVudEl0ZW1zIDwgMCkge1xuICAgICAgLy8gUHJldmlvdXNseS1zZWxlY3RlZCBpdGVtIHdhcyByZW1vdmVkIGZyb20gdGhlIGl0ZW1zLlxuICAgICAgLy8gU2VsZWN0IHRoZSBpdGVtIGF0IHRoZSBzYW1lIGluZGV4IChpZiBpdCBleGlzdHMpIG9yIGFzIGNsb3NlIGFzIHBvc3NpYmxlLlxuICAgICAgY29uc3QgbmV3U2VsZWN0ZWRJbmRleCA9IE1hdGgubWluKHByZXZpb3VzU2VsZWN0ZWRJbmRleCwgaXRlbUNvdW50IC0gMSk7XG4gICAgICAvLyBTZWxlY3QgYnkgaXRlbSwgc2luY2UgaW5kZXggbWF5IGJlIHRoZSBzYW1lLCBhbmQgd2Ugd2FudCB0byByYWlzZSB0aGVcbiAgICAgIC8vIHNlbGVjdGVkLWl0ZW0tY2hhbmdlZCBldmVudC5cbiAgICAgIGVsZW1lbnQuc2VsZWN0ZWRJdGVtID0gaXRlbXNbbmV3U2VsZWN0ZWRJbmRleF07XG4gICAgfSBlbHNlIGlmIChpbmRleEluQ3VycmVudEl0ZW1zICE9PSBwcmV2aW91c1NlbGVjdGVkSW5kZXgpIHtcbiAgICAgIC8vIFByZXZpb3VzbHktc2VsZWN0ZWQgaXRlbSBzdGlsbCB0aGVyZSwgYnV0IGNoYW5nZWQgcG9zaXRpb24uXG4gICAgICBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSBpbmRleEluQ3VycmVudEl0ZW1zO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGb2xsb3dpbmcgYSBjaGFuZ2UgaW4gc2VsZWN0aW9uLCByZXBvcnQgd2hldGhlciBpdCdzIG5vdyBwb3NzaWJsZSB0b1xuLy8gZ28gbmV4dC9wcmV2aW91cyBmcm9tIHRoZSBnaXZlbiBpbmRleC5cbmZ1bmN0aW9uIHVwZGF0ZVBvc3NpYmxlTmF2aWdhdGlvbnMoZWxlbWVudCkge1xuICBsZXQgY2FuU2VsZWN0TmV4dDtcbiAgbGV0IGNhblNlbGVjdFByZXZpb3VzO1xuICBjb25zdCBpdGVtcyA9IGVsZW1lbnQuaXRlbXM7XG4gIGlmIChpdGVtcyA9PSBudWxsIHx8IGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIE5vIGl0ZW1zIHRvIHNlbGVjdC5cbiAgICBjYW5TZWxlY3ROZXh0ID0gZmFsc2U7XG4gICAgY2FuU2VsZWN0UHJldmlvdXMgPSBmYWxzZTtcbiAgfSBpZiAoZWxlbWVudC5zZWxlY3Rpb25XcmFwcykge1xuICAgIC8vIFNpbmNlIHRoZXJlIGFyZSBpdGVtcywgY2FuIGFsd2F5cyBnbyBuZXh0L3ByZXZpb3VzLlxuICAgIGNhblNlbGVjdE5leHQgPSB0cnVlO1xuICAgIGNhblNlbGVjdFByZXZpb3VzID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpbmRleCA9IGVsZW1lbnQuc2VsZWN0ZWRJbmRleDtcbiAgICBpZiAoaW5kZXggPCAwICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZS4gSWYgdGhlcmUgYXJlIGl0ZW1zIGJ1dCBubyBzZWxlY3Rpb24sIGRlY2xhcmUgdGhhdCBpdCdzXG4gICAgICAvLyBhbHdheXMgcG9zc2libGUgdG8gZ28gbmV4dC9wcmV2aW91cyB0byBjcmVhdGUgYSBzZWxlY3Rpb24uXG4gICAgICBjYW5TZWxlY3ROZXh0ID0gdHJ1ZTtcbiAgICAgIGNhblNlbGVjdFByZXZpb3VzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9ybWFsIGNhc2U6IHdlIGhhdmUgYW4gaW5kZXggaW4gYSBsaXN0IHRoYXQgaGFzIGl0ZW1zLlxuICAgICAgY2FuU2VsZWN0UHJldmlvdXMgPSAoaW5kZXggPiAwKTtcbiAgICAgIGNhblNlbGVjdE5leHQgPSAoaW5kZXggPCBpdGVtcy5sZW5ndGggLSAxKTtcbiAgICB9XG4gIH1cbiAgaWYgKGVsZW1lbnQuY2FuU2VsZWN0TmV4dCAhPT0gY2FuU2VsZWN0TmV4dCkge1xuICAgIGVsZW1lbnQuY2FuU2VsZWN0TmV4dCA9IGNhblNlbGVjdE5leHQ7XG4gIH1cbiAgaWYgKGVsZW1lbnQuY2FuU2VsZWN0UHJldmlvdXMgIT09IGNhblNlbGVjdFByZXZpb3VzKSB7XG4gICAgZWxlbWVudC5jYW5TZWxlY3RQcmV2aW91cyA9IGNhblNlbGVjdFByZXZpb3VzO1xuICB9XG59XG4iLCIvKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzeW1ib2wgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYXNzb2NpYXRpbmcgcHJpdmF0ZVxuICogZGF0YSB3aXRoIGFuIGVsZW1lbnQuXG4gKlxuICogTWl4aW5zIGFuZCBjb21wb25lbnQgY2xhc3NlcyBvZnRlbiB3YW50IHRvIGFzc29jaWF0ZSBwcml2YXRlIGRhdGEgd2l0aCBhblxuICogZWxlbWVudCBpbnN0YW5jZSwgYnV0IEphdmFTY3JpcHQgZG9lcyBub3QgaGF2ZSBkaXJlY3Qgc3VwcG9ydCBmb3IgdHJ1ZVxuICogcHJpdmF0ZSBwcm9wZXJ0aWVzLiBPbmUgYXBwcm9hY2ggaXMgdG8gdXNlIHRoZVxuICogW1N5bWJvbF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3ltYm9sKVxuICogZGF0YSB0eXBlIHRvIHNldCBhbmQgcmV0cmlldmUgZGF0YSBvbiBhbiBlbGVtZW50LlxuICpcbiAqIFVuZm9ydHVuYXRlbHksIHRoZSBTeW1ib2wgdHlwZSBpcyBub3QgYXZhaWxhYmxlIGluIEludGVybmV0IEV4cGxvcmVyIDExLiBUaGVcbiAqIGBjcmVhdGVTeW1ib2xgIGhlbHBlciBmdW5jdGlvbiBleGlzdHMgYXMgYSB3b3JrYXJvdW5kIGZvciBJRSAxMS4gUmF0aGVyIHRoYW5cbiAqIHJldHVybmluZyBhIHRydWUgU3ltYm9sLCBpdCBzaW1wbHkgcmV0dXJucyBhbiB1bmRlcnNjb3JlLXByZWZpeGVkIHN0cmluZy5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgICAgY29uc3QgZm9vU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdmb28nKTtcbiAqXG4gKiAgICAgY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICogICAgICAgZ2V0IGZvbygpIHtcbiAqICAgICAgICAgcmV0dXJuIHRoaXNbZm9vU3ltYm9sXTtcbiAqICAgICAgIH1cbiAqICAgICAgIHNldCBmb28odmFsdWUpIHtcbiAqICAgICAgICAgdGhpc1tmb29TeW1ib2xdID0gdmFsdWU7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIEluIElFIDExLCB0aGlzIHNhbXBsZSB3aWxsIFwiaGlkZVwiIGRhdGEgYmVoaW5kIGFuIGluc3RhbmNlIHByb3BlcnR5IHRoaXMuX2Zvby5cbiAqIFRoZSB1c2Ugb2YgdGhlIHVuZGVyc2NvcmUgaXMgbWVhbnQgdG8gcmVkdWNlIChub3QgZWxpbWluYXRlKSB0aGUgcG90ZW50aWFsXG4gKiBmb3IgbmFtZSBjb25mbGljdHMsIGFuZCBkaXNjb3VyYWdlIChub3QgcHJldmVudCkgZXh0ZXJuYWwgYWNjZXNzIHRvIHRoaXNcbiAqIGRhdGEuIEluIG1vZGVybiBicm93c2VycywgdGhlIGFib3ZlIGNvZGUgd2lsbCBlbGltaW5hdGUgdGhlIHBvdGVudGlhbCBvZlxuICogbmFtaW5nIGNvbmZsaWN0cywgYW5kIGJldHRlciBoaWRlIHRoZSBkYXRhIGJlaGluZCBhIHJlYWwgU3ltYm9sLlxuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVTeW1ib2xcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgc3RyaW5nIHRvIGlkZW50aWZ5IHRoZSBzeW1ib2wgd2hlbiBkZWJ1Z2dpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nID9cbiAgICBTeW1ib2woZGVzY3JpcHRpb24pIDpcbiAgICBgXyR7ZGVzY3JpcHRpb259YDtcbn1cbiIsIi8qXG4gKiBNaWNyb3Rhc2sgaGVscGVyIGZvciBJRSAxMS5cbiAqXG4gKiBFeGVjdXRpbmcgYSBmdW5jdGlvbiBhcyBhIG1pY3JvdGFzayBpcyB0cml2aWFsIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydFxuICogcHJvbWlzZXMsIHdob3NlIHRoZW4oKSBjbGF1c2VzIHVzZSBtaWNyb3Rhc2sgdGltaW5nLiBJRSAxMSBkb2Vzbid0IHN1cHBvcnRcbiAqIHByb21pc2VzLCBidXQgZG9lcyBzdXBwb3J0IE11dGF0aW9uT2JzZXJ2ZXJzLCB3aGljaCBhcmUgYWxzbyBleGVjdXRlZCBhc1xuICogbWljcm90YXNrcy4gU28gdGhpcyBoZWxwZXIgdXNlcyBhbiBNdXRhdGlvbk9ic2VydmVyIHRvIGFjaGlldmUgbWljcm90YXNrXG4gKiB0aW1pbmcuXG4gKlxuICogU2VlIGh0dHBzOi8vamFrZWFyY2hpYmFsZC5jb20vMjAxNS90YXNrcy1taWNyb3Rhc2tzLXF1ZXVlcy1hbmQtc2NoZWR1bGVzL1xuICpcbiAqIEluc3BpcmVkIGJ5IFBvbHltZXIncyBhc3luYygpIGZ1bmN0aW9uLlxuICovXG5cblxuLy8gVGhlIHF1ZXVlIG9mIHBlbmRpbmcgY2FsbGJhY2tzIHRvIGJlIGV4ZWN1dGVkIGFzIG1pY3JvdGFza3MuXG5jb25zdCBjYWxsYmFja3MgPSBbXTtcblxuLy8gQ3JlYXRlIGFuIGVsZW1lbnQgdGhhdCB3ZSB3aWxsIG1vZGlmeSB0byBmb3JjZSBvYnNlcnZhYmxlIG11dGF0aW9ucy5cbmNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG5cbi8vIEEgbW9ub3RvbmljYWxseS1pbmNyZWFzaW5nIHZhbHVlLlxubGV0IGNvdW50ZXIgPSAwO1xuXG5cbi8qKlxuICogQWRkIGEgY2FsbGJhY2sgdG8gdGhlIG1pY3JvdGFzayBxdWV1ZS5cbiAqXG4gKiBUaGlzIHVzZXMgYSBNdXRhdGlvbk9ic2VydmVyIHNvIHRoYXQgaXQgd29ya3Mgb24gSUUgMTEuXG4gKlxuICogTk9URTogSUUgMTEgbWF5IGFjdHVhbGx5IHVzZSB0aW1lb3V0IHRpbWluZyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJzLiBUaGlzXG4gKiBuZWVkcyBtb3JlIGludmVzdGlnYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uIG1pY3JvdGFza1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWljcm90YXNrKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgLy8gRm9yY2UgYSBtdXRhdGlvbi5cbiAgZWxlbWVudC50ZXh0Q29udGVudCA9ICsrY291bnRlcjtcbn1cblxuXG4vLyBFeGVjdXRlIGFueSBwZW5kaW5nIGNhbGxiYWNrcy5cbmZ1bmN0aW9uIGV4ZWN1dGVDYWxsYmFja3MoKSB7XG4gIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzLnNoaWZ0KCk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG5cbi8vIENyZWF0ZSB0aGUgb2JzZXJ2ZXIuXG5jb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGV4ZWN1dGVDYWxsYmFja3MpO1xub2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gIGNoYXJhY3RlckRhdGE6IHRydWVcbn0pO1xuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuL2NyZWF0ZVN5bWJvbCc7XG5pbXBvcnQgdG9nZ2xlQ2xhc3MgZnJvbSAnLi90b2dnbGVDbGFzcyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IHNhZmVUb1NldEF0dHJpYnV0ZXNTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3NhZmVUb1NldEF0dHJpYnV0ZXMnKTtcbmNvbnN0IHBlbmRpbmdBdHRyaWJ1dGVzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdwZW5kaW5nQXR0cmlidXRlcycpO1xuY29uc3QgcGVuZGluZ0NsYXNzZXNTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3BlbmRpbmdDbGFzc2VzJyk7XG5cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciB1cGRhdGluZyBhdHRyaWJ1dGVzLCBpbmNsdWRpbmcgdGhlIGBjbGFzc2AgYXR0cmlidXRlLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYW55IHBlbmRpbmcgdXBkYXRlcyB0byBhdHRyaWJ1dGVzIGFuZCBjbGFzc2VzLlxuICAgKlxuICAgKiBUaGlzIHdyaXRlcyBhbnkgYHNldEF0dHJpYnV0ZWAgb3IgYHRvZ2dsZUNsYXNzYCB2YWx1ZXMgdGhhdCB3ZXJlIHBlcmZvcm1lZFxuICAgKiBiZWZvcmUgYW4gZWxlbWVudCB3YXMgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50IGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBieSBtaXhpbnMvY29tcG9uZW50cyBpbiB0aGVpclxuICAgKiBgY29ubmVjdGVkQ2FsbGJhY2tgLiBJZiBtdWxpdHBsZSBtaXhpbnMvY29tcG9uZW50cyBpbnZva2UgdGhpcyBkdXJpbmcgdGhlXG4gICAqIHNhbWUgYGNvbm5lY3RlZENhbGxiYWNrYCwgb25seSB0aGUgZmlyc3QgY2FsbCB3aWxsIGhhdmUgYW55IGVmZmVjdC4gVGhlXG4gICAqIHN1YnNlcXVlbnQgY2FsbHMgd2lsbCBiZSBoYXJtbGVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGJlaW5nIGFkZGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICovXG4gIGNvbm5lY3RlZChlbGVtZW50KSB7XG4gICAgZWxlbWVudFtzYWZlVG9TZXRBdHRyaWJ1dGVzU3ltYm9sXSA9IHRydWU7XG5cbiAgICAvLyBTZXQgYW55IHBlbmRpbmcgYXR0cmlidXRlcy5cbiAgICBpZiAoZWxlbWVudFtwZW5kaW5nQXR0cmlidXRlc1N5bWJvbF0pIHtcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBlbGVtZW50W3BlbmRpbmdBdHRyaWJ1dGVzU3ltYm9sXSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGVsZW1lbnRbcGVuZGluZ0F0dHJpYnV0ZXNTeW1ib2xdW2F0dHJpYnV0ZV07XG4gICAgICAgIHNldEF0dHJpYnV0ZVRvRWxlbWVudChlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRbcGVuZGluZ0F0dHJpYnV0ZXNTeW1ib2xdID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZXQgYW55IHBlbmRpbmcgY2xhc3Nlcy5cbiAgICBpZiAoZWxlbWVudFtwZW5kaW5nQ2xhc3Nlc1N5bWJvbF0pIHtcbiAgICAgIGZvciAobGV0IGNsYXNzTmFtZSBpbiBlbGVtZW50W3BlbmRpbmdDbGFzc2VzU3ltYm9sXSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGVsZW1lbnRbcGVuZGluZ0NsYXNzZXNTeW1ib2xdW2NsYXNzTmFtZV07XG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxlbWVudFtwZW5kaW5nQ2xhc3Nlc1N5bWJvbF0gPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0L3Vuc2V0IHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgaW5kaWNhdGVkIG5hbWUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGV4aXN0cyBwcmltYXJpbHkgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFuIGVsZW1lbnQgd2FudHMgdG9cbiAgICogc2V0IGEgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZSB0aGF0IHNob3VsZCBiZSByZWZsZWN0ZWQgYXMgYW4gYXR0cmlidXRlLiBBblxuICAgKiBpbXBvcnRhbnQgbGltaXRhdGlvbiBvZiBjdXN0b20gZWxlbWVudCBjb25zdHVyY3RvcnMgaXMgdGhhdCB0aGV5IGNhbm5vdFxuICAgKiBzZXQgYXR0cmlidXRlcy4gQSBjYWxsIHRvIGBzZXRBdHRyaWJ1dGVgIGR1cmluZyB0aGUgY29uc3RydWN0b3Igd2lsbFxuICAgKiBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgZWxlbWVudCBpcyBjb25uZWN0ZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIC0gVGhlIG5hbWUgb2YgdGhlICphdHRyaWJ1dGUqIChub3QgcHJvcGVydHkpIHRvIHNldC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldC4gSWYgbnVsbCwgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHJlbW92ZWQuXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGlmIChlbGVtZW50W3NhZmVUb1NldEF0dHJpYnV0ZXNTeW1ib2xdKSB7XG4gICAgICAvLyBTYWZlIHRvIHNldCBhdHRyaWJ1dGVzIGltbWVkaWF0ZWx5LlxuICAgICAgc2V0QXR0cmlidXRlVG9FbGVtZW50KGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZlciBzZXR0aW5nIGF0dHJpYnV0ZXMgdW50aWwgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGVkLlxuICAgICAgaWYgKCFlbGVtZW50W3BlbmRpbmdBdHRyaWJ1dGVzU3ltYm9sXSkge1xuICAgICAgICBlbGVtZW50W3BlbmRpbmdBdHRyaWJ1dGVzU3ltYm9sXSA9IHt9O1xuICAgICAgfVxuICAgICAgZWxlbWVudFtwZW5kaW5nQXR0cmlidXRlc1N5bWJvbF1bYXR0cmlidXRlXSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0L3Vuc2V0IHRoZSBjbGFzcyB3aXRoIHRoZSBpbmRpY2F0ZWQgbmFtZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZXhpc3RzIHByaW1hcmlseSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYW4gZWxlbWVudCB3YW50cyB0b1xuICAgKiBzZXQgYSBkZWZhdWx0IHByb3BlcnR5IHZhbHVlIHRoYXQgc2hvdWxkIGJlIHJlZmxlY3RlZCBhcyBhcyBjbGFzcy4gQW5cbiAgICogaW1wb3J0YW50IGxpbWl0YXRpb24gb2YgY3VzdG9tIGVsZW1lbnQgY29uc3R1cmN0b3JzIGlzIHRoYXQgdGhleSBjYW5ub3RcbiAgICogc2V0IGF0dHJpYnV0ZXMsIGluY2x1ZGluZyB0aGUgYGNsYXNzYCBhdHRyaWJ1dGUuIEEgY2FsbCB0b1xuICAgKiBgdG9nZ2xlQ2xhc3NgIGR1cmluZyB0aGUgY29uc3RydWN0b3Igd2lsbCBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgZWxlbWVudFxuICAgKiBpcyBjb25uZWN0ZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNsYXNzIHRvIHNldC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlIC0gVHJ1ZSB0byBzZXQgdGhlIGNsYXNzLCBmYWxzZSB0byByZW1vdmUgaXQuXG4gICAqL1xuICB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGVsZW1lbnRbc2FmZVRvU2V0QXR0cmlidXRlc1N5bWJvbF0pIHtcbiAgICAgIC8vIFNhZmUgdG8gc2V0IGNsYXNzIGltbWVkaWF0ZWx5LlxuICAgICAgdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZmVyIHNldHRpbmcgY2xhc3MgdW50aWwgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGVkLlxuICAgICAgaWYgKCFlbGVtZW50W3BlbmRpbmdDbGFzc2VzU3ltYm9sXSkge1xuICAgICAgICBlbGVtZW50W3BlbmRpbmdDbGFzc2VzU3ltYm9sXSA9IHt9O1xuICAgICAgfVxuICAgICAgZWxlbWVudFtwZW5kaW5nQ2xhc3Nlc1N5bWJvbF1bY2xhc3NOYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG59O1xuXG5cbi8vIFJlZmxlY3QgdGhlIGF0dHJpYnV0ZSB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cbi8vIElmIHRoZSB2YWx1ZSBpcyBudWxsLCByZW1vdmUgdGhlIGF0dHJpYnV0ZS5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZVRvRWxlbWVudChlbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRleHQgPSBTdHJpbmcodmFsdWUpO1xuICAgIC8vIEF2b2lkIHJlY3Vyc2l2ZSBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgY2FsbHMuXG4gICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpICE9PSB0ZXh0KSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgU3ltYm9sIG9iamVjdHMgZm9yIHN0YW5kYXJkIGNvbXBvbmVudCBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICpcbiAqIFRoZXNlIFN5bWJvbCBvYmplY3RzIGFyZSB1c2VkIHRvIGFsbG93IG1peGlucyBhbmQgYSBjb21wb25lbnQgdG8gaW50ZXJuYWxseVxuICogY29tbXVuaWNhdGUsIHdpdGhvdXQgZXhwb3NpbmcgdGhlc2UgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGUgY29tcG9uZW50J3NcbiAqIHB1YmxpYyBBUEkuXG4gKlxuICogVG8gdXNlIHRoZXNlIFN5bWJvbCBvYmplY3RzIGluIHlvdXIgb3duIGNvbXBvbmVudCwgaW5jbHVkZSB0aGlzIG1vZHVsZSBhbmRcbiAqIHRoZW4gY3JlYXRlIGEgcHJvcGVydHkgb3IgbWV0aG9kIHdob3NlIGtleSBpcyB0aGUgZGVzaXJlZCBTeW1ib2wuXG4gKlxuICogICAgIGltcG9ydCAnU2luZ2xlU2VsZWN0aW9uTWl4aW4nIGZyb20gJ2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NpbmdsZVNlbGVjdGlvbk1peGluJztcbiAqICAgICBpbXBvcnQgJ3N5bWJvbHMnIGZyb20gJ2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3N5bWJvbHMnO1xuICpcbiAqICAgICBjbGFzcyBNeUVsZW1lbnQgZXh0ZW5kcyBTaW5nbGVTZWxlY3Rpb25NaXhpbihIVE1MRWxlbWVudCkge1xuICogICAgICAgW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCkge1xuICogICAgICAgICAvLyBUaGlzIHdpbGwgYmUgaW52b2tlZCB3aGVuZXZlciBhbiBpdGVtIGlzIHNlbGVjdGVkL2Rlc2VsZWN0ZWQuXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIEBtb2R1bGUgc3ltYm9sc1xuICovXG5jb25zdCBzeW1ib2xzID0ge1xuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgZGVmYXVsdHNgIHByb3BlcnR5LlxuICAgKlxuICAgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIHNldCBvciBvdmVycmlkZSBkZWZhdWx0cyB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICAgKiB0byBhIG5ldyBjb21wb25lbnQgaW5zdGFuY2UuIFdoZW4gaW1wbGVtZW50aW5nIHRoaXMgcHJvcGVydHksIHRha2UgY2FyZSB0b1xuICAgKiBmaXJzdCBhY3F1aXJlIGFueSBkZWZhdWx0cyBkZWZpbmVkIGJ5IHRoZSBzdXBlcmNsYXNzLiBUaGUgc3RhbmRhcmQgaWRpb20gaXNcbiAgICogYXMgZm9sbG93czpcbiAgICpcbiAgICogICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAqICAgICAgIGNvbnN0IGRlZmF1bHRzID0gc3VwZXJbc3ltYm9scy5kZWZhdWx0c10gfHwge307XG4gICAqICAgICAgIC8vIFNldCBvciBvdmVycmlkZSBkZWZhdWx0IHZhbHVlcyBoZXJlXG4gICAqICAgICAgIGRlZmF1bHRzLmN1c3RvbVByb3BlcnR5ID0gZmFsc2U7XG4gICAqICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICogICAgIH1cbiAgICpcbiAgICogQHZhciB7b2JqZWN0fSBkZWZhdWx0c1xuICAgKi9cbiAgZGVmYXVsdHM6IGNyZWF0ZVN5bWJvbCgnZGVmYXVsdHMnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGRyYWdnaW5nYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQ29tcG9uZW50cyBsaWtlIGNhcm91c2VscyBvZnRlbiBkZWZpbmUgYW5pbWF0ZWQgQ1NTIHRyYW5zaXRpb25zIGZvclxuICAgKiBzbGlkaW5nIGVmZmVjdHMuIFN1Y2ggYSB0cmFuc2l0aW9uIHNob3VsZCB1c3VhbGx5ICpub3QqIGJlIGFwcGxpZWQgd2hpbGVcbiAgICogdGhlIHVzZXIgaXMgZHJhZ2dpbmcsIGJlY2F1c2UgYSBDU1MgYW5pbWF0aW9uIHdpbGwgaW50cm9kdWNlIGEgbGFnIHRoYXRcbiAgICogbWFrZXMgdGhlIHN3aXBlIGZlZWwgc2x1Z2dpc2guIEluc3RlYWQsIGFzIGxvbmcgYXMgdGhlIHVzZXIgaXMgZHJhZ2dpbmdcbiAgICogd2l0aCB0aGVpciBmaW5nZXIgZG93biwgdGhlIHRyYW5zaXRpb24gc2hvdWxkIGJlIHN1cHByZXNzZWQuIFdoZW4gdGhlXG4gICAqIHVzZXIgcmVsZWFzZXMgdGhlaXIgZmluZ2VyLCB0aGUgdHJhbnNpdGlvbiBjYW4gYmUgcmVzdG9yZWQsIGFsbG93aW5nIHRoZVxuICAgKiBhbmltYXRpb24gdG8gc2hvdyB0aGUgY2Fyb3VzZWwgc2xpZGluZyBpbnRvIGl0cyBmaW5hbCBwb3NpdGlvbi5cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59IHRydWUgaWYgYSBkcmFnIGlzIGluIHByb2dyZXNzLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBkcmFnZ2luZzogY3JlYXRlU3ltYm9sKCdkcmFnZ2luZycpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgZ29Eb3duYCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSBkb3duLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gZ29Eb3duXG4gICAqL1xuICBnb0Rvd246IGNyZWF0ZVN5bWJvbCgnZ29Eb3duJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBnb0VuZGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgdG8gdGhlIGVuZCAoZS5nLixcbiAgICogb2YgYSBsaXN0KS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGdvRW5kXG4gICAqL1xuICBnb0VuZDogY3JlYXRlU3ltYm9sKCdnb0VuZCcpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgZ29MZWZ0YCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSBsZWZ0LlxuICAgKlxuICAgKiBAZnVuY3Rpb24gZ29MZWZ0XG4gICAqL1xuICBnb0xlZnQ6IGNyZWF0ZVN5bWJvbCgnZ29MZWZ0JyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBnb1JpZ2h0YCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSByaWdodC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGdvUmlnaHRcbiAgICovXG4gIGdvUmlnaHQ6IGNyZWF0ZVN5bWJvbCgnZ29SaWdodCcpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgZ29TdGFydGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgdG8gdGhlIHN0YXJ0XG4gICAqIChlLmcuLCBvZiBhIGxpc3QpLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gZ29TdGFydFxuICAgKi9cbiAgZ29TdGFydDogY3JlYXRlU3ltYm9sKCdnb1N0YXJ0JyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBnb1VwYCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSB1cC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGdvVXBcbiAgICovXG4gIGdvVXA6IGNyZWF0ZVN5bWJvbCgnZ29VcCcpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgaXRlbUFkZGVkYCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiBhIG5ldyBpdGVtIGlzIGFkZGVkIHRvIGEgbGlzdC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGl0ZW1BZGRlZFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIC0gdGhlIGl0ZW0gYmVpbmcgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICAgKi9cbiAgaXRlbUFkZGVkOiBjcmVhdGVTeW1ib2woJ2l0ZW1BZGRlZCcpLFxuXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBpdGVtc0NoYW5nZWRgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIHRoZSB1bmRlcmx5aW5nIGNvbnRlbnRzIGNoYW5nZS4gSXQgaXMgYWxzb1xuICAgKiBpbnZva2VkIG9uIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbiDigJMgc2luY2UgdGhlIGl0ZW1zIGhhdmUgXCJjaGFuZ2VkXCIgZnJvbVxuICAgKiBiZWluZyBub3RoaW5nLlxuICAgKi9cbiAgaXRlbXNDaGFuZ2VkOiBjcmVhdGVTeW1ib2woJ2l0ZW1zQ2hhbmdlZCcpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgaXRlbVNlbGVjdGVkYCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiBhbiBpdGVtIGJlY29tZXMgc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGl0ZW1TZWxlY3RlZFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIC0gdGhlIGl0ZW0gYmVpbmcgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkIC0gdHJ1ZSBpZiB0aGUgaXRlbSBpcyBzZWxlY3RlZCwgZmFsc2UgaWYgbm90XG4gICAqL1xuICBpdGVtU2VsZWN0ZWQ6IGNyZWF0ZVN5bWJvbCgnaXRlbVNlbGVjdGVkJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBrZXlkb3duYCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiBhbiBlbGVtZW50IHJlY2VpdmVzIGEgYGtleWRvd25gIGV2ZW50LlxuICAgKlxuICAgKiBAZnVuY3Rpb24ga2V5ZG93blxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IGJlaW5nIHByb2Nlc3NlZFxuICAgKi9cbiAga2V5ZG93bjogY3JlYXRlU3ltYm9sKCdrZXlkb3duJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGB0ZW1wbGF0ZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIFRoaXMgcHJvcGVydHkgcmV0dXJucyBhIGNvbXBvbmVudCdzIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfEhUTUxFbGVtZW50fVxuICAgKi9cbiAgdGVtcGxhdGU6IGNyZWF0ZVN5bWJvbCgndGVtcGxhdGUnKVxufTtcblxuZXhwb3J0IGRlZmF1bHQgc3ltYm9scztcbiIsIi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBzdGFuZGFyZCBjbGFzc0xpc3QudG9nZ2xlKCkgYmVoYXZpb3Igb24gb2xkIGJyb3dzZXJzLFxuICogbmFtZWx5IElFIDExLlxuICpcbiAqIFRoZSBzdGFuZGFyZFxuICogW2NsYXNzbGlzdF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xhc3NMaXN0KVxuICogb2JqZWN0IGhhcyBhIGB0b2dnbGUoKWAgZnVuY3Rpb24gdGhhdCBzdXBwb3J0cyBhIHNlY29uZCBCb29sZWFuIHBhcmFtZXRlclxuICogdGhhdCBjYW4gYmUgdXNlZCB0byBzdWNjaW5jdGx5IHR1cm4gYSBjbGFzcyBvbiBvciBvZmYuIFRoaXMgZmVhdHVyZSBpcyBvZnRlblxuICogdXNlZnVsIGluIGRlc2lnbmluZyBjdXN0b20gZWxlbWVudHMsIHdoaWNoIG1heSB3YW50IHRvIGV4dGVybmFsbHkgcmVmbGVjdFxuICogY29tcG9uZW50IHN0YXRlIGluIGEgQ1NTIGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHN0eWxpbmcgcHVycG9zZXMuXG4gKlxuICogVW5mb3J0dW5hdGVseSwgSUUgMTEgZG9lcyBub3Qgc3VwcG9ydCB0aGUgQm9vbGVhbiBwYXJhbWV0ZXIgdG9cbiAqIGBjbGFzc0xpc3QudG9nZ2xlKClgLiBUaGlzIGhlbHBlciBmdW5jdGlvbiBiZWhhdmVzIGxpa2UgdGhlIHN0YW5kYXJkXG4gKiBgdG9nZ2xlKClgLCBpbmNsdWRpbmcgc3VwcG9ydCBmb3IgdGhlIEJvb2xlYW4gcGFyYW1ldGVyLCBzbyB0aGF0IGl0IGNhbiBiZVxuICogdXNlZCBldmVuIG9uIElFIDExLlxuICpcbiAqIEBmdW5jdGlvbiB0b2dnbGVDbGFzc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIG1vZGlmeVxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAtIFRoZSBjbGFzcyB0byBhZGQvcmVtb3ZlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZV0gLSBGb3JjZSB0aGUgY2xhc3MgdG8gYmUgYWRkZWQgKGlmIHRydWUpIG9yIHJlbW92ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpZiBmYWxzZSlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCBmb3JjZSkge1xuICBjb25zdCBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcbiAgY29uc3QgYWRkQ2xhc3MgPSAodHlwZW9mIGZvcmNlID09PSAndW5kZWZpbmVkJykgP1xuICAgICFjbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSA6XG4gICAgZm9yY2U7XG4gIGlmIChhZGRDbGFzcykge1xuICAgIGNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBjbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH1cbiAgcmV0dXJuIGFkZENsYXNzO1xufVxuIiwiaW1wb3J0IEF0dHJpYnV0ZU1hcnNoYWxsaW5nTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQXR0cmlidXRlTWFyc2hhbGxpbmdNaXhpbic7XG5pbXBvcnQgQ29tcG9zYWJsZU1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0NvbXBvc2FibGVNaXhpbic7XG5pbXBvcnQgRGlzdHJpYnV0ZWRDaGlsZHJlbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0Rpc3RyaWJ1dGVkQ2hpbGRyZW5NaXhpbic7XG5pbXBvcnQgU2hhZG93RWxlbWVudFJlZmVyZW5jZXNNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TaGFkb3dFbGVtZW50UmVmZXJlbmNlc01peGluJztcbmltcG9ydCBTaGFkb3dUZW1wbGF0ZU1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NoYWRvd1RlbXBsYXRlTWl4aW4nO1xuXG5cbi8qKlxuICogQSBzYW1wbGUgZ2VuZXJhbC1wdXJwb3NlIGJhc2UgY2xhc3MgZm9yIGRlZmluaW5nIGN1c3RvbSBlbGVtZW50cyB0aGF0IG1peGVzXG4gKiBpbiBzb21lIGNvbW1vbiBmZWF0dXJlczogdGVtcGxhdGUgc3RhbXBpbmcgaW50byBhIHNoYWRvdyByb290LCBzaGFkb3cgZWxlbWVudFxuICogcmVmZXJlbmNlcywgbWFyc2hhbGxpbmcgYXR0cmlidXRlcyB0byBwcm9wZXJ0aWVzLCBhbmQgcmV0cmlldmluZyB0aGUgY2hpbGRyZW5cbiAqIGRpc3RyaWJ1dGVkIHRvIGEgY29tcG9uZW50LlxuICpcbiAqIFRoaXMgYmFzZSBjbGFzcyBpcyBub3Qgc3BlY2lhbCBpbiBhbnkgd2F5LCBhbmQgaXMgZGVmaW5lZCBvbmx5IGFzIGFcbiAqIGNvbnZlbmllbnQgc2hvcnRoYW5kIGZvciBhcHBseWluZyB0aGUgbWl4aW5zIGxpc3RlZCBhYm92ZS4gWW91IGNhbiB1c2UgdGhpc1xuICogY2xhc3MgYXMgYSBiYXNlIGNsYXNzIGZvciB5b3VyIG93biBlbGVtZW50cywgb3IgZWFzaWx5IGNyZWF0ZSB5b3VyIG93biBiYXNlXG4gKiBjbGFzcyBieSBhcHBseWluZyB0aGUgc2FtZSBzZXQgb2YgbWl4aW5zLlxuICpcbiAqIFRoZSBFbGVtZW50QmFzZSBiYXNlIGNsYXNzIGRvZXMgbm90IHJlZ2lzdGVyIGl0c2VsZiBhcyBhIGN1c3RvbSBlbGVtZW50IHdpdGhcbiAqIHRoZSBicm93c2VyLCBhbmQgaGVuY2UgY2Fubm90IGJlIGluZGVwZW5kZW50bHkgaW5zdGFudGlhdGVkLlxuICpcbiAqIEBtaXhlcyBBdHRyaWJ1dGVNYXJzaGFsbGluZ01peGluXG4gKiBAbWl4ZXMgQ29tcG9zYWJsZU1peGluXG4gKiBAbWl4ZXMgRGlzdHJpYnV0ZWRDaGlsZHJlbk1peGluXG4gKiBAbWl4ZXMgU2hhZG93RWxlbWVudFJlZmVyZW5jZXNNaXhpblxuICogQG1peGVzIFNoYWRvd1RlbXBsYXRlTWl4aW5cbiAqL1xuY2xhc3MgRWxlbWVudEJhc2UgZXh0ZW5kcyBDb21wb3NhYmxlTWl4aW4oSFRNTEVsZW1lbnQpLmNvbXBvc2UoXG4gIFNoYWRvd1RlbXBsYXRlTWl4aW4sICAgICAgICAgIC8vIGJlZm9yZSBub2RlIGZpbmRpbmcsIHNvIHNoYWRvdyByb290IGlzIHBvcHVsYXRlZFxuICBTaGFkb3dFbGVtZW50UmVmZXJlbmNlc01peGluLCAvLyBiZWZvcmUgbWFyc2hhbGxpbmcsIHNvIHByb3BlcnRpZXMgY2FuIHVzZSByZWZzXG4gIEF0dHJpYnV0ZU1hcnNoYWxsaW5nTWl4aW4sXG4gIERpc3RyaWJ1dGVkQ2hpbGRyZW5NaXhpblxuKSB7fVxuXG5leHBvcnQgZGVmYXVsdCBFbGVtZW50QmFzZTtcbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgdHJhbnNwaWxlZCB0byBjcmVhdGUgYW4gRVM1LWNvbXBhdGlibGUgZGlzdHJpYnV0aW9uIGluIHdoaWNoXG4gKiB0aGUgcGFja2FnZSdzIG1haW4gZmVhdHVyZShzKSBhcmUgYXZhaWxhYmxlIHZpYSB0aGUgd2luZG93LkJhc2ljIGdsb2JhbC5cbiAqIElmIHlvdSdyZSBhbHJlYWR5IHVzaW5nIEVTNiB5b3Vyc2VsZiwgaWdub3JlIHRoaXMgZmlsZSwgYW5kIGluc3RlYWQgaW1wb3J0XG4gKiB0aGUgc291cmNlIGZpbGUocykgeW91IHdhbnQgZnJvbSB0aGUgc3JjIGZvbGRlci5cbiAqL1xuXG5pbXBvcnQgTW9kZXMgZnJvbSAnLi9zcmMvTW9kZXMnO1xuXG53aW5kb3cuQmFzaWMgPSB3aW5kb3cuQmFzaWMgfHwge307XG53aW5kb3cuQmFzaWMuTW9kZXMgPSBNb2RlcztcbiIsImltcG9ydCBFbGVtZW50QmFzZSBmcm9tICcuLi8uLi9iYXNpYy1lbGVtZW50LWJhc2Uvc3JjL0VsZW1lbnRCYXNlJztcbmltcG9ydCBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0Rpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4nO1xuaW1wb3J0IENvbnRlbnRJdGVtc01peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0NvbnRlbnRJdGVtc01peGluJztcbmltcG9ydCBTaW5nbGVTZWxlY3Rpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TaW5nbGVTZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zeW1ib2xzJztcblxuY29uc3QgYmFzZSA9IEVsZW1lbnRCYXNlLmNvbXBvc2UoXG4gIENvbnRlbnRJdGVtc01peGluLFxuICBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluLFxuICBTaW5nbGVTZWxlY3Rpb25NaXhpblxuKTtcblxuXG4vKipcbiAqIFNob3dzIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQgYXQgYSB0aW1lLiBUaGlzIGNhbiBiZSB1c2VmdWwsIGZvciBleGFtcGxlLFxuICogaWYgYSBnaXZlbiBVSSBlbGVtZW50IGhhcyBtdWx0aXBsZSBtb2RlcyB0aGF0IHByZXNlbnQgc3Vic3RhbnRpYWxseSBkaWZmZXJlbnRcbiAqIGVsZW1lbnRzLlxuICpcbiAqIFRoZSB0cmFuc2l0aW9uIGJldHdlZW4gY2hpbGQgZWxlbWVudHMgaXMgaW5zdGFudGVub3VzLiBJZiB5b3UnZCBsaWtlIHRoZVxuICogdHJhbnNpdGlvbiB0byBiZSBhY2NvbXBhbmllZCBieSB2aXNpYmxlIGFuaW1hdGVkIGVmZmVjdHMsIHNlZVxuICogW2Jhc2ljLWFuaW1hdGlvbi1zdGFnZV0oLi4vYmFzaWMtYW5pbWF0aW9uLXN0YWdlKS5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBkb2Vzbid0IHByb3ZpZGUgYW55IFVJIGZvciBjaGFuZ2luZyB3aGljaCBtb2RlIGlzIHNob3duLlxuICpcbiAqIEBleHRlbmRzIEVsZW1lbnRCYXNlXG4gKiBAbWl4ZXMgQ29udGVudEl0ZW1zTWl4aW5cbiAqIEBtaXhlcyBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluXG4gKiBAbWl4ZXMgU2luZ2xlU2VsZWN0aW9uTWl4aW5cbiAqL1xuY2xhc3MgTW9kZXMgZXh0ZW5kcyBiYXNlIHtcblxuICBnZXQgW3N5bWJvbHMuZGVmYXVsdHNdKCkge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gc3VwZXJbc3ltYm9scy5kZWZhdWx0c10gfHwge307XG4gICAgZGVmYXVsdHMuc2VsZWN0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIHJldHVybiBkZWZhdWx0cztcbiAgfVxuXG4gIFtzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgc2VsZWN0ZWQpIHtcbiAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCk7IH1cbiAgICBpdGVtLnN0eWxlLmRpc3BsYXkgPSBzZWxlY3RlZCA/ICcnIDogJ25vbmUnO1xuICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICFzZWxlY3RlZCk7XG4gIH1cblxuICBnZXQgW3N5bWJvbHMudGVtcGxhdGVdKCkge1xuICAgIHJldHVybiBgPHNsb3Q+PC9zbG90PmA7XG4gIH1cblxufVxuXG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnYmFzaWMtbW9kZXMnLCBNb2Rlcyk7XG5leHBvcnQgZGVmYXVsdCBNb2RlcztcbiJdfQ=="}