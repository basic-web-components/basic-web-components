{"version":3,"sources":["node_modules/browser-pack/_prelude.js","packages/basic-autosize-textarea/globals.js","packages/basic-autosize-textarea/src/AutosizeTextarea.js","packages/basic-component-mixins/src/AttributeMarshallingMixin.js","packages/basic-component-mixins/src/ComposableMixin.js","packages/basic-component-mixins/src/DistributedChildrenContentMixin.js","packages/basic-component-mixins/src/DistributedChildrenMixin.js","packages/basic-component-mixins/src/GenericMixin.js","packages/basic-component-mixins/src/ShadowElementReferencesMixin.js","packages/basic-component-mixins/src/ShadowTemplateMixin.js","packages/basic-component-mixins/src/createSymbol.js","packages/basic-component-mixins/src/microtask.js","packages/basic-component-mixins/src/safeAttributes.js","packages/basic-component-mixins/src/symbols.js","packages/basic-component-mixins/src/toggleClass.js","packages/basic-element-base/src/ElementBase.js","packages/basic-wrapped-standard-element/src/WrappedStandardElement.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","_AutosizeTextarea","window","Basic","AutosizeTextarea","_AutosizeTextarea2","default","getTextContent","element","text","distributedTextContent","trim","initializeWhenRendered","clientHeight","setTimeout","textBoxStyle","getComputedStyle","inner","copyContainerStyle","$","copyContainer","style","borderBottomStyle","borderBottomWidth","borderLeftStyle","borderLeftWidth","borderRightStyle","borderRightWidth","borderTopStyle","borderTopWidth","paddingBottom","paddingLeft","paddingRight","paddingTop","extraLine","display","lineHeightSymbol","setMinimumHeight","keypress","event","keyCode","outerHeight","getBoundingClientRect","height","parseFloat","innerHeight","bordersPlusPadding","minHeight","minimumRows","Math","ceil","unescapeHtml","html","replace","valueChanged","autoSize","_symbols2","handlingUserInteraction","dispatchEvent","CustomEvent","_createSymbol","_WrappedStandardElement","_DistributedChildrenContentMixin","_GenericMixin","_symbols","_createSymbol2","minimumRowsSymbol","valueTracksContentSymbol","base","_WrappedStandardElement2","wrap","compose","_DistributedChildrenContentMixin2","_GenericMixin2","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","addEventListener","defaults","textCopy","textContent","value","_get","prototype","parseInt","template","customElements","define","attributeToPropertyName","attributeName","propertyName","attributeToPropertyNames","hypenRegEx","match","toUpperCase","attributesForClass","classFn","HTMLElement","baseClass","constructor","baseAttributes","propertyNames","getOwnPropertyNames","setterNames","filter","getOwnPropertyDescriptor","set","attributes","map","setterName","propertyNameToAttribute","diff","attribute","indexOf","concat","propertyNamesToAttributes","uppercaseRegEx","toLowerCase","_safeAttributes","AttributeMarshalling","_base","apply","arguments","_inherits","_createClass","key","oldValue","newValue","_safeAttributes2","connected","setAttribute","className","toggleClass","get","composeClass","mixin","Subclass","_base2","copyOwnProperties","NON_MIXABLE_OBJECT_PROPERTIES","source","target","ignorePropertyNames","undefined","forEach","name","descriptor","defineProperty","Composable","_len","mixins","Array","_key","reduce","_microtask","DistributedChildrenContent","shadowRoot","slots","querySelectorAll","slot","contentChanged","_microtask2","distributedChildren","console","warn","_set","expandContentElements","nodes","includeTextNodes","_ref","expanded","node","isSlot","HTMLSlotElement","localName","assignedNodes","flatten","Text","flattened","_toConsumableArray","DistributedChildren","children","childNodes","strings","distributedChildNodes","child","join","genericSymbol","Generic","generic","parsed","String","removeAttribute","ShadowElementReferences","nodesWithIds","id","getAttribute","createTemplateWithInnerHTML","innerHTML","document","createElement","div","content","appendChild","shimTemplateStyles","tag","WebComponents","ShadowCSS","shimStyling","ShadowTemplate","ShadowDOMPolyfill","root","attachShadow","mode","clone","importNode","createSymbol","description","Symbol","microtask","callback","callbacks","push","counter","executeCallbacks","shift","createTextNode","observer","MutationObserver","observe","characterData","setAttributeToElement","_toggleClass2","safeToSetAttributesSymbol","pendingAttributesSymbol","pendingClassesSymbol","_value","_toggleClass3","symbols","dragging","goDown","goEnd","goLeft","goRight","goStart","goUp","itemAdded","itemsChanged","itemSelected","keydown","force","classList","addClass","contains","add","remove","_AttributeMarshallingMixin","_ComposableMixin","_DistributedChildrenMixin","_ShadowElementReferencesMixin","_ShadowTemplateMixin","ElementBase","_ComposableMixin2","_ShadowTemplateMixin2","_ShadowElementReferencesMixin2","_AttributeMarshallingMixin2","_DistributedChildrenMixin2","createPropertyDelegate","delegate","configurable","enumerable","writable","_ElementBase2","reraiseEvents","address","blockquote","caption","center","dd","dir","dl","dt","fieldset","form","frame","h1","h2","h3","h4","h5","h6","iframe","img","input","keygen","li","link","menu","object","ol","p","script","select","tbody","tfoot","thead","textarea","eventBubbles","abort","change","reset","blockElements","WrappedStandardElement","eventNames","extends","eventName","realEvent","Event","bubbles","label","extendsTag","Wrapped","_WrappedStandardEleme","extendsPrototype","names"],"mappings":"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","file":"basic-autosize-textarea.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport AutosizeTextarea from './src/AutosizeTextarea';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.AutosizeTextarea = AutosizeTextarea;\n","import createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport WrappedStandardElement from '../../basic-wrapped-standard-element/src/WrappedStandardElement';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport GenericMixin from '../../basic-component-mixins/src/GenericMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n// Symbols for private data members on an element.\nconst lineHeightSymbol = createSymbol('lineHeight');\nconst minimumRowsSymbol = createSymbol('minimumRows');\nconst valueTracksContentSymbol = createSymbol('valueTracksContent');\n\nconst base = WrappedStandardElement.wrap('textarea').compose(\n  DistributedChildrenContentMixin,\n  GenericMixin\n);\n\n/**\n * A text area that makes itself big enough to show its content.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-autosize-textarea/)\n *\n * This text input component is useful in situations where you want to ask the\n * user to enter as much text as they want, but don't want to take up a lot of\n * room on the page.\n *\n * The component works by copying the text to an invisible element which will\n * automatically grow in size; the expanding copy will expand the container,\n * which in turn will vertically stretch the text area to match.\n *\n * This component generally exposes all the same attributes/properties as a\n * standard HTML `<textarea>`.\n *\n * @extends WrappedStandardElement\n * @mixes GenericMixin\n * @mixes DistributedChildrenContentMixin\n */\nclass AutosizeTextarea extends base {\n\n  constructor() {\n    super();\n\n    this.inner.addEventListener('input', event => {\n      this[symbols.handlingUserInteraction] = true;\n      valueChanged(this);\n      this[symbols.handlingUserInteraction] = false;\n    });\n    this.inner.addEventListener('keypress', event => {\n      this[symbols.handlingUserInteraction] = true;\n      keypress(this, event);\n      this[symbols.handlingUserInteraction] = false;\n    });\n\n    // Set defaults.\n    if (typeof this.minimumRows === 'undefined') {\n      this.minimumRows = this[symbols.defaults].minimumRows;\n    }\n\n    // A standard textarea has its value track its textContent by default.\n    // That is, changes to textContent update the value. However, if an attempt\n    // is made to change the value directly, this breaks the automatic tracking.\n    // From that point on, changes to textContent do *not* update the value.\n    this[valueTracksContentSymbol] = true;\n  }\n\n  /**\n   * Resize the element such that the textarea can exactly contain its content.\n   * By default, this method is invoked whenever the text content changes.\n   */\n  autoSize() {\n    // If we had speculatively added an extra line because of an Enter keypress,\n    // we can now hide the extra line.\n    this.$.extraLine.style.display = 'none';\n\n    // We resize by copying the textarea contents to the element itself; the\n    // text will then appear (via <slot>) inside the invisible div. If\n    // we've set things up correctly, this new content should take up the same\n    // amount of room as the same text in the textarea. Updating the element's\n    // content adjusts the element's size, which in turn will make the textarea\n    // the correct height.\n    this.$.textCopy.textContent = this.value;\n  }\n\n  // Normally the value of the element is set and read through its value\n  // attribute. As a convenience, and to mirror standard textarea behavior, it\n  // is possible to set the content of the textarea by including text between\n  // the opening and closing tag. This works only in one direction: setting the\n  // tag content updates the textarea, but user edits in the textarea are not\n  // reflected in the tag content. We capture the value of the initial text\n  // content in order to set the value property during the create event.\n  // TODO: Normalize indentation in the text content. Users will often want to\n  // indent the markup so that it looks pretty. We should detect the indentation\n  // level and remove any indentation whitespace\n  // TODO: Consider using content innerHTML rather than plain text. The native\n  // textarea element will include HTML, not just the stripped text, as initial\n  // value property text.\n  connectedCallback() {\n    if (super.connectedCallback) { super.connectedCallback(); }\n    initializeWhenRendered(this);\n  }\n\n  contentChanged() {\n    if (super.contentChanged) { super.contentChanged(); }\n    if (this[valueTracksContentSymbol]) {\n      const text = getTextContent(this);\n      this.inner.value = unescapeHtml(text);\n      valueChanged(this);\n    }\n  }\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.minimumRows = 1;\n    return defaults;\n  }\n\n  /**\n   * Determines the minimum number of rows shown. This is similar to the rows\n   * attribute on a standard textarea, but because this element can grow, is\n   * expressed as a minimum rather than a fixed number.\n   *\n   * By default, this property is 1, so when empty, the text area will be a\n   * single line tall. That's efficient in terms of the space it consumes, but\n   * until the user interacts with the element, they may not realize they can\n   * enter multiple lines of text. Setting the property to a value higher than 1\n   * will signal to the user that they can enter multiple lines of a text.\n   *\n   * By setting this property, you can also communicate to the user some sense\n   * of how much text you're expecting them to provide. For example, on a\n   * feedback form, asking the user to enter their feedback in a single-line\n   * text box implies you don't really want them to enter much text — even if\n   * the text box will grow when they type. By setting this to a value like,\n   * say, 10 rows, you can signal that you're fully expecting them to enter more\n   * text.\n   *\n   * @type {number}\n   * @default 1\n   */\n  get minimumRows() {\n    return this[minimumRowsSymbol];\n  }\n  set minimumRows(value) {\n    this[minimumRowsSymbol] = parseInt(value);\n    if (this[lineHeightSymbol]) {\n      setMinimumHeight(this);\n    }\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        display: block;\n      }\n\n      #autoSizeContainer {\n        position: relative;\n      }\n\n      /*\n       * Ensure both the text area and copy end up with the element's own font\n       * metrics, so that text will lay out the same in both of them.\n       */\n      #inner,\n      #copyContainer {\n        -moz-box-sizing: border-box;\n        box-sizing: border-box;\n        font-family: inherit;\n        font-size: inherit;\n        font-style: inherit;\n        font-weight: inherit;\n        line-height: inherit;\n        margin: 0;\n      }\n\n      #inner {\n        height: 100%;\n        overflow: hidden;\n        position: absolute;\n        resize: none;\n        top: 0;\n        width: 100%;\n        @apply(--textarea);\n      }\n\n      #copyContainer {\n        visibility: hidden;\n        white-space: pre-wrap; /* So lines wrap */\n        word-wrap: break-word; /* So we break at word boundaries when possible */\n      }\n\n      #contentContainer {\n        display: none;\n      }\n      </style>\n\n      <!--\n      The invisible copyContainer contains an extraSpace element that ensures that,\n      even if the last line of the textarea is blank, there will be something in the\n      line that forces the text copy to grow by a line. This extra space is a thin\n      space, to reduce the amount by which the text copy will prematurely grow.\n\n      The copyContainer also contains an extraLine element exists to deal with the\n      fact that, if the user presses the Enter key down, the textarea's content will\n      move before the complete text is available. See notes at _keypress.\n\n      Lastly, we put the HTML content element into a separate container so we can\n      hide it. We need to have a content element somewhere in the template to\n      convince Polymer that we care about the content in the Shady DOM case --\n      without that content element, Shady DOM will conclude the element doesn't\n      need its light DOM content, and will throw it away.\n      -->\n      <div id=\"autoSizeContainer\">\n        <textarea id=\"inner\"></textarea>\n        <div id=\"copyContainer\"><span id=\"textCopy\"></span><span id=\"extraSpace\">&thinsp;</span><div id=\"extraLine\">&nbsp;</div></div>\n      </div>\n      <div id=\"contentContainer\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n  /**\n   * The text currently shown in the textarea.\n   *\n   * Note that the text shown in the textarea can also be updated by changing\n   * the element's innerHTML/textContent. However, if the value property is\n   * explicitly set, that will override the innerHTML/textContent.\n   *\n   * @type {string}\n   */\n  get value() {\n    return this.inner.value;\n  }\n  set value(text) {\n    // Explicitly setting value breaks automatic update of value from content.\n    this[valueTracksContentSymbol] = false;\n    this.inner.value = text;\n    valueChanged(this);\n  }\n\n  /**\n   * Fires when the user types in the textarea.\n   *\n   * @memberof AutosizeTextarea\n   * @event change\n   */\n}\n\n\nfunction getTextContent(element) {\n  let text = element.distributedTextContent;\n\n  // Trim the text.\n  // This is non-standard textarea behavior. A standard textarea will trim the\n  // first character if it's a newline, but that's it. However, authors will\n  // want to be able to place the opening and closing tags on their own lines.\n  // So it seems more helpful to trim whitespace on either side.\n  text = text.trim();\n\n  return text;\n}\n\n\n// Set up once this component has been rendered.\n//\n// On Chrome (as of 10/23/14) at least, if an instance if this component is\n// added dynamically, its attached handler may trigger before its been\n// rendered. That would cause our layout calculations to be incorrect.\n//\nfunction initializeWhenRendered(element) {\n\n  // If the component has been rendered, our height should be nonzero.\n  if (element.clientHeight === 0) {\n    // Not rendered yet: wait a bit before trying again.\n    setTimeout(() => initializeWhenRendered(element), 10);\n    return;\n  }\n\n  // If we reach this point, the component's elements should by styled.\n\n  // For auto-sizing to work, we need the text copy to have the same border,\n  // padding, and other relevant characteristics as the original text area.\n  // Since those aspects are affected by CSS, we have to wait until the\n  // element is in the document before we can update the text copy.\n  const textBoxStyle = getComputedStyle(element.inner);\n  const copyContainerStyle = element.$.copyContainer.style;\n  copyContainerStyle.borderBottomStyle  = textBoxStyle.borderBottomStyle;\n  copyContainerStyle.borderBottomWidth  = textBoxStyle.borderBottomWidth;\n  copyContainerStyle.borderLeftStyle    = textBoxStyle.borderLeftStyle;\n  copyContainerStyle.borderLeftWidth    = textBoxStyle.borderLeftWidth;\n  copyContainerStyle.borderRightStyle   = textBoxStyle.borderRightStyle;\n  copyContainerStyle.borderRightWidth   = textBoxStyle.borderRightWidth;\n  copyContainerStyle.borderTopStyle     = textBoxStyle.borderTopStyle;\n  copyContainerStyle.borderTopWidth     = textBoxStyle.borderTopWidth;\n  copyContainerStyle.paddingBottom      = textBoxStyle.paddingBottom;\n  copyContainerStyle.paddingLeft        = textBoxStyle.paddingLeft;\n  copyContainerStyle.paddingRight       = textBoxStyle.paddingRight;\n  copyContainerStyle.paddingTop         = textBoxStyle.paddingTop;\n\n  // Use the extraLine member to gauge the expected height of a single line of\n  // text. We can't use lineHeight, because that can be reported as \"normal\",\n  // and we want to know the actual pixel height.\n  element.$.extraLine.style.display = 'inherit';\n  element[lineHeightSymbol] = element.$.extraLine.clientHeight;\n\n  // Now that we know the line height, we can hide the extra line.\n  element.$.extraLine.style.display = 'none';\n\n  // Use the line height in conjunction with minimumRows to establish the\n  // overall minimum height of the component.\n  setMinimumHeight(element);\n}\n\n\n// Speculatively add a line to our copy of the text. We're not sure what the\n// exact effect of typing this character will be, and at this point it's not\n// reflected yet in the textarea's content. We speculate that it will add a\n// line to the text and size accordingly. (One other possibility is that the\n// user's replacing a selected chunk of text with a newline.) In any event,\n// once we get the keyup or change event, we'll make any final adjustments.\n//\n// TODO: If the user holds down the Enter key, we can get a bunch of keypress\n// events before we get keyup. This causes flicker. Instead of supporting only\n// a single extra speculative line, we should grow the speculative element to\n// contain the number of Enter keypresses we've received.\nfunction keypress(element, event) {\n  if (event.keyCode === 13 /* Enter */) {\n    element.$.extraLine.style.display = 'inherit';\n  }\n}\n\n\n// Setting the minimumRows attribute translates into setting the minimum\n// height on the text copy container.\nfunction setMinimumHeight(element) {\n  const copyContainer = element.$.copyContainer;\n  const outerHeight = copyContainer.getBoundingClientRect().height;\n  const style = getComputedStyle(copyContainer);\n  const paddingTop = parseFloat(style.paddingTop);\n  const paddingBottom = parseFloat(style.paddingBottom);\n  const innerHeight = copyContainer.clientHeight - paddingTop - paddingBottom;\n  const bordersPlusPadding = outerHeight - innerHeight;\n  let minHeight = (element.minimumRows * element[lineHeightSymbol]) + bordersPlusPadding;\n  minHeight = Math.ceil(minHeight);\n  copyContainer.style.minHeight = minHeight + 'px';\n}\n\n\nfunction unescapeHtml(html) {\n  return html\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, \">\")\n    .replace(/&quot;/g, '\\\"')\n    .replace(/&#039;/g, '\\'');\n}\n\n\n/*\n * Handle a change in the element's value property.\n */\nfunction valueChanged(element) {\n  element.autoSize();\n  if (element[symbols.handlingUserInteraction]) {\n    element.dispatchEvent(new CustomEvent('value-changed'));\n  }\n}\n\n\ncustomElements.define('basic-autosize-textarea', AutosizeTextarea);\nexport default AutosizeTextarea;\n","import safeAttributes from './safeAttributes';\n\n\n// Memoized maps of attribute to property names and vice versa.\nconst attributeToPropertyNames = {};\nconst propertyNamesToAttributes = {};\n\n\n/* Exported function extends a base class with AttributeMarshalling. */\nexport default (base) => {\n\n  /**\n   * Mixin which marshalls attributes to properties and vice versa.\n   *\n   * If your component exposes a setter for a property, it's generally a good\n   * idea to let devs using your component be able to set that property in HTML\n   * via an element attribute. You can code that yourself by writing an\n   * `attributeChangedCallback`, or you can use this mixin to get a degree of\n   * automatic support.\n   *\n   * This mixin implements an `attributeChangedCallback` that will attempt to\n   * convert a change in an element attribute into a call to the corresponding\n   * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n   * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n   * respects that convention, automatically mapping the hyphenated attribute\n   * name to the corresponding camelCase property name.\n   *\n   * Example: You define a component using this mixin:\n   *\n   *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n   *       get fooBar() { return this._fooBar; }\n   *       set fooBar(value) { this._fooBar = value; }\n   *     }\n   *     customElements.define('my-element', MyElement);\n   *\n   * If someone then instantiates your component in HTML:\n   *\n   *     <my-element foo-bar=\"Hello\"></my-element>\n   *\n   * Then, after the element has been upgraded, the `fooBar` setter will\n   * automatically be invoked with the initial value \"Hello\".\n   *\n   * For the time being, this mixin only supports string-valued properties.\n   * If you'd like to convert string attributes to other types (numbers,\n   * booleans), you need to implement `attributeChangedCallback` yourself.\n   */\n  class AttributeMarshalling extends base {\n\n    /*\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n      const propertyName = attributeToPropertyName(attributeName);\n      // If the attribute name corresponds to a property name, set the property.\n      // Ignore standard HTMLElement properties handled by the DOM.\n      if (propertyName in this && !(propertyName in HTMLElement.prototype)) {\n        this[propertyName] = newValue;\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    static get observedAttributes() {\n      return attributesForClass(this);\n    }\n\n    /**\n     * Set/unset the attribute with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as an attribute. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes. A call to `reflectAttribute` during the constructor will\n     * be deferred until the element is connected to the document.\n     *\n     * @param {string} attribute - The name of the *attribute* (not property) to set.\n     * @param {object} value - The value to set. If null, the attribute will be removed.\n     */\n    reflectAttribute(attribute, value) {\n      return safeAttributes.setAttribute(this, attribute, value);\n    }\n\n    /**\n     * Set/unset the class with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as as class. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes, including the `class` attribute. A call to\n     * `reflectClass` during the constructor will be deferred until the element\n     * is connected to the document.\n     *\n     * @param {string} className - The name of the class to set.\n     * @param {object} value - True to set the class, false to remove it.\n     */\n    reflectClass(className, value) {\n      return safeAttributes.toggleClass(this, className, value);\n    }\n\n  }\n\n  return AttributeMarshalling;\n};\n\n\n// Convert hyphenated foo-bar attribute name to camel case fooBar property name.\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hypenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hypenRegEx,\n        match => match[1].toUpperCase());\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\nfunction attributesForClass(classFn) {\n\n  // We treat the element base classes as if they have no attributes, since we\n  // don't want to receive attributeChangedCallback for them.\n  if (classFn === HTMLElement || classFn === Object) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n  const baseAttributes = attributesForClass(baseClass);\n\n  // Get attributes for this class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter(propertyName =>\n    typeof Object.getOwnPropertyDescriptor(\n        classFn.prototype, propertyName).set === 'function');\n  const attributes = setterNames.map(setterName =>\n      propertyNameToAttribute(setterName));\n\n  // Merge.\n  const diff = attributes.filter(attribute =>\n      baseAttributes.indexOf(attribute) < 0);\n  return baseAttributes.concat(diff);\n}\n\n// Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, '-$1').toLowerCase();\n  }\n  return attribute;\n}\n","/* Exported function extends a base class with Composable. */\nexport default (base) => {\n\n  /**\n   * Mixin to make a class more easily composable with other mixins.\n   *\n   * This mixin contributes a `compose` method that applies a set of mixin\n   * functions and returns the resulting new class. This sugar can make the\n   * application of many mixins at once easier to read.\n   */\n  class Composable extends base {\n\n    /**\n     * Apply a set of mixin functions or mixin objects to the present class and\n     * return the new class.\n     *\n     * Instead of writing:\n     *\n     *     let MyClass = Mixin1(Mixin2(Mixin3(Mixin4(Mixin5(BaseClass)))));\n     *\n     * You can write:\n     *\n     *     let MyClass = ComposableMixin(BaseClass).compose(\n     *       Mixin1,\n     *       Mixin2,\n     *       Mixin3,\n     *       Mixin4,\n     *       Mixin5\n     *     );\n     *\n     * This function can also take mixin objects. A mixin object is just a\n     * shorthand for a mixin function that creates a new subclass with the given\n     * members. The mixin object's members are *not* copied directly onto the\n     * prototype of the base class, as with traditional mixins.\n     *\n     * In addition to providing syntactic sugar, this mixin can be used to\n     * define a class in ES5, which lacks ES6's `class` keyword.\n     *\n     * @param {...mixins} mixins - A set of mixin functions or objects to apply.\n     */\n    static compose(...mixins) {\n      // We create a new subclass for each mixin in turn. The result becomes\n      // the base class extended by any subsequent mixins. It turns out that\n      // we can use Array.reduce() to concisely express this, using the current\n      // object as the seed for reduce().\n      return mixins.reduce(composeClass, this);\n    }\n\n  }\n\n  return Composable;\n};\n\n\n// Properties defined by Object that we don't want to mixin.\nconst NON_MIXABLE_OBJECT_PROPERTIES = [\n  'constructor'\n];\n\n/*\n * Apply the mixin to the given base class to return a new class.\n * The mixin can either be a function that returns the modified class, or a\n * plain object whose members will be copied to the new class' prototype.\n */\nfunction composeClass(base, mixin) {\n  if (typeof mixin === 'function') {\n    // Mixin function\n    return mixin(base);\n  } else {\n    // Mixin object\n    class Subclass extends base {}\n    copyOwnProperties(mixin, Subclass.prototype, NON_MIXABLE_OBJECT_PROPERTIES);\n    return Subclass;\n  }\n}\n\n\n/*\n * Copy the given properties/methods to the target.\n * Return the updated target.\n */\nfunction copyOwnProperties(source, target, ignorePropertyNames = []) {\n  Object.getOwnPropertyNames(source).forEach(name => {\n    if (ignorePropertyNames.indexOf(name) < 0) {\n      const descriptor = Object.getOwnPropertyDescriptor(source, name);\n      Object.defineProperty(target, name, descriptor);\n    }\n  });\n  return target;\n}\n","import microtask from './microtask';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/* Exported function extends a base class with DistributedChildrenContent. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines a component's content as its children, expanding any\n   * nodes distributed to the component's slots.\n   *\n   * This also provides notification of changes to a component's content. It\n   * will invoke a `contentChanged` method when the component is first\n   * instantiated, and whenever its distributed children change. This is an\n   * easy way to satisfy the Gold Standard checklist item for monitoring\n   * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n   *\n   * Example:\n   *\n   * ```\n   * let base = DistributedChildrenContentMixin(DistributedChildrenMixin(HTMLElement));\n   * class CountingElement extends base {\n   *\n   *   constructor() {\n   *     super();\n   *     let root = this.attachShadow({ mode: 'open' });\n   *     root.innerHTML = `<slot></slot>`;\n   *   }\n   *\n   *   contentChanged() {\n   *     // Count the component's children, both initially and when changed.\n   *     this.count = this.distributedChildren.length;\n   *   }\n   *\n   * }\n   * ```\n   *\n   * Note that content change detection depends upon the element having at least\n   * one `slot` element in its shadow subtree.\n   *\n   * This mixin is intended for use with the\n   * [DistributedChildrenMixin](DistributedChildrenMixin.md). See that mixin for\n   * a discussion of how that works. This DistributedChildrenContentMixin\n   * provides an easy way of defining the \"content\" of a component as the\n   * component's distributed children. That in turn lets mixins like\n   * [ContentItemsMixin](ContentItemsMixin.md) manipulate the children as list\n   * items.\n   */\n  class DistributedChildrenContent extends base {\n\n    constructor() {\n      super();\n\n      if (this.shadowRoot) {\n        // Listen to changes on all slots.\n        const slots = this.shadowRoot.querySelectorAll('slot');\n        slots.forEach(slot => slot.addEventListener('slotchange', event => {\n          this.contentChanged();\n        }));\n      }\n\n      // Make an initial call to contentChanged() so that the component can do\n      // initialization that it normally does when content changes.\n      //\n      // This will invoke contentChanged() handlers in other mixins. In order\n      // that those mixins have a chance to complete their own initialization,\n      // we add the contentChanged() call to the microtask queue.\n      microtask(() => this.contentChanged());\n    }\n\n    /**\n     * Invoked when the contents of the component (including distributed\n     * children) have changed.\n     *\n     * This method is also invoked when a component is first instantiated; the\n     * contents have essentially \"changed\" from being nothing. This allows the\n     * component to perform initial processing of its children.\n     */\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n      if (this[symbols.handlingUserInteraction]) {\n        const event = new CustomEvent('content-changed');\n        this.dispatchEvent(event);\n      }\n    }\n\n    /**\n     * The content of this component, defined to be the flattened array of\n     * children distributed to the component.\n     *\n     * @type {HTMLElement[]}\n     */\n    get content() {\n      const distributedChildren = this.distributedChildren;\n      if (typeof distributedChildren === 'undefined') {\n        console.warn(`DistributedChildrenContentMixin expects the component to define a \"distributedChildren\" property.`);\n      }\n      return distributedChildren;\n    }\n    set content(value) {\n      if ('content' in base.prototype) { super.content = value; }\n      // TODO: Set the children to the given value (which should be an array of\n      // elements)?\n    }\n\n    /**\n     * This event is raised when the component's contents (including distributed\n     * children) have changed.\n     *\n     * @memberof DistributedChildrenContent\n     * @event content-changed\n     */\n  }\n\n  return DistributedChildrenContent;\n};\n","/* Exported function extends a base class with DistributedChildren. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines helpers for accessing a component's distributed\n   * children as a flattened array or string.\n   *\n   * The standard DOM API provides several ways of accessing child content:\n   * `children`, `childNodes`, and `textContent`. None of these functions are\n   * Shadow DOM aware. This mixin defines variations of those functions that\n   * *are* Shadow DOM aware.\n   *\n   * Example: you create a component `<count-children>` that displays a number\n   * equal to the number of children placed inside that component. If someone\n   * instantiates your component like:\n   *\n   *     <count-children>\n   *       <div></div>\n   *       <div></div>\n   *       <div></div>\n   *     </count-children>\n   *\n   * Then the component should show \"3\", because there are three children. To\n   * calculate the number of children, the component can just calculate\n   * `this.children.length`. However, suppose someone instantiates your\n   * component inside one of their own components, and puts a `<slot>` element\n   * inside your component:\n   *\n   *     <count-children>\n   *       <slot></slot>\n   *     </count-children>\n   *\n   * If your component only looks at `this.children`, it will always see exactly\n   * one child — the `<slot>` element. But the user looking at the page will\n   * *see* any nodes distributed to that slot. To match what the user sees, your\n   * component should expand any `<slot>` elements it contains.\n   *\n   * That is the problem this mixin solves. After applying this mixin, your\n   * component code has access to `this.distributedChildren`, whose `length`\n   * will return the total number of all children distributed to your component\n   * in the composed tree.\n   *\n   * Note: The latest Custom Elements API design calls for a new function,\n   * `getAssignedNodes` that takes an optional `deep` parameter, that will solve\n   * this problem at the API level.\n   */\n  class DistributedChildren extends base {\n\n    /**\n     * An in-order collection of distributed children, expanding any slot\n     * elements. Like the standard children property, this skips text nodes.\n     *\n     * @type {HTMLElement[]}\n     */\n    get distributedChildren() {\n      return expandContentElements(this.children, false);\n    }\n\n    /**\n     * An in-order collection of distributed child nodes, expanding any slot\n     * elements. Like the standard childNodes property, this includes text\n     * nodes.\n     *\n     * @type {Node[]}\n     */\n    get distributedChildNodes() {\n      return expandContentElements(this.childNodes, true);\n    }\n\n    /**\n     * The concatenated text content of all distributed child nodes, expanding\n     * any slot elements.\n     *\n     * @type {string}\n     */\n    get distributedTextContent() {\n      const strings = this.distributedChildNodes.map(function(child) {\n        return child.textContent;\n      });\n      return strings.join('');\n    }\n\n  }\n\n  return DistributedChildren;\n};\n\n\n/*\n * Given a array of nodes, return a new array with any content elements expanded\n * to the nodes distributed to that content element. This rule is applied\n * recursively.\n *\n * If includeTextNodes is true, text nodes will be included, as in the\n * standard childNodes property; by default, this skips text nodes, like the\n * standard children property.\n */\nfunction expandContentElements(nodes, includeTextNodes) {\n  const expanded = Array.prototype.map.call(nodes, node => {\n    // We want to see if the node is an instanceof HTMLSlotELement, but\n    // that class won't exist if the browser that doesn't support native\n    // Shadow DOM and if the Shadow DOM polyfill hasn't been loaded. Instead,\n    // we do a simplistic check to see if the tag name is \"slot\".\n    const isSlot = typeof HTMLSlotElement !== 'undefined' ?\n      node instanceof HTMLSlotElement :\n      node.localName === 'slot';\n    if (isSlot) {\n      // Use the nodes assigned to this node instead.\n      const assignedNodes = node.assignedNodes({ flatten: true });\n      return assignedNodes ?\n        expandContentElements(assignedNodes, includeTextNodes) :\n        [];\n    } else if (node instanceof HTMLElement) {\n      // Plain element; use as is.\n      return [node];\n    } else if (node instanceof Text && includeTextNodes) {\n      // Text node.\n      return [node];\n    } else {\n      // Comment, processing instruction, etc.; skip.\n      return [];\n    }\n  });\n  const flattened = [].concat(...expanded);\n  return flattened;\n}\n","import createSymbol from './createSymbol';\nimport safeAttributes from './safeAttributes';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst genericSymbol = createSymbol('generic');\n\n\n/* Exported function extends a base class with Generic. */\nexport default (base) => {\n\n  /**\n   * Mixin which allows a component to support a \"generic\" style: a minimalist\n   * style that can easily be removed to reset its visual appearance to a\n   * baseline state.\n   *\n   * By default, a component should provide a minimal visual presentation that\n   * allows the component to function. However, the more styling the component\n   * provides by default, the harder it becomes to get the component to fit in\n   * in other settings. Each CSS rule has to be overridden. Worse, new CSS rules\n   * added to the default style won't be overridden by default, making it hard\n   * to know whether a new version of a component will still look okay.\n   *\n   * As a compromise, the mixin defines a `generic` attribute. This attribute is\n   * normally set by default, and styles can be written that apply only when the\n   * generic attribute is set. This allows the construction of CSS rules that\n   * will only apply to generic components like:\n   *\n   *     :host([generic=\"\"]) {\n   *       ... generic appearance defined here ...\n   *     }\n   *\n   * This makes it easy to remove all default styling — set the `GenericMixin`\n   * attribute to false, and all default styling will be removed.\n   */\n  class Generic extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.generic === 'undefined') {\n        this.generic = this[symbols.defaults].generic;\n      }\n    }\n\n    // This mixin doesn't actually respond to attribute changes, but relies\n    // on separately-defined behavior (e.g., in AttributeMarshallingMixin) for that.\n    // Still, we need define a baseline attributeChangedCallback that does\n    // nothing, in case this mixin gets used on its own.\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(name, oldValue, newValue); }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.generic = true;\n      return defaults;\n    }\n\n    /**\n     * True if the component would like to receive generic styling.\n     *\n     * This property is true by default — set it to false to turn off all\n     * generic styles. This makes it easier to apply custom styling; you won't\n     * have to explicitly override styling you don't want.\n     *\n     * @type Boolean\n     * @default true\n     */\n    get generic() {\n      return this[genericSymbol];\n    }\n    set generic(value) {\n      const parsed = typeof value === 'string' ?\n        String(value) !== 'false' :\n        value;\n      this[genericSymbol] = parsed;\n\n      if ('generic' in base.prototype) { super.generic = value; }\n\n      // We roll our own attribute setting so that an explicitly false value\n      // shows up as GenericMixin=\"false\".\n      if (parsed === false) {\n        // Explicitly use false string.\n        safeAttributes.setAttribute(this, 'generic', 'false');\n      } else if (parsed == null) {\n        // Explicitly remove attribute. (Always safe to do this.)\n        this.removeAttribute('generic');\n      } else {\n        // Use the empty string to get attribute to appear with no value.\n        safeAttributes.setAttribute(this, 'generic', '');\n      }\n    }\n\n  }\n\n  return Generic;\n};\n\n\n","/* Exported function extends a base class with ShadowElementReferences. */\nexport default (base) => {\n\n  /**\n   * Mixin to create references to elements in a component's Shadow DOM subtree.\n   *\n   * This adds a member on the component called `this.$` that can be used to\n   * reference shadow elements with IDs. E.g., if component's shadow contains an\n   * element `<button id=\"foo\">`, then this mixin will create a member\n   * `this.$.foo` that points to that button.\n   *\n   * Such references simplify a component's access to its own elements. In\n   * exchange, this mixin trades off a one-time cost of querying all elements in\n   * the shadow tree instead of paying an ongoing cost to query for an element\n   * each time the component wants to inspect or manipulate it.\n   *\n   * This mixin expects the component to define a Shadow DOM subtree. You can\n   * create that tree yourself, or make use of\n   * [ShadowTemplateMixin](ShadowTemplateMixin.md).\n   *\n   * This mixin is inspired by Polymer's [automatic\n   * node finding](https://www.polymer-project.org/1.0/docs/devguide/local-dom.html#node-finding)\n   * feature.\n   */\n  class ShadowElementReferences extends base {\n\n    constructor() {\n      super();\n      if (this.shadowRoot) {\n        // Look for elements in the shadow subtree that have id attributes.\n        // An alternatively implementation of this mixin would be to just define\n        // a this.$ getter that lazily does this search the first time someone\n        // tries to access this.$. That might introduce some complexity – if the\n        // the tree changed after it was first populated, the result of\n        // searching for a node might be somewhat unpredictable.\n        this.$ = {};\n        const nodesWithIds = this.shadowRoot.querySelectorAll('[id]');\n        [].forEach.call(nodesWithIds, node => {\n          const id = node.getAttribute('id');\n          this.$[id] = node;\n        });\n      }\n    }\n\n    /**\n     * The collection of references to the elements with IDs in a component's\n     * Shadow DOM subtree.\n     *\n     * @type {object}\n     * @member $\n     */\n  }\n\n  return ShadowElementReferences;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with ShadowTemplate. */\nexport default (base) => {\n\n  /**\n   * Mixin for stamping a template into a Shadow DOM subtree upon component\n   * instantiation.\n   *\n   * To use this mixin, define a `template` property as a string or HTML\n   * `<template>` element:\n   *\n   *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n   *       get [symbols.template]() {\n   *         return `Hello, <em>world</em>.`;\n   *       }\n   *     }\n   *\n   * When your component class is instantiated, a shadow root will be created on\n   * the instance, and the contents of the template will be cloned into the\n   * shadow root. If your component does not define a `template` property, this\n   * mixin has no effect.\n   *\n   * For the time being, this extension retains support for Shadow DOM v0. That\n   * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n   * implement Shadow DOM v1.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n      let template = this[symbols.template];\n      // TODO: Save the processed template with the component's class prototype\n      // so it doesn't need to be processed with every instantiation.\n      if (template) {\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          template = createTemplateWithInnerHTML(template);\n        }\n\n        if (window.ShadowDOMPolyfill) {\n          shimTemplateStyles(template, this.localName);\n        }\n\n        const root = this.attachShadow({ mode: 'open' });\n        const clone = document.importNode(template.content, true);\n        root.appendChild(clone);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n};\n\n\n// Convert a plain string of HTML into a real template element.\nfunction createTemplateWithInnerHTML(innerHTML) {\n  const template = document.createElement('template');\n  // REVIEW: Is there an easier way to do this?\n  // We'd like to just set innerHTML on the template content, but since it's\n  // a DocumentFragment, that doesn't work.\n  const div = document.createElement('div');\n  div.innerHTML = innerHTML;\n  while (div.childNodes.length > 0) {\n    template.content.appendChild(div.childNodes[0]);\n  }\n  return template;\n}\n\n// Invoke basic style shimming with ShadowCSS.\nfunction shimTemplateStyles(template, tag) {\n  window.WebComponents.ShadowCSS.shimStyling(template.content, tag);\n}\n","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n","/*\n * Microtask helper for IE 11.\n *\n * Executing a function as a microtask is trivial in browsers that support\n * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n * promises, but does support MutationObservers, which are also executed as\n * microtasks. So this helper uses an MutationObserver to achieve microtask\n * timing.\n *\n * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * Inspired by Polymer's async() function.\n */\n\n\n// The queue of pending callbacks to be executed as microtasks.\nconst callbacks = [];\n\n// Create an element that we will modify to force observable mutations.\nconst element = document.createTextNode('');\n\n// A monotonically-increasing value.\nlet counter = 0;\n\n\n/**\n * Add a callback to the microtask queue.\n *\n * This uses a MutationObserver so that it works on IE 11.\n *\n * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n * needs more investigation.\n *\n * @function microtask\n * @param {function} callback\n */\nexport default function microtask(callback) {\n  callbacks.push(callback);\n  // Force a mutation.\n  element.textContent = ++counter;\n}\n\n\n// Execute any pending callbacks.\nfunction executeCallbacks() {\n  while (callbacks.length > 0) {\n    const callback = callbacks.shift();\n    callback();\n  }\n}\n\n\n// Create the observer.\nconst observer = new MutationObserver(executeCallbacks);\nobserver.observe(element, {\n  characterData: true\n});\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\n\n\n// Symbols for private data members on an element.\nconst safeToSetAttributesSymbol = createSymbol('safeToSetAttributes');\nconst pendingAttributesSymbol = createSymbol('pendingAttributes');\nconst pendingClassesSymbol = createSymbol('pendingClasses');\n\n\n/**\n * Helper functions for updating attributes, including the `class` attribute.\n */\nexport default {\n\n  /**\n   * Perform any pending updates to attributes and classes.\n   *\n   * This writes any `setAttribute` or `toggleClass` values that were performed\n   * before an element was attached to the document for the first time.\n   *\n   * This method should be called by mixins/components in their\n   * `connectedCallback`. If mulitple mixins/components invoke this during the\n   * same `connectedCallback`, only the first call will have any effect. The\n   * subsequent calls will be harmless.\n   *\n   * @param {HTMLElement} element - The element being added to the document.\n   */\n  connected(element) {\n    element[safeToSetAttributesSymbol] = true;\n\n    // Set any pending attributes.\n    if (element[pendingAttributesSymbol]) {\n      for (let attribute in element[pendingAttributesSymbol]) {\n        const value = element[pendingAttributesSymbol][attribute];\n        setAttributeToElement(element, attribute, value);\n      }\n      element[pendingAttributesSymbol] = null;\n    }\n\n    // Set any pending classes.\n    if (element[pendingClassesSymbol]) {\n      for (let className in element[pendingClassesSymbol]) {\n        const value = element[pendingClassesSymbol][className];\n        toggleClass(element, className, value);\n      }\n      element[pendingClassesSymbol] = null;\n    }\n  },\n\n  /**\n   * Set/unset the attribute with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as an attribute. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes. A call to `setAttribute` during the constructor will\n   * be deferred until the element is connected to the document.\n   *\n   * @param {string} attribute - The name of the *attribute* (not property) to set.\n   * @param {object} value - The value to set. If null, the attribute will be removed.\n   */\n  setAttribute(element, attribute, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set attributes immediately.\n      setAttributeToElement(element, attribute, value);\n    } else {\n      // Defer setting attributes until the first time we're connected.\n      if (!element[pendingAttributesSymbol]) {\n        element[pendingAttributesSymbol] = {};\n      }\n      element[pendingAttributesSymbol][attribute] = value;\n    }\n  },\n\n  /**\n   * Set/unset the class with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as as class. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes, including the `class` attribute. A call to\n   * `toggleClass` during the constructor will be deferred until the element\n   * is connected to the document.\n   *\n   * @param {string} className - The name of the class to set.\n   * @param {object} value - True to set the class, false to remove it.\n   */\n  toggleClass(element, className, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set class immediately.\n      toggleClass(element, className, value);\n    } else {\n      // Defer setting class until the first time we're connected.\n      if (!element[pendingClassesSymbol]) {\n        element[pendingClassesSymbol] = {};\n      }\n      element[pendingClassesSymbol][className] = value;\n    }\n  }\n\n};\n\n\n// Reflect the attribute to the given element.\n// If the value is null, remove the attribute.\nfunction setAttributeToElement(element, attributeName, value) {\n  if (value === null || typeof value === 'undefined') {\n    element.removeAttribute(attributeName);\n  } else {\n    const text = String(value);\n    // Avoid recursive attributeChangedCallback calls.\n    if (element.getAttribute(attributeName) !== text) {\n      element.setAttribute(attributeName, value);\n    }\n  }\n}\n","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'basic-component-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'basic-component-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `dragging` property.\n   *\n   * Components like carousels often define animated CSS transitions for\n   * sliding effects. Such a transition should usually *not* be applied while\n   * the user is dragging, because a CSS animation will introduce a lag that\n   * makes the swipe feel sluggish. Instead, as long as the user is dragging\n   * with their finger down, the transition should be suppressed. When the\n   * user releases their finger, the transition can be restored, allowing the\n   * animation to show the carousel sliding into its final position.\n   *\n   * @type {boolean} true if a drag is in progress, false if not.\n   */\n  dragging: createSymbol('dragging'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: createSymbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: createSymbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: createSymbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: createSymbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: createSymbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: createSymbol('goUp'),\n\n  /**\n   * Symbol for the `handlingUserInteraction` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. This property can be used\n   * to manage events as follows.\n   *\n   * First, UI event listeners should set this property to `true` at the start\n   * of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.handlingUserInteraction] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.handlingUserInteraction] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.handlingUserInteraction]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   */\n  handlingUserInteraction: createSymbol('handlingUserInteraction'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: createSymbol('keydown'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLElement}\n   */\n  template: createSymbol('template')\n};\n\nexport default symbols;\n","/**\n * Helper function for standard classList.toggle() behavior on old browsers,\n * namely IE 11.\n *\n * The standard\n * [classlist](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)\n * object has a `toggle()` function that supports a second Boolean parameter\n * that can be used to succinctly turn a class on or off. This feature is often\n * useful in designing custom elements, which may want to externally reflect\n * component state in a CSS class that can be used for styling purposes.\n *\n * Unfortunately, IE 11 does not support the Boolean parameter to\n * `classList.toggle()`. This helper function behaves like the standard\n * `toggle()`, including support for the Boolean parameter, so that it can be\n * used even on IE 11.\n *\n * @function toggleClass\n * @param {HTMLElement} element - The element to modify\n * @param {string} className - The class to add/remove\n * @param {boolean} [force] - Force the class to be added (if true) or removed\n *                            (if false)\n */\nexport default function toggleClass(element, className, force) {\n  const classList = element.classList;\n  const addClass = (typeof force === 'undefined') ?\n    !classList.contains(className) :\n    force;\n  if (addClass) {\n    classList.add(className);\n  } else {\n    classList.remove(className);\n  }\n  return addClass;\n}\n","import AttributeMarshallingMixin from '../../basic-component-mixins/src/AttributeMarshallingMixin';\nimport ComposableMixin from '../../basic-component-mixins/src/ComposableMixin';\nimport DistributedChildrenMixin from '../../basic-component-mixins/src/DistributedChildrenMixin';\nimport ShadowElementReferencesMixin from '../../basic-component-mixins/src/ShadowElementReferencesMixin';\nimport ShadowTemplateMixin from '../../basic-component-mixins/src/ShadowTemplateMixin';\n\n\n/**\n * A sample general-purpose base class for defining custom elements that mixes\n * in some common features: template stamping into a shadow root, shadow element\n * references, marshalling attributes to properties, and retrieving the children\n * distributed to a component.\n *\n * This base class is not special in any way, and is defined only as a\n * convenient shorthand for applying the mixins listed above. You can use this\n * class as a base class for your own elements, or easily create your own base\n * class by applying the same set of mixins.\n *\n * The ElementBase base class does not register itself as a custom element with\n * the browser, and hence cannot be independently instantiated.\n *\n * @mixes AttributeMarshallingMixin\n * @mixes ComposableMixin\n * @mixes DistributedChildrenMixin\n * @mixes ShadowElementReferencesMixin\n * @mixes ShadowTemplateMixin\n */\nclass ElementBase extends ComposableMixin(HTMLElement).compose(\n  ShadowTemplateMixin,          // before node finding, so shadow root is populated\n  ShadowElementReferencesMixin, // before marshalling, so properties can use refs\n  AttributeMarshallingMixin,\n  DistributedChildrenMixin\n) {}\n\nexport default ElementBase;\n","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/*\n * A set of events which, if fired by the inner standard element, should be\n * re-raised by the custom element. (We only need to do that under native\n * Shadow DOM, not the polyfill.)\n *\n * These are events which are spec'ed to NOT get retargetted across a Shadow DOM\n * boundary, organized by which element(s) raise the events. To properly\n * simulate these, we will need to listen for the real events, then re-raise a\n * simulation of the original event. For more information, see\n * https://www.w3.org/TR/shadow-dom/#h-events-that-are-not-leaked-into-ancestor-trees.\n *\n * It appears that we do *not* need to re-raise the non-bubbling \"focus\" and\n * \"blur\" events. These appear to be automatically re-raised as expected -- but\n * it's not clear why that happens.\n *\n * The list below is reasonably complete. It omits elements that cannot be\n * wrapped (see class notes above). Also, we haven't actually tried wrapping\n * every element in this list; some of the more obscure ones might not actually\n * work as expected, but it was easier to include them for completeness than\n * to actually verify whether or not the element can be wrapped.\n */\nconst reraiseEvents = {\n  address: ['scroll'],\n  blockquote: ['scroll'],\n  caption: ['scroll'],\n  center: ['scroll'],\n  dd: ['scroll'],\n  dir: ['scroll'],\n  div: ['scroll'],\n  dl: ['scroll'],\n  dt: ['scroll'],\n  fieldset: ['scroll'],\n  form: ['reset', 'scroll'],\n  frame: ['load'],\n  h1: ['scroll'],\n  h2: ['scroll'],\n  h3: ['scroll'],\n  h4: ['scroll'],\n  h5: ['scroll'],\n  h6: ['scroll'],\n  iframe: ['load'],\n  img: ['abort', 'error', 'load'],\n  input: ['abort', 'change', 'error', 'select', 'load'],\n  keygen: ['reset', 'select'],\n  li: ['scroll'],\n  link: ['load'],\n  menu: ['scroll'],\n  object: ['error', 'scroll'],\n  ol: ['scroll'],\n  p: ['scroll'],\n  script: ['error', 'load'],\n  select: ['change', 'scroll'],\n  tbody: ['scroll'],\n  tfoot: ['scroll'],\n  thead: ['scroll'],\n  textarea: ['change', 'select', 'scroll']\n};\n\n\n// Keep track of which re-raised events should bubble.\nconst eventBubbles = {\n  abort: true,\n  change: true,\n  reset: true\n};\n\n\n// Elements which are display: block by default.\n// Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nconst blockElements = [\n  'address',\n  'article',\n  'aside',\n  'blockquote',\n  'canvas',\n  'dd',\n  'div',\n  'dl',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'header',\n  'hgroup',\n  'hr',\n  'li',\n  'main',\n  'nav',\n  'noscript',\n  'ol',\n  'output',\n  'p',\n  'pre',\n  'section',\n  'table',\n  'tfoot',\n  'ul',\n  'video'\n];\n\n\n/**\n * Wraps a standard HTML element so that the standard behavior can then be\n * extended.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-wrapped-standard-element/)\n *\n * See also [basic-autosize-textarea](../basic-autosize-textarea) and\n * [basic-current-anchor](../basic-current-anchor). The former uses\n * WrappedStandardElement to wrap a standard `<textarea>` and `<a>`,\n * respectively.\n *\n * The Custom Elements spec does not currently (as of March 2016) allow you to\n * extend the behavior of a standard HTML element like `<a>` or `<button>`.\n * As a partial workaround, the WrappedStandardElement class can create a class\n * for you that wraps an instance of a standard HTML element. For example, the\n * code below creates a class that will wrap an instance of a standard `<a>`\n * element:\n *\n *     class WrappedA extends WrappedStandardElement.wrap('a') {\n *       customMethod() { ... }\n *     }\n *     customElements.define('wrapped-a', WrappedA);\n *\n * An instance of the resulting class will look to the user like an instance of\n * the standard element class it wraps. The resulting class will *not* be an\n * `instanceof` the standard class (here, HTMLAnchorElement). Another limitation\n * is that the resulting `<wrapped-a>` will not automatically pick up CSS styles\n * for standard `<a>` elements. However, the resulting class *can* be extended.\n * E.g., instances of the above class have a `customMethod()` available to them.\n *\n * Any properties defined by the original standard element will be exposed on\n * the resulting wrapper class, and calls to get or set those properties will be\n * delegated to the wrapped element instance. Continuing the above example:\n *\n *     let wrapped = document.createElement('wrapped-a');\n *     wrapped.href = 'http://example.com/';\n *     wrapped.textContent = 'Click here';\n *\n * Here, the created custom `<wrapped-a>` element will contain inside its\n * shadow tree an instance of a standard `<a>` element. The call to set the\n * wrapper's `href` property will ultimately set the `href` on the inner link.\n * Moreover, the text content of the `<wrapped-a>` element will appear inside\n * the inner link. The result of all this is that the user will see what *looks*\n * like a normal link, just as if you had written\n * `<a href=\"http://example.com/\">Click here</a>`. However, the actual element\n * will be an instance of your custom class, with whatever behavior you've\n * defined for it.\n *\n * Wrapped elements should raise the same events as the original standard\n * elements. E.g., if you wrap an `<img>` element, the wrapped result will raise\n * the standard `load` event as expected.\n *\n * Some elements, such as `<body>`, `<html>`, and `<style>` cannot be wrapped\n * and still achieve their standard behavior.\n *\n * @extends ElementBase\n */\nclass WrappedStandardElement extends ElementBase {\n\n  constructor() {\n    super();\n\n    // Listen for any events raised by the inner element which will not\n    // automatically be retargetted across the Shadow DOM boundary, and re-raise\n    // those events when they happen.\n    //\n    // Note: It's unclear why we need to do this in the Shadow DOM polyfill.\n    // In theory, events in the light DOM should bubble as normal. But this\n    // code appears to be required in the polyfill case as well.\n    const eventNames = reraiseEvents[this.extends] || [];\n    eventNames.forEach(eventName => {\n      this.inner.addEventListener(eventName, realEvent => {\n        const event = new Event(eventName, {\n          bubbles: eventBubbles[eventName] || false\n        });\n        this.dispatchEvent(event);\n      });\n    });\n  }\n\n  /**\n   * A description for the user of the element's purpose on the page. Setting\n   * this applies the label to the inner element, ensuring that screen readers\n   * and other assistive technologies will provide a meaningful description to\n   * the user.\n   *\n   * @type {string}\n   */\n  get ariaLabel() {\n    return this.inner.getAttribute('aria-label');\n  }\n  set ariaLabel(label) {\n    // Propagate the ARIA label to the inner textarea.\n    this.inner.setAttribute('aria-label', label);\n  }\n\n  /**\n   * Returns a reference to the inner standard HTML element.\n   *\n   * @type {HTMLElement}\n   */\n  get inner() {\n    return this.$.inner;\n  }\n\n  /**\n   * The template copied into the shadow tree of new instances of this element.\n   *\n   * The default value of this property is a template that includes an instance\n   * the standard element being wrapped, with a `<slot>` element inside that\n   * to pick up the element's light DOM content. For example, if you wrap an\n   * `<a>` element, then the default template will look like:\n   *\n   *     <template>\n   *       <style>\n   *       :host {\n   *         display: inline-block;\n   *       }\n   *       </style>\n   *       <a id=\"inner\">\n   *         <slot></slot>\n   *       </a>\n   *     </template>\n   *\n   * The `display` styling applied to the host will be `block` for elements that\n   * are block elements by default, and `inline-block` (not `inline`) for other\n   * elements.\n   *\n   * If you'd like the template to include other elements, then override this\n   * property and return a template of your own. The template should include an\n   * instance of the standard HTML element you are wrapping, and the ID of that\n   * element should be \"inner\".\n   *\n   * @type {(string|HTMLTemplateElement)}\n   */\n  get [symbols.template]() {\n    const display = blockElements.indexOf(this.extends) >= 0 ?\n      'block' :\n      'inline-block';\n    return `<style>:host { display: ${display}}</style><${this.extends} id=\"inner\"><slot></slot></${this.extends}`;\n  }\n\n  /**\n   * Creates a class that wraps a standard HTML element.\n   *\n   * Note that the resulting class is a subclass of WrappedStandardElement, not\n   * the standard class being wrapped. E.g., if you call\n   * `WrappedStandardElement.wrap('a')`, you will get a class whose shadow tree\n   * will include an anchor element, but the class will *not* inherit from\n   * HTMLAnchorElement.\n   *\n   * @param {string} extendsTag - the standard HTML element tag to extend\n   */\n  static wrap(extendsTag) {\n\n    // Create the new class.\n    class Wrapped extends WrappedStandardElement {}\n\n    // Indicate which tag it wraps.\n    Wrapped.prototype.extends = extendsTag;\n\n    // Create getter/setters that delegate to the wrapped element.\n    const element = document.createElement(extendsTag);\n    const extendsPrototype = element.constructor.prototype;\n    const names = Object.getOwnPropertyNames(extendsPrototype);\n    names.forEach(name => {\n        const descriptor = Object.getOwnPropertyDescriptor(extendsPrototype, name);\n        const delegate = createPropertyDelegate(name, descriptor);\n        Object.defineProperty(Wrapped.prototype, name, delegate);\n    });\n\n    return Wrapped;\n  }\n\n}\n\n\nfunction createPropertyDelegate(name, descriptor) {\n  const delegate = {\n    configurable: descriptor.configurable,\n    enumerable: descriptor.enumerable,\n  };\n  if (descriptor.get) {\n    delegate.get = function() {\n      return this.inner[name];\n    };\n  }\n  if (descriptor.set) {\n    delegate.set = function(value) {\n      this.inner[name] = value;\n    };\n  }\n  if (descriptor.writable) {\n    delegate.writable = descriptor.writable;\n  }\n  return delegate;\n}\n\n\nexport default WrappedStandardElement;\n"]}