{"version":3,"sources":["node_modules/browser-pack/_prelude.js","packages/basic-animation-stage/src/AnimationStage.js","packages/basic-carousel/globals.js","packages/basic-carousel/src/Carousel.js","packages/basic-component-mixins/src/AttributeMarshallingMixin.js","packages/basic-component-mixins/src/ComposableMixin.js","packages/basic-component-mixins/src/ContentItemsMixin.js","packages/basic-component-mixins/src/DirectionSelectionMixin.js","packages/basic-component-mixins/src/DistributedChildrenContentMixin.js","packages/basic-component-mixins/src/DistributedChildrenMixin.js","packages/basic-component-mixins/src/FractionalSelectionMixin.js","packages/basic-component-mixins/src/HorizontalNavigationMixin.js","packages/basic-component-mixins/src/KeyboardDirectionMixin.js","packages/basic-component-mixins/src/KeyboardMixin.js","packages/basic-component-mixins/src/SelectionAnimationMixin.js","packages/basic-component-mixins/src/SelectionAriaActiveMixin.js","packages/basic-component-mixins/src/ShadowElementReferencesMixin.js","packages/basic-component-mixins/src/ShadowTemplateMixin.js","packages/basic-component-mixins/src/SingleSelectionMixin.js","packages/basic-component-mixins/src/SwipeDirectionMixin.js","packages/basic-component-mixins/src/TrackpadDirectionMixin.js","packages/basic-component-mixins/src/createSymbol.js","packages/basic-component-mixins/src/microtask.js","packages/basic-component-mixins/src/safeAttributes.js","packages/basic-component-mixins/src/symbols.js","packages/basic-component-mixins/src/toggleClass.js","packages/basic-element-base/src/ElementBase.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","_ElementBase","_ContentItemsMixin","_DistributedChildrenContentMixin","_FractionalSelectionMixin","_SelectionAnimationMixin","_SelectionAriaActiveMixin","_SingleSelectionMixin","_symbols","base","_ElementBase2","default","compose","_ContentItemsMixin2","_DistributedChildrenContentMixin2","_FractionalSelectionMixin2","_SelectionAnimationMixin2","_SelectionAriaActiveMixin2","_SingleSelectionMixin2","AnimationStage","_symbols2","defaults","_get","prototype","__proto__","Object","getPrototypeOf","this","selectionRequired","template","customElements","define","_Carousel","window","Basic","Carousel","_Carousel2","_AnimationStage","_HorizontalNavigationMixin","_AnimationStage2","_HorizontalNavigationMixin2","attributeToPropertyName","attributeName","propertyName","attributeToPropertyNames","hypenRegEx","replace","match","toUpperCase","attributesForClass","classFn","HTMLElement","baseClass","constructor","baseAttributes","propertyNames","getOwnPropertyNames","setterNames","filter","getOwnPropertyDescriptor","set","attributes","map","setterName","propertyNameToAttribute","diff","attribute","indexOf","concat","propertyNamesToAttributes","uppercaseRegEx","toLowerCase","_safeAttributes","AttributeMarshalling","_base","_classCallCheck","_possibleConstructorReturn","apply","arguments","_inherits","_createClass","key","value","oldValue","newValue","_safeAttributes2","connected","setAttribute","className","toggleClass","get","composeClass","mixin","Subclass","_base2","copyOwnProperties","NON_MIXABLE_OBJECT_PROPERTIES","source","target","ignorePropertyNames","undefined","forEach","name","descriptor","defineProperty","Composable","_len","mixins","Array","_key","reduce","filterAuxiliaryElements","items","auxiliaryTags","item","localName","_createSymbol","_toggleClass","itemsSymbol","_createSymbol2","itemInitializedSymbol","ContentItems","itemsChanged","itemAdded","itemSelected","selected","_toggleClass2","_this2","dispatchEvent","CustomEvent","content","DirectionSelection","goDown","selectNext","goEnd","selectLast","goLeft","selectPrevious","goRight","goStart","selectFirst","goUp","_set","selectedFraction","_microtask","DistributedChildrenContent","_this","shadowRoot","slots","querySelectorAll","slot","addEventListener","event","contentChanged","_microtask2","distributedChildren","console","warn","expandContentElements","nodes","includeTextNodes","_ref","expanded","node","isSlot","HTMLSlotElement","assignedNodes","flatten","Text","flattened","_toConsumableArray","DistributedChildren","children","childNodes","strings","distributedChildNodes","child","textContent","join","FractionalSelection","selectedFractionSymbol","helpers","dampedSelection","selection","itemCount","bound","damped","damping","x","y","elementSelection","element","selectedIndex","selectionParts","index","Math","ceil","floor","fraction","wrappedSelection","wrappedSelectionParts","wrap","_DirectionSelectionMixin","_KeyboardDirectionMixin","_KeyboardMixin","_SwipeDirectionMixin","_TrackpadDirectionMixin","_DirectionSelectionMixin2","_KeyboardMixin2","_KeyboardDirectionMixin2","_SwipeDirectionMixin2","_TrackpadDirectionMixin2","baseWithMixins","c","HorizontalNavigation","_baseWithMixins","navigationAxis","selectionAnimationEffect","navigationAxisSymbol","KeyboardDirection","keydown","handled","axis","horizontal","vertical","keyCode","metaKey","altKey","Keyboard","preventDefault","stopPropagation","getAttribute","tabindex","SelectionAnimation","selectionAnimationDuration","selectionAnimationKeyframes","dragging","_resetAnimations","renderSelection","draggingSymbol","previousValue","resetAnimationsOnNextRenderSymbol","selectionAnimationDurationSymbol","selectionAnimationEffectSymbol","standardEffectKeyframes","selectionAnimationKeyframesSymbol","animateSelection","fromSelection","toSelection","keyframes","playingAnimationSymbol","timings","effectTimingsForSelectionAnimation","selectionWraps","selectionIndex","totalSteps","stepsToIndex","forward","nextUpIndex","isItemIndexInBounds","lastAnimationDetails","timing","showItem","animation","animate","animationSymbol","endDelay","onfinish","selectionAnimationFinished","lastAnimationSymbol","getAnimationForItemIndex","duration","fill","pause","previousSelection","previousSelectionSymbol","renderSelectionInstantly","animationFractions","animationFractionsForSelection","animationFraction","setAnimationFraction","animations","cancel","details","itemIndex","currentTime","flag","style","visibility","allowWrap","steps","wrapSteps","abs","toIndex","direction","totalDuration","stepDuration","positionInSequence","delay","crossfade","opacity","reveal","transform","zIndex","revealWithFade","showAdjacent","slide","slideWithGap","idCount","SelectionAriaActive","role","id","baseId","itemId","removeAttribute","ShadowElementReferences","$","nodesWithIds","createTemplateWithInnerHTML","innerHTML","document","createElement","div","appendChild","shimTemplateStyles","tag","WebComponents","ShadowCSS","shimStyling","ShadowTemplate","ShadowDOMPolyfill","root","attachShadow","mode","clone","importNode","selectIndex","count","boundedIndex","max","min","previousIndex","trackSelectedItem","previousSelectedItem","selectedItem","indexInCurrentItems","previousSelectedIndex","newSelectedIndex","updatePossibleNavigations","canSelectNext","canSelectPrevious","canSelectNextSymbol","canSelectPreviousSymbol","selectionRequiredSymbol","selectionWrapsSymbol","externalSelectedIndexSymbol","externalSelectedItemSymbol","internalSelectedIndexSymbol","internalSelectedItemSymbol","SingleSelection","newIndex","previousCanSelectNext","previousCanSelectPrevious","hasItems","detail","String","isEventForPenOrPrimaryTouch","pointerType","isPrimary","touchEnd","clientX","clientY","deltaXSymbol","trackTo","travelFraction","deltaYSymbol","touchMove","previousXSymbol","previousYSymbol","touchStart","startXSymbol","width","offsetWidth","dragDistance","multiTouchSymbol","travelFractionSymbol","SwipeDirection","PointerEvent","touches","changedTouches","getComputedStyle","touchAction","postNavigate","wheelDistanceSymbol","postNavigateDelayCompleteSymbol","absorbDecelerationSymbol","setTimeout","POST_NAVIGATE_TIME","resetWheelTracking","lastDeltaXSymbol","lastWheelTimeoutSymbol","clearTimeout","sign","wheel","wheelTimedOut","WHEEL_TIME","deltaX","deltaY","acceleration","TrackpadDirection","createSymbol","description","Symbol","microtask","callback","callbacks","push","counter","executeCallbacks","shift","createTextNode","observer","MutationObserver","observe","characterData","setAttributeToElement","text","safeToSetAttributesSymbol","pendingAttributesSymbol","pendingClassesSymbol","_value","_toggleClass3","symbols","force","classList","addClass","contains","add","remove","_AttributeMarshallingMixin","_ComposableMixin","_DistributedChildrenMixin","_ShadowElementReferencesMixin","_ShadowTemplateMixin","ElementBase","_ComposableMixin2","_ShadowTemplateMixin2","_ShadowElementReferencesMixin2","_AttributeMarshallingMixin2","_DistributedChildrenMixin2"],"mappings":"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","file":"basic-carousel.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport ContentItemsMixin from '../../basic-component-mixins/src/ContentItemsMixin';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport FractionalSelectionMixin from '../../basic-component-mixins/src/FractionalSelectionMixin';\nimport SelectionAnimationMixin from '../../basic-component-mixins/src/SelectionAnimationMixin';\nimport SelectionAriaActiveMixin from '../../basic-component-mixins/src/SelectionAriaActiveMixin';\nimport SingleSelectionMixin from '../../basic-component-mixins/src/SingleSelectionMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\nconst base = ElementBase.compose(\n  ContentItemsMixin,\n  DistributedChildrenContentMixin,\n  FractionalSelectionMixin,\n  SelectionAnimationMixin,\n  SelectionAriaActiveMixin,\n  SingleSelectionMixin\n);\n\n/**\n * Presents a single item as selected, providing animated transitions when the\n * selection changes. The same animation can be shown at an arbitrary point,\n * generally used to reflect a user-controlled touch or trackpad drag operation\n * in progress.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-animation-stage/)\n *\n * This component is intended to be used as a programmatic rendering surface for\n * components which want to show transitional effects.\n *\n * The component uses [SelectionAnimationMixin](../basic-component-mixins/docs/SelectionAnimationMixin.md)\n * mixin, which in turn uses the Web Animations API. For use on browsers which\n * do not support that API natively, you will need to load the\n * [Web Animations polyfill](https://github.com/web-animations/web-animations-js).\n *\n * For a simpler component that exhibits only a sliding effect, but does not\n * require the Web Animations API, see [basic-sliding-viewport](../basic-sliding-viewport).\n *\n * @extends ElementBase\n * @mixes ContentItemsMixin\n * @mixes DistributedChildrenContentMixin\n * @mixes SelectionAnimationMixin\n * @mixes SelectionAriaActiveMixin\n * @mixes SingleSelectionMixin\n */\nclass AnimationStage extends base {\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.selectionRequired = true;\n    return defaults;\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        overflow: hidden;\n        position: relative;\n      }\n\n      #container ::slotted(*) {\n        height: 100%;\n        object-fit: contain;\n        position: absolute;\n        width: 100%;\n        will-change: transform;\n      }\n      </style>\n\n      <div id=\"container\" role=\"none\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n}\n\n\ncustomElements.define('basic-animation-stage', AnimationStage);\nexport default AnimationStage;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport Carousel from './src/Carousel';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.Carousel = Carousel;\n","import AnimationStage from '../../basic-animation-stage/src/AnimationStage';\nimport HorizontalNavigationMixin from '../../basic-component-mixins/src/HorizontalNavigationMixin';\n\n\n/**\n * Lets the user navigate laterally through a sequence of child elements.\n *\n * basic-carousel is an implementation of the carousel user interface pattern,\n * commonly used for navigating between images, pages, and other elements. This\n * pattern presents the user with a linear sequence of elements, only one of\n * which is shown at a time. The user can navigate to the next/previous element\n * with a variety of input methods.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-carousel/)\n *\n * The above demo is a plain carousel. It's often combined, however, with\n * mixins like\n * [ArrowSelectionMixin](../basic-component-mixins/docs/ArrowSelectionMixin.md),\n * [PageDotsMixin](../basic-component-mixins/docs/PageDotsMixin.md),\n * [TimerSelectionMixin](../basic-component-mixins/docs/TimerSelectionMixin.md).\n * For example, you can view a\n * [demo with arrows and page dots](http://basicwebcomponents.org/basic-web-components/packages/demos/carousel-with-arrows-and-dots.html).\n * See the specific mixins for other carousel demos.\n *\n * basic-carousel uses its children as the elements the user will navigate\n * through. In a typical use, a basic-carousel can be used to navigate between a\n * sequence of images:\n *\n *     <basic-carousel>\n *       <img src=\"image1.jpg\">\n *       <img src=\"image2.jpg\">\n *       <img src=\"image3.jpg\">\n *     </basic-carousel>\n *\n * The child elements can be of any type they are not restricted to images.\n *\n * This component attempts to meet the [Gold Standard for web components]\n * (https://github.com/webcomponents/gold-standard/wiki) so that it is generally\n * as flexible and robust as standard HTML elements. For example, it meets the\n * \"Content Changes\" criteria: the carousel will adapt to new child elements\n * added or removed at runtime.\n *\n * Currently, this component does not meet the Gold Standard criteria \"Size to\n * Content\". As a result, for the time being, **you must manually set a size on\n * this component**. Two approaches are to: 1) stretch the component across\n * whatever surface it is contained within, or 2) set it to be larger than the\n * largest child element you want to display. The former approach is more\n * common, and can be achieved with CSS styling such as:\n *\n *     html {\n *       height: 100%;\n *     }\n *\n *     body {\n *       display: -webkit-flex;\n *       display: flex;\n *       height: 100%;\n *       margin: 0;\n *     }\n *\n *     basic-carousel {\n *       -webkit-flex: 1;\n *       flex: 1;\n *     }\n *\n * The standard basic-carousel component supports navigation via the following\n * input methods:\n *\n * * Keyboard. When the carousel has focus, the user can press Left, Right,\n *   Home, or End. These navigate to the expected element.\n * * Touch. On mobile and other touch-enabled devices, the user can drag left or\n *   right.\n * * Trackpad. The user can swipe left or right on a trackpad to navigate.\n *\n * Because carousels are used in a wide variety of circumstances, by default\n * basic-carousel provides a minimal appearance and no separately interactive\n * elements such as arrow buttons on the side or dots along the bottom. Those\n * elements can be added by wrapping a Carousel in optional mixins:\n *\n * * [ArrowSelectionMixin](../basic-component-mixins/docs/ArrowSelectionMixin.md).\n *   Adds prominent left and right arrow buttons on the side of the carousel.\n * * [PageDotsMixin](../basic-component-mixins/docs/PageDotsMixin.md).\n *   Adds a series of small dots below the carousel to indicate the user's\n *   current position in the sequence.\n * * [TimerSelectionMixin](../basic-component-mixins/docs/TimerSelectionMixin.md).\n *   Advances to the next item on a timer.\n * * [TabStripMixin](../basic-tab-strip).\n *   Adds a strip of traditional tab buttons.\n *\n * See those components for more details, but in general you can construct a\n * common carousel with both arrow buttons and dots like so:\n *\n *     class MyCarousel extends\n *         ArrowSelectionMixin(PageDotsMixin(Carousel)) {}\n *     customElements.define('my-carousel', MyCarousel);\n *\n * For universal access, basic-carousel automatically adds a variety of\n * [ARIA](http://www.w3.org/WAI/intro/aria) properties to itself and to child\n * elements. This helps users navigate the sequence of elements in the carousel\n * using assistive technologies.\n *\n * @extends AnimationStage\n * @mixes HorizontalNavigationMixin\n */\nclass Carousel extends AnimationStage.compose(\n  HorizontalNavigationMixin\n) {}\n\ncustomElements.define('basic-carousel', Carousel);\nexport default Carousel;\n","import safeAttributes from './safeAttributes';\n\n\n// Memoized maps of attribute to property names and vice versa.\nconst attributeToPropertyNames = {};\nconst propertyNamesToAttributes = {};\n\n\n/* Exported function extends a base class with AttributeMarshalling. */\nexport default (base) => {\n\n  /**\n   * Mixin which marshalls attributes to properties and vice versa.\n   *\n   * If your component exposes a setter for a property, it's generally a good\n   * idea to let devs using your component be able to set that property in HTML\n   * via an element attribute. You can code that yourself by writing an\n   * `attributeChangedCallback`, or you can use this mixin to get a degree of\n   * automatic support.\n   *\n   * This mixin implements an `attributeChangedCallback` that will attempt to\n   * convert a change in an element attribute into a call to the corresponding\n   * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n   * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n   * respects that convention, automatically mapping the hyphenated attribute\n   * name to the corresponding camelCase property name.\n   *\n   * Example: You define a component using this mixin:\n   *\n   *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n   *       get fooBar() { return this._fooBar; }\n   *       set fooBar(value) { this._fooBar = value; }\n   *     }\n   *     customElements.define('my-element', MyElement);\n   *\n   * If someone then instantiates your component in HTML:\n   *\n   *     <my-element foo-bar=\"Hello\"></my-element>\n   *\n   * Then, after the element has been upgraded, the `fooBar` setter will\n   * automatically be invoked with the initial value \"Hello\".\n   *\n   * For the time being, this mixin only supports string-valued properties.\n   * If you'd like to convert string attributes to other types (numbers,\n   * booleans), you need to implement `attributeChangedCallback` yourself.\n   */\n  class AttributeMarshalling extends base {\n\n    /*\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n      const propertyName = attributeToPropertyName(attributeName);\n      // If the attribute name corresponds to a property name, set the property.\n      // Ignore standard HTMLElement properties handled by the DOM.\n      if (propertyName in this && !(propertyName in HTMLElement.prototype)) {\n        this[propertyName] = newValue;\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    static get observedAttributes() {\n      return attributesForClass(this);\n    }\n\n    /**\n     * Set/unset the attribute with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as an attribute. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes. A call to `reflectAttribute` during the constructor will\n     * be deferred until the element is connected to the document.\n     *\n     * @param {string} attribute - The name of the *attribute* (not property) to set.\n     * @param {object} value - The value to set. If null, the attribute will be removed.\n     */\n    reflectAttribute(attribute, value) {\n      return safeAttributes.setAttribute(this, attribute, value);\n    }\n\n    /**\n     * Set/unset the class with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as as class. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes, including the `class` attribute. A call to\n     * `reflectClass` during the constructor will be deferred until the element\n     * is connected to the document.\n     *\n     * @param {string} className - The name of the class to set.\n     * @param {object} value - True to set the class, false to remove it.\n     */\n    reflectClass(className, value) {\n      return safeAttributes.toggleClass(this, className, value);\n    }\n\n  }\n\n  return AttributeMarshalling;\n};\n\n\n// Convert hyphenated foo-bar attribute name to camel case fooBar property name.\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hypenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hypenRegEx,\n        match => match[1].toUpperCase());\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\nfunction attributesForClass(classFn) {\n\n  // We treat the element base classes as if they have no attributes, since we\n  // don't want to receive attributeChangedCallback for them.\n  if (classFn === HTMLElement || classFn === Object) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n  const baseAttributes = attributesForClass(baseClass);\n\n  // Get attributes for this class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter(propertyName =>\n    typeof Object.getOwnPropertyDescriptor(\n        classFn.prototype, propertyName).set === 'function');\n  const attributes = setterNames.map(setterName =>\n      propertyNameToAttribute(setterName));\n\n  // Merge.\n  const diff = attributes.filter(attribute =>\n      baseAttributes.indexOf(attribute) < 0);\n  return baseAttributes.concat(diff);\n}\n\n// Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, '-$1').toLowerCase();\n  }\n  return attribute;\n}\n","/* Exported function extends a base class with Composable. */\nexport default (base) => {\n\n  /**\n   * Mixin to make a class more easily composable with other mixins.\n   *\n   * This mixin contributes a `compose` method that applies a set of mixin\n   * functions and returns the resulting new class. This sugar can make the\n   * application of many mixins at once easier to read.\n   */\n  class Composable extends base {\n\n    /**\n     * Apply a set of mixin functions or mixin objects to the present class and\n     * return the new class.\n     *\n     * Instead of writing:\n     *\n     *     let MyClass = Mixin1(Mixin2(Mixin3(Mixin4(Mixin5(BaseClass)))));\n     *\n     * You can write:\n     *\n     *     let MyClass = ComposableMixin(BaseClass).compose(\n     *       Mixin1,\n     *       Mixin2,\n     *       Mixin3,\n     *       Mixin4,\n     *       Mixin5\n     *     );\n     *\n     * This function can also take mixin objects. A mixin object is just a\n     * shorthand for a mixin function that creates a new subclass with the given\n     * members. The mixin object's members are *not* copied directly onto the\n     * prototype of the base class, as with traditional mixins.\n     *\n     * In addition to providing syntactic sugar, this mixin can be used to\n     * define a class in ES5, which lacks ES6's `class` keyword.\n     *\n     * @param {...mixins} mixins - A set of mixin functions or objects to apply.\n     */\n    static compose(...mixins) {\n      // We create a new subclass for each mixin in turn. The result becomes\n      // the base class extended by any subsequent mixins. It turns out that\n      // we can use Array.reduce() to concisely express this, using the current\n      // object as the seed for reduce().\n      return mixins.reduce(composeClass, this);\n    }\n\n  }\n\n  return Composable;\n};\n\n\n// Properties defined by Object that we don't want to mixin.\nconst NON_MIXABLE_OBJECT_PROPERTIES = [\n  'constructor'\n];\n\n/*\n * Apply the mixin to the given base class to return a new class.\n * The mixin can either be a function that returns the modified class, or a\n * plain object whose members will be copied to the new class' prototype.\n */\nfunction composeClass(base, mixin) {\n  if (typeof mixin === 'function') {\n    // Mixin function\n    return mixin(base);\n  } else {\n    // Mixin object\n    class Subclass extends base {}\n    copyOwnProperties(mixin, Subclass.prototype, NON_MIXABLE_OBJECT_PROPERTIES);\n    return Subclass;\n  }\n}\n\n\n/*\n * Copy the given properties/methods to the target.\n * Return the updated target.\n */\nfunction copyOwnProperties(source, target, ignorePropertyNames = []) {\n  Object.getOwnPropertyNames(source).forEach(name => {\n    if (ignorePropertyNames.indexOf(name) < 0) {\n      const descriptor = Object.getOwnPropertyDescriptor(source, name);\n      Object.defineProperty(target, name, descriptor);\n    }\n  });\n  return target;\n}\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemsSymbol = createSymbol('items');\nconst itemInitializedSymbol = createSymbol('itemInitialized');\n\n\n/* Exported function extends a base class with ContentItems. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps content semantics (elements) to list item semantics.\n   *\n   * Items differ from element contents in several ways:\n   *\n   * * They are often referenced via index.\n   * * They may have a selection state.\n   * * It's common to do work to initialize the appearance or state of a new\n   *   item.\n   * * Auxiliary invisible child elements are filtered out and not counted as\n   *   items. Auxiliary elements include link, script, style, and template\n   *   elements. This filtering ensures that those auxiliary elements can be\n   *   used in markup inside of a list without being treated as list items.\n   *\n   * This mixin expects a component to provide a `content` property returning a\n   * raw set of elements. You can provide that yourself, or use\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md).\n   *\n   * The most commonly referenced property defined by this mixin is the `items`\n   * property. To avoid having to do work each time that property is requested,\n   * this mixin supports an optimized mode. If you invoke the `contentChanged`\n   * method when the set of items changes, the mixin concludes that you'll take\n   * care of notifying it of future changes, and turns on the optimization. With\n   * that on, the mixin saves a reference to the computed set of items, and will\n   * return that immediately on subsequent calls to the `items` property. If you\n   * use this mixin in conjunction with\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md), the\n   * `contentChanged` method will be invoked for you when the element's children\n   * change, turning on the optimization automatically.\n   */\n  class ContentItems extends base {\n\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n\n      // Since we got the contentChanged call, we'll assume we'll be notified if\n      // the set of items changes later. We turn on memoization of the items\n      // property by setting our internal property to null (instead of\n      // undefined).\n      this[itemsSymbol] = null;\n\n      this[symbols.itemsChanged]();\n    }\n\n    /**\n     * This method is invoked whenever a new item is added to the list.\n     *\n     * The default implementation of this method does nothing. You can override\n     * this to perform per-item initialization.\n     *\n     * @param {HTMLElement} item - The item that was added.\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n    }\n\n    /**\n     * The selection state for a single item has changed.\n     *\n     * Invoke this method to signal that the selected state of the indicated item\n     * has changed. By default, this applies a `selected` CSS class if the item\n     * is selected, and removed it if not selected.\n     *\n     * @param {HTMLElement} item - The item whose selection state has changed.\n     * @param {boolean} selected - True if the item is selected, false if not.\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      toggleClass(item, 'selected', selected);\n    }\n\n    /**\n     * The current set of items in the list. See the top-level documentation for\n     * mixin for a description of how items differ from plain content.\n     *\n     * @type {HTMLElement[]}\n     */\n    get items() {\n      let items;\n      if (this[itemsSymbol] == null) {\n        items = filterAuxiliaryElements(this.content);\n        // Note: test for *equality* with null; don't treat undefined as a match.\n        if (this[itemsSymbol] === null) {\n          // Memoize the set of items.\n          this[itemsSymbol] = items;\n        }\n      } else {\n        // Return the memoized items.\n        items = this[itemsSymbol];\n      }\n      return items;\n    }\n\n    /**\n     * This method is invoked when the underlying contents change. It is also\n     * invoked on component initialization  since the items have \"changed\" from\n     * being nothing.\n     */\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // Perform per-item initialization.\n      Array.prototype.forEach.call(this.items, item => {\n        if (!item[itemInitializedSymbol]) {\n          this[symbols.itemAdded](item);\n          item[itemInitializedSymbol] = true;\n        }\n      });\n\n      this.dispatchEvent(new CustomEvent('items-changed'));\n    }\n\n    /**\n     * Fires when the items in the list change.\n     *\n     * @memberof ContentItems\n     * @event items-changed\n     */\n  }\n\n  return ContentItems;\n};\n\n\n// Return the given elements, filtering out auxiliary elements that aren't\n// typically visible. Items which are not elements are returned as is.\nfunction filterAuxiliaryElements(items) {\n  const auxiliaryTags = [\n    'link',\n    'script',\n    'style',\n    'template'\n  ];\n  return [].filter.call(items, function(item) {\n    return !item.localName || auxiliaryTags.indexOf(item.localName) < 0;\n  });\n}\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with DirectionSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps direction semantics (goLeft, goRight, etc.) to selection\n   * semantics (selectPrevious, selectNext, etc.).\n   *\n   * This mixin can be used in conjunction with\n   * [KeyboardDirectionMixin](KeyboardDirectionMixin.md) (which maps keyboard\n   * events to directions) and a mixin that handles selection like\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class DirectionSelection extends base {\n\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { super[symbols.goDown](); }\n      return this.selectNext();\n    }\n\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { super[symbols.goEnd](); }\n      return this.selectLast();\n    }\n\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { super[symbols.goLeft](); }\n      return this.selectPrevious();\n    }\n\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { super[symbols.goRight](); }\n      return this.selectNext();\n    }\n\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { super[symbols.goStart](); }\n      return this.selectFirst();\n    }\n\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { super[symbols.goUp](); }\n      return this.selectPrevious();\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    get selectedFraction() {\n      return super.selectedFraction;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectFirst() {\n      if (super.selectFirst) { return super.selectFirst(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectLast() {\n      if (super.selectLast) { return super.selectLast(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectNext() {\n      if (super.selectNext) { return super.selectNext(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectPrevious() {\n      if (super.selectPrevious) { return super.selectPrevious(); }\n    }\n\n    // Map drag travel fraction to selection fraction.\n    get travelFraction() {\n      return super.travelFraction;\n    }\n    set travelFraction(value) {\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n      this.selectedFraction = value;\n    }\n\n  }\n\n  return DirectionSelection;\n};\n","import microtask from './microtask';\n\n\n/* Exported function extends a base class with DistributedChildrenContent. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines a component's content as its children, expanding any\n   * nodes distributed to the component's slots.\n   *\n   * This also provides notification of changes to a component's content. It\n   * will invoke a `contentChanged` method when the component is first\n   * instantiated, and whenever its distributed children change. This is an\n   * easy way to satisfy the Gold Standard checklist item for monitoring\n   * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n   *\n   * Example:\n   *\n   * ```\n   * let base = DistributedChildrenContentMixin(DistributedChildrenMixin(HTMLElement));\n   * class CountingElement extends base {\n   *\n   *   constructor() {\n   *     super();\n   *     let root = this.attachShadow({ mode: 'open' });\n   *     root.innerHTML = `<slot></slot>`;\n   *   }\n   *\n   *   contentChanged() {\n   *     // Count the component's children, both initially and when changed.\n   *     this.count = this.distributedChildren.length;\n   *   }\n   *\n   * }\n   * ```\n   *\n   * Note that content change detection depends upon the element having at least\n   * one `slot` element in its shadow subtree.\n   *\n   * This mixin is intended for use with the\n   * [DistributedChildrenMixin](DistributedChildrenMixin.md). See that mixin for\n   * a discussion of how that works. This DistributedChildrenContentMixin\n   * provides an easy way of defining the \"content\" of a component as the\n   * component's distributed children. That in turn lets mixins like\n   * [ContentItemsMixin](ContentItemsMixin.md) manipulate the children as list\n   * items.\n   */\n  class DistributedChildrenContent extends base {\n\n    constructor() {\n      super();\n\n      if (this.shadowRoot) {\n        // Listen to changes on all slots.\n        const slots = this.shadowRoot.querySelectorAll('slot');\n        slots.forEach(slot => slot.addEventListener('slotchange', event => {\n          this.contentChanged();\n        }));\n      }\n\n      // Make an initial call to contentChanged() so that the component can do\n      // initialization that it normally does when content changes.\n      //\n      // This will invoke contentChanged() handlers in other mixins. In order\n      // that those mixins have a chance to complete their own initialization,\n      // we add the contentChanged() call to the microtask queue.\n      microtask(() => this.contentChanged());\n    }\n\n    /**\n     * Invoked when the contents of the component (including distributed\n     * children) have changed.\n     *\n     * This method is also invoked when a component is first instantiated; the\n     * contents have essentially \"changed\" from being nothing. This allows the\n     * component to perform initial processing of its children.\n     */\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n      const event = new CustomEvent('content-changed');\n      this.dispatchEvent(event);\n    }\n\n    /**\n     * The content of this component, defined to be the flattened array of\n     * children distributed to the component.\n     *\n     * @type {HTMLElement[]}\n     */\n    get content() {\n      const distributedChildren = this.distributedChildren;\n      if (typeof distributedChildren === 'undefined') {\n        console.warn(`DistributedChildrenContentMixin expects the component to define a \"distributedChildren\" property.`);\n      }\n      return distributedChildren;\n    }\n    set content(value) {\n      if ('content' in base.prototype) { super.content = value; }\n      // TODO: Set the children to the given value (which should be an array of\n      // elements)?\n    }\n\n    /**\n     * This event is raised when the component's contents (including distributed\n     * children) have changed.\n     *\n     * @memberof DistributedChildrenContent\n     * @event content-changed\n     */\n  }\n\n  return DistributedChildrenContent;\n};\n","/* Exported function extends a base class with DistributedChildren. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines helpers for accessing a component's distributed\n   * children as a flattened array or string.\n   *\n   * The standard DOM API provides several ways of accessing child content:\n   * `children`, `childNodes`, and `textContent`. None of these functions are\n   * Shadow DOM aware. This mixin defines variations of those functions that\n   * *are* Shadow DOM aware.\n   *\n   * Example: you create a component `<count-children>` that displays a number\n   * equal to the number of children placed inside that component. If someone\n   * instantiates your component like:\n   *\n   *     <count-children>\n   *       <div></div>\n   *       <div></div>\n   *       <div></div>\n   *     </count-children>\n   *\n   * Then the component should show \"3\", because there are three children. To\n   * calculate the number of children, the component can just calculate\n   * `this.children.length`. However, suppose someone instantiates your\n   * component inside one of their own components, and puts a `<slot>` element\n   * inside your component:\n   *\n   *     <count-children>\n   *       <slot></slot>\n   *     </count-children>\n   *\n   * If your component only looks at `this.children`, it will always see exactly\n   * one child the `<slot>` element. But the user looking at the page will\n   * *see* any nodes distributed to that slot. To match what the user sees, your\n   * component should expand any `<slot>` elements it contains.\n   *\n   * That is the problem this mixin solves. After applying this mixin, your\n   * component code has access to `this.distributedChildren`, whose `length`\n   * will return the total number of all children distributed to your component\n   * in the composed tree.\n   *\n   * Note: The latest Custom Elements API design calls for a new function,\n   * `getAssignedNodes` that takes an optional `deep` parameter, that will solve\n   * this problem at the API level.\n   */\n  class DistributedChildren extends base {\n\n    /**\n     * An in-order collection of distributed children, expanding any slot\n     * elements. Like the standard children property, this skips text nodes.\n     *\n     * @type {HTMLElement[]}\n     */\n    get distributedChildren() {\n      return expandContentElements(this.children, false);\n    }\n\n    /**\n     * An in-order collection of distributed child nodes, expanding any slot\n     * elements. Like the standard childNodes property, this includes text\n     * nodes.\n     *\n     * @type {Node[]}\n     */\n    get distributedChildNodes() {\n      return expandContentElements(this.childNodes, true);\n    }\n\n    /**\n     * The concatenated text content of all distributed child nodes, expanding\n     * any slot elements.\n     *\n     * @type {string}\n     */\n    get distributedTextContent() {\n      const strings = this.distributedChildNodes.map(function(child) {\n        return child.textContent;\n      });\n      return strings.join('');\n    }\n\n  }\n\n  return DistributedChildren;\n};\n\n\n/*\n * Given a array of nodes, return a new array with any content elements expanded\n * to the nodes distributed to that content element. This rule is applied\n * recursively.\n *\n * If includeTextNodes is true, text nodes will be included, as in the\n * standard childNodes property; by default, this skips text nodes, like the\n * standard children property.\n */\nfunction expandContentElements(nodes, includeTextNodes) {\n  const expanded = Array.prototype.map.call(nodes, node => {\n    // We want to see if the node is an instanceof HTMLSlotELement, but\n    // that class won't exist if the browser that doesn't support native\n    // Shadow DOM and if the Shadow DOM polyfill hasn't been loaded. Instead,\n    // we do a simplistic check to see if the tag name is \"slot\".\n    const isSlot = typeof HTMLSlotElement !== 'undefined' ?\n      node instanceof HTMLSlotElement :\n      node.localName === 'slot';\n    if (isSlot) {\n      // Use the nodes assigned to this node instead.\n      const assignedNodes = node.assignedNodes({ flatten: true });\n      return assignedNodes ?\n        expandContentElements(assignedNodes, includeTextNodes) :\n        [];\n    } else if (node instanceof HTMLElement) {\n      // Plain element; use as is.\n      return [node];\n    } else if (node instanceof Text && includeTextNodes) {\n      // Text node.\n      return [node];\n    } else {\n      // Comment, processing instruction, etc.; skip.\n      return [];\n    }\n  });\n  const flattened = [].concat(...expanded);\n  return flattened;\n}\n","import createSymbol from './createSymbol';\n\n\n// Symbols for private data members on an element.\nconst selectedFractionSymbol = createSymbol('selectedFraction');\n\n\n/* Exported function extends a base class with FractionalSelection. */\nexport default function mixin(base) {\n\n  /**\n   * Adds support for fractional selection: treating a selection as a real\n   * number that combines an integer portion (an index into a list), and a\n   * fraction (indicating how far of the way we are to the next or previous\n   * item).\n   *\n   * This is useful in components that support incremental operations during\n   * dragging and swiping. Example: a carousel component has several items, and the\n   * currently selected item is item 3. The user begins swiping to the left,\n   * moving towards selecting item 4. Halfway through this operation, the\n   * fractional selection value is 3.5.\n   *\n   * This value permits communication between mixins like\n   * [SwipeDirectionMixin](./SwipeDirectionMixin.md) and\n   * [TrackpadDirectionMixin](./TrackpadDirectionMixin.md), which generate\n   * fractional selection values, and mixins like\n   * [SelectionAnimationMixin](./SelectionAnimationMixin.md), which can render\n   * selection at a fractional value.\n   */\n  class FractionalSelection extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      this.selectedFraction = 0;\n    }\n\n    /**\n     * A fractional value indicating how far the user has currently advanced to\n     * the next/previous item. E.g., a `selectedFraction` of 3.5 indicates the\n     * user is halfway between items 3 and 4.\n     *\n     * @type {number}\n     */\n    get selectedFraction() {\n      return this[selectedFractionSymbol];\n    }\n    set selectedFraction(value) {\n      this[selectedFractionSymbol] = value;\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      const event = new CustomEvent('selected-fraction-changed');\n      this.dispatchEvent(event);\n    }\n\n  }\n\n  return FractionalSelection;\n}\n\n\nmixin.helpers = {\n\n  /*\n   * Dampen a selection that goes past the beginning or end of a list. This is\n   * generally used to produce a visual effect of tension as the user tries to\n   * go further in a direction that has no more items.\n   *\n   * Example: suppose `itemCount` is 5, indicating a list of 5 items. The index of\n   * the last item is 4. If the `selection` parameter is 4.5, the user is trying\n   * to go past this last item. When a damping function is applied, the resulting\n   * value will be less than 4.5 (the actual value will be 4.25). When this\n   * selection state is rendered, the user will see that, each unit distance the\n   * drag travels has less and less visible effect. This is perceived as tension.\n   *\n   * @param {number} selection - A real number indicating a selection position\n   * @param {number} itemCount - An integer for the number of items in the list\n   * @returns {number} A real number representing the damped selection value.\n   */\n  dampedSelection(selection, itemCount) {\n    const bound = itemCount - 1;\n    let damped;\n    if (selection < 0) {\n      // Trying to go past beginning of list. Apply tension from the left edge.\n      damped = -mixin.helpers.damping(-selection);\n    } else if (selection >= bound) {\n      // Trying to go past end of list. Apply tension from the right edge.\n      damped = bound + mixin.helpers.damping(selection - bound);\n    } else {\n      // No damping required.\n      damped = selection;\n    }\n    return damped;\n  },\n\n  /*\n   * Calculate damping as a function of the distance past the minimum/maximum\n   * values.\n   *\n   * We want to asymptotically approach an absolute minimum of 1 unit\n   * below/above the actual minimum/maximum. This requires calculating a\n   * hyperbolic function.\n   *\n   * See http://www.wolframalpha.com/input/?i=y+%3D+-1%2F%28x%2B1%29+%2B+1\n   * for the one we use. The only portion of that function we care about is when\n   * x is zero or greater. An important consideration is that the curve be\n   * tangent to the diagonal line x=y at (0, 0). This ensures smooth continuity\n   * with the normal drag behavior, in which the visible sliding is linear with\n   * the distance the touchpoint has been dragged.\n   */\n  damping(x) {\n    const y = (-1 / (x + 1)) + 1;\n    return y;\n  },\n\n  /*\n   * Return the current fractional selection value for the given element.\n   *\n   * This simply adds the element's `selectedIndex` and `selectedFraction`\n   * properties.\n   *\n   * @param {HTMLElement} element - An element that supports selection\n   */\n  elementSelection(element) {\n    const selectedIndex = element.selectedIndex;\n    if (selectedIndex < 0) {\n      // No selection\n      return;\n    }\n    const selectedFraction = element.selectedFraction || 0;\n    return selectedIndex + selectedFraction;\n  },\n\n  /*\n   * Breaks a fractional selection into its integer and fractional parts.\n   *\n   * Example: if passed 3.5, this returns { index: 3, fraction: 5 }.\n   *\n   * @param {number} selection A real number representing a selection point\n   * @returns {object} - An object with an `index` property holding the\n   * selection's integer component, and a `fraction` property holding the\n   * selection's fractional component.\n   */\n  selectionParts(selection) {\n    // Stupid IE doesn't have Math.trunc.\n    // const index = Math.trunc(selection);\n    const index = selection < 0 ? Math.ceil(selection) : Math.floor(selection);\n    const fraction = selection - index;\n    return { index, fraction };\n  },\n\n  /*\n   * Returns a fractional selection point after accounting for wrapping, ensuring\n   * that the integer portion of the selection stays between 0 and `itemCount`-1.\n   * That is, the integer portion will always be a valid index into the list.\n   *\n   * Example of wrapping past the end of the list: if `selection` is 5.5 and\n   * `itemCount` is 5, this returns 0.5. Example of wrapping past the beginning of\n   * the list: if `selection` is 0.5 and `itemCount` is 5, this returns 4.5.\n   *\n   * @param {number} selection - A real number representing a selection point\n   * @param {number} itemCount - The number of items in the list\n   * @returns {number} - The result of wrapping the selection point\n   */\n  wrappedSelection(selection, itemCount) {\n    // Handles possibility of negative mod.\n    // See http://stackoverflow.com/a/18618250/76472\n    return ((selection % itemCount) + itemCount) % itemCount;\n  },\n\n  /*\n   * Return the parts of a selection, first wrapping if necessary.\n   *\n   * @param {number} selection  A real number representing a selection point\n   * @param {number} itemCount - The number of items in the list\n   * @param {boolean} wrap  True if the selection should wrap to stay within the\n   * list\n   * @returns {object}  The parts of the selection, using the same format as\n   * `selectionParts`.\n   */\n  wrappedSelectionParts(selection, itemCount, wrap) {\n    if (wrap) {\n      selection = mixin.helpers.wrappedSelection(selection, itemCount);\n    }\n    return mixin.helpers.selectionParts(selection);\n  }\n\n};\n","import DirectionSelectionMixin from '../../basic-component-mixins/src/DirectionSelectionMixin';\nimport KeyboardDirectionMixin from '../../basic-component-mixins/src/KeyboardDirectionMixin';\nimport KeyboardMixin from '../../basic-component-mixins/src/KeyboardMixin';\nimport SwipeDirectionMixin from '../../basic-component-mixins/src/SwipeDirectionMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\nimport TrackpadDirectionMixin from '../../basic-component-mixins/src/TrackpadDirectionMixin';\n\n\nexport default (base) => {\n\n  const mixins = [\n    DirectionSelectionMixin,\n    KeyboardMixin,\n    KeyboardDirectionMixin,\n    SwipeDirectionMixin,\n    TrackpadDirectionMixin\n  ];\n\n  // Don't assume base class uses ComposableMixin. Do composition by hand.\n  const baseWithMixins = mixins.reduce((c, mixin) => mixin(c), base);\n\n  /**\n   * @mixes KeyboardMixin\n   * @mixes KeyboardDirectionMixin\n   * @mixes SwipeDirectionMixin\n   * @mixes TrackpadDirectionMixin\n   */\n  class HorizontalNavigation extends baseWithMixins {\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.navigationAxis = 'horizontal';\n      defaults.selectionAnimationEffect = 'slideWithGap';\n      // defaults.selectionRequired = true;\n      return defaults;\n    }\n\n  }\n\n  return HorizontalNavigation;\n\n};\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst navigationAxisSymbol = createSymbol('navigationAxis');\n\n\n/* Exported function extends a base class with KeyboardDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps direction keys (Left, Right, etc.) to direction semantics\n   * (go left, go right, etc.).\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   *\n   * This mixin calls methods such as `goLeft` and `goRight`. You can define\n   * what that means by implementing those methods yourself. If you want to use\n   * direction keys to navigate a selection, use this mixin with\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n   */\n  class KeyboardDirection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.navigationAxis === 'undefined') {\n        this.navigationAxis = this[symbols.defaults].navigationAxis;\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.navigationAxis = 'both';\n      return defaults;\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate down.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { return super[symbols.goDown](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the end (e.g., of a list).\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { return super[symbols.goEnd](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the start (e.g., of a\n     * list). The default implementation of this method does nothing.\n     */\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { return super[symbols.goStart](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate up.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { return super[symbols.goUp](); }\n    }\n\n    /**\n     * Indicates the direction of permitted navigation with the keyboard.\n     *\n     * Accepted values are \"horizontal\", \"vertical\", or \"both\" (the default).\n     * If this property is \"horizontal\", the Up Arrow and Down Arrow keys will\n     * be ignored. Conversely, if this is \"vertical\", the Left Arrow and Right\n     * Arrow keys will be ignored.\n     *\n     * @type {string}\n     */\n    get navigationAxis() {\n      return this[navigationAxisSymbol];\n    }\n    set navigationAxis(value) {\n      this[navigationAxisSymbol] = value;\n      if ('navigationAxis' in base.prototype) { super.navigationAxis = value; }\n    }\n\n    [symbols.keydown](event) {\n      let handled;\n\n      const axis = this.navigationAxis;\n      const horizontal = (axis === 'horizontal' || axis === 'both');\n      const vertical = (axis === 'vertical' || axis === 'both');\n\n      // Ignore Left/Right keys when metaKey or altKey modifier is also pressed,\n      // as the user may be trying to navigate back or forward in the browser.\n      switch (event.keyCode) {\n        case 35: // End\n          handled = this[symbols.goEnd]();\n          break;\n        case 36: // Home\n          handled = this[symbols.goStart]();\n          break;\n        case 37: // Left\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goLeft]();\n          }\n          break;\n        case 38: // Up\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goStart]() : this[symbols.goUp]();\n          }\n          break;\n        case 39: // Right\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goRight]();\n          }\n          break;\n        case 40: // Down\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goEnd]() : this[symbols.goDown]();\n          }\n          break;\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n  }\n\n  return KeyboardDirection;\n};\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with Keyboard. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages the keydown handling for a component.\n   *\n   * This mixin handles several keyboard-related features.\n   *\n   * First, it wires up a single keydown event handler that can be shared by\n   * multiple mixins on a component. The event handler will invoke a `keydown`\n   * method with the event object, and any mixin along the prototype chain that\n   * wants to handle that method can do so.\n   *\n   * If a mixin wants to indicate that keyboard event has been handled, and that\n   * other mixins should *not* handle it, the mixin's `keydown` handler should\n   * return a value of true. The convention that seems to work well is that a\n   * mixin should see if it wants to handle the event and, if not, then ask the\n   * superclass to see if it wants to handle the event. This has the effect of\n   * giving the mixin that was applied last the first chance at handling a\n   * keyboard event.\n   *\n   * Example:\n   *\n   *     [symbols.keydown](event) {\n   *       let handled;\n   *       switch (event.keyCode) {\n   *         // Handle the keys you want, setting handled = true if appropriate.\n   *       }\n   *       // Prefer mixin result if it's defined, otherwise use base result.\n   *       return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n   *     }\n   *\n   * A second feature provided by this mixin is that it implicitly makes the\n   * component a tab stop if it isn't already, by setting `tabIndex` to 0. This\n   * has the effect of adding the component to the tab order in document order.\n   */\n  class Keyboard extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('keydown', event => {\n        const handled = this[symbols.keydown](event);\n        if (handled) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      });\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (this.getAttribute('tabindex') == null && this[symbols.defaults].tabindex !== null) {\n        this.setAttribute('tabindex', this[symbols.defaults].tabindex);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      // The default tab index is 0 (document order).\n      defaults.tabindex = 0;\n      return defaults;\n    }\n\n    /**\n     * Handle the indicated keyboard event.\n     *\n     * The default implementation of this method does nothing. This will\n     * typically be handled by other mixins.\n     *\n     * @param {KeyboardEvent} event - the keyboard event\n     * @return {boolean} true if the event was handled\n     */\n    [symbols.keydown](event) {\n      if (super[symbols.keydown]) { return super[symbols.keydown](event); }\n    }\n\n  }\n\n  return Keyboard;\n};\n","import createSymbol from './createSymbol';\nimport FractionalSelectionMixin from './FractionalSelectionMixin';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst animationSymbol = createSymbol('animation');\nconst draggingSymbol = createSymbol('dragging');\nconst lastAnimationSymbol = createSymbol('lastAnimation');\nconst playingAnimationSymbol = createSymbol('animatingSelection');\nconst previousSelectionSymbol = createSymbol('previousSelection');\nconst selectionAnimationDurationSymbol = createSymbol('selectionAnimationDuration');\nconst selectionAnimationEffectSymbol = createSymbol('selectionAnimationEffect');\nconst selectionAnimationKeyframesSymbol = createSymbol('selectionAnimationKeyframes');\nconst resetAnimationsOnNextRenderSymbol = createSymbol('resetAnimationsOnNextRender');\n\n\n/* Exported function extends a base class with SelectionAnimation. */\nexport default function mixin(base) {\n\n  /**\n   * Mixin which uses animation to show transitions between selection states.\n   *\n   * This mixin can be used by components that want to provide visible\n   * animations when changing the selection. For example, a carousel component\n   * may want to define a sliding animation effect shown when moving between\n   * items.\n   *\n   * The animation is defined by a `selectionAnimationKeyframes` property; see\n   * that property for details on how to define these keyframes. This animation\n   * will be used in two ways. First, when moving strictly between items, the\n   * animation will play smoothly to show the selection changing. Second, the\n   * animation can be used to render the selection at a fixed point in the\n   * transition between states. E.g., if the user pauses halfway through\n   * dragging an element using [SwipeDirectionMixin](SwipeDirectionMixin.md)\n   * or [TrackpadDirectionMixin](TrackpadDirectionMixin.md)s, then the selection\n   * animation will be shown at the point exactly halfway through.\n   *\n   * This mixin expects a component to provide an `items` array of all elements\n   * in the list, which can be provided via\n   * [ContentItemsMixin](ContentItemsMixin.md). This mixin also expects\n   * `selectedIndex` and `selectedItem` properties, which can be provided via\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   *\n   * This mixin supports a `selectionWraps` property. When true, the user can\n   * navigate forward from the last item in the list and wrap around to the\n   * first item, or navigate backward from the first item and wrap around to the\n   * last item.\n   *\n   * This mixin uses the Web Animations API. For use on browsers which\n   * do not support that API natively, you will need to load the\n   * [Web Animations polyfill](https://github.com/web-animations/web-animations-js).\n   */\n  class SelectionAnimation extends base {\n\n    constructor() {\n      super();\n\n      // Set defaults.\n      if (typeof this.selectionAnimationDuration === 'undefined') {\n        this.selectionAnimationDuration = this[symbols.defaults].selectionAnimationDuration;\n      }\n      if (typeof this.selectionAnimationEffect === 'undefined' && this.selectionAnimationKeyframes == null) {\n        this.selectionAnimationEffect = this[symbols.defaults].selectionAnimationEffect;\n      }\n\n      this[symbols.dragging] = false;\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionAnimationDuration = 250;\n      defaults.selectionAnimationEffect = 'slide';\n      return defaults;\n    }\n\n    /*\n     * Provide backing for the dragging property.\n     * Also, when a drag begins, reset the animations.\n     */\n    get [symbols.dragging]() {\n      return this[draggingSymbol];\n    }\n    set [symbols.dragging](value) {\n      const previousValue = this[symbols.dragging];\n      this[draggingSymbol] = value;\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n      if (value && !previousValue) {\n        // Have begun a drag.\n        this[resetAnimationsOnNextRenderSymbol] = true;\n      }\n    }\n\n    [symbols.itemAdded](item) {\n      // We mark new items in the list as explicitly visible to ARIA. Otherwise,\n      // when an item isn't visible on the screen, ARIA will assume the item is\n      // of no interest to the user, and leave it out of the accessibility tree.\n      // If the list contains 10 items, but only 3 are visible, a screen reader\n      // might then announce the list only has 3 items. To ensure that screen\n      // readers and other assistive technologies announce the correct total\n      // number of items, we explicitly mark all items as not hidden. This will\n      // expose them all in the accessibility tree, even the items which are\n      // currently not rendered.\n      //\n      // TODO: Generally speaking, this entire mixin assumes that the user can\n      // navigate through all items in a list. But an app could style an item as\n      // display:none or visibility:hidden because the user is not allowed to\n      // interact with that item at the moment. Support for this scenario should\n      // be added. This would entail changing all locations where a mixin\n      // function is counting items, iterating over the (visible) items, and\n      // showing or hiding items. Among other things, the code below to make\n      // items visible to ARIA would need to discriminate between items which\n      // are invisible because of animation state, or invisible because the user\n      // shouldn't interact with them.\n      item.setAttribute('aria-hidden', false);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      resetAnimations(this);\n\n      // TODO: Also reset our notion of the last rendered selection? This comes\n      // up when a DOM removal causes the selected item to change position.\n      // this[previousSelectionSymbol] = null;\n\n      renderSelection(this);\n    }\n\n    resetAnimations() {\n      resetAnimations(this);\n    }\n\n    /**\n     * A fractional value indicating how far the user has currently advanced to\n     * the next/previous item. E.g., a `selectedFraction` of 3.5 indicates the\n     * user is halfway between items 3 and 4.\n     *\n     * For more details, see [FractionalSelectionMixin](FractionalSelectionMixin.md)\n     * mixin.\n     *\n     * @type {number}\n     */\n    get selectedFraction() {\n      return super.selectedFraction || 0;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      renderSelection(this, this.selectedIndex, value);\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n      renderSelection(this, index, 0);\n    }\n\n    /**\n     * The duration of a selection animation in milliseconds.\n     *\n     * This measures the amount of time required for a selection animation to\n     * complete. This number remains constant, even if the number of items being\n     * animated increases.\n     *\n     * The default value is 250 milliseconds (a quarter a second).\n     *\n     * @type {number}\n     * @default 250\n     */\n    get selectionAnimationDuration() {\n      return this[selectionAnimationDurationSymbol];\n    }\n    set selectionAnimationDuration(value) {\n      this[selectionAnimationDurationSymbol] = value;\n      if ('selectionAnimationDuration' in base.prototype) { super.selectionAnimationDuration = value; }\n    }\n\n    /**\n     * The name of a standard selection animation effect.\n     *\n     * This is a shorthand for setting the `selectionAnimationKeyframes`\n     * property to standard keyframes. Supported string values:\n     *\n     * * \"crossfade\"\n     * * \"reveal\"\n     * * \"revealWithFade\"\n     * * \"showAdjacent\"\n     * * \"slide\"\n     * * \"slideWithGap\"\n     *\n     * @type {string}\n     * @default \"slide\"\n     */\n    get selectionAnimationEffect() {\n      return this[selectionAnimationEffectSymbol];\n    }\n    set selectionAnimationEffect(value) {\n      this[selectionAnimationEffectSymbol] = value;\n      if ('selectionAnimationEffect' in base.prototype) { super.selectionAnimationEffect = value; }\n      this.selectionAnimationKeyframes = mixin.standardEffectKeyframes[value];\n    }\n\n    /**\n     * The keyframes that define an animation that plays for an item when moving\n     * forward in the sequence.\n     *\n     * This is an array of CSS rules that will be applied. These are used as\n     * [keyframes](http://w3c.github.io/web-animations/#keyframes-section)\n     * to animate the item with the\n     * [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/animation).\n     *\n     * The animation represents the state of the next item as it moves from\n     * completely unselected (offstage, usually right), to selected (center\n     * stage), to completely unselected (offstage, usually left). The center time\n     * of the animation should correspond to the item's quiscent selected state,\n     * typically in the center of the stage and at the item's largest size.\n     *\n     * The default forward animation is a smooth slide at full size from right to\n     * left.\n     *\n     * When moving the selection backward, this animation is played in reverse.\n     *\n     * @type {cssRules[]}\n     */\n    get selectionAnimationKeyframes() {\n      // Standard animation slides left/right, keeps adjacent items out of view.\n      return this[selectionAnimationKeyframesSymbol];\n    }\n    set selectionAnimationKeyframes(value) {\n      this[selectionAnimationKeyframesSymbol] = value;\n      if ('selectionAnimationKeyframes' in base.prototype) { super.selectionAnimationKeyframes = value; }\n      resetAnimations(this);\n      renderSelection(this);\n    }\n\n    get selectionWraps() {\n      return super.selectionWraps;\n    }\n    set selectionWraps(value) {\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      resetAnimations(this);\n      renderSelection(this);\n    }\n  }\n\n  return SelectionAnimation;\n}\n\n\n// We expose helpers on the mixin function that we want to be able to unit test.\n// Since these are on the function, not on the class emitted by the function,\n// they don't end up getting exposed on actual element instances.\nmixin.helpers = {\n\n  /*\n   * Calculate the animation fractions for an element's items at the given\n   * selection point. This is used when rendering the element's selection state\n   * instantaneously.\n   *\n   * This function considers the selectedIndex parameter, which can be a whole\n   * or fractional number, and determines which items will be visible at that\n   * index. This function then calculates a corresponding animation fraction: a\n   * number between 0 and 1 indicating how far through the selection animation\n   * an item should be shown, or null if the item should not be visible at that\n   * selection index. These fractions are returned as an array, where the\n   * animation fraction at position N corresponds to how item N should be shown.\n   */\n  animationFractionsForSelection(element, selection) {\n\n    const items = element.items;\n    if (!items) {\n      return;\n    }\n\n    const itemCount = items.length;\n    const selectionWraps = element.selectionWraps;\n\n    return items.map((item, itemIndex) => {\n      // How many steps from the selection point to this item?\n      const steps = stepsToIndex(itemCount, selectionWraps, selection, itemIndex);\n      // To convert steps to animation fraction:\n      // steps      animation fraction\n      //  1         0     (stage right)\n      //  0         0.5   (center stage)\n      // -1         1     (stage left)\n      const animationFraction = (1 - steps) / 2;\n      return (animationFraction >= 0 && animationFraction <= 1) ?\n        animationFraction :\n        null; // Outside animation range\n    });\n  },\n\n  /*\n   * Calculate the animation timings that should be used to smoothly animate the\n   * element's items from one selection state to another.\n   *\n   * This returns an array of timings, where the timing at position N should be\n   * used to animate item N. If an item's timing is null, then that item should\n   * not take place in the animation, and should be hidden instead.\n   */\n  effectTimingsForSelectionAnimation(element, fromSelection, toSelection) {\n\n    const items = element.items;\n    if (!items) {\n      return;\n    }\n    const itemCount = items.length;\n    const selectionWraps = element.selectionWraps;\n    const toIndex = FractionalSelectionMixin.helpers.wrappedSelectionParts(toSelection, itemCount, selectionWraps).index;\n    const totalSteps = stepsToIndex(itemCount, selectionWraps, fromSelection, toSelection);\n    const direction = totalSteps >= 0 ? 'normal': 'reverse';\n    const fill = 'both';\n    const totalDuration = element.selectionAnimationDuration;\n    const stepDuration = totalSteps !== 0 ?\n      totalDuration * 2 / Math.ceil(Math.abs(totalSteps)) :\n      0;  // No steps required, animation will be instantenous.\n\n    const timings = items.map((item, itemIndex) => {\n      const steps = stepsToIndex(itemCount, selectionWraps, itemIndex, toSelection);\n      // If we include this item in the staggered sequence of animations we're\n      // creating, where would the item appear in the sequence?\n      let positionInSequence = totalSteps - steps;\n      if (totalSteps < 0) {\n        positionInSequence = -positionInSequence;\n      }\n      // So, is this item really included in the sequence?\n      if (Math.ceil(positionInSequence) >= 0 && positionInSequence <= Math.abs(totalSteps)) {\n        // Note that delay for first item will be negative. That will cause\n        // the animation to start halfway through, which is what we want.\n        const delay = stepDuration * (positionInSequence - 1)/2;\n        const endDelay = itemIndex === toIndex ?\n          -stepDuration/2 :   // Stop halfway through.\n          0;              // Play animation until end.\n        return { duration: stepDuration, direction, fill, delay, endDelay };\n      } else {\n        return null;\n      }\n    });\n\n    return timings;\n  }\n\n};\n\n\n// Keyframes for standard selection animation effects.\nmixin.standardEffectKeyframes = {\n\n  // Simple crossfade\n  crossfade: [\n    { opacity: 0 },\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n\n  // Reveal, as if sliding the top card off a deck of cards\n  reveal: [\n    { transform: 'translateX(0%)', zIndex: 0 },\n    { transform: 'translateX(0%)', zIndex: 1 },\n    { transform: 'translateX(-100%)', zIndex: 2 }\n  ],\n\n  // Google Photos-style reveal-with-fade animation\n  revealWithFade: [\n    { transform: 'translateX(0%) scale(0.75)', opacity: 0, zIndex: 0 },\n    { transform: 'translateX(0%) scale(1.0)', opacity: 1, zIndex: 1 },\n    { transform: 'translateX(-100%) scale(1.0)', opacity: 1, zIndex: 2 }\n  ],\n\n  // Carousel variant with a bit of off-stage elements showing\n  showAdjacent: [\n    { transform: 'translateX(78%) scale(0.7)', zIndex: 0 },\n    { transform: 'translateX(0%) scale(0.82)', zIndex: 1 },\n    { transform: 'translateX(-78%) scale(0.7)', zIndex: 0 }\n  ],\n\n  // Simple slide\n  slide: [\n    { transform: 'translateX(100%)' },\n    { transform: 'translateX(-100%)' }\n  ],\n\n  // Slide, with a gap between\n  slideWithGap: [\n    { transform: 'translateX(110%)' },\n    { transform: 'translateX(-110%)' }\n  ]\n\n};\n\n\n/*\n * Smoothly animate the selection between the indicated \"from\" and \"to\"\n * indices. The former can be a fraction, e.g., when the user releases a finger\n * to complete a touch drag, and the selection will snap to the closest whole\n * index.\n */\nfunction animateSelection(element, fromSelection, toSelection) {\n\n  resetAnimations(element);\n\n  // Calculate the animation timings.\n  const items = element.items;\n  const keyframes = element.selectionAnimationKeyframes;\n  element[playingAnimationSymbol] = true;\n  const timings = mixin.helpers.effectTimingsForSelectionAnimation(element, fromSelection, toSelection);\n\n  // Figure out which item will be the one *after* the one we're selecting.\n  const itemCount = items.length;\n  const selectionWraps = element.selectionWraps;\n  const selectionIndex = FractionalSelectionMixin.helpers.selectionParts(toSelection, itemCount, selectionWraps).index;\n  const totalSteps = stepsToIndex(itemCount, selectionWraps, fromSelection, toSelection);\n  const forward = totalSteps >= 0;\n  let nextUpIndex = selectionIndex + (forward ? 1 : - 1);\n  if (selectionWraps) {\n    nextUpIndex = FractionalSelectionMixin.helpers.wrappedSelection(nextUpIndex, itemCount);\n  } else if (!isItemIndexInBounds(element, nextUpIndex)) {\n    nextUpIndex = null; // At start/end of list; don't have a next item to show.\n  }\n\n  // Play the animations using those timings.\n  let lastAnimationDetails;\n  timings.forEach((timing, index) => {\n    const item = items[index];\n    if (timing) {\n      showItem(item, true);\n      const animation = item.animate(keyframes, timing);\n      element[animationSymbol][index] = animation;\n      if (index === nextUpIndex) {\n        // This item will be animated, so will already be in the desired state\n        // after the animation completes.\n        nextUpIndex = null;\n      }\n      if (timing.endDelay !== 0) {\n        // This is the animation for the item that will be left selected.\n        // We want to clean up when this animation completes.\n        lastAnimationDetails = { animation, index, timing, forward };\n      }\n    } else {\n      // This item doesn't participate in the animation.\n      showItem(item, false);\n    }\n  });\n\n  if (lastAnimationDetails != null) {\n    // Arrange for clean-up work to be performed.\n    lastAnimationDetails.nextUpIndex = nextUpIndex;\n    lastAnimationDetails.animation.onfinish = event => selectionAnimationFinished(element, lastAnimationDetails);\n    element[lastAnimationSymbol] = lastAnimationDetails.animation;\n  } else {\n    // Shouldn't happen -- we should always have at least one animation.\n    element[playingAnimationSymbol] = false;\n  }\n}\n\n\nfunction getAnimationForItemIndex(element, index) {\n  if (element[animationSymbol] == null) {\n    // Not ready yet;\n    return null;\n  }\n  let animation = element[animationSymbol][index];\n  if (!animation) {\n    const item = element.items[index];\n    animation = item.animate(element.selectionAnimationKeyframes, {\n      duration: element.selectionAnimationDuration,\n      fill: 'both'\n    });\n    animation.pause();\n    element[animationSymbol][index] = animation;\n  }\n  return animation;\n}\n\nfunction isItemIndexInBounds(element, index) {\n  return index >= 0 && element.items && index < element.items.length;\n}\n\n/*\n * Render the selection state of the element.\n *\n * This can be used to re-render a previous selection state (if the\n * selectedIndex param is omitted), render the selection instantly at a given\n * whole or fractional selection index, or animate to a given selection index.\n *\n * There are several distinct scenarios we need to cover:\n *\n * 1. Initial positioning, or repositioning after changing a property like\n *    selectionAnimationKeyframes that affects rendering.\n * 2. Animate on selectedIndex change. This should override any animation/swipe\n *    already in progress.\n * 3. Instantly render the current position of a drag operation in progress.\n * 4. Complete a drag operation. If the drag wasn't far enough to affect\n *    selection, we'll just be restoring the selectedFraction to 0.\n *\n * If the list does not wrap, any selection position outside the list's bounds\n * will be damped to produce a visual effect of tension.\n */\nfunction renderSelection(element, selectedIndex=element.selectedIndex, selectedFraction=element.selectedFraction) {\n  const itemCount = element.items ? element.items.length : 0;\n  if (itemCount === 0) {\n    // Nothing to render.\n    return;\n  }\n  if (selectedIndex < 0) {\n    // TODO: Handle no selection.\n    return;\n  }\n  let selection = selectedIndex + selectedFraction;\n  if (element.selectionWraps) {\n    // Apply wrapping to ensure consistent representation of selection.\n    selection = FractionalSelectionMixin.helpers.wrappedSelection(selection, itemCount);\n  } else {\n    // Apply damping if necessary.\n    selection = FractionalSelectionMixin.helpers.dampedSelection(selection, itemCount);\n  }\n  const previousSelection = element[previousSelectionSymbol];\n  // TODO: If an item changes position in the DOM, we end up animating from\n  // its old index to its new index, but we really don't want to animate at all.\n  if (!element[symbols.dragging] && previousSelection != null &&\n      previousSelection !== selection) {\n    // Animate selection from previous state to new state.\n    animateSelection(element, previousSelection, selection);\n  } else if (selectedFraction === 0 && element[playingAnimationSymbol]) {\n    // Already in process of animating to fraction 0. During that process,\n    // ignore subsequent attempts to renderSelection to fraction 0.\n    return;\n  } else {\n    // Render current selection state instantly.\n    renderSelectionInstantly(element, selection);\n  }\n  element[previousSelectionSymbol] = selection;\n}\n\n/*\n * Instantly render (don't animate) the element's items at the given whole or\n * fractional selection index.\n */\nfunction renderSelectionInstantly(element, toSelection) {\n  if (element[resetAnimationsOnNextRenderSymbol]) {\n    resetAnimations(element);\n    element[resetAnimationsOnNextRenderSymbol] = false;\n  }\n  const animationFractions = mixin.helpers.animationFractionsForSelection(element, toSelection);\n  animationFractions.map((animationFraction, index) => {\n    const item = element.items[index];\n    if (animationFraction != null) {\n      showItem(item, true);\n      setAnimationFraction(element, index, animationFraction);\n    } else {\n      showItem(item, false);\n    }\n  });\n}\n\n/*\n * We maintain an array containing an animation per item. This is used for two\n * reasons:\n *\n * * During a drag operation, we want to be able to reuse animations between\n *   drag updates.\n * * When a selection animation completes, we need to be able to leave the\n *   visibile items in a paused state. Later, we'll want to be able to clean up\n *   those animations.\n *\n * Note that this array is sparse: it will only hold up from 03 animations at\n * any given point.\n */\nfunction resetAnimations(element) {\n  const animations = element[animationSymbol];\n  if (animations) {\n    // Cancel existing animations to remove the effects they're applying.\n    animations.forEach((animation, index) => {\n      if (animation) {\n        animation.cancel();\n        animations[index] = null;\n      }\n    });\n  }\n  const itemCount = element.items ? element.items.length : 0;\n  if (!animations || animations.length !== itemCount) {\n    // Haven't animated before with this number of items; (re)create array.\n    element[animationSymbol] = new Array(itemCount);\n  }\n}\n\n/*\n * The last animation in our selection animation has completed. Clean up.\n */\nfunction selectionAnimationFinished(element, details) {\n\n  // When the last animation completes, show the next item in the direction\n  // we're going. Waiting to that until this point is a bit of a hack to avoid\n  // having a next item that's higher in the natural z-order obscure other items\n  // during animation.\n  const nextUpIndex = details.nextUpIndex;\n  if (nextUpIndex != null) {\n    if (element[animationSymbol][nextUpIndex]) {\n      // Cancel existing selection animation so we can construct a new one.\n      element[animationSymbol][nextUpIndex].cancel();\n      element[animationSymbol][nextUpIndex] = null;\n    }\n    const animationFraction = details.forward ? 0 : 1;\n    setAnimationFraction(element, nextUpIndex, animationFraction);\n    showItem(element.items[nextUpIndex], true);\n  }\n\n  element[lastAnimationSymbol].onfinish = null;\n  element[playingAnimationSymbol] = false;\n}\n\n/*\n * Pause the indicated animation and have it show the animation at the given\n * fraction (between 0 and 1) of the way through the animation.\n */\nfunction setAnimationFraction(element, itemIndex, fraction) {\n  const animation = getAnimationForItemIndex(element, itemIndex);\n  if (animation) {\n    const duration = element.selectionAnimationDuration;\n    if (duration) {\n      animation.currentTime = fraction * duration;\n    }\n  }\n}\n\nfunction showItem(item, flag) {\n  item.style.visibility = flag ? 'visible' : 'hidden';\n}\n\n/*\n * Figure out how many steps it will take to go from fromSelection to\n * toSelection. To go from item 3 to item 4 is one step.\n *\n * If wrapping is allowed, then going from the last item to the first will take\n * one step (forward), and going from the first item to the last will take one\n * step (backward).\n */\nfunction stepsToIndex(length, allowWrap, fromSelection, toSelection) {\n  let steps = toSelection - fromSelection;\n  // Wrapping only kicks in when list has more than 1 item.\n  if (allowWrap && length > 1) {\n    const wrapSteps = length - Math.abs(steps);\n    if (wrapSteps <= 1) {\n      // Special case\n      steps = steps < 0 ?\n        wrapSteps :   // Wrap forward from last item to first.\n        -wrapSteps;   // Wrap backward from first item to last.\n    }\n  }\n  return steps;\n}\n","import symbols from './symbols';\n\n\n// Used to assign unique IDs to item elements without IDs.\nlet idCount = 0;\n\n\n/* Exported function extends a base class with SelectionAriaActive. */\nexport default (base) => {\n\n  /**\n   * Mixin which treats the selected item in a list as the active item in ARIA\n   * accessibility terms.\n   *\n   * Handling ARIA selection state properly is actually quite complex:\n   *\n   * * The items in the list need to be indicated as possible items via an ARIA\n   *   `role` attribute value such as \"option\".\n   * * The selected item need to be marked as selected by setting the item's\n   *   `aria-selected` attribute to true *and* the other items need be marked as\n   *   *not* selected by setting `aria-selected` to false.\n   * * The outermost element with the keyboard focus needs to have attributes\n   *   set on it so that the selection is knowable at the list level via the\n   *   `aria-activedescendant` attribute.\n   * * Use of `aria-activedescendant` in turn requires that all items in the\n   *   list have ID attributes assigned to them.\n   *\n   * This mixin tries to address all of the above requirements. To that end,\n   * this mixin will assign generated IDs to any item that doesn't already have\n   * an ID.\n   *\n   * ARIA relies on elements to provide `role` attributes. This mixin will apply\n   * a default role of \"listbox\" on the outer list if it doesn't already have an\n   * explicit role. Similarly, this mixin will apply a default role of \"option\"\n   * to any list item that does not already have a role specified.\n   *\n   * This mixin expects a set of members that manage the state of the selection:\n   * `[symbols.itemSelected]`, `itemAdded`, and `selectedIndex`. You can\n   * supply these yourself, or do so via\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class SelectionAriaActive extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      // Set default ARIA role.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'listbox';\n      return defaults;\n    }\n\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n\n      if (!item.getAttribute('role')) {\n        // Assign a default ARIA role.\n        item.setAttribute('role', 'option');\n      }\n\n      // Ensure each item has an ID so we can set aria-activedescendant on the\n      // overall list whenever the selection changes.\n      //\n      // The ID will take the form of a base ID plus a unique integer. The base\n      // ID will be incorporate the component's own ID. E.g., if a component has\n      // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n      // the compnent has no ID itself, its items will get IDs that look like\n      // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n      // them from manually-assigned IDs, and to minimize the potential for ID\n      // conflicts.\n      if (!item.id) {\n        const baseId = this.id ?\n            \"_\" + this.id + \"Option\" :\n            \"_option\";\n        item.id = baseId + idCount++;\n      }\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      item.setAttribute('aria-selected', selected);\n      const itemId = item.id;\n      if (itemId && selected) {\n        this.setAttribute('aria-activedescendant', itemId);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item == null) {\n        // Selection was removed.\n        this.removeAttribute('aria-activedescendant');\n      }\n    }\n\n  }\n\n  return SelectionAriaActive;\n};\n","/* Exported function extends a base class with ShadowElementReferences. */\nexport default (base) => {\n\n  /**\n   * Mixin to create references to elements in a component's Shadow DOM subtree.\n   *\n   * This adds a member on the component called `this.$` that can be used to\n   * reference shadow elements with IDs. E.g., if component's shadow contains an\n   * element `<button id=\"foo\">`, then this mixin will create a member\n   * `this.$.foo` that points to that button.\n   *\n   * Such references simplify a component's access to its own elements. In\n   * exchange, this mixin trades off a one-time cost of querying all elements in\n   * the shadow tree instead of paying an ongoing cost to query for an element\n   * each time the component wants to inspect or manipulate it.\n   *\n   * This mixin expects the component to define a Shadow DOM subtree. You can\n   * create that tree yourself, or make use of\n   * [ShadowTemplateMixin](ShadowTemplateMixin.md).\n   *\n   * This mixin is inspired by Polymer's [automatic\n   * node finding](https://www.polymer-project.org/1.0/docs/devguide/local-dom.html#node-finding)\n   * feature.\n   */\n  class ShadowElementReferences extends base {\n\n    constructor() {\n      super();\n      if (this.shadowRoot) {\n        // Look for elements in the shadow subtree that have id attributes.\n        // An alternatively implementation of this mixin would be to just define\n        // a this.$ getter that lazily does this search the first time someone\n        // tries to access this.$. That might introduce some complexity  if the\n        // the tree changed after it was first populated, the result of\n        // searching for a node might be somewhat unpredictable.\n        this.$ = {};\n        const nodesWithIds = this.shadowRoot.querySelectorAll('[id]');\n        [].forEach.call(nodesWithIds, node => {\n          const id = node.getAttribute('id');\n          this.$[id] = node;\n        });\n      }\n    }\n\n    /**\n     * The collection of references to the elements with IDs in a component's\n     * Shadow DOM subtree.\n     *\n     * @type {object}\n     * @member $\n     */\n  }\n\n  return ShadowElementReferences;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with ShadowTemplate. */\nexport default (base) => {\n\n  /**\n   * Mixin for stamping a template into a Shadow DOM subtree upon component\n   * instantiation.\n   *\n   * To use this mixin, define a `template` property as a string or HTML\n   * `<template>` element:\n   *\n   *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n   *       get [symbols.template]() {\n   *         return `Hello, <em>world</em>.`;\n   *       }\n   *     }\n   *\n   * When your component class is instantiated, a shadow root will be created on\n   * the instance, and the contents of the template will be cloned into the\n   * shadow root. If your component does not define a `template` property, this\n   * mixin has no effect.\n   *\n   * For the time being, this extension retains support for Shadow DOM v0. That\n   * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n   * implement Shadow DOM v1.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n      let template = this[symbols.template];\n      // TODO: Save the processed template with the component's class prototype\n      // so it doesn't need to be processed with every instantiation.\n      if (template) {\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          template = createTemplateWithInnerHTML(template);\n        }\n\n        if (window.ShadowDOMPolyfill) {\n          shimTemplateStyles(template, this.localName);\n        }\n\n        const root = this.attachShadow({ mode: 'open' });\n        const clone = document.importNode(template.content, true);\n        root.appendChild(clone);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n};\n\n\n// Convert a plain string of HTML into a real template element.\nfunction createTemplateWithInnerHTML(innerHTML) {\n  const template = document.createElement('template');\n  // REVIEW: Is there an easier way to do this?\n  // We'd like to just set innerHTML on the template content, but since it's\n  // a DocumentFragment, that doesn't work.\n  const div = document.createElement('div');\n  div.innerHTML = innerHTML;\n  while (div.childNodes.length > 0) {\n    template.content.appendChild(div.childNodes[0]);\n  }\n  return template;\n}\n\n// Invoke basic style shimming with ShadowCSS.\nfunction shimTemplateStyles(template, tag) {\n  window.WebComponents.ShadowCSS.shimStyling(template.content, tag);\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = createSymbol('canSelectNext');\nconst canSelectPreviousSymbol = createSymbol('canSelectPrevious');\nconst selectionRequiredSymbol = createSymbol('selectionRequired');\nconst selectionWrapsSymbol = createSymbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = createSymbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = createSymbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = createSymbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = createSymbol('internalSelectedItem');\n\n\n/* Exported function extends a base class with SingleSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages single-selection semantics for items in a list.\n   *\n   * This mixin expects a component to provide an `items` Array or NodeList of\n   * all elements in the list. A standard way to do that with is the\n   * [ContentItemsMixin](ContentItemsMixin.md), which takes a component's\n   * content (typically its distributed children) as the set of list items; see\n   * that mixin for details.\n   *\n   * This mixin tracks a single selected item in the list, and provides means to\n   * get and set that state by item position (`selectedIndex`) or item identity\n   * (`selectedItem`). The selection can be moved in the list via the methods\n   * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n   *\n   * This mixin does not produce any user-visible effects to represent\n   * selection. Other mixins, such as\n   * [SelectionAriaActiveMixin](SelectionAriaActiveMixin.md),\n   * [SelectionHighlightMixin](SelectionHighlightMixin.md) and\n   * [SelectionInViewMixin](SelectionInViewMixin.md), modify the selected item\n   * in common ways to let the user know a given item is selected or not\n   * selected.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const previousCanSelectNext = this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (canSelectNext !== previousCanSelectNext) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const previousCanSelectPrevious = this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (canSelectPrevious !== previousCanSelectPrevious) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedIndex = this[internalSelectedIndexSymbol];\n      let item;\n      if (index !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && index >= 0 && index < items.length)) {\n          index = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = index;\n        item = hasItems && index >= 0 ? items[index] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (index !== previousSelectedIndex) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = index;\n\n        const event = new CustomEvent('selected-index-changed', {\n          detail: {\n            selectedIndex: index,\n            value: index // for Polymer binding. TODO: Verify still necessary\n          }\n        });\n        this.dispatchEvent(event);\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (item !== previousSelectedItem) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        const event = new CustomEvent('selected-item-changed', {\n          detail: {\n            selectedItem: item,\n            value: item // for Polymer binding\n          }\n        });\n        this.dispatchEvent(event);\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      this[selectionRequiredSymbol] = selectionRequired;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      trackSelectedItem(this);\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(value) {\n      this[selectionWrapsSymbol] = String(value) === 'true';\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Select the last item in the list.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the selectedItem property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     * @param {HTMLElement} detail.previousItem The previously selected item.\n     */\n\n    /**\n     * Fires when the selectedIndex property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n  }\n\n  return SingleSelection;\n};\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n  const count = element.items.length;\n\n  const boundedIndex = (element.selectionWraps) ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst deltaXSymbol = createSymbol('deltaX');\nconst deltaYSymbol = createSymbol('deltaY');\nconst multiTouchSymbol = createSymbol('multiTouch');\nconst previousXSymbol = createSymbol('previousX');\nconst previousYSymbol = createSymbol('previousY');\nconst startXSymbol = createSymbol('startX');\nconst travelFractionSymbol = createSymbol('travelFraction');\n\n\n/* Exported function extends a base class with SwipeDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps touch gestures (swipe left, swipe right) to direction\n   * semantics (go right, go left).\n   *\n   * By default, this mixin presents no user-visible effects; it just indicates\n   * a direction in which the user is currently swiping or has finished swiping.\n   * To map the direction to a change in selection, use\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n   */\n  class SwipeDirection extends base {\n\n    constructor() {\n      super();\n\n      this.travelFraction = 0;\n\n      // In all touch events, only handle single touches. We don't want to\n      // inadvertently do work when the user's trying to pinch-zoom for example.\n      // TODO: Even better approach than below would be to ignore touches after\n      // the first if the user has already begun a swipe.\n      // TODO: Touch events should probably be factored out into its own mixin.\n      if (window.PointerEvent) {\n        // Prefer listening to standard pointer events.\n        this.addEventListener('pointerdown', event => {\n          if (isEventForPenOrPrimaryTouch(event)) {\n            touchStart(this, event.clientX, event.clientY);\n          }\n        });\n        this.addEventListener('pointermove', event => {\n          if (isEventForPenOrPrimaryTouch(event)) {\n            const handled = touchMove(this, event.clientX, event.clientY);\n            if (handled) {\n              event.preventDefault();\n            }\n          }\n        });\n        this.addEventListener('pointerup', event => {\n          if (isEventForPenOrPrimaryTouch(event)) {\n            touchEnd(this, event.clientX, event.clientY);\n          }\n        });\n      } else {\n        // Pointer events not supported -- listen to older touch events.\n        this.addEventListener('touchstart', event => {\n          if (this[multiTouchSymbol]) {\n            return;\n          } else if (event.touches.length === 1) {\n            const clientX = event.changedTouches[0].clientX;\n            const clientY = event.changedTouches[0].clientY;\n            touchStart(this, clientX, clientY);\n          } else {\n            this[multiTouchSymbol] = true;\n          }\n        });\n        this.addEventListener('touchmove', event => {\n          if (!this[multiTouchSymbol] && event.touches.length === 1) {\n            const clientX = event.changedTouches[0].clientX;\n            const clientY = event.changedTouches[0].clientY;\n            const handled = touchMove(this, clientX, clientY);\n            if (handled) {\n              event.preventDefault();\n            }\n          }\n        });\n        this.addEventListener('touchend', event => {\n          if (event.touches.length === 0) {\n            // All touches removed; gesture is complete.\n            if (!this[multiTouchSymbol]) {\n              // Single-touch swipe has finished.\n              const clientX = event.changedTouches[0].clientX;\n              const clientY = event.changedTouches[0].clientY;\n              touchEnd(this, clientX, clientY);\n            }\n            this[multiTouchSymbol] = false;\n          }\n        });\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // For the component to receive PointerEvents in IE/Edge, we need to set\n      // touch-action: none. Only make this change if touch-action is currently\n      // the default value (\"auto\"), in case the developer knows better than we\n      // do what they want in their particular context.\n      if (getComputedStyle(this).touchAction === 'auto') {\n        this.style.touchAction = 'none';\n      }\n    }\n\n    // Default implementation.\n    get [symbols.dragging]() {\n      return super[symbols.dragging];\n    }\n    set [symbols.dragging](value) {\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * The distance the first touchpoint has traveled since the beginning of a\n     * drag, expressed as a fraction of the element's width.\n     *\n     * @type number\n     */\n    get travelFraction() {\n      return this[travelFractionSymbol];\n    }\n    set travelFraction(value) {\n      this[travelFractionSymbol] = value;\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n    }\n\n  }\n\n  return SwipeDirection;\n};\n\n\n// Return true if the pointer event is for the pen, or the primary touch point.\nfunction isEventForPenOrPrimaryTouch(event) {\n  return event.pointerType === 'pen' ||\n      (event.pointerType === 'touch' && event.isPrimary);\n}\n\n/*\n * Invoked when the user has finished a touch operation.\n */\nfunction touchEnd(element, clientX, clientY) {\n  element[symbols.dragging] = false;\n  if (element[deltaXSymbol] >= 20) {\n    // Finished going right at high speed.\n    element[symbols.goLeft]();\n  } else if (element[deltaXSymbol] <= -20) {\n    // Finished going left at high speed.\n    element[symbols.goRight]();\n  } else {\n    // Finished at low speed.\n    trackTo(element, clientX);\n    const travelFraction = element.travelFraction;\n    if (travelFraction >= 0.5) {\n      element[symbols.goRight]();\n    } else if (travelFraction <= -0.5) {\n      element[symbols.goLeft]();\n    }\n  }\n  element.travelFraction = 0;\n  element[deltaXSymbol] = null;\n  element[deltaYSymbol] = null;\n}\n\n/*\n * Invoked when the user has moved during a touch operation.\n */\nfunction touchMove(element, clientX, clientY) {\n\n  element[deltaXSymbol] = clientX - element[previousXSymbol];\n  element[deltaYSymbol] = clientY - element[previousYSymbol];\n  element[previousXSymbol] = clientX;\n  element[previousYSymbol] = clientY;\n  if (Math.abs(element[deltaXSymbol]) > Math.abs(element[deltaYSymbol])) {\n    // Move was mostly horizontal.\n    trackTo(element, clientX);\n    // Indicate that the event was handled. It'd be nicer if we didn't have\n    // to do this so that, e.g., a user could be swiping left and right\n    // while simultaneously scrolling up and down. (Native touch apps can do\n    // that.) However, Mobile Safari wants to handle swipe events near the\n    // page and interpret them as navigations. To avoid having a horiziontal\n    // swipe misintepreted as a navigation, we indicate that we've handled\n    // the event, and prevent default behavior.\n    return true;\n  } else {\n    // Move was mostly vertical.\n    return false; // Not handled\n  }\n}\n\n/*\n * Invoked when the user has begun a touch operation.\n */\nfunction touchStart(element, clientX, clientY) {\n  element[symbols.dragging] = true;\n  element[startXSymbol] = clientX;\n  element[previousXSymbol] = clientX;\n  element[previousYSymbol] = clientY;\n  element[deltaXSymbol] = 0;\n  element[deltaYSymbol] = 0;\n}\n\nfunction trackTo(element, x) {\n  const width = element.offsetWidth;\n  const dragDistance = element[startXSymbol] - x;\n  const fraction = width > 0 ?\n    dragDistance / width :\n    0;\n  element.travelFraction = fraction;\n}\n","import createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst absorbDecelerationSymbol = createSymbol('absorbDeceleration');\nconst lastDeltaXSymbol = createSymbol('lastDeltaX');\nconst lastWheelTimeoutSymbol = createSymbol('lastWheelTimeout');\nconst postNavigateDelayCompleteSymbol = createSymbol('postNavigateDelayComplete');\nconst wheelDistanceSymbol = createSymbol('wheelDistance');\n\n\n/* Exported function extends a base class with TrackpadDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps a horizontal trackpad swipe gestures (or horizontal mouse\n   * wheel actions) to direction semantics.\n   *\n   * You can use this mixin with a mixin like\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md) to let the user\n   * change the selection with the trackpad or mouse wheel.\n   *\n   * To respond to the trackpad, we can listen to the DOM's \"wheel\" events.\n   * These events are fired as the user drags their fingers across a trackpad.\n   * Unfortunately, browsers are missing a critical event there is no event\n   * when the user *stops* a gestured on the trackpad or mouse wheel.\n   *\n   * To make things worse, the mainstream browsers continue to generate fake\n   * wheel events even after the user has stopped dragging their fingers. These\n   * fake events simulate the user gradually slowing down the drag until they\n   * come to a smooth stop. In some contexts, these fake wheel events might be\n   * helpful, but in trying to supply typical trackpad swipe navigation, these\n   * fake events get in the way.\n   *\n   * This component uses heuristics to work around these problems, but the\n   * complex nature of the problem make it extremely difficult to achieve the\n   * same degree of trackpad responsiveness possible with native applications.\n   */\n  class TrackpadDirection extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('wheel', event => {\n        const handled = wheel(this, event);\n        if (handled) {\n          event.preventDefault();\n        }\n      });\n      resetWheelTracking(this);\n    }\n\n    // Default implementation.\n    get [symbols.dragging]() {\n      return super[symbols.dragging];\n    }\n    set [symbols.dragging](value) {\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * The distance the user has moved the first touchpoint since the beginning\n     * of a trackpad/wheel operation, expressed as a fraction of the element's\n     * width.\n     *\n     * @type number\n     */\n    get travelFraction() {\n      return super.travelFraction;\n    }\n    set travelFraction(value) {\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n    }\n\n  }\n\n  return TrackpadDirection;\n};\n\n\n// Time we wait following a navigation before paying attention to wheel\n// events again.\nconst POST_NAVIGATE_TIME = 250;\n\n// Time we wait after the last wheel event before we reset things.\nconst WHEEL_TIME = 100;\n\n\n// Following a navigation, partially reset our wheel tracking.\nfunction postNavigate(element) {\n  element.travelFraction = 0;\n  element[wheelDistanceSymbol] = 0;\n  element[postNavigateDelayCompleteSymbol] = true;\n  element[absorbDecelerationSymbol] = true;\n  setTimeout(() => {\n    element[postNavigateDelayCompleteSymbol] = false;\n  }, POST_NAVIGATE_TIME);\n}\n\n// Reset all state related to the tracking of the wheel.\nfunction resetWheelTracking(element) {\n  element.travelFraction = 0;\n  element[wheelDistanceSymbol] = 0;\n  element[lastDeltaXSymbol] = 0;\n  element[absorbDecelerationSymbol] = false;\n  element[postNavigateDelayCompleteSymbol] = false;\n  if (element[lastWheelTimeoutSymbol]) {\n    clearTimeout(element[lastWheelTimeoutSymbol]);\n    element[lastWheelTimeoutSymbol] = null;\n  }\n}\n\n// Define our own sign function, since (as of May 2015), Safari and IE don't\n// supply Math.sign().\nfunction sign(x) {\n  return (x === 0) ?\n    0 :\n    (x > 0) ?\n      1 :\n      -1;\n}\n\n// TODO: Damping, or some other treatment for going past the ends.\n\n/*\n * A wheel event has been generated. This could be a real wheel event, or it\n * could be fake (see notes in the header).\n *\n * This handler uses several strategies to try to approximate native trackpad\n * swipe navigation.\n *\n * If the user has dragged enough to cause a navigation, then for a short\n * delay following that navigation, subsequent wheel events will be ignored.\n *\n * Furthermore, follwowing a navigation, we ignore all wheel events until we\n * receive at least one event where the event's deltaX (distance traveled) is\n * *greater* than the previous event's deltaX. This helps us filter out the\n * fake wheel events generated by the browser to simulate deceleration.\n *\n */\nfunction wheel(element, event) {\n\n  // Since we have a new wheel event, reset our timer waiting for the last\n  // wheel event to pass.\n  if (element[lastWheelTimeoutSymbol]) {\n    clearTimeout(element[lastWheelTimeoutSymbol]);\n  }\n  element[lastWheelTimeoutSymbol] = setTimeout(() => {\n    wheelTimedOut(element);\n  }, WHEEL_TIME);\n\n  const deltaX = event.deltaX;\n  const deltaY = event.deltaY;\n\n  // See if element event represents acceleration or deceleration.\n  const acceleration = sign(deltaX) * (deltaX - element[lastDeltaXSymbol]);\n  element[lastDeltaXSymbol] = deltaX;\n\n  if (Math.abs(deltaX) < Math.abs(deltaY)) {\n    // Move was mostly vertical. The user may be trying scroll with the\n    // trackpad/wheel. To be on the safe, we ignore such events.\n    return false;\n  }\n\n  if (element[postNavigateDelayCompleteSymbol]) {\n    // It's too soon after a navigation; ignore the event.\n    return true;\n  }\n\n  if (acceleration > 0) {\n    // The events are not (or are no longer) decelerating, so we can start\n    // paying attention to them again.\n    element[absorbDecelerationSymbol] = false;\n  } else if (element[absorbDecelerationSymbol]) {\n    // The wheel event was likely faked to simulate deceleration; ignore it.\n    return true;\n  }\n\n  element[wheelDistanceSymbol] += deltaX;\n\n  // Update the travel fraction of the element being navigated.\n  const width = element.offsetWidth;\n  let travelFraction = width > 0 ?\n    element[wheelDistanceSymbol] / width :\n    0;\n  element[symbols.dragging] = true;\n  travelFraction = sign(travelFraction) * Math.min(Math.abs(travelFraction), 1);\n  element.travelFraction = travelFraction;\n\n  // If the user has dragged enough to reach the previous/next item, then\n  // complete a navigation to that item.\n  if (travelFraction === 1) {\n    element[symbols.dragging] = false;\n    element[symbols.goRight]();\n    postNavigate(element);\n  } else if (travelFraction === -1) {\n    element[symbols.dragging] = false;\n    element[symbols.goLeft]();\n    postNavigate(element);\n  }\n\n  return true;\n}\n\n// A sufficiently long period of time has passed since the last wheel event.\n// We snap the selection to the closest item, then reset our state.\nfunction wheelTimedOut(element) {\n\n  // Snap to the closest item.\n  element[symbols.dragging] = false;\n  const travelFraction = element.travelFraction;\n  if (travelFraction >= 0.5) {\n    element[symbols.goRight]();\n  } else if (travelFraction <= -0.5) {\n    element[symbols.goLeft]();\n  }\n\n  // TODO: Listen for the transition to complete, and then restore\n  // dragging to false (or the previous value).\n\n  resetWheelTracking(element);\n}\n","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n","/*\n * Microtask helper for IE 11.\n *\n * Executing a function as a microtask is trivial in browsers that support\n * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n * promises, but does support MutationObservers, which are also executed as\n * microtasks. So this helper uses an MutationObserver to achieve microtask\n * timing.\n *\n * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * Inspired by Polymer's async() function.\n */\n\n\n// The queue of pending callbacks to be executed as microtasks.\nconst callbacks = [];\n\n// Create an element that we will modify to force observable mutations.\nconst element = document.createTextNode('');\n\n// A monotonically-increasing value.\nlet counter = 0;\n\n\n/**\n * Add a callback to the microtask queue.\n *\n * This uses a MutationObserver so that it works on IE 11.\n *\n * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n * needs more investigation.\n *\n * @function microtask\n * @param {function} callback\n */\nexport default function microtask(callback) {\n  callbacks.push(callback);\n  // Force a mutation.\n  element.textContent = ++counter;\n}\n\n\n// Execute any pending callbacks.\nfunction executeCallbacks() {\n  while (callbacks.length > 0) {\n    const callback = callbacks.shift();\n    callback();\n  }\n}\n\n\n// Create the observer.\nconst observer = new MutationObserver(executeCallbacks);\nobserver.observe(element, {\n  characterData: true\n});\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\n\n\n// Symbols for private data members on an element.\nconst safeToSetAttributesSymbol = createSymbol('safeToSetAttributes');\nconst pendingAttributesSymbol = createSymbol('pendingAttributes');\nconst pendingClassesSymbol = createSymbol('pendingClasses');\n\n\n/**\n * Helper functions for updating attributes, including the `class` attribute.\n */\nexport default {\n\n  /**\n   * Perform any pending updates to attributes and classes.\n   *\n   * This writes any `setAttribute` or `toggleClass` values that were performed\n   * before an element was attached to the document for the first time.\n   *\n   * This method should be called by mixins/components in their\n   * `connectedCallback`. If mulitple mixins/components invoke this during the\n   * same `connectedCallback`, only the first call will have any effect. The\n   * subsequent calls will be harmless.\n   *\n   * @param {HTMLElement} element - The element being added to the document.\n   */\n  connected(element) {\n    element[safeToSetAttributesSymbol] = true;\n\n    // Set any pending attributes.\n    if (element[pendingAttributesSymbol]) {\n      for (let attribute in element[pendingAttributesSymbol]) {\n        const value = element[pendingAttributesSymbol][attribute];\n        setAttributeToElement(element, attribute, value);\n      }\n      element[pendingAttributesSymbol] = null;\n    }\n\n    // Set any pending classes.\n    if (element[pendingClassesSymbol]) {\n      for (let className in element[pendingClassesSymbol]) {\n        const value = element[pendingClassesSymbol][className];\n        toggleClass(element, className, value);\n      }\n      element[pendingClassesSymbol] = null;\n    }\n  },\n\n  /**\n   * Set/unset the attribute with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as an attribute. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes. A call to `setAttribute` during the constructor will\n   * be deferred until the element is connected to the document.\n   *\n   * @param {string} attribute - The name of the *attribute* (not property) to set.\n   * @param {object} value - The value to set. If null, the attribute will be removed.\n   */\n  setAttribute(element, attribute, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set attributes immediately.\n      setAttributeToElement(element, attribute, value);\n    } else {\n      // Defer setting attributes until the first time we're connected.\n      if (!element[pendingAttributesSymbol]) {\n        element[pendingAttributesSymbol] = {};\n      }\n      element[pendingAttributesSymbol][attribute] = value;\n    }\n  },\n\n  /**\n   * Set/unset the class with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as as class. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes, including the `class` attribute. A call to\n   * `toggleClass` during the constructor will be deferred until the element\n   * is connected to the document.\n   *\n   * @param {string} className - The name of the class to set.\n   * @param {object} value - True to set the class, false to remove it.\n   */\n  toggleClass(element, className, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set class immediately.\n      toggleClass(element, className, value);\n    } else {\n      // Defer setting class until the first time we're connected.\n      if (!element[pendingClassesSymbol]) {\n        element[pendingClassesSymbol] = {};\n      }\n      element[pendingClassesSymbol][className] = value;\n    }\n  }\n\n};\n\n\n// Reflect the attribute to the given element.\n// If the value is null, remove the attribute.\nfunction setAttributeToElement(element, attributeName, value) {\n  if (value === null || typeof value === 'undefined') {\n    element.removeAttribute(attributeName);\n  } else {\n    const text = String(value);\n    // Avoid recursive attributeChangedCallback calls.\n    if (element.getAttribute(attributeName) !== text) {\n      element.setAttribute(attributeName, value);\n    }\n  }\n}\n","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'basic-component-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'basic-component-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `dragging` property.\n   *\n   * Components like carousels often define animated CSS transitions for\n   * sliding effects. Such a transition should usually *not* be applied while\n   * the user is dragging, because a CSS animation will introduce a lag that\n   * makes the swipe feel sluggish. Instead, as long as the user is dragging\n   * with their finger down, the transition should be suppressed. When the\n   * user releases their finger, the transition can be restored, allowing the\n   * animation to show the carousel sliding into its final position.\n   *\n   * @type {boolean} true if a drag is in progress, false if not.\n   */\n  dragging: createSymbol('dragging'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: createSymbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: createSymbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: createSymbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: createSymbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: createSymbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: createSymbol('goUp'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization  since the items have \"changed\" from\n   * being nothing.\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: createSymbol('keydown'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLElement}\n   */\n  template: createSymbol('template')\n};\n\nexport default symbols;\n","/**\n * Helper function for standard classList.toggle() behavior on old browsers,\n * namely IE 11.\n *\n * The standard\n * [classlist](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)\n * object has a `toggle()` function that supports a second Boolean parameter\n * that can be used to succinctly turn a class on or off. This feature is often\n * useful in designing custom elements, which may want to externally reflect\n * component state in a CSS class that can be used for styling purposes.\n *\n * Unfortunately, IE 11 does not support the Boolean parameter to\n * `classList.toggle()`. This helper function behaves like the standard\n * `toggle()`, including support for the Boolean parameter, so that it can be\n * used even on IE 11.\n *\n * @function toggleClass\n * @param {HTMLElement} element - The element to modify\n * @param {string} className - The class to add/remove\n * @param {boolean} [force] - Force the class to be added (if true) or removed\n *                            (if false)\n */\nexport default function toggleClass(element, className, force) {\n  const classList = element.classList;\n  const addClass = (typeof force === 'undefined') ?\n    !classList.contains(className) :\n    force;\n  if (addClass) {\n    classList.add(className);\n  } else {\n    classList.remove(className);\n  }\n  return addClass;\n}\n","import AttributeMarshallingMixin from '../../basic-component-mixins/src/AttributeMarshallingMixin';\nimport ComposableMixin from '../../basic-component-mixins/src/ComposableMixin';\nimport DistributedChildrenMixin from '../../basic-component-mixins/src/DistributedChildrenMixin';\nimport ShadowElementReferencesMixin from '../../basic-component-mixins/src/ShadowElementReferencesMixin';\nimport ShadowTemplateMixin from '../../basic-component-mixins/src/ShadowTemplateMixin';\n\n\n/**\n * A sample general-purpose base class for defining custom elements that mixes\n * in some common features: template stamping into a shadow root, shadow element\n * references, marshalling attributes to properties, and retrieving the children\n * distributed to a component.\n *\n * This base class is not special in any way, and is defined only as a\n * convenient shorthand for applying the mixins listed above. You can use this\n * class as a base class for your own elements, or easily create your own base\n * class by applying the same set of mixins.\n *\n * The ElementBase base class does not register itself as a custom element with\n * the browser, and hence cannot be independently instantiated.\n *\n * @mixes AttributeMarshallingMixin\n * @mixes ComposableMixin\n * @mixes DistributedChildrenMixin\n * @mixes ShadowElementReferencesMixin\n * @mixes ShadowTemplateMixin\n */\nclass ElementBase extends ComposableMixin(HTMLElement).compose(\n  ShadowTemplateMixin,          // before node finding, so shadow root is populated\n  ShadowElementReferencesMixin, // before marshalling, so properties can use refs\n  AttributeMarshallingMixin,\n  DistributedChildrenMixin\n) {}\n\nexport default ElementBase;\n"]}