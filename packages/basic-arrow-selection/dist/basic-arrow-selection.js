(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _ArrowSelectionMixin = require('./src/ArrowSelectionMixin');

var _ArrowSelectionMixin2 = _interopRequireDefault(_ArrowSelectionMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.Basic = window.Basic || {}; /*
                                    * This file is transpiled to create an ES5-compatible distribution in which
                                    * the package's main feature(s) are available via the window.Basic global.
                                    * If you're already using ES6 yourself, ignore this file, and instead import
                                    * the source file(s) you want from the src folder.
                                    */

window.Basic.ArrowSelectionMixin = _ArrowSelectionMixin2.default;

},{"./src/ArrowSelectionMixin":2}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if ("value" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createSymbol = require('../../basic-component-mixins/src/createSymbol');

var _createSymbol2 = _interopRequireDefault(_createSymbol);

var _symbols = require('../../basic-component-mixins/src/symbols');

var _symbols2 = _interopRequireDefault(_symbols);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Symbols for private data members on an element.
var mousedownListenerSymbol = (0, _createSymbol2.default)('mousedownListener');
var mousemoveListenerSymbol = (0, _createSymbol2.default)('mousemoveListener');
var lastMouseXSymbol = (0, _createSymbol2.default)('lastMouseX');
var lastMouseYSymbol = (0, _createSymbol2.default)('lastMouseY');
var mouseTimeoutSymbol = (0, _createSymbol2.default)('mouseTimeout');

/* Exported function extends a base class with ArrowSelection. */

exports.default = function (base) {

  /**
   * Template mixin which adds prominent left and right arrow buttons to a
   * wrapped child such as a carousel.
   *
   * You can see a [live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-arrow-selection.html)
   * of this component applied to a carousel.
   *
   * Clicking the left/right buttons selects the previous/next item.
   *
   * Typical usage:
   *
   *     class CarouselWithArrows extends ArrowSelectionMixin(Carousel) {}
   *     customElements.define('carousel-with-arrows', CarouselWithArrows);
   *
   * By default, the arrow buttons are shown on devices with a mouse or mouse-like
   * pointing device. They are not shown on a touch-capable device unless mouse
   * movement is detected. To cause the buttons to always appear, apply the
   * 'showArrows' CSS class.
   */
  var ArrowSelection = function (_base) {
    _inherits(ArrowSelection, _base);

    function ArrowSelection() {
      _classCallCheck(this, ArrowSelection);

      var _this = _possibleConstructorReturn(this, (ArrowSelection.__proto__ || Object.getPrototypeOf(ArrowSelection)).call(this));

      _this.$.buttonLeft.addEventListener('click', function (event) {
        _this.selectPrevious();
        event.stopPropagation();
      });
      _this.$.buttonRight.addEventListener('click', function (event) {
        _this.selectNext();
        event.stopPropagation();
      });
      assumeButtonFocus(_this, _this.$.buttonLeft);
      assumeButtonFocus(_this, _this.$.buttonRight);
      return _this;
    }

    _createClass(ArrowSelection, [{
      key: 'connectedCallback',
      value: function connectedCallback() {
        if (_get(ArrowSelection.prototype.__proto__ || Object.getPrototypeOf(ArrowSelection.prototype), 'connectedCallback', this)) {
          _get(ArrowSelection.prototype.__proto__ || Object.getPrototypeOf(ArrowSelection.prototype), 'connectedCallback', this).call(this);
        }

        if (!this.classList.contains('showArrows')) {
          // Determine whether we should show arrow buttons or not.
          if (deviceSupportsTouch()) {
            // A touch device might also support a mouse, but we can't know whether
            // there's actually a mouse until we hear from it.
            listenForMouse(this);
          } else {
            // The device doesn't support touch, so assume it has a mouse.
            showArrows(this);
          }
        }
      }
    }, {
      key: 'canSelectNext',
      get: function get() {
        return _get(ArrowSelection.prototype.__proto__ || Object.getPrototypeOf(ArrowSelection.prototype), 'canSelectNext', this);
      },
      set: function set(canSelectNext) {
        if ('canSelectNext' in base.prototype) {
          _set(ArrowSelection.prototype.__proto__ || Object.getPrototypeOf(ArrowSelection.prototype), 'canSelectNext', canSelectNext, this);
        }
        this.$.buttonRight.disabled = !canSelectNext;
      }
    }, {
      key: 'canSelectPrevious',
      get: function get() {
        return _get(ArrowSelection.prototype.__proto__ || Object.getPrototypeOf(ArrowSelection.prototype), 'canSelectPrevious', this);
      },
      set: function set(canSelectPrevious) {
        if ('canSelectPrevious' in base.prototype) {
          _set(ArrowSelection.prototype.__proto__ || Object.getPrototypeOf(ArrowSelection.prototype), 'canSelectPrevious', canSelectPrevious, this);
        }
        this.$.buttonLeft.disabled = !canSelectPrevious;
      }
    }, {
      key: _symbols2.default.defaults,
      get: function get() {
        var defaults = _get(ArrowSelection.prototype.__proto__ || Object.getPrototypeOf(ArrowSelection.prototype), _symbols2.default.defaults, this) || {};
        defaults.navigationAxis = 'horizontal';
        return defaults;
      }

      /*
       * The template uses the chevron-left and chevron-right SVG icons from
       * https://github.com/PolymerElements/iron-icons/blob/master/iron-icons.html.
       */

    }, {
      key: 'template',
      get: function get() {
        var baseTemplate = _get(ArrowSelection.prototype.__proto__ || Object.getPrototypeOf(ArrowSelection.prototype), 'template', this) || '';
        return '\n        <style>\n        :host {\n          -webkit-align-items: stretch;\n          align-items: stretch;\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          -webkit-justify-content: center;\n          justify-content: center;\n        }\n\n        #arrowNavigationContainer {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          position: relative;\n        }\n\n        .navigationButton {\n          background: transparent;\n          border: 1px solid transparent;\n          box-sizing: border-box;\n          color: rgba(0, 0, 0, 0.7);\n          fill: currentColor;\n          margin: 0;\n          opacity: 1;\n          outline: none; /* REVIEW: Accessibility should be provided by other elements. */\n          padding: 0;\n          transition: opacity 1s;\n          z-index: 1;\n        }\n\n        .navigationButton:hover:not(:disabled) {\n          background: rgba(0, 0, 0, 0.5);\n          color: rgba(0, 0, 0, 0.8);\n          cursor: pointer;\n        }\n        .navigationButton:active:not(:disabled) {\n          background: rgba(0, 0, 0, 0.7);\n          color: rgba(0, 0, 0, 0.9);\n        }\n        .navigationButton:disabled {\n          color: rgba(0, 0, 0, 0.2);\n        }\n\n        :host(:not(.showArrows)) .navigationButton {\n          opacity: 0;\n          visibility: hidden;\n        }\n\n        .navigationButton .icon {\n          height: 48px;\n          width: 48px;\n        }\n\n        /* Overlay variant */\n        :host(.overlayArrows) {\n          position: relative;\n        }\n        :host(.overlayArrows) .navigationButton {\n          bottom: 0;\n          color: rgba(255, 255, 255, 0.7);\n          position: absolute;\n          top: 0;\n        }\n        :host(.overlayArrows) #buttonLeft {\n          left: 0;\n        }\n        :host(.overlayArrows) #buttonRight {\n          right: 0;\n        }\n        :host(.overlayArrows) .navigationButton:hover:not(:disabled) {\n          background: rgba(255, 255, 255, 0.2);\n          color: rgba(255, 255, 255, 0.8);\n        }\n        :host(.overlayArrows) .navigationButton:active:not(:disabled) {\n          background: rgba(255, 255, 255, 0.4);\n          color: rgba(255, 255, 255, 0.9);\n        }\n        :host(.overlayArrows) .navigationButton:disabled {\n          color: rgba(255, 255, 255, 0.3);\n        }\n        </style>\n\n        <!--\n        Accessibility note: since the navigation offered by the arrow buttons should\n        be redundant (that is, there should be other ways of navigating the list),\n        we mark the button as aria-hidden so that assistive devices ignore them.\n        -->\n        <button id="buttonLeft" class="navigationButton" disabled tabindex="-1" aria-hidden="true">\n          <svg class="icon" viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet">\n            <g id="chevron-left">\n              <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>\n            </g>\n          </svg>\n        </button>\n        <div id="arrowNavigationContainer" role="none">\n          ' + baseTemplate + '\n        </div>\n        <button id="buttonRight" class="navigationButton" disabled tabindex="-1" aria-hidden="true">\n          <svg class="icon" viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet">\n            <g id="chevron-right">\n              <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>\n            </g>\n          </svg>\n        </button>\n      ';
      }
    }]);

    return ArrowSelection;
  }(base);

  return ArrowSelection;
};

/*
 * By default, a button will always take focus on mousedown. For this component,
 * we want to override that behavior, such that a mousedown on a button keeps
 * the focus on the outer component.
 */


function assumeButtonFocus(element, button) {
  button.addEventListener('mousedown', function (event) {
    // Given the main element the focus if it doesn't already have it.
    element.focus();
    // Prevent the default focus-on-mousedown behavior.
    event.preventDefault();
  });
}

function deviceSupportsTouch() {
  return 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch;
}

// We try to detect the presence of a mouse by listening for mousemove events
// which are *not* the result of a mousedown. On a touch device, a tap on the
// page will generate a fake mousemove, followed by a mousedown. We don't want
// to respond to those fake mousemove events. To discriminate between fake and
// real mousemove events, when we get a mousemove event, we wait for a bit to
// see if the same location is reported as the location of a subsequent
// mousedown.
function listenForMouse(element) {

  element[mousedownListenerSymbol] = function (event) {
    if (element[mouseTimeoutSymbol]) {
      clearTimeout(element[mouseTimeoutSymbol]);
    }
    element[lastMouseXSymbol] = event.pageX;
    element[lastMouseYSymbol] = event.pageY;
  };
  window.addEventListener('mousedown', element[mousedownListenerSymbol]);

  element[mousemoveListenerSymbol] = function (event) {
    // Postpone checking the mousemove location to give the mousedown event a
    // chance to fire. The 250 ms delay is just guesswork; a shorter delay
    // doesn't seem to work.
    element[mouseTimeoutSymbol] = setTimeout(function () {
      if (element[lastMouseXSymbol] != null && event.pageX !== element[lastMouseXSymbol] || element[lastMouseYSymbol] != null && event.pageY !== element[lastMouseYSymbol]) {
        // mousemove event was at a location other than the last mousedown,
        // and hence most likely a real mousemove event.
        mouseDetected(element);
      } else {
        element[lastMouseXSymbol] = event.pageX;
        element[lastMouseYSymbol] = event.pageY;
      }
    }, 250);
  };
  window.addEventListener('mousemove', element[mousemoveListenerSymbol]);
}

function mouseDetected(element) {
  showArrows(element);

  // We can stop listening for mouse events now.
  if (element[mouseTimeoutSymbol]) {
    clearTimeout(element[mouseTimeoutSymbol]);
  }
  window.removeEventListener('mousedown', element[mousedownListenerSymbol]);
  window.removeEventListener('mousemove', element[mousemoveListenerSymbol]);
  element[mousedownListenerSymbol] = null;
  element[mousemoveListenerSymbol] = null;
}

function showArrows(element) {
  element.classList.add('showArrows');
}

},{"../../basic-component-mixins/src/createSymbol":3,"../../basic-component-mixins/src/symbols":4}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createSymbol;
/**
 * Helper function to create a symbol that can be used for associating private
 * data with an element.
 *
 * Mixins and component classes often want to associate private data with an
 * element instance, but JavaScript does not have direct support for true
 * private properties. One approach is to use the
 * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)
 * data type to set and retrieve data on an element.
 *
 * Unfortunately, the Symbol type is not available in Internet Explorer 11. The
 * `createSymbol` helper function exists as a workaround for IE 11. Rather than
 * returning a true Symbol, it simply returns an underscore-prefixed string.
 *
 * Usage:
 *
 *     const fooSymbol = createSymbol('foo');
 *
 *     class MyElement extends HTMLElement {
 *       get foo() {
 *         return this[fooSymbol];
 *       }
 *       set foo(value) {
 *         this[fooSymbol] = value;
 *       }
 *     }
 *
 * In IE 11, this sample will "hide" data behind an instance property this._foo.
 * The use of the underscore is meant to reduce (not eliminate) the potential
 * for name conflicts, and discourage (not prevent) external access to this
 * data. In modern browsers, the above code will eliminate the potential of
 * naming conflicts, and better hide the data behind a real Symbol.
 *
 * @function createSymbol
 * @param {string} description - A string to identify the symbol when debugging
 */
function createSymbol(description) {
  return typeof Symbol === 'function' ? Symbol(description) : '_' + description;
}

},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createSymbol = require('./createSymbol');

var _createSymbol2 = _interopRequireDefault(_createSymbol);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A collection of Symbol objects for standard component properties and methods.
 *
 * These Symbol objects are used to allow mixins and a component to internally
 * communicate, without exposing these properties and methods in the component's
 * public API.
 *
 * To use these Symbol objects in your own component, include this module and
 * then create a property or method whose key is the desired Symbol.
 *
 *     import 'SingleSelectionMixin' from 'basic-component-mixins/src/SingleSelectionMixin';
 *     import 'symbols' from 'basic-component-mixins/src/symbols';
 *
 *     class MyElement extends SingleSelectionMixin(HTMLElement) {
 *       [symbols.applySelection](item, selected) {
 *         // This will be invoked whenever an item is selected/deselected.
 *       }
 *     }
 *
 * @module symbols
 */
var symbols = {

  /**
   * Symbol for the `applySelection` method.
   *
   * This method applies the indicated selection state to an item.
   *
   * @function applySelection
   * @param {HTMLElement} item - the item being selected/deselected
   * @param {boolean} selected - true if the item is selected, false if not
   */
  applySelection: (0, _createSymbol2.default)('applySelection'),

  /**
   * Symbol for the `defaults` property.
   *
   * This property can be used to set or override defaults that will be applied
   * to a new component instance. When implementing this property, take care to
   * first acquire any defaults defined by the superclass. The standard idiom is
   * as follows:
   *
   *     get [symbols.defaults]() {
   *       const defaults = super[symbols.defaults] || {};
   *       // Set or override default values here
   *       defaults.customProperty = false;
   *       return defaults;
   *     }
   *
   * @var {object} defaults
   */
  defaults: (0, _createSymbol2.default)('defaults'),

  /**
   * Symbol for the `dragging` property.
   *
   * Components like carousels often define animated CSS transitions for
   * sliding effects. Such a transition should usually *not* be applied while
   * the user is dragging, because a CSS animation will introduce a lag that
   * makes the swipe feel sluggish. Instead, as long as the user is dragging
   * with their finger down, the transition should be suppressed. When the
   * user releases their finger, the transition can be restored, allowing the
   * animation to show the carousel sliding into its final position.
   *
   * @type {boolean} true if a drag is in progress, false if not.
   */
  dragging: (0, _createSymbol2.default)('dragging'),

  /**
   * Symbol for the `goDown` method.
   *
   * This method is invoked when the user wants to go/navigate down.
   *
   * @function goDown
   */
  goDown: (0, _createSymbol2.default)('goDown'),

  /**
   * Symbol for the `goEnd` method.
   *
   * This method is invoked when the user wants to go/navigate to the end (e.g.,
   * of a list).
   *
   * @function goEnd
   */
  goEnd: (0, _createSymbol2.default)('goEnd'),

  /**
   * Symbol for the `goLeft` method.
   *
   * This method is invoked when the user wants to go/navigate left.
   *
   * @function goLeft
   */
  goLeft: (0, _createSymbol2.default)('goLeft'),

  /**
   * Symbol for the `goRight` method.
   *
   * This method is invoked when the user wants to go/navigate right.
   *
   * @function goRight
   */
  goRight: (0, _createSymbol2.default)('goRight'),

  /**
   * Symbol for the `goStart` method.
   *
   * This method is invoked when the user wants to go/navigate to the start
   * (e.g., of a list).
   *
   * @function goStart
   */
  goStart: (0, _createSymbol2.default)('goStart'),

  /**
   * Symbol for the `goUp` method.
   *
   * This method is invoked when the user wants to go/navigate up.
   *
   * @function goUp
   */
  goUp: (0, _createSymbol2.default)('goUp'),

  /**
   * Symbol for the `itemAdded` method.
   *
   * This method is invoked when a new item is added to a list.
   *
   * @function itemAdded
   * @param {HTMLElement} item - the item being selected/deselected
   */
  itemAdded: (0, _createSymbol2.default)('itemAdded'),

  /**
   * Symbol for the `keydown` method.
   *
   * This method is invoked when an element receives a `keydown` event.
   *
   * @function keydown
   * @param {KeyboardEvent} event - the event being processed
   */
  keydown: (0, _createSymbol2.default)('keydown')
};

exports.default = symbols;

},{"./createSymbol":3}]},{},[1])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJwYWNrYWdlcy9iYXNpYy1hcnJvdy1zZWxlY3Rpb24vZ2xvYmFscy5qcyIsInBhY2thZ2VzL2Jhc2ljLWFycm93LXNlbGVjdGlvbi9zcmMvQXJyb3dTZWxlY3Rpb25NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL2NyZWF0ZVN5bWJvbC5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3N5bWJvbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ09BOzs7Ozs7QUFFQSxPQUFPLEtBQVAsR0FBZSxPQUFPLEtBQVAsSUFBZ0IsRUFBL0IsQyxDQVRBOzs7Ozs7O0FBVUEsT0FBTyxLQUFQLENBQWEsbUJBQWI7Ozs7Ozs7Ozs7Ozs7OztBQ1ZBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUdBO0FBQ0EsSUFBTSwwQkFBMEIsNEJBQWEsbUJBQWIsQ0FBaEM7QUFDQSxJQUFNLDBCQUEwQiw0QkFBYSxtQkFBYixDQUFoQztBQUNBLElBQU0sbUJBQW1CLDRCQUFhLFlBQWIsQ0FBekI7QUFDQSxJQUFNLG1CQUFtQiw0QkFBYSxZQUFiLENBQXpCO0FBQ0EsSUFBTSxxQkFBcUIsNEJBQWEsY0FBYixDQUEzQjs7QUFHQTs7a0JBQ2UsVUFBQyxJQUFELEVBQVU7O0FBRXZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRnVCLE1BcUJqQixjQXJCaUI7QUFBQTs7QUF1QnJCLDhCQUFjO0FBQUE7O0FBQUE7O0FBR1osWUFBSyxDQUFMLENBQU8sVUFBUCxDQUFrQixnQkFBbEIsQ0FBbUMsT0FBbkMsRUFBNEMsaUJBQVM7QUFDbkQsY0FBSyxjQUFMO0FBQ0EsY0FBTSxlQUFOO0FBQ0QsT0FIRDtBQUlBLFlBQUssQ0FBTCxDQUFPLFdBQVAsQ0FBbUIsZ0JBQW5CLENBQW9DLE9BQXBDLEVBQTZD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QU9BLFVBQVEsNEJBQWEsUUFBYixDQXRETTs7QUF3RGQ7Ozs7Ozs7O0FBUUEsU0FBTyw0QkFBYSxPQUFiLENBaEVPOztBQWtFZDs7Ozs7OztBQU9BLFVBQVEsNEJBQWEsUUFBYixDQXpFTTs7QUEyRWQ7Ozs7Ozs7QUFPQSxXQUFTLDRCQUFhLFNBQWIsQ0FsRks7O0FBb0ZkOzs7Ozs7OztBQVFBLFdBQVMsNEJBQWEsU0FBYixDQTVGSzs7QUE4RmQ7Ozs7Ozs7QUFPQSxRQUFNLDRCQUFhLE1BQWIsQ0FyR1E7O0FBdUdkOzs7Ozs7OztBQVFBLGFBQVcsNEJBQWEsV0FBYixDQS9HRzs7QUFpSGQ7Ozs7Ozs7O0FBUUEsV0FBUyw0QkFBYSxTQUFiO0FBekhLLENBQWhCOztrQkE0SGUsTyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKlxuICogVGhpcyBmaWxlIGlzIHRyYW5zcGlsZWQgdG8gY3JlYXRlIGFuIEVTNS1jb21wYXRpYmxlIGRpc3RyaWJ1dGlvbiBpbiB3aGljaFxuICogdGhlIHBhY2thZ2UncyBtYWluIGZlYXR1cmUocykgYXJlIGF2YWlsYWJsZSB2aWEgdGhlIHdpbmRvdy5CYXNpYyBnbG9iYWwuXG4gKiBJZiB5b3UncmUgYWxyZWFkeSB1c2luZyBFUzYgeW91cnNlbGYsIGlnbm9yZSB0aGlzIGZpbGUsIGFuZCBpbnN0ZWFkIGltcG9ydFxuICogdGhlIHNvdXJjZSBmaWxlKHMpIHlvdSB3YW50IGZyb20gdGhlIHNyYyBmb2xkZXIuXG4gKi9cblxuaW1wb3J0IEFycm93U2VsZWN0aW9uTWl4aW4gZnJvbSAnLi9zcmMvQXJyb3dTZWxlY3Rpb25NaXhpbic7XG5cbndpbmRvdy5CYXNpYyA9IHdpbmRvdy5CYXNpYyB8fCB7fTtcbndpbmRvdy5CYXNpYy5BcnJvd1NlbGVjdGlvbk1peGluID0gQXJyb3dTZWxlY3Rpb25NaXhpbjtcbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvY3JlYXRlU3ltYm9sJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3N5bWJvbHMnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBtb3VzZWRvd25MaXN0ZW5lclN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbW91c2Vkb3duTGlzdGVuZXInKTtcbmNvbnN0IG1vdXNlbW92ZUxpc3RlbmVyU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdtb3VzZW1vdmVMaXN0ZW5lcicpO1xuY29uc3QgbGFzdE1vdXNlWFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbGFzdE1vdXNlWCcpO1xuY29uc3QgbGFzdE1vdXNlWVN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbGFzdE1vdXNlWScpO1xuY29uc3QgbW91c2VUaW1lb3V0U3ltYm9sID0gY3JlYXRlU3ltYm9sKCdtb3VzZVRpbWVvdXQnKTtcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIEFycm93U2VsZWN0aW9uLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogVGVtcGxhdGUgbWl4aW4gd2hpY2ggYWRkcyBwcm9taW5lbnQgbGVmdCBhbmQgcmlnaHQgYXJyb3cgYnV0dG9ucyB0byBhXG4gICAqIHdyYXBwZWQgY2hpbGQgc3VjaCBhcyBhIGNhcm91c2VsLlxuICAgKlxuICAgKiBZb3UgY2FuIHNlZSBhIFtsaXZlIGRlbW9dKGh0dHA6Ly9iYXNpY3dlYmNvbXBvbmVudHMub3JnL2Jhc2ljLXdlYi1jb21wb25lbnRzL3BhY2thZ2VzL2Jhc2ljLWFycm93LXNlbGVjdGlvbi5odG1sKVxuICAgKiBvZiB0aGlzIGNvbXBvbmVudCBhcHBsaWVkIHRvIGEgY2Fyb3VzZWwuXG4gICAqXG4gICAqIENsaWNraW5nIHRoZSBsZWZ0L3JpZ2h0IGJ1dHRvbnMgc2VsZWN0cyB0aGUgcHJldmlvdXMvbmV4dCBpdGVtLlxuICAgKlxuICAgKiBUeXBpY2FsIHVzYWdlOlxuICAgKlxuICAgKiAgICAgY2xhc3MgQ2Fyb3VzZWxXaXRoQXJyb3dzIGV4dGVuZHMgQXJyb3dTZWxlY3Rpb25NaXhpbihDYXJvdXNlbCkge31cbiAgICogICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnY2Fyb3VzZWwtd2l0aC1hcnJvd3MnLCBDYXJvdXNlbFdpdGhBcnJvd3MpO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgYXJyb3cgYnV0dG9ucyBhcmUgc2hvd24gb24gZGV2aWNlcyB3aXRoIGEgbW91c2Ugb3IgbW91c2UtbGlrZVxuICAgKiBwb2ludGluZyBkZXZpY2UuIFRoZXkgYXJlIG5vdCBzaG93biBvbiBhIHRvdWNoLWNhcGFibGUgZGV2aWNlIHVubGVzcyBtb3VzZVxuICAgKiBtb3ZlbWVudCBpcyBkZXRlY3RlZC4gVG8gY2F1c2UgdGhlIGJ1dHRvbnMgdG8gYWx3YXlzIGFwcGVhciwgYXBwbHkgdGhlXG4gICAqICdzaG93QXJyb3dzJyBDU1MgY2xhc3MuXG4gICAqL1xuICBjbGFzcyBBcnJvd1NlbGVjdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICB0aGlzLiQuYnV0dG9uTGVmdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kLmJ1dHRvblJpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnNlbGVjdE5leHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIGFzc3VtZUJ1dHRvbkZvY3VzKHRoaXMsIHRoaXMuJC5idXR0b25MZWZ0KTtcbiAgICAgIGFzc3VtZUJ1dHRvbkZvY3VzKHRoaXMsIHRoaXMuJC5idXR0b25SaWdodCk7XG4gICAgfVxuXG4gICAgZ2V0IGNhblNlbGVjdE5leHQoKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY2FuU2VsZWN0TmV4dDtcbiAgICB9XG4gICAgc2V0IGNhblNlbGVjdE5leHQoY2FuU2VsZWN0TmV4dCkge1xuICAgICAgaWYgKCdjYW5TZWxlY3ROZXh0JyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5jYW5TZWxlY3ROZXh0ID0gY2FuU2VsZWN0TmV4dDsgfVxuICAgICAgdGhpcy4kLmJ1dHRvblJpZ2h0LmRpc2FibGVkID0gIWNhblNlbGVjdE5leHQ7XG4gICAgfVxuXG4gICAgZ2V0IGNhblNlbGVjdFByZXZpb3VzKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLmNhblNlbGVjdFByZXZpb3VzO1xuICAgIH1cbiAgICBzZXQgY2FuU2VsZWN0UHJldmlvdXMoY2FuU2VsZWN0UHJldmlvdXMpIHtcbiAgICAgIGlmICgnY2FuU2VsZWN0UHJldmlvdXMnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLmNhblNlbGVjdFByZXZpb3VzID0gY2FuU2VsZWN0UHJldmlvdXM7IH1cbiAgICAgIHRoaXMuJC5idXR0b25MZWZ0LmRpc2FibGVkID0gIWNhblNlbGVjdFByZXZpb3VzO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgaWYgKHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKSB7IHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7IH1cblxuICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucygnc2hvd0Fycm93cycpKSB7XG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHdlIHNob3VsZCBzaG93IGFycm93IGJ1dHRvbnMgb3Igbm90LlxuICAgICAgICBpZiAoZGV2aWNlU3VwcG9ydHNUb3VjaCgpKSB7XG4gICAgICAgICAgLy8gQSB0b3VjaCBkZXZpY2UgbWlnaHQgYWxzbyBzdXBwb3J0IGEgbW91c2UsIGJ1dCB3ZSBjYW4ndCBrbm93IHdoZXRoZXJcbiAgICAgICAgICAvLyB0aGVyZSdzIGFjdHVhbGx5IGEgbW91c2UgdW50aWwgd2UgaGVhciBmcm9tIGl0LlxuICAgICAgICAgIGxpc3RlbkZvck1vdXNlKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSBkZXZpY2UgZG9lc24ndCBzdXBwb3J0IHRvdWNoLCBzbyBhc3N1bWUgaXQgaGFzIGEgbW91c2UuXG4gICAgICAgICAgc2hvd0Fycm93cyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMubmF2aWdhdGlvbkF4aXMgPSAnaG9yaXpvbnRhbCc7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBUaGUgdGVtcGxhdGUgdXNlcyB0aGUgY2hldnJvbi1sZWZ0IGFuZCBjaGV2cm9uLXJpZ2h0IFNWRyBpY29ucyBmcm9tXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXJFbGVtZW50cy9pcm9uLWljb25zL2Jsb2IvbWFzdGVyL2lyb24taWNvbnMuaHRtbC5cbiAgICAgKi9cbiAgICBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICBjb25zdCBiYXNlVGVtcGxhdGUgPSBzdXBlci50ZW1wbGF0ZSB8fCAnJztcbiAgICAgIHJldHVybiBgXG4gICAgICAgIDxzdHlsZT5cbiAgICAgICAgOmhvc3Qge1xuICAgICAgICAgIC13ZWJraXQtYWxpZ24taXRlbXM6IHN0cmV0Y2g7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XG4gICAgICAgICAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgLXdlYmtpdC1mbGV4OiAxO1xuICAgICAgICAgIGZsZXg6IDE7XG4gICAgICAgICAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgICNhcnJvd05hdmlnYXRpb25Db250YWluZXIge1xuICAgICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIC13ZWJraXQtZmxleDogMTtcbiAgICAgICAgICBmbGV4OiAxO1xuICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5uYXZpZ2F0aW9uQnV0dG9uIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XG4gICAgICAgICAgZmlsbDogY3VycmVudENvbG9yO1xuICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICAgIG91dGxpbmU6IG5vbmU7IC8qIFJFVklFVzogQWNjZXNzaWJpbGl0eSBzaG91bGQgYmUgcHJvdmlkZWQgYnkgb3RoZXIgZWxlbWVudHMuICovXG4gICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDFzO1xuICAgICAgICAgIHotaW5kZXg6IDE7XG4gICAgICAgIH1cblxuICAgICAgICAubmF2aWdhdGlvbkJ1dHRvbjpob3Zlcjpub3QoOmRpc2FibGVkKSB7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjUpO1xuICAgICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOCk7XG4gICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICB9XG4gICAgICAgIC5uYXZpZ2F0aW9uQnV0dG9uOmFjdGl2ZTpub3QoOmRpc2FibGVkKSB7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjcpO1xuICAgICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOSk7XG4gICAgICAgIH1cbiAgICAgICAgLm5hdmlnYXRpb25CdXR0b246ZGlzYWJsZWQge1xuICAgICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMik7XG4gICAgICAgIH1cblxuICAgICAgICA6aG9zdCg6bm90KC5zaG93QXJyb3dzKSkgLm5hdmlnYXRpb25CdXR0b24ge1xuICAgICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLm5hdmlnYXRpb25CdXR0b24gLmljb24ge1xuICAgICAgICAgIGhlaWdodDogNDhweDtcbiAgICAgICAgICB3aWR0aDogNDhweDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIE92ZXJsYXkgdmFyaWFudCAqL1xuICAgICAgICA6aG9zdCgub3ZlcmxheUFycm93cykge1xuICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdCgub3ZlcmxheUFycm93cykgLm5hdmlnYXRpb25CdXR0b24ge1xuICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICB0b3A6IDA7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QoLm92ZXJsYXlBcnJvd3MpICNidXR0b25MZWZ0IHtcbiAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB9XG4gICAgICAgIDpob3N0KC5vdmVybGF5QXJyb3dzKSAjYnV0dG9uUmlnaHQge1xuICAgICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICB9XG4gICAgICAgIDpob3N0KC5vdmVybGF5QXJyb3dzKSAubmF2aWdhdGlvbkJ1dHRvbjpob3Zlcjpub3QoOmRpc2FibGVkKSB7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xuICAgICAgICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QoLm92ZXJsYXlBcnJvd3MpIC5uYXZpZ2F0aW9uQnV0dG9uOmFjdGl2ZTpub3QoOmRpc2FibGVkKSB7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjQpO1xuICAgICAgICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSk7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QoLm92ZXJsYXlBcnJvd3MpIC5uYXZpZ2F0aW9uQnV0dG9uOmRpc2FibGVkIHtcbiAgICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpO1xuICAgICAgICB9XG4gICAgICAgIDwvc3R5bGU+XG5cbiAgICAgICAgPCEtLVxuICAgICAgICBBY2Nlc3NpYmlsaXR5IG5vdGU6IHNpbmNlIHRoZSBuYXZpZ2F0aW9uIG9mZmVyZWQgYnkgdGhlIGFycm93IGJ1dHRvbnMgc2hvdWxkXG4gICAgICAgIGJlIHJlZHVuZGFudCAodGhhdCBpcywgdGhlcmUgc2hvdWxkIGJlIG90aGVyIHdheXMgb2YgbmF2aWdhdGluZyB0aGUgbGlzdCksXG4gICAgICAgIHdlIG1hcmsgdGhlIGJ1dHRvbiBhcyBhcmlhLWhpZGRlbiBzbyB0aGF0IGFzc2lzdGl2ZSBkZXZpY2VzIGlnbm9yZSB0aGVtLlxuICAgICAgICAtLT5cbiAgICAgICAgPGJ1dHRvbiBpZD1cImJ1dHRvbkxlZnRcIiBjbGFzcz1cIm5hdmlnYXRpb25CdXR0b25cIiBkaXNhYmxlZCB0YWJpbmRleD1cIi0xXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICAgICAgPHN2ZyBjbGFzcz1cImljb25cIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIj5cbiAgICAgICAgICAgIDxnIGlkPVwiY2hldnJvbi1sZWZ0XCI+XG4gICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTUuNDEgNy40MUwxNCA2bC02IDYgNiA2IDEuNDEtMS40MUwxMC44MyAxMnpcIi8+XG4gICAgICAgICAgICA8L2c+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8ZGl2IGlkPVwiYXJyb3dOYXZpZ2F0aW9uQ29udGFpbmVyXCIgcm9sZT1cIm5vbmVcIj5cbiAgICAgICAgICAke2Jhc2VUZW1wbGF0ZX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxidXR0b24gaWQ9XCJidXR0b25SaWdodFwiIGNsYXNzPVwibmF2aWdhdGlvbkJ1dHRvblwiIGRpc2FibGVkIHRhYmluZGV4PVwiLTFcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgICAgICA8c3ZnIGNsYXNzPVwiaWNvblwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pZFlNaWQgbWVldFwiPlxuICAgICAgICAgICAgPGcgaWQ9XCJjaGV2cm9uLXJpZ2h0XCI+XG4gICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTAgNkw4LjU5IDcuNDEgMTMuMTcgMTJsLTQuNTggNC41OUwxMCAxOGw2LTZ6XCIvPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIGA7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQXJyb3dTZWxlY3Rpb247XG59O1xuXG5cbi8qXG4gKiBCeSBkZWZhdWx0LCBhIGJ1dHRvbiB3aWxsIGFsd2F5cyB0YWtlIGZvY3VzIG9uIG1vdXNlZG93bi4gRm9yIHRoaXMgY29tcG9uZW50LFxuICogd2Ugd2FudCB0byBvdmVycmlkZSB0aGF0IGJlaGF2aW9yLCBzdWNoIHRoYXQgYSBtb3VzZWRvd24gb24gYSBidXR0b24ga2VlcHNcbiAqIHRoZSBmb2N1cyBvbiB0aGUgb3V0ZXIgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBhc3N1bWVCdXR0b25Gb2N1cyhlbGVtZW50LCBidXR0b24pIHtcbiAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGV2ZW50ID0+IHtcbiAgICAvLyBHaXZlbiB0aGUgbWFpbiBlbGVtZW50IHRoZSBmb2N1cyBpZiBpdCBkb2Vzbid0IGFscmVhZHkgaGF2ZSBpdC5cbiAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBmb2N1cy1vbi1tb3VzZWRvd24gYmVoYXZpb3IuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRldmljZVN1cHBvcnRzVG91Y2goKSB7XG4gIHJldHVybiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHxcbiAgICAgICh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKTtcbn1cblxuLy8gV2UgdHJ5IHRvIGRldGVjdCB0aGUgcHJlc2VuY2Ugb2YgYSBtb3VzZSBieSBsaXN0ZW5pbmcgZm9yIG1vdXNlbW92ZSBldmVudHNcbi8vIHdoaWNoIGFyZSAqbm90KiB0aGUgcmVzdWx0IG9mIGEgbW91c2Vkb3duLiBPbiBhIHRvdWNoIGRldmljZSwgYSB0YXAgb24gdGhlXG4vLyBwYWdlIHdpbGwgZ2VuZXJhdGUgYSBmYWtlIG1vdXNlbW92ZSwgZm9sbG93ZWQgYnkgYSBtb3VzZWRvd24uIFdlIGRvbid0IHdhbnRcbi8vIHRvIHJlc3BvbmQgdG8gdGhvc2UgZmFrZSBtb3VzZW1vdmUgZXZlbnRzLiBUbyBkaXNjcmltaW5hdGUgYmV0d2VlbiBmYWtlIGFuZFxuLy8gcmVhbCBtb3VzZW1vdmUgZXZlbnRzLCB3aGVuIHdlIGdldCBhIG1vdXNlbW92ZSBldmVudCwgd2Ugd2FpdCBmb3IgYSBiaXQgdG9cbi8vIHNlZSBpZiB0aGUgc2FtZSBsb2NhdGlvbiBpcyByZXBvcnRlZCBhcyB0aGUgbG9jYXRpb24gb2YgYSBzdWJzZXF1ZW50XG4vLyBtb3VzZWRvd24uXG5mdW5jdGlvbiBsaXN0ZW5Gb3JNb3VzZShlbGVtZW50KSB7XG5cbiAgZWxlbWVudFttb3VzZWRvd25MaXN0ZW5lclN5bWJvbF0gPSBldmVudCA9PiB7XG4gICAgaWYgKGVsZW1lbnRbbW91c2VUaW1lb3V0U3ltYm9sXSkge1xuICAgICAgY2xlYXJUaW1lb3V0KGVsZW1lbnRbbW91c2VUaW1lb3V0U3ltYm9sXSk7XG4gICAgfVxuICAgIGVsZW1lbnRbbGFzdE1vdXNlWFN5bWJvbF0gPSBldmVudC5wYWdlWDtcbiAgICBlbGVtZW50W2xhc3RNb3VzZVlTeW1ib2xdID0gZXZlbnQucGFnZVk7XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBlbGVtZW50W21vdXNlZG93bkxpc3RlbmVyU3ltYm9sXSk7XG5cbiAgZWxlbWVudFttb3VzZW1vdmVMaXN0ZW5lclN5bWJvbF0gPSBldmVudCA9PiB7XG4gICAgLy8gUG9zdHBvbmUgY2hlY2tpbmcgdGhlIG1vdXNlbW92ZSBsb2NhdGlvbiB0byBnaXZlIHRoZSBtb3VzZWRvd24gZXZlbnQgYVxuICAgIC8vIGNoYW5jZSB0byBmaXJlLiBUaGUgMjUwIG1zIGRlbGF5IGlzIGp1c3QgZ3Vlc3N3b3JrOyBhIHNob3J0ZXIgZGVsYXlcbiAgICAvLyBkb2Vzbid0IHNlZW0gdG8gd29yay5cbiAgICBlbGVtZW50W21vdXNlVGltZW91dFN5bWJvbF0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChlbGVtZW50W2xhc3RNb3VzZVhTeW1ib2xdICE9IG51bGwgJiYgZXZlbnQucGFnZVggIT09IGVsZW1lbnRbbGFzdE1vdXNlWFN5bWJvbF0gfHxcbiAgICAgICAgICBlbGVtZW50W2xhc3RNb3VzZVlTeW1ib2xdICE9IG51bGwgJiYgZXZlbnQucGFnZVkgIT09IGVsZW1lbnRbbGFzdE1vdXNlWVN5bWJvbF0pIHtcbiAgICAgICAgLy8gbW91c2Vtb3ZlIGV2ZW50IHdhcyBhdCBhIGxvY2F0aW9uIG90aGVyIHRoYW4gdGhlIGxhc3QgbW91c2Vkb3duLFxuICAgICAgICAvLyBhbmQgaGVuY2UgbW9zdCBsaWtlbHkgYSByZWFsIG1vdXNlbW92ZSBldmVudC5cbiAgICAgICAgbW91c2VEZXRlY3RlZChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRbbGFzdE1vdXNlWFN5bWJvbF0gPSBldmVudC5wYWdlWDtcbiAgICAgICAgZWxlbWVudFtsYXN0TW91c2VZU3ltYm9sXSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgfVxuICAgIH0sIDI1MCk7XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBlbGVtZW50W21vdXNlbW92ZUxpc3RlbmVyU3ltYm9sXSk7XG59XG5cbmZ1bmN0aW9uIG1vdXNlRGV0ZWN0ZWQoZWxlbWVudCkge1xuICBzaG93QXJyb3dzKGVsZW1lbnQpO1xuXG4gIC8vIFdlIGNhbiBzdG9wIGxpc3RlbmluZyBmb3IgbW91c2UgZXZlbnRzIG5vdy5cbiAgaWYgKGVsZW1lbnRbbW91c2VUaW1lb3V0U3ltYm9sXSkge1xuICAgIGNsZWFyVGltZW91dChlbGVtZW50W21vdXNlVGltZW91dFN5bWJvbF0pO1xuICB9XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBlbGVtZW50W21vdXNlZG93bkxpc3RlbmVyU3ltYm9sXSk7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBlbGVtZW50W21vdXNlbW92ZUxpc3RlbmVyU3ltYm9sXSk7XG4gIGVsZW1lbnRbbW91c2Vkb3duTGlzdGVuZXJTeW1ib2xdID0gbnVsbDtcbiAgZWxlbWVudFttb3VzZW1vdmVMaXN0ZW5lclN5bWJvbF0gPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzaG93QXJyb3dzKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzaG93QXJyb3dzJyk7XG59XG4iLCIvKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzeW1ib2wgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYXNzb2NpYXRpbmcgcHJpdmF0ZVxuICogZGF0YSB3aXRoIGFuIGVsZW1lbnQuXG4gKlxuICogTWl4aW5zIGFuZCBjb21wb25lbnQgY2xhc3NlcyBvZnRlbiB3YW50IHRvIGFzc29jaWF0ZSBwcml2YXRlIGRhdGEgd2l0aCBhblxuICogZWxlbWVudCBpbnN0YW5jZSwgYnV0IEphdmFTY3JpcHQgZG9lcyBub3QgaGF2ZSBkaXJlY3Qgc3VwcG9ydCBmb3IgdHJ1ZVxuICogcHJpdmF0ZSBwcm9wZXJ0aWVzLiBPbmUgYXBwcm9hY2ggaXMgdG8gdXNlIHRoZVxuICogW1N5bWJvbF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3ltYm9sKVxuICogZGF0YSB0eXBlIHRvIHNldCBhbmQgcmV0cmlldmUgZGF0YSBvbiBhbiBlbGVtZW50LlxuICpcbiAqIFVuZm9ydHVuYXRlbHksIHRoZSBTeW1ib2wgdHlwZSBpcyBub3QgYXZhaWxhYmxlIGluIEludGVybmV0IEV4cGxvcmVyIDExLiBUaGVcbiAqIGBjcmVhdGVTeW1ib2xgIGhlbHBlciBmdW5jdGlvbiBleGlzdHMgYXMgYSB3b3JrYXJvdW5kIGZvciBJRSAxMS4gUmF0aGVyIHRoYW5cbiAqIHJldHVybmluZyBhIHRydWUgU3ltYm9sLCBpdCBzaW1wbHkgcmV0dXJucyBhbiB1bmRlcnNjb3JlLXByZWZpeGVkIHN0cmluZy5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgICAgY29uc3QgZm9vU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdmb28nKTtcbiAqXG4gKiAgICAgY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICogICAgICAgZ2V0IGZvbygpIHtcbiAqICAgICAgICAgcmV0dXJuIHRoaXNbZm9vU3ltYm9sXTtcbiAqICAgICAgIH1cbiAqICAgICAgIHNldCBmb28odmFsdWUpIHtcbiAqICAgICAgICAgdGhpc1tmb29TeW1ib2xdID0gdmFsdWU7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIEluIElFIDExLCB0aGlzIHNhbXBsZSB3aWxsIFwiaGlkZVwiIGRhdGEgYmVoaW5kIGFuIGluc3RhbmNlIHByb3BlcnR5IHRoaXMuX2Zvby5cbiAqIFRoZSB1c2Ugb2YgdGhlIHVuZGVyc2NvcmUgaXMgbWVhbnQgdG8gcmVkdWNlIChub3QgZWxpbWluYXRlKSB0aGUgcG90ZW50aWFsXG4gKiBmb3IgbmFtZSBjb25mbGljdHMsIGFuZCBkaXNjb3VyYWdlIChub3QgcHJldmVudCkgZXh0ZXJuYWwgYWNjZXNzIHRvIHRoaXNcbiAqIGRhdGEuIEluIG1vZGVybiBicm93c2VycywgdGhlIGFib3ZlIGNvZGUgd2lsbCBlbGltaW5hdGUgdGhlIHBvdGVudGlhbCBvZlxuICogbmFtaW5nIGNvbmZsaWN0cywgYW5kIGJldHRlciBoaWRlIHRoZSBkYXRhIGJlaGluZCBhIHJlYWwgU3ltYm9sLlxuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVTeW1ib2xcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgc3RyaW5nIHRvIGlkZW50aWZ5IHRoZSBzeW1ib2wgd2hlbiBkZWJ1Z2dpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nID9cbiAgICBTeW1ib2woZGVzY3JpcHRpb24pIDpcbiAgICBgXyR7ZGVzY3JpcHRpb259YDtcbn1cbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi9jcmVhdGVTeW1ib2wnO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBTeW1ib2wgb2JqZWN0cyBmb3Igc3RhbmRhcmQgY29tcG9uZW50IHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gKlxuICogVGhlc2UgU3ltYm9sIG9iamVjdHMgYXJlIHVzZWQgdG8gYWxsb3cgbWl4aW5zIGFuZCBhIGNvbXBvbmVudCB0byBpbnRlcm5hbGx5XG4gKiBjb21tdW5pY2F0ZSwgd2l0aG91dCBleHBvc2luZyB0aGVzZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZSBjb21wb25lbnQnc1xuICogcHVibGljIEFQSS5cbiAqXG4gKiBUbyB1c2UgdGhlc2UgU3ltYm9sIG9iamVjdHMgaW4geW91ciBvd24gY29tcG9uZW50LCBpbmNsdWRlIHRoaXMgbW9kdWxlIGFuZFxuICogdGhlbiBjcmVhdGUgYSBwcm9wZXJ0eSBvciBtZXRob2Qgd2hvc2Uga2V5IGlzIHRoZSBkZXNpcmVkIFN5bWJvbC5cbiAqXG4gKiAgICAgaW1wb3J0ICdTaW5nbGVTZWxlY3Rpb25NaXhpbicgZnJvbSAnYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2luZ2xlU2VsZWN0aW9uTWl4aW4nO1xuICogICAgIGltcG9ydCAnc3ltYm9scycgZnJvbSAnYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc3ltYm9scyc7XG4gKlxuICogICAgIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIFNpbmdsZVNlbGVjdGlvbk1peGluKEhUTUxFbGVtZW50KSB7XG4gKiAgICAgICBbc3ltYm9scy5hcHBseVNlbGVjdGlvbl0oaXRlbSwgc2VsZWN0ZWQpIHtcbiAqICAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGludm9rZWQgd2hlbmV2ZXIgYW4gaXRlbSBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkLlxuICogICAgICAgfVxuICogICAgIH1cbiAqXG4gKiBAbW9kdWxlIHN5bWJvbHNcbiAqL1xuY29uc3Qgc3ltYm9scyA9IHtcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGFwcGx5U2VsZWN0aW9uYCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGFwcGxpZXMgdGhlIGluZGljYXRlZCBzZWxlY3Rpb24gc3RhdGUgdG8gYW4gaXRlbS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGFwcGx5U2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGl0ZW0gLSB0aGUgaXRlbSBiZWluZyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgLSB0cnVlIGlmIHRoZSBpdGVtIGlzIHNlbGVjdGVkLCBmYWxzZSBpZiBub3RcbiAgICovXG4gIGFwcGx5U2VsZWN0aW9uOiBjcmVhdGVTeW1ib2woJ2FwcGx5U2VsZWN0aW9uJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBkZWZhdWx0c2AgcHJvcGVydHkuXG4gICAqXG4gICAqIFRoaXMgcHJvcGVydHkgY2FuIGJlIHVzZWQgdG8gc2V0IG9yIG92ZXJyaWRlIGRlZmF1bHRzIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gICAqIHRvIGEgbmV3IGNvbXBvbmVudCBpbnN0YW5jZS4gV2hlbiBpbXBsZW1lbnRpbmcgdGhpcyBwcm9wZXJ0eSwgdGFrZSBjYXJlIHRvXG4gICAqIGZpcnN0IGFjcXVpcmUgYW55IGRlZmF1bHRzIGRlZmluZWQgYnkgdGhlIHN1cGVyY2xhc3MuIFRoZSBzdGFuZGFyZCBpZGlvbSBpc1xuICAgKiBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiAgICAgZ2V0IFtzeW1ib2xzLmRlZmF1bHRzXSgpIHtcbiAgICogICAgICAgY29uc3QgZGVmYXVsdHMgPSBzdXBlcltzeW1ib2xzLmRlZmF1bHRzXSB8fCB7fTtcbiAgICogICAgICAgLy8gU2V0IG9yIG92ZXJyaWRlIGRlZmF1bHQgdmFsdWVzIGhlcmVcbiAgICogICAgICAgZGVmYXVsdHMuY3VzdG9tUHJvcGVydHkgPSBmYWxzZTtcbiAgICogICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgKiAgICAgfVxuICAgKlxuICAgKiBAdmFyIHtvYmplY3R9IGRlZmF1bHRzXG4gICAqL1xuICBkZWZhdWx0czogY3JlYXRlU3ltYm9sKCdkZWZhdWx0cycpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgZHJhZ2dpbmdgIHByb3BlcnR5LlxuICAgKlxuICAgKiBDb21wb25lbnRzIGxpa2UgY2Fyb3VzZWxzIG9mdGVuIGRlZmluZSBhbmltYXRlZCBDU1MgdHJhbnNpdGlvbnMgZm9yXG4gICAqIHNsaWRpbmcgZWZmZWN0cy4gU3VjaCBhIHRyYW5zaXRpb24gc2hvdWxkIHVzdWFsbHkgKm5vdCogYmUgYXBwbGllZCB3aGlsZVxuICAgKiB0aGUgdXNlciBpcyBkcmFnZ2luZywgYmVjYXVzZSBhIENTUyBhbmltYXRpb24gd2lsbCBpbnRyb2R1Y2UgYSBsYWcgdGhhdFxuICAgKiBtYWtlcyB0aGUgc3dpcGUgZmVlbCBzbHVnZ2lzaC4gSW5zdGVhZCwgYXMgbG9uZyBhcyB0aGUgdXNlciBpcyBkcmFnZ2luZ1xuICAgKiB3aXRoIHRoZWlyIGZpbmdlciBkb3duLCB0aGUgdHJhbnNpdGlvbiBzaG91bGQgYmUgc3VwcHJlc3NlZC4gV2hlbiB0aGVcbiAgICogdXNlciByZWxlYXNlcyB0aGVpciBmaW5nZXIsIHRoZSB0cmFuc2l0aW9uIGNhbiBiZSByZXN0b3JlZCwgYWxsb3dpbmcgdGhlXG4gICAqIGFuaW1hdGlvbiB0byBzaG93IHRoZSBjYXJvdXNlbCBzbGlkaW5nIGludG8gaXRzIGZpbmFsIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIGRyYWcgaXMgaW4gcHJvZ3Jlc3MsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGRyYWdnaW5nOiBjcmVhdGVTeW1ib2woJ2RyYWdnaW5nJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBnb0Rvd25gIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIGRvd24uXG4gICAqXG4gICAqIEBmdW5jdGlvbiBnb0Rvd25cbiAgICovXG4gIGdvRG93bjogY3JlYXRlU3ltYm9sKCdnb0Rvd24nKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGdvRW5kYCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSB0byB0aGUgZW5kIChlLmcuLFxuICAgKiBvZiBhIGxpc3QpLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gZ29FbmRcbiAgICovXG4gIGdvRW5kOiBjcmVhdGVTeW1ib2woJ2dvRW5kJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBnb0xlZnRgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIGxlZnQuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBnb0xlZnRcbiAgICovXG4gIGdvTGVmdDogY3JlYXRlU3ltYm9sKCdnb0xlZnQnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGdvUmlnaHRgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIHJpZ2h0LlxuICAgKlxuICAgKiBAZnVuY3Rpb24gZ29SaWdodFxuICAgKi9cbiAgZ29SaWdodDogY3JlYXRlU3ltYm9sKCdnb1JpZ2h0JyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBnb1N0YXJ0YCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSB0byB0aGUgc3RhcnRcbiAgICogKGUuZy4sIG9mIGEgbGlzdCkuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBnb1N0YXJ0XG4gICAqL1xuICBnb1N0YXJ0OiBjcmVhdGVTeW1ib2woJ2dvU3RhcnQnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGdvVXBgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIHVwLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gZ29VcFxuICAgKi9cbiAgZ29VcDogY3JlYXRlU3ltYm9sKCdnb1VwJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBpdGVtQWRkZWRgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIGEgbmV3IGl0ZW0gaXMgYWRkZWQgdG8gYSBsaXN0LlxuICAgKlxuICAgKiBAZnVuY3Rpb24gaXRlbUFkZGVkXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGl0ZW0gLSB0aGUgaXRlbSBiZWluZyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gICAqL1xuICBpdGVtQWRkZWQ6IGNyZWF0ZVN5bWJvbCgnaXRlbUFkZGVkJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBrZXlkb3duYCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiBhbiBlbGVtZW50IHJlY2VpdmVzIGEgYGtleWRvd25gIGV2ZW50LlxuICAgKlxuICAgKiBAZnVuY3Rpb24ga2V5ZG93blxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IGJlaW5nIHByb2Nlc3NlZFxuICAgKi9cbiAga2V5ZG93bjogY3JlYXRlU3ltYm9sKCdrZXlkb3duJylcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN5bWJvbHM7XG4iXX0=
