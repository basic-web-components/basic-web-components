{"version":3,"sources":["node_modules/browser-pack/_prelude.js","packages/basic-component-mixins/src/AttributeMarshallingMixin.js","packages/basic-component-mixins/src/ComposableMixin.js","packages/basic-component-mixins/src/ContentItemsMixin.js","packages/basic-component-mixins/src/DistributedChildrenContentMixin.js","packages/basic-component-mixins/src/DistributedChildrenMixin.js","packages/basic-component-mixins/src/FractionalSelectionMixin.js","packages/basic-component-mixins/src/SelectionAriaActiveMixin.js","packages/basic-component-mixins/src/ShadowElementReferencesMixin.js","packages/basic-component-mixins/src/ShadowTemplateMixin.js","packages/basic-component-mixins/src/SingleSelectionMixin.js","packages/basic-component-mixins/src/createSymbol.js","packages/basic-component-mixins/src/microtask.js","packages/basic-component-mixins/src/safeAttributes.js","packages/basic-component-mixins/src/symbols.js","packages/basic-component-mixins/src/toggleClass.js","packages/basic-element-base/src/ElementBase.js","packages/basic-sliding-viewport/globals.js","packages/basic-sliding-viewport/src/SlidingViewport.js","packages/basic-spread-items/src/SpreadItems.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","attributeToPropertyName","attributeName","propertyName","attributeToPropertyNames","hypenRegEx","replace","match","toUpperCase","attributesForClass","classFn","HTMLElement","Object","baseClass","getPrototypeOf","prototype","constructor","baseAttributes","propertyNames","getOwnPropertyNames","setterNames","filter","getOwnPropertyDescriptor","set","attributes","map","setterName","propertyNameToAttribute","diff","attribute","indexOf","concat","propertyNamesToAttributes","uppercaseRegEx","toLowerCase","_safeAttributes","base","AttributeMarshalling","_base","_classCallCheck","this","_possibleConstructorReturn","__proto__","apply","arguments","_inherits","_createClass","key","value","oldValue","newValue","_get","_safeAttributes2","default","connected","setAttribute","className","toggleClass","get","composeClass","mixin","Subclass","_base2","copyOwnProperties","NON_MIXABLE_OBJECT_PROPERTIES","source","target","ignorePropertyNames","undefined","forEach","name","descriptor","defineProperty","Composable","_len","mixins","Array","_key","reduce","filterAuxiliaryElements","items","auxiliaryTags","item","localName","_createSymbol","_toggleClass","_symbols","itemsSymbol","_createSymbol2","itemInitializedSymbol","ContentItems","_symbols2","itemsChanged","itemAdded","itemSelected","selected","_toggleClass2","_this2","handlingUserInteraction","dispatchEvent","CustomEvent","content","_microtask","DistributedChildrenContent","_this","shadowRoot","slots","querySelectorAll","slot","addEventListener","event","contentChanged","_microtask2","distributedChildren","console","warn","_set","expandContentElements","nodes","includeTextNodes","_ref","expanded","node","isSlot","HTMLSlotElement","assignedNodes","flatten","Text","flattened","_toConsumableArray","DistributedChildren","children","childNodes","strings","distributedChildNodes","child","textContent","join","FractionalSelection","selectedFraction","selectedFractionSymbol","helpers","dampedSelection","selection","itemCount","bound","damped","damping","x","y","elementSelection","element","selectedIndex","selectionParts","index","Math","ceil","floor","fraction","wrappedSelection","wrappedSelectionParts","wrap","idCount","SelectionAriaActive","getAttribute","defaults","role","id","baseId","itemId","removeAttribute","ShadowElementReferences","$","nodesWithIds","createTemplateWithInnerHTML","innerHTML","template","document","createElement","div","appendChild","shimTemplateStyles","tag","window","WebComponents","ShadowCSS","shimStyling","ShadowTemplate","ShadowDOMPolyfill","root","attachShadow","mode","clone","importNode","selectIndex","count","boundedIndex","selectionWraps","max","min","previousIndex","trackSelectedItem","previousSelectedItem","selectedItem","indexInCurrentItems","previousSelectedIndex","newSelectedIndex","selectionRequired","updatePossibleNavigations","canSelectNext","canSelectPrevious","canSelectNextSymbol","canSelectPreviousSymbol","selectionRequiredSymbol","selectionWrapsSymbol","externalSelectedIndexSymbol","externalSelectedItemSymbol","internalSelectedIndexSymbol","internalSelectedItemSymbol","SingleSelection","newIndex","previousCanSelectNext","previousCanSelectPrevious","hasItems","detail","String","createSymbol","description","Symbol","microtask","callback","callbacks","push","counter","executeCallbacks","shift","createTextNode","observer","MutationObserver","observe","characterData","setAttributeToElement","text","safeToSetAttributesSymbol","pendingAttributesSymbol","pendingClassesSymbol","_value","_toggleClass3","symbols","dragging","goDown","goEnd","goLeft","goRight","goStart","goUp","keydown","force","classList","addClass","contains","add","remove","_AttributeMarshallingMixin","_ComposableMixin","_DistributedChildrenMixin","_ShadowElementReferencesMixin","_ShadowTemplateMixin","ElementBase","_ComposableMixin2","compose","_ShadowTemplateMixin2","_ShadowElementReferencesMixin2","_AttributeMarshallingMixin2","_DistributedChildrenMixin2","_SlidingViewport","Basic","SlidingViewport","_SlidingViewport2","render","requestAnimationFrame","renderSelection","bind","_FractionalSelectionMixin2","left","transform","slidingContainer","style","webkitTransform","_ContentItemsMixin","_DistributedChildrenContentMixin","_ElementBase","_FractionalSelectionMixin","_SelectionAriaActiveMixin","_SingleSelectionMixin","_SpreadItems","_ElementBase2","_ContentItemsMixin2","_DistributedChildrenContentMixin2","_SelectionAriaActiveMixin2","_SingleSelectionMixin2","showTransition","reflectClass","customElements","define","SpreadItems","spreadContainer","width","itemWidth"],"mappings":"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","file":"basic-sliding-viewport.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import safeAttributes from './safeAttributes';\n\n\n// Memoized maps of attribute to property names and vice versa.\nconst attributeToPropertyNames = {};\nconst propertyNamesToAttributes = {};\n\n\n/* Exported function extends a base class with AttributeMarshalling. */\nexport default (base) => {\n\n  /**\n   * Mixin which marshalls attributes to properties and vice versa.\n   *\n   * If your component exposes a setter for a property, it's generally a good\n   * idea to let devs using your component be able to set that property in HTML\n   * via an element attribute. You can code that yourself by writing an\n   * `attributeChangedCallback`, or you can use this mixin to get a degree of\n   * automatic support.\n   *\n   * This mixin implements an `attributeChangedCallback` that will attempt to\n   * convert a change in an element attribute into a call to the corresponding\n   * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n   * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n   * respects that convention, automatically mapping the hyphenated attribute\n   * name to the corresponding camelCase property name.\n   *\n   * Example: You define a component using this mixin:\n   *\n   *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n   *       get fooBar() { return this._fooBar; }\n   *       set fooBar(value) { this._fooBar = value; }\n   *     }\n   *     customElements.define('my-element', MyElement);\n   *\n   * If someone then instantiates your component in HTML:\n   *\n   *     <my-element foo-bar=\"Hello\"></my-element>\n   *\n   * Then, after the element has been upgraded, the `fooBar` setter will\n   * automatically be invoked with the initial value \"Hello\".\n   *\n   * For the time being, this mixin only supports string-valued properties.\n   * If you'd like to convert string attributes to other types (numbers,\n   * booleans), you need to implement `attributeChangedCallback` yourself.\n   */\n  class AttributeMarshalling extends base {\n\n    /*\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n      const propertyName = attributeToPropertyName(attributeName);\n      // If the attribute name corresponds to a property name, set the property.\n      // Ignore standard HTMLElement properties handled by the DOM.\n      if (propertyName in this && !(propertyName in HTMLElement.prototype)) {\n        this[propertyName] = newValue;\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    static get observedAttributes() {\n      return attributesForClass(this);\n    }\n\n    /**\n     * Set/unset the attribute with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as an attribute. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes. A call to `reflectAttribute` during the constructor will\n     * be deferred until the element is connected to the document.\n     *\n     * @param {string} attribute - The name of the *attribute* (not property) to set.\n     * @param {object} value - The value to set. If null, the attribute will be removed.\n     */\n    reflectAttribute(attribute, value) {\n      return safeAttributes.setAttribute(this, attribute, value);\n    }\n\n    /**\n     * Set/unset the class with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as as class. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes, including the `class` attribute. A call to\n     * `reflectClass` during the constructor will be deferred until the element\n     * is connected to the document.\n     *\n     * @param {string} className - The name of the class to set.\n     * @param {object} value - True to set the class, false to remove it.\n     */\n    reflectClass(className, value) {\n      return safeAttributes.toggleClass(this, className, value);\n    }\n\n  }\n\n  return AttributeMarshalling;\n};\n\n\n// Convert hyphenated foo-bar attribute name to camel case fooBar property name.\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hypenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hypenRegEx,\n        match => match[1].toUpperCase());\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\nfunction attributesForClass(classFn) {\n\n  // We treat the element base classes as if they have no attributes, since we\n  // don't want to receive attributeChangedCallback for them.\n  if (classFn === HTMLElement || classFn === Object) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n  const baseAttributes = attributesForClass(baseClass);\n\n  // Get attributes for this class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter(propertyName =>\n    typeof Object.getOwnPropertyDescriptor(\n        classFn.prototype, propertyName).set === 'function');\n  const attributes = setterNames.map(setterName =>\n      propertyNameToAttribute(setterName));\n\n  // Merge.\n  const diff = attributes.filter(attribute =>\n      baseAttributes.indexOf(attribute) < 0);\n  return baseAttributes.concat(diff);\n}\n\n// Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, '-$1').toLowerCase();\n  }\n  return attribute;\n}\n","/* Exported function extends a base class with Composable. */\nexport default (base) => {\n\n  /**\n   * Mixin to make a class more easily composable with other mixins.\n   *\n   * This mixin contributes a `compose` method that applies a set of mixin\n   * functions and returns the resulting new class. This sugar can make the\n   * application of many mixins at once easier to read.\n   */\n  class Composable extends base {\n\n    /**\n     * Apply a set of mixin functions or mixin objects to the present class and\n     * return the new class.\n     *\n     * Instead of writing:\n     *\n     *     let MyClass = Mixin1(Mixin2(Mixin3(Mixin4(Mixin5(BaseClass)))));\n     *\n     * You can write:\n     *\n     *     let MyClass = ComposableMixin(BaseClass).compose(\n     *       Mixin1,\n     *       Mixin2,\n     *       Mixin3,\n     *       Mixin4,\n     *       Mixin5\n     *     );\n     *\n     * This function can also take mixin objects. A mixin object is just a\n     * shorthand for a mixin function that creates a new subclass with the given\n     * members. The mixin object's members are *not* copied directly onto the\n     * prototype of the base class, as with traditional mixins.\n     *\n     * In addition to providing syntactic sugar, this mixin can be used to\n     * define a class in ES5, which lacks ES6's `class` keyword.\n     *\n     * @param {...mixins} mixins - A set of mixin functions or objects to apply.\n     */\n    static compose(...mixins) {\n      // We create a new subclass for each mixin in turn. The result becomes\n      // the base class extended by any subsequent mixins. It turns out that\n      // we can use Array.reduce() to concisely express this, using the current\n      // object as the seed for reduce().\n      return mixins.reduce(composeClass, this);\n    }\n\n  }\n\n  return Composable;\n};\n\n\n// Properties defined by Object that we don't want to mixin.\nconst NON_MIXABLE_OBJECT_PROPERTIES = [\n  'constructor'\n];\n\n/*\n * Apply the mixin to the given base class to return a new class.\n * The mixin can either be a function that returns the modified class, or a\n * plain object whose members will be copied to the new class' prototype.\n */\nfunction composeClass(base, mixin) {\n  if (typeof mixin === 'function') {\n    // Mixin function\n    return mixin(base);\n  } else {\n    // Mixin object\n    class Subclass extends base {}\n    copyOwnProperties(mixin, Subclass.prototype, NON_MIXABLE_OBJECT_PROPERTIES);\n    return Subclass;\n  }\n}\n\n\n/*\n * Copy the given properties/methods to the target.\n * Return the updated target.\n */\nfunction copyOwnProperties(source, target, ignorePropertyNames = []) {\n  Object.getOwnPropertyNames(source).forEach(name => {\n    if (ignorePropertyNames.indexOf(name) < 0) {\n      const descriptor = Object.getOwnPropertyDescriptor(source, name);\n      Object.defineProperty(target, name, descriptor);\n    }\n  });\n  return target;\n}\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemsSymbol = createSymbol('items');\nconst itemInitializedSymbol = createSymbol('itemInitialized');\n\n\n/* Exported function extends a base class with ContentItems. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps content semantics (elements) to list item semantics.\n   *\n   * Items differ from element contents in several ways:\n   *\n   * * They are often referenced via index.\n   * * They may have a selection state.\n   * * It's common to do work to initialize the appearance or state of a new\n   *   item.\n   * * Auxiliary invisible child elements are filtered out and not counted as\n   *   items. Auxiliary elements include link, script, style, and template\n   *   elements. This filtering ensures that those auxiliary elements can be\n   *   used in markup inside of a list without being treated as list items.\n   *\n   * This mixin expects a component to provide a `content` property returning a\n   * raw set of elements. You can provide that yourself, or use\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md).\n   *\n   * The most commonly referenced property defined by this mixin is the `items`\n   * property. To avoid having to do work each time that property is requested,\n   * this mixin supports an optimized mode. If you invoke the `contentChanged`\n   * method when the set of items changes, the mixin concludes that you'll take\n   * care of notifying it of future changes, and turns on the optimization. With\n   * that on, the mixin saves a reference to the computed set of items, and will\n   * return that immediately on subsequent calls to the `items` property. If you\n   * use this mixin in conjunction with\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md), the\n   * `contentChanged` method will be invoked for you when the element's children\n   * change, turning on the optimization automatically.\n   */\n  class ContentItems extends base {\n\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n\n      // Since we got the contentChanged call, we'll assume we'll be notified if\n      // the set of items changes later. We turn on memoization of the items\n      // property by setting our internal property to null (instead of\n      // undefined).\n      this[itemsSymbol] = null;\n\n      this[symbols.itemsChanged]();\n    }\n\n    /**\n     * This method is invoked whenever a new item is added to the list.\n     *\n     * The default implementation of this method does nothing. You can override\n     * this to perform per-item initialization.\n     *\n     * @param {HTMLElement} item - The item that was added.\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n    }\n\n    /**\n     * The selection state for a single item has changed.\n     *\n     * Invoke this method to signal that the selected state of the indicated item\n     * has changed. By default, this applies a `selected` CSS class if the item\n     * is selected, and removed it if not selected.\n     *\n     * @param {HTMLElement} item - The item whose selection state has changed.\n     * @param {boolean} selected - True if the item is selected, false if not.\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      toggleClass(item, 'selected', selected);\n    }\n\n    /**\n     * The current set of items in the list. See the top-level documentation for\n     * mixin for a description of how items differ from plain content.\n     *\n     * @type {HTMLElement[]}\n     */\n    get items() {\n      let items;\n      if (this[itemsSymbol] == null) {\n        items = filterAuxiliaryElements(this.content);\n        // Note: test for *equality* with null; don't treat undefined as a match.\n        if (this[itemsSymbol] === null) {\n          // Memoize the set of items.\n          this[itemsSymbol] = items;\n        }\n      } else {\n        // Return the memoized items.\n        items = this[itemsSymbol];\n      }\n      return items;\n    }\n\n    /**\n     * This method is invoked when the underlying contents change. It is also\n     * invoked on component initialization – since the items have \"changed\" from\n     * being nothing.\n     */\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // Perform per-item initialization.\n      Array.prototype.forEach.call(this.items, item => {\n        if (!item[itemInitializedSymbol]) {\n          this[symbols.itemAdded](item);\n          item[itemInitializedSymbol] = true;\n        }\n      });\n\n      if (this[symbols.handlingUserInteraction]) {\n        this.dispatchEvent(new CustomEvent('items-changed'));\n      }\n    }\n\n    /**\n     * Fires when the items in the list change.\n     *\n     * @memberof ContentItems\n     * @event items-changed\n     */\n  }\n\n  return ContentItems;\n};\n\n\n// Return the given elements, filtering out auxiliary elements that aren't\n// typically visible. Items which are not elements are returned as is.\nfunction filterAuxiliaryElements(items) {\n  const auxiliaryTags = [\n    'link',\n    'script',\n    'style',\n    'template'\n  ];\n  return [].filter.call(items, function(item) {\n    return !item.localName || auxiliaryTags.indexOf(item.localName) < 0;\n  });\n}\n","import microtask from './microtask';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/* Exported function extends a base class with DistributedChildrenContent. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines a component's content as its children, expanding any\n   * nodes distributed to the component's slots.\n   *\n   * This also provides notification of changes to a component's content. It\n   * will invoke a `contentChanged` method when the component is first\n   * instantiated, and whenever its distributed children change. This is an\n   * easy way to satisfy the Gold Standard checklist item for monitoring\n   * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n   *\n   * Example:\n   *\n   * ```\n   * let base = DistributedChildrenContentMixin(DistributedChildrenMixin(HTMLElement));\n   * class CountingElement extends base {\n   *\n   *   constructor() {\n   *     super();\n   *     let root = this.attachShadow({ mode: 'open' });\n   *     root.innerHTML = `<slot></slot>`;\n   *   }\n   *\n   *   contentChanged() {\n   *     // Count the component's children, both initially and when changed.\n   *     this.count = this.distributedChildren.length;\n   *   }\n   *\n   * }\n   * ```\n   *\n   * Note that content change detection depends upon the element having at least\n   * one `slot` element in its shadow subtree.\n   *\n   * This mixin is intended for use with the\n   * [DistributedChildrenMixin](DistributedChildrenMixin.md). See that mixin for\n   * a discussion of how that works. This DistributedChildrenContentMixin\n   * provides an easy way of defining the \"content\" of a component as the\n   * component's distributed children. That in turn lets mixins like\n   * [ContentItemsMixin](ContentItemsMixin.md) manipulate the children as list\n   * items.\n   */\n  class DistributedChildrenContent extends base {\n\n    constructor() {\n      super();\n\n      if (this.shadowRoot) {\n        // Listen to changes on all slots.\n        const slots = this.shadowRoot.querySelectorAll('slot');\n        slots.forEach(slot => slot.addEventListener('slotchange', event => {\n          this.contentChanged();\n        }));\n      }\n\n      // Make an initial call to contentChanged() so that the component can do\n      // initialization that it normally does when content changes.\n      //\n      // This will invoke contentChanged() handlers in other mixins. In order\n      // that those mixins have a chance to complete their own initialization,\n      // we add the contentChanged() call to the microtask queue.\n      microtask(() => this.contentChanged());\n    }\n\n    /**\n     * Invoked when the contents of the component (including distributed\n     * children) have changed.\n     *\n     * This method is also invoked when a component is first instantiated; the\n     * contents have essentially \"changed\" from being nothing. This allows the\n     * component to perform initial processing of its children.\n     */\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n      if (this[symbols.handlingUserInteraction]) {\n        const event = new CustomEvent('content-changed');\n        this.dispatchEvent(event);\n      }\n    }\n\n    /**\n     * The content of this component, defined to be the flattened array of\n     * children distributed to the component.\n     *\n     * @type {HTMLElement[]}\n     */\n    get content() {\n      const distributedChildren = this.distributedChildren;\n      if (typeof distributedChildren === 'undefined') {\n        console.warn(`DistributedChildrenContentMixin expects the component to define a \"distributedChildren\" property.`);\n      }\n      return distributedChildren;\n    }\n    set content(value) {\n      if ('content' in base.prototype) { super.content = value; }\n      // TODO: Set the children to the given value (which should be an array of\n      // elements)?\n    }\n\n    /**\n     * This event is raised when the component's contents (including distributed\n     * children) have changed.\n     *\n     * @memberof DistributedChildrenContent\n     * @event content-changed\n     */\n  }\n\n  return DistributedChildrenContent;\n};\n","/* Exported function extends a base class with DistributedChildren. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines helpers for accessing a component's distributed\n   * children as a flattened array or string.\n   *\n   * The standard DOM API provides several ways of accessing child content:\n   * `children`, `childNodes`, and `textContent`. None of these functions are\n   * Shadow DOM aware. This mixin defines variations of those functions that\n   * *are* Shadow DOM aware.\n   *\n   * Example: you create a component `<count-children>` that displays a number\n   * equal to the number of children placed inside that component. If someone\n   * instantiates your component like:\n   *\n   *     <count-children>\n   *       <div></div>\n   *       <div></div>\n   *       <div></div>\n   *     </count-children>\n   *\n   * Then the component should show \"3\", because there are three children. To\n   * calculate the number of children, the component can just calculate\n   * `this.children.length`. However, suppose someone instantiates your\n   * component inside one of their own components, and puts a `<slot>` element\n   * inside your component:\n   *\n   *     <count-children>\n   *       <slot></slot>\n   *     </count-children>\n   *\n   * If your component only looks at `this.children`, it will always see exactly\n   * one child — the `<slot>` element. But the user looking at the page will\n   * *see* any nodes distributed to that slot. To match what the user sees, your\n   * component should expand any `<slot>` elements it contains.\n   *\n   * That is the problem this mixin solves. After applying this mixin, your\n   * component code has access to `this.distributedChildren`, whose `length`\n   * will return the total number of all children distributed to your component\n   * in the composed tree.\n   *\n   * Note: The latest Custom Elements API design calls for a new function,\n   * `getAssignedNodes` that takes an optional `deep` parameter, that will solve\n   * this problem at the API level.\n   */\n  class DistributedChildren extends base {\n\n    /**\n     * An in-order collection of distributed children, expanding any slot\n     * elements. Like the standard children property, this skips text nodes.\n     *\n     * @type {HTMLElement[]}\n     */\n    get distributedChildren() {\n      return expandContentElements(this.children, false);\n    }\n\n    /**\n     * An in-order collection of distributed child nodes, expanding any slot\n     * elements. Like the standard childNodes property, this includes text\n     * nodes.\n     *\n     * @type {Node[]}\n     */\n    get distributedChildNodes() {\n      return expandContentElements(this.childNodes, true);\n    }\n\n    /**\n     * The concatenated text content of all distributed child nodes, expanding\n     * any slot elements.\n     *\n     * @type {string}\n     */\n    get distributedTextContent() {\n      const strings = this.distributedChildNodes.map(function(child) {\n        return child.textContent;\n      });\n      return strings.join('');\n    }\n\n  }\n\n  return DistributedChildren;\n};\n\n\n/*\n * Given a array of nodes, return a new array with any content elements expanded\n * to the nodes distributed to that content element. This rule is applied\n * recursively.\n *\n * If includeTextNodes is true, text nodes will be included, as in the\n * standard childNodes property; by default, this skips text nodes, like the\n * standard children property.\n */\nfunction expandContentElements(nodes, includeTextNodes) {\n  const expanded = Array.prototype.map.call(nodes, node => {\n    // We want to see if the node is an instanceof HTMLSlotELement, but\n    // that class won't exist if the browser that doesn't support native\n    // Shadow DOM and if the Shadow DOM polyfill hasn't been loaded. Instead,\n    // we do a simplistic check to see if the tag name is \"slot\".\n    const isSlot = typeof HTMLSlotElement !== 'undefined' ?\n      node instanceof HTMLSlotElement :\n      node.localName === 'slot';\n    if (isSlot) {\n      // Use the nodes assigned to this node instead.\n      const assignedNodes = node.assignedNodes({ flatten: true });\n      return assignedNodes ?\n        expandContentElements(assignedNodes, includeTextNodes) :\n        [];\n    } else if (node instanceof HTMLElement) {\n      // Plain element; use as is.\n      return [node];\n    } else if (node instanceof Text && includeTextNodes) {\n      // Text node.\n      return [node];\n    } else {\n      // Comment, processing instruction, etc.; skip.\n      return [];\n    }\n  });\n  const flattened = [].concat(...expanded);\n  return flattened;\n}\n","import createSymbol from './createSymbol';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n// Symbols for private data members on an element.\nconst selectedFractionSymbol = createSymbol('selectedFraction');\n\n\n/* Exported function extends a base class with FractionalSelection. */\nexport default function mixin(base) {\n\n  /**\n   * Adds support for fractional selection: treating a selection as a real\n   * number that combines an integer portion (an index into a list), and a\n   * fraction (indicating how far of the way we are to the next or previous\n   * item).\n   *\n   * This is useful in components that support incremental operations during\n   * dragging and swiping. Example: a carousel component has several items, and the\n   * currently selected item is item 3. The user begins swiping to the left,\n   * moving towards selecting item 4. Halfway through this operation, the\n   * fractional selection value is 3.5.\n   *\n   * This value permits communication between mixins like\n   * [SwipeDirectionMixin](./SwipeDirectionMixin.md) and\n   * [TrackpadDirectionMixin](./TrackpadDirectionMixin.md), which generate\n   * fractional selection values, and mixins like\n   * [SelectionAnimationMixin](./SelectionAnimationMixin.md), which can render\n   * selection at a fractional value.\n   */\n  class FractionalSelection extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      this.selectedFraction = 0;\n    }\n\n    /**\n     * A fractional value indicating how far the user has currently advanced to\n     * the next/previous item. E.g., a `selectedFraction` of 3.5 indicates the\n     * user is halfway between items 3 and 4.\n     *\n     * @type {number}\n     */\n    get selectedFraction() {\n      return this[selectedFractionSymbol];\n    }\n    set selectedFraction(value) {\n      this[selectedFractionSymbol] = value;\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      if (this[symbols.handlingUserInteraction]) {\n        const event = new CustomEvent('selected-fraction-changed');\n        this.dispatchEvent(event);\n      }\n    }\n\n  }\n\n  return FractionalSelection;\n}\n\n\nmixin.helpers = {\n\n  /*\n   * Dampen a selection that goes past the beginning or end of a list. This is\n   * generally used to produce a visual effect of tension as the user tries to\n   * go further in a direction that has no more items.\n   *\n   * Example: suppose `itemCount` is 5, indicating a list of 5 items. The index of\n   * the last item is 4. If the `selection` parameter is 4.5, the user is trying\n   * to go past this last item. When a damping function is applied, the resulting\n   * value will be less than 4.5 (the actual value will be 4.25). When this\n   * selection state is rendered, the user will see that, each unit distance the\n   * drag travels has less and less visible effect. This is perceived as tension.\n   *\n   * @param {number} selection - A real number indicating a selection position\n   * @param {number} itemCount - An integer for the number of items in the list\n   * @returns {number} A real number representing the damped selection value.\n   */\n  dampedSelection(selection, itemCount) {\n    const bound = itemCount - 1;\n    let damped;\n    if (selection < 0) {\n      // Trying to go past beginning of list. Apply tension from the left edge.\n      damped = -mixin.helpers.damping(-selection);\n    } else if (selection >= bound) {\n      // Trying to go past end of list. Apply tension from the right edge.\n      damped = bound + mixin.helpers.damping(selection - bound);\n    } else {\n      // No damping required.\n      damped = selection;\n    }\n    return damped;\n  },\n\n  /*\n   * Calculate damping as a function of the distance past the minimum/maximum\n   * values.\n   *\n   * We want to asymptotically approach an absolute minimum of 1 unit\n   * below/above the actual minimum/maximum. This requires calculating a\n   * hyperbolic function.\n   *\n   * See http://www.wolframalpha.com/input/?i=y+%3D+-1%2F%28x%2B1%29+%2B+1\n   * for the one we use. The only portion of that function we care about is when\n   * x is zero or greater. An important consideration is that the curve be\n   * tangent to the diagonal line x=y at (0, 0). This ensures smooth continuity\n   * with the normal drag behavior, in which the visible sliding is linear with\n   * the distance the touchpoint has been dragged.\n   */\n  damping(x) {\n    const y = (-1 / (x + 1)) + 1;\n    return y;\n  },\n\n  /*\n   * Return the current fractional selection value for the given element.\n   *\n   * This simply adds the element's `selectedIndex` and `selectedFraction`\n   * properties.\n   *\n   * @param {HTMLElement} element - An element that supports selection\n   */\n  elementSelection(element) {\n    const selectedIndex = element.selectedIndex;\n    if (selectedIndex < 0) {\n      // No selection\n      return;\n    }\n    const selectedFraction = element.selectedFraction || 0;\n    return selectedIndex + selectedFraction;\n  },\n\n  /*\n   * Breaks a fractional selection into its integer and fractional parts.\n   *\n   * Example: if passed 3.5, this returns { index: 3, fraction: 5 }.\n   *\n   * @param {number} selection – A real number representing a selection point\n   * @returns {object} - An object with an `index` property holding the\n   * selection's integer component, and a `fraction` property holding the\n   * selection's fractional component.\n   */\n  selectionParts(selection) {\n    // Stupid IE doesn't have Math.trunc.\n    // const index = Math.trunc(selection);\n    const index = selection < 0 ? Math.ceil(selection) : Math.floor(selection);\n    const fraction = selection - index;\n    return { index, fraction };\n  },\n\n  /*\n   * Returns a fractional selection point after accounting for wrapping, ensuring\n   * that the integer portion of the selection stays between 0 and `itemCount`-1.\n   * That is, the integer portion will always be a valid index into the list.\n   *\n   * Example of wrapping past the end of the list: if `selection` is 5.5 and\n   * `itemCount` is 5, this returns 0.5. Example of wrapping past the beginning of\n   * the list: if `selection` is 0.5 and `itemCount` is 5, this returns 4.5.\n   *\n   * @param {number} selection - A real number representing a selection point\n   * @param {number} itemCount - The number of items in the list\n   * @returns {number} - The result of wrapping the selection point\n   */\n  wrappedSelection(selection, itemCount) {\n    // Handles possibility of negative mod.\n    // See http://stackoverflow.com/a/18618250/76472\n    return ((selection % itemCount) + itemCount) % itemCount;\n  },\n\n  /*\n   * Return the parts of a selection, first wrapping if necessary.\n   *\n   * @param {number} selection – A real number representing a selection point\n   * @param {number} itemCount - The number of items in the list\n   * @param {boolean} wrap – True if the selection should wrap to stay within the\n   * list\n   * @returns {object} – The parts of the selection, using the same format as\n   * `selectionParts`.\n   */\n  wrappedSelectionParts(selection, itemCount, wrap) {\n    if (wrap) {\n      selection = mixin.helpers.wrappedSelection(selection, itemCount);\n    }\n    return mixin.helpers.selectionParts(selection);\n  }\n\n};\n","import symbols from './symbols';\n\n\n// Used to assign unique IDs to item elements without IDs.\nlet idCount = 0;\n\n\n/* Exported function extends a base class with SelectionAriaActive. */\nexport default (base) => {\n\n  /**\n   * Mixin which treats the selected item in a list as the active item in ARIA\n   * accessibility terms.\n   *\n   * Handling ARIA selection state properly is actually quite complex:\n   *\n   * * The items in the list need to be indicated as possible items via an ARIA\n   *   `role` attribute value such as \"option\".\n   * * The selected item need to be marked as selected by setting the item's\n   *   `aria-selected` attribute to true *and* the other items need be marked as\n   *   *not* selected by setting `aria-selected` to false.\n   * * The outermost element with the keyboard focus needs to have attributes\n   *   set on it so that the selection is knowable at the list level via the\n   *   `aria-activedescendant` attribute.\n   * * Use of `aria-activedescendant` in turn requires that all items in the\n   *   list have ID attributes assigned to them.\n   *\n   * This mixin tries to address all of the above requirements. To that end,\n   * this mixin will assign generated IDs to any item that doesn't already have\n   * an ID.\n   *\n   * ARIA relies on elements to provide `role` attributes. This mixin will apply\n   * a default role of \"listbox\" on the outer list if it doesn't already have an\n   * explicit role. Similarly, this mixin will apply a default role of \"option\"\n   * to any list item that does not already have a role specified.\n   *\n   * This mixin expects a set of members that manage the state of the selection:\n   * `[symbols.itemSelected]`, `itemAdded`, and `selectedIndex`. You can\n   * supply these yourself, or do so via\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class SelectionAriaActive extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      // Set default ARIA role.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'listbox';\n      return defaults;\n    }\n\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n\n      if (!item.getAttribute('role')) {\n        // Assign a default ARIA role.\n        item.setAttribute('role', 'option');\n      }\n\n      // Ensure each item has an ID so we can set aria-activedescendant on the\n      // overall list whenever the selection changes.\n      //\n      // The ID will take the form of a base ID plus a unique integer. The base\n      // ID will be incorporate the component's own ID. E.g., if a component has\n      // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n      // the compnent has no ID itself, its items will get IDs that look like\n      // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n      // them from manually-assigned IDs, and to minimize the potential for ID\n      // conflicts.\n      if (!item.id) {\n        const baseId = this.id ?\n            \"_\" + this.id + \"Option\" :\n            \"_option\";\n        item.id = baseId + idCount++;\n      }\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      item.setAttribute('aria-selected', selected);\n      const itemId = item.id;\n      if (itemId && selected) {\n        this.setAttribute('aria-activedescendant', itemId);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item == null) {\n        // Selection was removed.\n        this.removeAttribute('aria-activedescendant');\n      }\n    }\n\n  }\n\n  return SelectionAriaActive;\n};\n","/* Exported function extends a base class with ShadowElementReferences. */\nexport default (base) => {\n\n  /**\n   * Mixin to create references to elements in a component's Shadow DOM subtree.\n   *\n   * This adds a member on the component called `this.$` that can be used to\n   * reference shadow elements with IDs. E.g., if component's shadow contains an\n   * element `<button id=\"foo\">`, then this mixin will create a member\n   * `this.$.foo` that points to that button.\n   *\n   * Such references simplify a component's access to its own elements. In\n   * exchange, this mixin trades off a one-time cost of querying all elements in\n   * the shadow tree instead of paying an ongoing cost to query for an element\n   * each time the component wants to inspect or manipulate it.\n   *\n   * This mixin expects the component to define a Shadow DOM subtree. You can\n   * create that tree yourself, or make use of\n   * [ShadowTemplateMixin](ShadowTemplateMixin.md).\n   *\n   * This mixin is inspired by Polymer's [automatic\n   * node finding](https://www.polymer-project.org/1.0/docs/devguide/local-dom.html#node-finding)\n   * feature.\n   */\n  class ShadowElementReferences extends base {\n\n    constructor() {\n      super();\n      if (this.shadowRoot) {\n        // Look for elements in the shadow subtree that have id attributes.\n        // An alternatively implementation of this mixin would be to just define\n        // a this.$ getter that lazily does this search the first time someone\n        // tries to access this.$. That might introduce some complexity – if the\n        // the tree changed after it was first populated, the result of\n        // searching for a node might be somewhat unpredictable.\n        this.$ = {};\n        const nodesWithIds = this.shadowRoot.querySelectorAll('[id]');\n        [].forEach.call(nodesWithIds, node => {\n          const id = node.getAttribute('id');\n          this.$[id] = node;\n        });\n      }\n    }\n\n    /**\n     * The collection of references to the elements with IDs in a component's\n     * Shadow DOM subtree.\n     *\n     * @type {object}\n     * @member $\n     */\n  }\n\n  return ShadowElementReferences;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with ShadowTemplate. */\nexport default (base) => {\n\n  /**\n   * Mixin for stamping a template into a Shadow DOM subtree upon component\n   * instantiation.\n   *\n   * To use this mixin, define a `template` property as a string or HTML\n   * `<template>` element:\n   *\n   *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n   *       get [symbols.template]() {\n   *         return `Hello, <em>world</em>.`;\n   *       }\n   *     }\n   *\n   * When your component class is instantiated, a shadow root will be created on\n   * the instance, and the contents of the template will be cloned into the\n   * shadow root. If your component does not define a `template` property, this\n   * mixin has no effect.\n   *\n   * For the time being, this extension retains support for Shadow DOM v0. That\n   * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n   * implement Shadow DOM v1.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n      let template = this[symbols.template];\n      // TODO: Save the processed template with the component's class prototype\n      // so it doesn't need to be processed with every instantiation.\n      if (template) {\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          template = createTemplateWithInnerHTML(template);\n        }\n\n        if (window.ShadowDOMPolyfill) {\n          shimTemplateStyles(template, this.localName);\n        }\n\n        const root = this.attachShadow({ mode: 'open' });\n        const clone = document.importNode(template.content, true);\n        root.appendChild(clone);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n};\n\n\n// Convert a plain string of HTML into a real template element.\nfunction createTemplateWithInnerHTML(innerHTML) {\n  const template = document.createElement('template');\n  // REVIEW: Is there an easier way to do this?\n  // We'd like to just set innerHTML on the template content, but since it's\n  // a DocumentFragment, that doesn't work.\n  const div = document.createElement('div');\n  div.innerHTML = innerHTML;\n  while (div.childNodes.length > 0) {\n    template.content.appendChild(div.childNodes[0]);\n  }\n  return template;\n}\n\n// Invoke basic style shimming with ShadowCSS.\nfunction shimTemplateStyles(template, tag) {\n  window.WebComponents.ShadowCSS.shimStyling(template.content, tag);\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = createSymbol('canSelectNext');\nconst canSelectPreviousSymbol = createSymbol('canSelectPrevious');\nconst selectionRequiredSymbol = createSymbol('selectionRequired');\nconst selectionWrapsSymbol = createSymbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = createSymbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = createSymbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = createSymbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = createSymbol('internalSelectedItem');\n\n\n/* Exported function extends a base class with SingleSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages single-selection semantics for items in a list.\n   *\n   * This mixin expects a component to provide an `items` Array or NodeList of\n   * all elements in the list. A standard way to do that with is the\n   * [ContentItemsMixin](ContentItemsMixin.md), which takes a component's\n   * content (typically its distributed children) as the set of list items; see\n   * that mixin for details.\n   *\n   * This mixin tracks a single selected item in the list, and provides means to\n   * get and set that state by item position (`selectedIndex`) or item identity\n   * (`selectedItem`). The selection can be moved in the list via the methods\n   * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n   *\n   * This mixin does not produce any user-visible effects to represent\n   * selection. Other mixins, such as\n   * [SelectionAriaActiveMixin](SelectionAriaActiveMixin.md),\n   * [SelectionHighlightMixin](SelectionHighlightMixin.md) and\n   * [SelectionInViewMixin](SelectionInViewMixin.md), modify the selected item\n   * in common ways to let the user know a given item is selected or not\n   * selected.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const previousCanSelectNext = this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (canSelectNext !== previousCanSelectNext && this[symbols.handlingUserInteraction]) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const previousCanSelectPrevious = this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (canSelectPrevious !== previousCanSelectPrevious && this[symbols.handlingUserInteraction]) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedIndex = this[internalSelectedIndexSymbol];\n      let item;\n      if (index !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && index >= 0 && index < items.length)) {\n          index = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = index;\n        item = hasItems && index >= 0 ? items[index] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (index !== previousSelectedIndex) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = index;\n\n        if (this[symbols.handlingUserInteraction]) {\n          const event = new CustomEvent('selected-index-changed', {\n            detail: {\n              selectedIndex: index,\n              value: index // for Polymer binding. TODO: Verify still necessary\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (item !== previousSelectedItem) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        if (this[symbols.handlingUserInteraction]) {\n          const event = new CustomEvent('selected-item-changed', {\n            detail: {\n              selectedItem: item,\n              value: item // for Polymer binding\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      this[selectionRequiredSymbol] = selectionRequired;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      trackSelectedItem(this);\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(value) {\n      this[selectionWrapsSymbol] = String(value) === 'true';\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Select the last item in the list.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the selectedItem property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     * @param {HTMLElement} detail.previousItem The previously selected item.\n     */\n\n    /**\n     * Fires when the selectedIndex property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n  }\n\n  return SingleSelection;\n};\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n  const count = element.items.length;\n\n  const boundedIndex = (element.selectionWraps) ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n","/*\n * Microtask helper for IE 11.\n *\n * Executing a function as a microtask is trivial in browsers that support\n * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n * promises, but does support MutationObservers, which are also executed as\n * microtasks. So this helper uses an MutationObserver to achieve microtask\n * timing.\n *\n * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * Inspired by Polymer's async() function.\n */\n\n\n// The queue of pending callbacks to be executed as microtasks.\nconst callbacks = [];\n\n// Create an element that we will modify to force observable mutations.\nconst element = document.createTextNode('');\n\n// A monotonically-increasing value.\nlet counter = 0;\n\n\n/**\n * Add a callback to the microtask queue.\n *\n * This uses a MutationObserver so that it works on IE 11.\n *\n * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n * needs more investigation.\n *\n * @function microtask\n * @param {function} callback\n */\nexport default function microtask(callback) {\n  callbacks.push(callback);\n  // Force a mutation.\n  element.textContent = ++counter;\n}\n\n\n// Execute any pending callbacks.\nfunction executeCallbacks() {\n  while (callbacks.length > 0) {\n    const callback = callbacks.shift();\n    callback();\n  }\n}\n\n\n// Create the observer.\nconst observer = new MutationObserver(executeCallbacks);\nobserver.observe(element, {\n  characterData: true\n});\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\n\n\n// Symbols for private data members on an element.\nconst safeToSetAttributesSymbol = createSymbol('safeToSetAttributes');\nconst pendingAttributesSymbol = createSymbol('pendingAttributes');\nconst pendingClassesSymbol = createSymbol('pendingClasses');\n\n\n/**\n * Helper functions for updating attributes, including the `class` attribute.\n */\nexport default {\n\n  /**\n   * Perform any pending updates to attributes and classes.\n   *\n   * This writes any `setAttribute` or `toggleClass` values that were performed\n   * before an element was attached to the document for the first time.\n   *\n   * This method should be called by mixins/components in their\n   * `connectedCallback`. If mulitple mixins/components invoke this during the\n   * same `connectedCallback`, only the first call will have any effect. The\n   * subsequent calls will be harmless.\n   *\n   * @param {HTMLElement} element - The element being added to the document.\n   */\n  connected(element) {\n    element[safeToSetAttributesSymbol] = true;\n\n    // Set any pending attributes.\n    if (element[pendingAttributesSymbol]) {\n      for (let attribute in element[pendingAttributesSymbol]) {\n        const value = element[pendingAttributesSymbol][attribute];\n        setAttributeToElement(element, attribute, value);\n      }\n      element[pendingAttributesSymbol] = null;\n    }\n\n    // Set any pending classes.\n    if (element[pendingClassesSymbol]) {\n      for (let className in element[pendingClassesSymbol]) {\n        const value = element[pendingClassesSymbol][className];\n        toggleClass(element, className, value);\n      }\n      element[pendingClassesSymbol] = null;\n    }\n  },\n\n  /**\n   * Set/unset the attribute with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as an attribute. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes. A call to `setAttribute` during the constructor will\n   * be deferred until the element is connected to the document.\n   *\n   * @param {string} attribute - The name of the *attribute* (not property) to set.\n   * @param {object} value - The value to set. If null, the attribute will be removed.\n   */\n  setAttribute(element, attribute, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set attributes immediately.\n      setAttributeToElement(element, attribute, value);\n    } else {\n      // Defer setting attributes until the first time we're connected.\n      if (!element[pendingAttributesSymbol]) {\n        element[pendingAttributesSymbol] = {};\n      }\n      element[pendingAttributesSymbol][attribute] = value;\n    }\n  },\n\n  /**\n   * Set/unset the class with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as as class. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes, including the `class` attribute. A call to\n   * `toggleClass` during the constructor will be deferred until the element\n   * is connected to the document.\n   *\n   * @param {string} className - The name of the class to set.\n   * @param {object} value - True to set the class, false to remove it.\n   */\n  toggleClass(element, className, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set class immediately.\n      toggleClass(element, className, value);\n    } else {\n      // Defer setting class until the first time we're connected.\n      if (!element[pendingClassesSymbol]) {\n        element[pendingClassesSymbol] = {};\n      }\n      element[pendingClassesSymbol][className] = value;\n    }\n  }\n\n};\n\n\n// Reflect the attribute to the given element.\n// If the value is null, remove the attribute.\nfunction setAttributeToElement(element, attributeName, value) {\n  if (value === null || typeof value === 'undefined') {\n    element.removeAttribute(attributeName);\n  } else {\n    const text = String(value);\n    // Avoid recursive attributeChangedCallback calls.\n    if (element.getAttribute(attributeName) !== text) {\n      element.setAttribute(attributeName, value);\n    }\n  }\n}\n","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'basic-component-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'basic-component-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `dragging` property.\n   *\n   * Components like carousels often define animated CSS transitions for\n   * sliding effects. Such a transition should usually *not* be applied while\n   * the user is dragging, because a CSS animation will introduce a lag that\n   * makes the swipe feel sluggish. Instead, as long as the user is dragging\n   * with their finger down, the transition should be suppressed. When the\n   * user releases their finger, the transition can be restored, allowing the\n   * animation to show the carousel sliding into its final position.\n   *\n   * @type {boolean} true if a drag is in progress, false if not.\n   */\n  dragging: createSymbol('dragging'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: createSymbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: createSymbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: createSymbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: createSymbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: createSymbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: createSymbol('goUp'),\n\n  /**\n   * Symbol for the `handlingUserInteraction` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. This property can be used\n   * to manage events as follows.\n   *\n   * First, UI event listeners should set this property to `true` at the start\n   * of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.handlingUserInteraction] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.handlingUserInteraction] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.handlingUserInteraction]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   */\n  handlingUserInteraction: createSymbol('handlingUserInteraction'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: createSymbol('keydown'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLElement}\n   */\n  template: createSymbol('template')\n};\n\nexport default symbols;\n","/**\n * Helper function for standard classList.toggle() behavior on old browsers,\n * namely IE 11.\n *\n * The standard\n * [classlist](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)\n * object has a `toggle()` function that supports a second Boolean parameter\n * that can be used to succinctly turn a class on or off. This feature is often\n * useful in designing custom elements, which may want to externally reflect\n * component state in a CSS class that can be used for styling purposes.\n *\n * Unfortunately, IE 11 does not support the Boolean parameter to\n * `classList.toggle()`. This helper function behaves like the standard\n * `toggle()`, including support for the Boolean parameter, so that it can be\n * used even on IE 11.\n *\n * @function toggleClass\n * @param {HTMLElement} element - The element to modify\n * @param {string} className - The class to add/remove\n * @param {boolean} [force] - Force the class to be added (if true) or removed\n *                            (if false)\n */\nexport default function toggleClass(element, className, force) {\n  const classList = element.classList;\n  const addClass = (typeof force === 'undefined') ?\n    !classList.contains(className) :\n    force;\n  if (addClass) {\n    classList.add(className);\n  } else {\n    classList.remove(className);\n  }\n  return addClass;\n}\n","import AttributeMarshallingMixin from '../../basic-component-mixins/src/AttributeMarshallingMixin';\nimport ComposableMixin from '../../basic-component-mixins/src/ComposableMixin';\nimport DistributedChildrenMixin from '../../basic-component-mixins/src/DistributedChildrenMixin';\nimport ShadowElementReferencesMixin from '../../basic-component-mixins/src/ShadowElementReferencesMixin';\nimport ShadowTemplateMixin from '../../basic-component-mixins/src/ShadowTemplateMixin';\n\n\n/**\n * A sample general-purpose base class for defining custom elements that mixes\n * in some common features: template stamping into a shadow root, shadow element\n * references, marshalling attributes to properties, and retrieving the children\n * distributed to a component.\n *\n * This base class is not special in any way, and is defined only as a\n * convenient shorthand for applying the mixins listed above. You can use this\n * class as a base class for your own elements, or easily create your own base\n * class by applying the same set of mixins.\n *\n * The ElementBase base class does not register itself as a custom element with\n * the browser, and hence cannot be independently instantiated.\n *\n * @mixes AttributeMarshallingMixin\n * @mixes ComposableMixin\n * @mixes DistributedChildrenMixin\n * @mixes ShadowElementReferencesMixin\n * @mixes ShadowTemplateMixin\n */\nclass ElementBase extends ComposableMixin(HTMLElement).compose(\n  ShadowTemplateMixin,          // before node finding, so shadow root is populated\n  ShadowElementReferencesMixin, // before marshalling, so properties can use refs\n  AttributeMarshallingMixin,\n  DistributedChildrenMixin\n) {}\n\nexport default ElementBase;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport SlidingViewport from './src/SlidingViewport';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.SlidingViewport = SlidingViewport;\n","import ContentItemsMixin from '../../basic-component-mixins/src/ContentItemsMixin';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport ElementBase from '../../basic-element-base/src/ElementBase';\nimport FractionalSelectionMixin from '../../basic-component-mixins/src/FractionalSelectionMixin';\nimport SelectionAriaActiveMixin from '../../basic-component-mixins/src/SelectionAriaActiveMixin';\nimport SingleSelectionMixin from '../../basic-component-mixins/src/SingleSelectionMixin';\nimport SpreadItems from '../../basic-spread-items/src/SpreadItems'; // jshint ignore:line\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\nconst base = ElementBase.compose(\n  ContentItemsMixin,\n  DistributedChildrenContentMixin,\n  FractionalSelectionMixin,\n  SelectionAriaActiveMixin,\n  SingleSelectionMixin\n);\n\n\n/**\n * Presents list items in a viewport such that only a single item is visible at\n * a time.\n *\n * Navigating between items will be represented with a horizontal visual\n * sliding effect. For more complex visual effects, see\n * [basic-animation-stage](../basic-animation-stage), which takes advantage of\n * the Web Animations API.\n *\n * This component handles the rendering responsibilities for the basic-carousel\n * component.\n *\n * This component currently requires that you explicitly apply a size to it.\n *\n * @extends ElementBase\n * @mixes ContentItemsMixin\n * @mixes DistributedChildrenContentMixin\n * @mixes FractionalSelectionMixin\n * @mixes SelectionAriaActiveMixin\n * @mixes SingleSelectionMixin\n */\nclass SlidingViewport extends base {\n\n  constructor() {\n    super();\n    this[symbols.dragging] = false;\n  }\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.selectionRequired = true;\n    return defaults;\n  }\n\n  /*\n   * During drags, don't show CSS transitions.\n   */\n  get [symbols.dragging]() {\n    return !this.showTransition;\n  }\n  set [symbols.dragging](value) {\n    if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n    this.reflectClass('showTransition', !value);\n  }\n\n  get selectedFraction() {\n    return super.selectedFraction;\n  }\n  set selectedFraction(value) {\n    if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n    render(this);\n  }\n\n  get selectedItem() {\n    return super.selectedItem;\n  }\n  set selectedItem(item) {\n    if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n    render(this);\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        display: block;\n        overflow: hidden;\n        position: relative;\n      }\n\n      #slidingContainer {\n        height: 100%;\n        position: absolute;\n        /*\n         Set width for IE/Edge. It's not clear why they need this, and the other\n         browsers don't.\n         */\n        width: 100%;\n        will-change: transform;\n      }\n\n      :host(.showTransition) #slidingContainer {\n        -webkit-transition: -webkit-transform 0.2s ease-out;\n        transition: transform 0.2s ease-out;\n      }\n      </style>\n\n      <basic-spread-items id=\"slidingContainer\" role=\"none\">\n        <slot></slot>\n      </basic-spread-items>\n    `;\n  }\n\n}\n\n\n\nfunction render(element) {\n  requestAnimationFrame(renderSelection.bind(element));\n}\n\n// Note: In this routine, \"this\" is bound to an element instance.\nfunction renderSelection() {\n  if (!this.selectedItem) {\n    return;\n  }\n  const selection = FractionalSelectionMixin.helpers.elementSelection(this);\n  const itemCount = this.items ? this.items.length : 0;\n  const damped = FractionalSelectionMixin.helpers.dampedSelection(selection, itemCount);\n  // Use a percentage so the transform will still work if screen size changes\n  // (e.g., if device orientation changes).\n  const left = -damped * 100;\n  const transform = 'translateX(' + left + '%)';\n  this.$.slidingContainer.style.webkitTransform = transform;\n  this.$.slidingContainer.style.transform = transform;\n}\n\n\ncustomElements.define('basic-sliding-viewport', SlidingViewport);\nexport default SlidingViewport;\n","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/**\n * Spreads out a set of items horizontally so they take equal space.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-spread-items/)\n *\n * This component is used, for example, by the basic-sliding-viewport component\n * to ensure that children of different size will take up the same amount of\n * horizontal space.\n *\n * This component currently requires an explicit size by applied to it.\n *\n * @extends ElementBase\n * @mixes DistributedChildrenContentMixin\n */\nclass SpreadItems extends ElementBase.compose(\n  DistributedChildrenContentMixin\n) {\n\n  connectedCallback() {\n    if (super.connectedCallback) { super.connectedCallback(); }\n    // HACK\n    this[symbols.itemsChanged]();\n  }\n\n  get items() {\n    return this.content;\n  }\n\n  // TODO: Should also handle contentChanged(), but need to rationalize with\n  // invocation of [symbols.itemsChanged] in connectedCallback.\n  [symbols.itemsChanged]() {\n    if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n    const items = this.items;\n    const count = items.length;\n    this.$.spreadContainer.style.width = (count * 100) + '%';\n    const itemWidth = (100 / count) + \"%\";\n    [].forEach.call(items, item => {\n      item.style.width = itemWidth;\n    });\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        display: block;\n      }\n\n      #spreadContainer {\n        display: -webkit-flex;\n        display: flex;\n        height: 100%;\n        position: relative;\n      }\n\n      #spreadContainer ::slotted(*) {\n        object-fit: contain;\n        object-fit: var(--basic-item-object-fit, contain);\n        height: 100%;\n        -webkit-user-drag: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n      </style>\n\n      <div id=\"spreadContainer\" role=\"none\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n}\n\n\ncustomElements.define('basic-spread-items', SpreadItems);\nexport default SpreadItems;\n"]}