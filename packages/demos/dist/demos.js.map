{"version":3,"sources":["node_modules/browser-pack/_prelude.js","packages/basic-animation-stage/src/AnimationStage.js","packages/basic-carousel/src/Carousel.js","packages/basic-component-mixins/src/ArrowSelectionMixin.js","packages/basic-component-mixins/src/AttributeMarshallingMixin.js","packages/basic-component-mixins/src/ComposableMixin.js","packages/basic-component-mixins/src/ContentItemsMixin.js","packages/basic-component-mixins/src/DirectionSelectionMixin.js","packages/basic-component-mixins/src/DistributedChildrenContentMixin.js","packages/basic-component-mixins/src/DistributedChildrenMixin.js","packages/basic-component-mixins/src/FractionalSelectionMixin.js","packages/basic-component-mixins/src/HorizontalNavigationMixin.js","packages/basic-component-mixins/src/KeyboardDirectionMixin.js","packages/basic-component-mixins/src/KeyboardMixin.js","packages/basic-component-mixins/src/PageDotsMixin.js","packages/basic-component-mixins/src/SelectionAnimationMixin.js","packages/basic-component-mixins/src/SelectionAriaActiveMixin.js","packages/basic-component-mixins/src/ShadowElementReferencesMixin.js","packages/basic-component-mixins/src/ShadowTemplateMixin.js","packages/basic-component-mixins/src/SingleSelectionMixin.js","packages/basic-component-mixins/src/SwipeDirectionMixin.js","packages/basic-component-mixins/src/TrackpadDirectionMixin.js","packages/basic-component-mixins/src/createSymbol.js","packages/basic-component-mixins/src/microtask.js","packages/basic-component-mixins/src/renderArrayAsElements.js","packages/basic-component-mixins/src/safeAttributes.js","packages/basic-component-mixins/src/symbols.js","packages/basic-component-mixins/src/toggleClass.js","packages/basic-element-base/src/ElementBase.js","packages/basic-sliding-carousel/src/SlidingCarousel.js","packages/basic-sliding-viewport/src/SlidingViewport.js","packages/basic-spread-items/src/SpreadItems.js","packages/demos/src/AnimationStageWithDots.js","packages/demos/src/CarouselWithArrows.js","packages/demos/src/CarouselWithArrowsAndDots.js","packages/demos/src/CarouselWithDots.js","packages/demos/src/SlidingCarouselWithArrowsAndDots.js"],"names":[],"mappings":"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","file":"demos.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport ContentItemsMixin from '../../basic-component-mixins/src/ContentItemsMixin';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport FractionalSelectionMixin from '../../basic-component-mixins/src/FractionalSelectionMixin';\nimport SelectionAnimationMixin from '../../basic-component-mixins/src/SelectionAnimationMixin';\nimport SelectionAriaActiveMixin from '../../basic-component-mixins/src/SelectionAriaActiveMixin';\nimport SingleSelectionMixin from '../../basic-component-mixins/src/SingleSelectionMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\nconst base = ElementBase.compose(\n  ContentItemsMixin,\n  DistributedChildrenContentMixin,\n  FractionalSelectionMixin,\n  SelectionAnimationMixin,\n  SelectionAriaActiveMixin,\n  SingleSelectionMixin\n);\n\n/**\n * Presents a single item as selected, providing animated transitions when the\n * selection changes. The same animation can be shown at an arbitrary point,\n * generally used to reflect a user-controlled touch or trackpad drag operation\n * in progress.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-animation-stage/)\n *\n * This component is intended to be used as a programmatic rendering surface for\n * components which want to show transitional effects.\n *\n * The component uses [SelectionAnimationMixin](../basic-component-mixins/docs/SelectionAnimationMixin.md)\n * mixin, which in turn uses the Web Animations API. For use on browsers which\n * do not support that API natively, you will need to load the\n * [Web Animations polyfill](https://github.com/web-animations/web-animations-js).\n *\n * For a simpler component that exhibits only a sliding effect, but does not\n * require the Web Animations API, see [basic-sliding-viewport](../basic-sliding-viewport).\n *\n * @extends ElementBase\n * @mixes ContentItemsMixin\n * @mixes DistributedChildrenContentMixin\n * @mixes SelectionAnimationMixin\n * @mixes SelectionAriaActiveMixin\n * @mixes SingleSelectionMixin\n */\nclass AnimationStage extends base {\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.selectionRequired = true;\n    return defaults;\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        overflow: hidden;\n        position: relative;\n      }\n\n      #container ::slotted(*) {\n        height: 100%;\n        object-fit: contain;\n        position: absolute;\n        width: 100%;\n        will-change: transform;\n      }\n      </style>\n\n      <div id=\"container\" role=\"none\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n}\n\n\ncustomElements.define('basic-animation-stage', AnimationStage);\nexport default AnimationStage;\n","import AnimationStage from '../../basic-animation-stage/src/AnimationStage';\nimport HorizontalNavigationMixin from '../../basic-component-mixins/src/HorizontalNavigationMixin';\n\n\n/**\n * Lets the user navigate laterally through a sequence of child elements.\n *\n * basic-carousel is an implementation of the carousel user interface pattern,\n * commonly used for navigating between images, pages, and other elements. This\n * pattern presents the user with a linear sequence of elements, only one of\n * which is shown at a time. The user can navigate to the next/previous element\n * with a variety of input methods.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-carousel/)\n *\n * The above demo is a plain carousel. It's often combined, however, with\n * mixins like\n * [ArrowSelectionMixin](../basic-component-mixins/docs/ArrowSelectionMixin.md),\n * [PageDotsMixin](../basic-component-mixins/docs/PageDotsMixin.md),\n * [TimerSelectionMixin](../basic-component-mixins/docs/TimerSelectionMixin.md).\n * For example, you can view a\n * [demo with arrows and page dots](http://basicwebcomponents.org/basic-web-components/packages/demos/carousel-with-arrows-and-dots.html).\n * See the specific mixins for other carousel demos.\n *\n * basic-carousel uses its children as the elements the user will navigate\n * through. In a typical use, a basic-carousel can be used to navigate between a\n * sequence of images:\n *\n *     <basic-carousel>\n *       <img src=\"image1.jpg\">\n *       <img src=\"image2.jpg\">\n *       <img src=\"image3.jpg\">\n *     </basic-carousel>\n *\n * The child elements can be of any type — they are not restricted to images.\n *\n * This component attempts to meet the [Gold Standard for web components]\n * (https://github.com/webcomponents/gold-standard/wiki) so that it is generally\n * as flexible and robust as standard HTML elements. For example, it meets the\n * \"Content Changes\" criteria: the carousel will adapt to new child elements\n * added or removed at runtime.\n *\n * Currently, this component does not meet the Gold Standard criteria \"Size to\n * Content\". As a result, for the time being, **you must manually set a size on\n * this component**. Two approaches are to: 1) stretch the component across\n * whatever surface it is contained within, or 2) set it to be larger than the\n * largest child element you want to display. The former approach is more\n * common, and can be achieved with CSS styling such as:\n *\n *     html {\n *       height: 100%;\n *     }\n *\n *     body {\n *       display: -webkit-flex;\n *       display: flex;\n *       height: 100%;\n *       margin: 0;\n *     }\n *\n *     basic-carousel {\n *       -webkit-flex: 1;\n *       flex: 1;\n *     }\n *\n * The standard basic-carousel component supports navigation via the following\n * input methods:\n *\n * * Keyboard. When the carousel has focus, the user can press Left, Right,\n *   Home, or End. These navigate to the expected element.\n * * Touch. On mobile and other touch-enabled devices, the user can drag left or\n *   right.\n * * Trackpad. The user can swipe left or right on a trackpad to navigate.\n *\n * Because carousels are used in a wide variety of circumstances, by default\n * basic-carousel provides a minimal appearance and no separately interactive\n * elements such as arrow buttons on the side or dots along the bottom. Those\n * elements can be added by wrapping a Carousel in optional mixins:\n *\n * * [ArrowSelectionMixin](../basic-component-mixins/docs/ArrowSelectionMixin.md).\n *   Adds prominent left and right arrow buttons on the side of the carousel.\n * * [PageDotsMixin](../basic-component-mixins/docs/PageDotsMixin.md).\n *   Adds a series of small dots below the carousel to indicate the user's\n *   current position in the sequence.\n * * [TimerSelectionMixin](../basic-component-mixins/docs/TimerSelectionMixin.md).\n *   Advances to the next item on a timer.\n * * [TabStripMixin](../basic-tab-strip).\n *   Adds a strip of traditional tab buttons.\n *\n * See those components for more details, but in general you can construct a\n * common carousel with both arrow buttons and dots like so:\n *\n *     class MyCarousel extends\n *         ArrowSelectionMixin(PageDotsMixin(Carousel)) {}\n *     customElements.define('my-carousel', MyCarousel);\n *\n * For universal access, basic-carousel automatically adds a variety of\n * [ARIA](http://www.w3.org/WAI/intro/aria) properties to itself and to child\n * elements. This helps users navigate the sequence of elements in the carousel\n * using assistive technologies.\n *\n * @extends AnimationStage\n * @mixes HorizontalNavigationMixin\n */\nclass Carousel extends AnimationStage.compose(\n  HorizontalNavigationMixin\n) {}\n\ncustomElements.define('basic-carousel', Carousel);\nexport default Carousel;\n","import createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n// Symbols for private data members on an element.\nconst mousedownListenerSymbol = createSymbol('mousedownListener');\nconst mousemoveListenerSymbol = createSymbol('mousemoveListener');\nconst lastMouseXSymbol = createSymbol('lastMouseX');\nconst lastMouseYSymbol = createSymbol('lastMouseY');\nconst mouseTimeoutSymbol = createSymbol('mouseTimeout');\n\n\n/* Exported function extends a base class with ArrowSelection. */\nexport default (base) => {\n\n  /**\n   * Template mixin which adds prominent left and right arrow buttons to a\n   * wrapped child such as a carousel.\n   *\n   * You can see a\n   * [live demo](http://basicwebcomponents.org/basic-web-components/packages/demos/carousel-with-arrows.html)\n   * of this mixin applied to a carousel.\n   *\n   * Clicking the left/right buttons selects the previous/next item.\n   *\n   * Typical usage:\n   *\n   *     class CarouselWithArrows extends ArrowSelectionMixin(Carousel) {}\n   *     customElements.define('carousel-with-arrows', CarouselWithArrows);\n   *\n   * By default, the arrow buttons are shown on devices with a mouse or mouse-like\n   * pointing device. They are not shown on a touch-capable device unless mouse\n   * movement is detected. To cause the buttons to always appear, apply the\n   * 'showArrows' CSS class.\n   */\n  class ArrowSelection extends base {\n\n    constructor() {\n      super();\n\n      this.$.buttonLeft.addEventListener('click', event => {\n        this.selectPrevious();\n        event.stopPropagation();\n      });\n      this.$.buttonRight.addEventListener('click', event => {\n        this.selectNext();\n        event.stopPropagation();\n      });\n      assumeButtonFocus(this, this.$.buttonLeft);\n      assumeButtonFocus(this, this.$.buttonRight);\n    }\n\n    get canSelectNext() {\n      return super.canSelectNext;\n    }\n    set canSelectNext(canSelectNext) {\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      this.$.buttonRight.disabled = !canSelectNext;\n    }\n\n    get canSelectPrevious() {\n      return super.canSelectPrevious;\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      this.$.buttonLeft.disabled = !canSelectPrevious;\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      if (!this.classList.contains('showArrows')) {\n        // Determine whether we should show arrow buttons or not.\n        if (deviceSupportsTouch()) {\n          // A touch device might also support a mouse, but we can't know whether\n          // there's actually a mouse until we hear from it.\n          listenForMouse(this);\n        } else {\n          // The device doesn't support touch, so assume it has a mouse.\n          showArrows(this);\n        }\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.navigationAxis = 'horizontal';\n      return defaults;\n    }\n\n    /*\n     * The template uses the chevron-left and chevron-right SVG icons from\n     * https://github.com/PolymerElements/iron-icons/blob/master/iron-icons.html.\n     */\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n        :host {\n          -webkit-align-items: stretch;\n          align-items: stretch;\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          -webkit-justify-content: center;\n          justify-content: center;\n        }\n\n        #arrowNavigationContainer {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          position: relative;\n        }\n\n        .navigationButton {\n          background: transparent;\n          border: 1px solid transparent;\n          box-sizing: border-box;\n          color: rgba(0, 0, 0, 0.7);\n          fill: currentColor;\n          margin: 0;\n          opacity: 1;\n          outline: none; /* REVIEW: Accessibility should be provided by other elements. */\n          padding: 0;\n          transition: opacity 1s;\n          z-index: 1;\n        }\n\n        .navigationButton:hover:not(:disabled) {\n          background: rgba(0, 0, 0, 0.5);\n          color: rgba(0, 0, 0, 0.8);\n          cursor: pointer;\n        }\n        .navigationButton:active:not(:disabled) {\n          background: rgba(0, 0, 0, 0.7);\n          color: rgba(0, 0, 0, 0.9);\n        }\n        .navigationButton:disabled {\n          color: rgba(0, 0, 0, 0.2);\n        }\n\n        :host(:not(.showArrows)) .navigationButton {\n          opacity: 0;\n          visibility: hidden;\n        }\n\n        .navigationButton .icon {\n          height: 48px;\n          width: 48px;\n        }\n\n        /* Overlay variant */\n        :host(.overlayArrows) {\n          position: relative;\n        }\n        :host(.overlayArrows) .navigationButton {\n          bottom: 0;\n          color: rgba(255, 255, 255, 0.7);\n          position: absolute;\n          top: 0;\n        }\n        :host(.overlayArrows) #buttonLeft {\n          left: 0;\n        }\n        :host(.overlayArrows) #buttonRight {\n          right: 0;\n        }\n        :host(.overlayArrows) .navigationButton:hover:not(:disabled) {\n          background: rgba(255, 255, 255, 0.2);\n          color: rgba(255, 255, 255, 0.8);\n        }\n        :host(.overlayArrows) .navigationButton:active:not(:disabled) {\n          background: rgba(255, 255, 255, 0.4);\n          color: rgba(255, 255, 255, 0.9);\n        }\n        :host(.overlayArrows) .navigationButton:disabled {\n          color: rgba(255, 255, 255, 0.3);\n        }\n        </style>\n\n        <!--\n        Accessibility note: since the navigation offered by the arrow buttons should\n        be redundant (that is, there should be other ways of navigating the list),\n        we mark the button as aria-hidden so that assistive devices ignore them.\n        -->\n        <button id=\"buttonLeft\" class=\"navigationButton\" disabled tabindex=\"-1\" aria-hidden=\"true\">\n          <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n            <g id=\"chevron-left\">\n              <path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"/>\n            </g>\n          </svg>\n        </button>\n        <div id=\"arrowNavigationContainer\" role=\"none\">\n          ${baseTemplate}\n        </div>\n        <button id=\"buttonRight\" class=\"navigationButton\" disabled tabindex=\"-1\" aria-hidden=\"true\">\n          <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n            <g id=\"chevron-right\">\n              <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"/>\n            </g>\n          </svg>\n        </button>\n      `;\n    }\n\n  }\n\n  return ArrowSelection;\n};\n\n\n/*\n * By default, a button will always take focus on mousedown. For this component,\n * we want to override that behavior, such that a mousedown on a button keeps\n * the focus on the outer component.\n */\nfunction assumeButtonFocus(element, button) {\n  button.addEventListener('mousedown', event => {\n    // Given the main element the focus if it doesn't already have it.\n    element.focus();\n    // Prevent the default focus-on-mousedown behavior.\n    event.preventDefault();\n  });\n}\n\nfunction deviceSupportsTouch() {\n  return 'ontouchstart' in window ||\n      (window.DocumentTouch && document instanceof window.DocumentTouch);\n}\n\n// We try to detect the presence of a mouse by listening for mousemove events\n// which are *not* the result of a mousedown. On a touch device, a tap on the\n// page will generate a fake mousemove, followed by a mousedown. We don't want\n// to respond to those fake mousemove events. To discriminate between fake and\n// real mousemove events, when we get a mousemove event, we wait for a bit to\n// see if the same location is reported as the location of a subsequent\n// mousedown.\nfunction listenForMouse(element) {\n\n  element[mousedownListenerSymbol] = event => {\n    if (element[mouseTimeoutSymbol]) {\n      clearTimeout(element[mouseTimeoutSymbol]);\n    }\n    element[lastMouseXSymbol] = event.pageX;\n    element[lastMouseYSymbol] = event.pageY;\n  };\n  window.addEventListener('mousedown', element[mousedownListenerSymbol]);\n\n  element[mousemoveListenerSymbol] = event => {\n    // Postpone checking the mousemove location to give the mousedown event a\n    // chance to fire. The 250 ms delay is just guesswork; a shorter delay\n    // doesn't seem to work.\n    element[mouseTimeoutSymbol] = setTimeout(() => {\n      if (element[lastMouseXSymbol] != null && event.pageX !== element[lastMouseXSymbol] ||\n          element[lastMouseYSymbol] != null && event.pageY !== element[lastMouseYSymbol]) {\n        // mousemove event was at a location other than the last mousedown,\n        // and hence most likely a real mousemove event.\n        mouseDetected(element);\n      } else {\n        element[lastMouseXSymbol] = event.pageX;\n        element[lastMouseYSymbol] = event.pageY;\n      }\n    }, 250);\n  };\n  window.addEventListener('mousemove', element[mousemoveListenerSymbol]);\n}\n\nfunction mouseDetected(element) {\n  showArrows(element);\n\n  // We can stop listening for mouse events now.\n  if (element[mouseTimeoutSymbol]) {\n    clearTimeout(element[mouseTimeoutSymbol]);\n  }\n  window.removeEventListener('mousedown', element[mousedownListenerSymbol]);\n  window.removeEventListener('mousemove', element[mousemoveListenerSymbol]);\n  element[mousedownListenerSymbol] = null;\n  element[mousemoveListenerSymbol] = null;\n}\n\nfunction showArrows(element) {\n  element.classList.add('showArrows');\n}\n","import safeAttributes from './safeAttributes';\n\n\n// Memoized maps of attribute to property names and vice versa.\nconst attributeToPropertyNames = {};\nconst propertyNamesToAttributes = {};\n\n\n/* Exported function extends a base class with AttributeMarshalling. */\nexport default (base) => {\n\n  /**\n   * Mixin which marshalls attributes to properties and vice versa.\n   *\n   * If your component exposes a setter for a property, it's generally a good\n   * idea to let devs using your component be able to set that property in HTML\n   * via an element attribute. You can code that yourself by writing an\n   * `attributeChangedCallback`, or you can use this mixin to get a degree of\n   * automatic support.\n   *\n   * This mixin implements an `attributeChangedCallback` that will attempt to\n   * convert a change in an element attribute into a call to the corresponding\n   * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n   * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n   * respects that convention, automatically mapping the hyphenated attribute\n   * name to the corresponding camelCase property name.\n   *\n   * Example: You define a component using this mixin:\n   *\n   *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n   *       get fooBar() { return this._fooBar; }\n   *       set fooBar(value) { this._fooBar = value; }\n   *     }\n   *     customElements.define('my-element', MyElement);\n   *\n   * If someone then instantiates your component in HTML:\n   *\n   *     <my-element foo-bar=\"Hello\"></my-element>\n   *\n   * Then, after the element has been upgraded, the `fooBar` setter will\n   * automatically be invoked with the initial value \"Hello\".\n   *\n   * For the time being, this mixin only supports string-valued properties.\n   * If you'd like to convert string attributes to other types (numbers,\n   * booleans), you need to implement `attributeChangedCallback` yourself.\n   */\n  class AttributeMarshalling extends base {\n\n    /*\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n      const propertyName = attributeToPropertyName(attributeName);\n      // If the attribute name corresponds to a property name, set the property.\n      // Ignore standard HTMLElement properties handled by the DOM.\n      if (propertyName in this && !(propertyName in HTMLElement.prototype)) {\n        this[propertyName] = newValue;\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    static get observedAttributes() {\n      return attributesForClass(this);\n    }\n\n    /**\n     * Set/unset the attribute with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as an attribute. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes. A call to `reflectAttribute` during the constructor will\n     * be deferred until the element is connected to the document.\n     *\n     * @param {string} attribute - The name of the *attribute* (not property) to set.\n     * @param {object} value - The value to set. If null, the attribute will be removed.\n     */\n    reflectAttribute(attribute, value) {\n      return safeAttributes.setAttribute(this, attribute, value);\n    }\n\n    /**\n     * Set/unset the class with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as as class. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes, including the `class` attribute. A call to\n     * `reflectClass` during the constructor will be deferred until the element\n     * is connected to the document.\n     *\n     * @param {string} className - The name of the class to set.\n     * @param {object} value - True to set the class, false to remove it.\n     */\n    reflectClass(className, value) {\n      return safeAttributes.toggleClass(this, className, value);\n    }\n\n  }\n\n  return AttributeMarshalling;\n};\n\n\n// Convert hyphenated foo-bar attribute name to camel case fooBar property name.\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hypenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hypenRegEx,\n        match => match[1].toUpperCase());\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\nfunction attributesForClass(classFn) {\n\n  // We treat the element base classes as if they have no attributes, since we\n  // don't want to receive attributeChangedCallback for them.\n  if (classFn === HTMLElement || classFn === Object) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n  const baseAttributes = attributesForClass(baseClass);\n\n  // Get attributes for this class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter(propertyName =>\n    typeof Object.getOwnPropertyDescriptor(\n        classFn.prototype, propertyName).set === 'function');\n  const attributes = setterNames.map(setterName =>\n      propertyNameToAttribute(setterName));\n\n  // Merge.\n  const diff = attributes.filter(attribute =>\n      baseAttributes.indexOf(attribute) < 0);\n  return baseAttributes.concat(diff);\n}\n\n// Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, '-$1').toLowerCase();\n  }\n  return attribute;\n}\n","/* Exported function extends a base class with Composable. */\nexport default (base) => {\n\n  /**\n   * Mixin to make a class more easily composable with other mixins.\n   *\n   * This mixin contributes a `compose` method that applies a set of mixin\n   * functions and returns the resulting new class. This sugar can make the\n   * application of many mixins at once easier to read.\n   */\n  class Composable extends base {\n\n    /**\n     * Apply a set of mixin functions or mixin objects to the present class and\n     * return the new class.\n     *\n     * Instead of writing:\n     *\n     *     let MyClass = Mixin1(Mixin2(Mixin3(Mixin4(Mixin5(BaseClass)))));\n     *\n     * You can write:\n     *\n     *     let MyClass = ComposableMixin(BaseClass).compose(\n     *       Mixin1,\n     *       Mixin2,\n     *       Mixin3,\n     *       Mixin4,\n     *       Mixin5\n     *     );\n     *\n     * This function can also take mixin objects. A mixin object is just a\n     * shorthand for a mixin function that creates a new subclass with the given\n     * members. The mixin object's members are *not* copied directly onto the\n     * prototype of the base class, as with traditional mixins.\n     *\n     * In addition to providing syntactic sugar, this mixin can be used to\n     * define a class in ES5, which lacks ES6's `class` keyword.\n     *\n     * @param {...mixins} mixins - A set of mixin functions or objects to apply.\n     */\n    static compose(...mixins) {\n      // We create a new subclass for each mixin in turn. The result becomes\n      // the base class extended by any subsequent mixins. It turns out that\n      // we can use Array.reduce() to concisely express this, using the current\n      // object as the seed for reduce().\n      return mixins.reduce(composeClass, this);\n    }\n\n  }\n\n  return Composable;\n};\n\n\n// Properties defined by Object that we don't want to mixin.\nconst NON_MIXABLE_OBJECT_PROPERTIES = [\n  'constructor'\n];\n\n/*\n * Apply the mixin to the given base class to return a new class.\n * The mixin can either be a function that returns the modified class, or a\n * plain object whose members will be copied to the new class' prototype.\n */\nfunction composeClass(base, mixin) {\n  if (typeof mixin === 'function') {\n    // Mixin function\n    return mixin(base);\n  } else {\n    // Mixin object\n    class Subclass extends base {}\n    copyOwnProperties(mixin, Subclass.prototype, NON_MIXABLE_OBJECT_PROPERTIES);\n    return Subclass;\n  }\n}\n\n\n/*\n * Copy the given properties/methods to the target.\n * Return the updated target.\n */\nfunction copyOwnProperties(source, target, ignorePropertyNames = []) {\n  Object.getOwnPropertyNames(source).forEach(name => {\n    if (ignorePropertyNames.indexOf(name) < 0) {\n      const descriptor = Object.getOwnPropertyDescriptor(source, name);\n      Object.defineProperty(target, name, descriptor);\n    }\n  });\n  return target;\n}\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemsSymbol = createSymbol('items');\nconst itemInitializedSymbol = createSymbol('itemInitialized');\n\n\n/* Exported function extends a base class with ContentItems. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps content semantics (elements) to list item semantics.\n   *\n   * Items differ from element contents in several ways:\n   *\n   * * They are often referenced via index.\n   * * They may have a selection state.\n   * * It's common to do work to initialize the appearance or state of a new\n   *   item.\n   * * Auxiliary invisible child elements are filtered out and not counted as\n   *   items. Auxiliary elements include link, script, style, and template\n   *   elements. This filtering ensures that those auxiliary elements can be\n   *   used in markup inside of a list without being treated as list items.\n   *\n   * This mixin expects a component to provide a `content` property returning a\n   * raw set of elements. You can provide that yourself, or use\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md).\n   *\n   * The most commonly referenced property defined by this mixin is the `items`\n   * property. To avoid having to do work each time that property is requested,\n   * this mixin supports an optimized mode. If you invoke the `contentChanged`\n   * method when the set of items changes, the mixin concludes that you'll take\n   * care of notifying it of future changes, and turns on the optimization. With\n   * that on, the mixin saves a reference to the computed set of items, and will\n   * return that immediately on subsequent calls to the `items` property. If you\n   * use this mixin in conjunction with\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md), the\n   * `contentChanged` method will be invoked for you when the element's children\n   * change, turning on the optimization automatically.\n   */\n  class ContentItems extends base {\n\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n\n      // Since we got the contentChanged call, we'll assume we'll be notified if\n      // the set of items changes later. We turn on memoization of the items\n      // property by setting our internal property to null (instead of\n      // undefined).\n      this[itemsSymbol] = null;\n\n      this[symbols.itemsChanged]();\n    }\n\n    /**\n     * This method is invoked whenever a new item is added to the list.\n     *\n     * The default implementation of this method does nothing. You can override\n     * this to perform per-item initialization.\n     *\n     * @param {HTMLElement} item - The item that was added.\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n    }\n\n    /**\n     * The selection state for a single item has changed.\n     *\n     * Invoke this method to signal that the selected state of the indicated item\n     * has changed. By default, this applies a `selected` CSS class if the item\n     * is selected, and removed it if not selected.\n     *\n     * @param {HTMLElement} item - The item whose selection state has changed.\n     * @param {boolean} selected - True if the item is selected, false if not.\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      toggleClass(item, 'selected', selected);\n    }\n\n    /**\n     * The current set of items in the list. See the top-level documentation for\n     * mixin for a description of how items differ from plain content.\n     *\n     * @type {HTMLElement[]}\n     */\n    get items() {\n      let items;\n      if (this[itemsSymbol] == null) {\n        items = filterAuxiliaryElements(this.content);\n        // Note: test for *equality* with null; don't treat undefined as a match.\n        if (this[itemsSymbol] === null) {\n          // Memoize the set of items.\n          this[itemsSymbol] = items;\n        }\n      } else {\n        // Return the memoized items.\n        items = this[itemsSymbol];\n      }\n      return items;\n    }\n\n    /**\n     * This method is invoked when the underlying contents change. It is also\n     * invoked on component initialization – since the items have \"changed\" from\n     * being nothing.\n     */\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // Perform per-item initialization.\n      Array.prototype.forEach.call(this.items, item => {\n        if (!item[itemInitializedSymbol]) {\n          this[symbols.itemAdded](item);\n          item[itemInitializedSymbol] = true;\n        }\n      });\n\n      this.dispatchEvent(new CustomEvent('items-changed'));\n    }\n\n    /**\n     * Fires when the items in the list change.\n     *\n     * @memberof ContentItems\n     * @event items-changed\n     */\n  }\n\n  return ContentItems;\n};\n\n\n// Return the given elements, filtering out auxiliary elements that aren't\n// typically visible. Items which are not elements are returned as is.\nfunction filterAuxiliaryElements(items) {\n  const auxiliaryTags = [\n    'link',\n    'script',\n    'style',\n    'template'\n  ];\n  return [].filter.call(items, function(item) {\n    return !item.localName || auxiliaryTags.indexOf(item.localName) < 0;\n  });\n}\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with DirectionSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps direction semantics (goLeft, goRight, etc.) to selection\n   * semantics (selectPrevious, selectNext, etc.).\n   *\n   * This mixin can be used in conjunction with\n   * [KeyboardDirectionMixin](KeyboardDirectionMixin.md) (which maps keyboard\n   * events to directions) and a mixin that handles selection like\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class DirectionSelection extends base {\n\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { super[symbols.goDown](); }\n      return this.selectNext();\n    }\n\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { super[symbols.goEnd](); }\n      return this.selectLast();\n    }\n\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { super[symbols.goLeft](); }\n      return this.selectPrevious();\n    }\n\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { super[symbols.goRight](); }\n      return this.selectNext();\n    }\n\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { super[symbols.goStart](); }\n      return this.selectFirst();\n    }\n\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { super[symbols.goUp](); }\n      return this.selectPrevious();\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    get selectedFraction() {\n      return super.selectedFraction;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectFirst() {\n      if (super.selectFirst) { return super.selectFirst(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectLast() {\n      if (super.selectLast) { return super.selectLast(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectNext() {\n      if (super.selectNext) { return super.selectNext(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectPrevious() {\n      if (super.selectPrevious) { return super.selectPrevious(); }\n    }\n\n    // Map drag travel fraction to selection fraction.\n    get travelFraction() {\n      return super.travelFraction;\n    }\n    set travelFraction(value) {\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n      this.selectedFraction = value;\n    }\n\n  }\n\n  return DirectionSelection;\n};\n","import microtask from './microtask';\n\n\n/* Exported function extends a base class with DistributedChildrenContent. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines a component's content as its children, expanding any\n   * nodes distributed to the component's slots.\n   *\n   * This also provides notification of changes to a component's content. It\n   * will invoke a `contentChanged` method when the component is first\n   * instantiated, and whenever its distributed children change. This is an\n   * easy way to satisfy the Gold Standard checklist item for monitoring\n   * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n   *\n   * Example:\n   *\n   * ```\n   * let base = DistributedChildrenContentMixin(DistributedChildrenMixin(HTMLElement));\n   * class CountingElement extends base {\n   *\n   *   constructor() {\n   *     super();\n   *     let root = this.attachShadow({ mode: 'open' });\n   *     root.innerHTML = `<slot></slot>`;\n   *   }\n   *\n   *   contentChanged() {\n   *     // Count the component's children, both initially and when changed.\n   *     this.count = this.distributedChildren.length;\n   *   }\n   *\n   * }\n   * ```\n   *\n   * Note that content change detection depends upon the element having at least\n   * one `slot` element in its shadow subtree.\n   *\n   * This mixin is intended for use with the\n   * [DistributedChildrenMixin](DistributedChildrenMixin.md). See that mixin for\n   * a discussion of how that works. This DistributedChildrenContentMixin\n   * provides an easy way of defining the \"content\" of a component as the\n   * component's distributed children. That in turn lets mixins like\n   * [ContentItemsMixin](ContentItemsMixin.md) manipulate the children as list\n   * items.\n   */\n  class DistributedChildrenContent extends base {\n\n    constructor() {\n      super();\n\n      if (this.shadowRoot) {\n        // Listen to changes on all slots.\n        const slots = this.shadowRoot.querySelectorAll('slot');\n        slots.forEach(slot => slot.addEventListener('slotchange', event => {\n          this.contentChanged();\n        }));\n      }\n\n      // Make an initial call to contentChanged() so that the component can do\n      // initialization that it normally does when content changes.\n      //\n      // This will invoke contentChanged() handlers in other mixins. In order\n      // that those mixins have a chance to complete their own initialization,\n      // we add the contentChanged() call to the microtask queue.\n      microtask(() => this.contentChanged());\n    }\n\n    /**\n     * Invoked when the contents of the component (including distributed\n     * children) have changed.\n     *\n     * This method is also invoked when a component is first instantiated; the\n     * contents have essentially \"changed\" from being nothing. This allows the\n     * component to perform initial processing of its children.\n     */\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n      const event = new CustomEvent('content-changed');\n      this.dispatchEvent(event);\n    }\n\n    /**\n     * The content of this component, defined to be the flattened array of\n     * children distributed to the component.\n     *\n     * @type {HTMLElement[]}\n     */\n    get content() {\n      const distributedChildren = this.distributedChildren;\n      if (typeof distributedChildren === 'undefined') {\n        console.warn(`DistributedChildrenContentMixin expects the component to define a \"distributedChildren\" property.`);\n      }\n      return distributedChildren;\n    }\n    set content(value) {\n      if ('content' in base.prototype) { super.content = value; }\n      // TODO: Set the children to the given value (which should be an array of\n      // elements)?\n    }\n\n    /**\n     * This event is raised when the component's contents (including distributed\n     * children) have changed.\n     *\n     * @memberof DistributedChildrenContent\n     * @event content-changed\n     */\n  }\n\n  return DistributedChildrenContent;\n};\n","/* Exported function extends a base class with DistributedChildren. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines helpers for accessing a component's distributed\n   * children as a flattened array or string.\n   *\n   * The standard DOM API provides several ways of accessing child content:\n   * `children`, `childNodes`, and `textContent`. None of these functions are\n   * Shadow DOM aware. This mixin defines variations of those functions that\n   * *are* Shadow DOM aware.\n   *\n   * Example: you create a component `<count-children>` that displays a number\n   * equal to the number of children placed inside that component. If someone\n   * instantiates your component like:\n   *\n   *     <count-children>\n   *       <div></div>\n   *       <div></div>\n   *       <div></div>\n   *     </count-children>\n   *\n   * Then the component should show \"3\", because there are three children. To\n   * calculate the number of children, the component can just calculate\n   * `this.children.length`. However, suppose someone instantiates your\n   * component inside one of their own components, and puts a `<slot>` element\n   * inside your component:\n   *\n   *     <count-children>\n   *       <slot></slot>\n   *     </count-children>\n   *\n   * If your component only looks at `this.children`, it will always see exactly\n   * one child — the `<slot>` element. But the user looking at the page will\n   * *see* any nodes distributed to that slot. To match what the user sees, your\n   * component should expand any `<slot>` elements it contains.\n   *\n   * That is the problem this mixin solves. After applying this mixin, your\n   * component code has access to `this.distributedChildren`, whose `length`\n   * will return the total number of all children distributed to your component\n   * in the composed tree.\n   *\n   * Note: The latest Custom Elements API design calls for a new function,\n   * `getAssignedNodes` that takes an optional `deep` parameter, that will solve\n   * this problem at the API level.\n   */\n  class DistributedChildren extends base {\n\n    /**\n     * An in-order collection of distributed children, expanding any slot\n     * elements. Like the standard children property, this skips text nodes.\n     *\n     * @type {HTMLElement[]}\n     */\n    get distributedChildren() {\n      return expandContentElements(this.children, false);\n    }\n\n    /**\n     * An in-order collection of distributed child nodes, expanding any slot\n     * elements. Like the standard childNodes property, this includes text\n     * nodes.\n     *\n     * @type {Node[]}\n     */\n    get distributedChildNodes() {\n      return expandContentElements(this.childNodes, true);\n    }\n\n    /**\n     * The concatenated text content of all distributed child nodes, expanding\n     * any slot elements.\n     *\n     * @type {string}\n     */\n    get distributedTextContent() {\n      const strings = this.distributedChildNodes.map(function(child) {\n        return child.textContent;\n      });\n      return strings.join('');\n    }\n\n  }\n\n  return DistributedChildren;\n};\n\n\n/*\n * Given a array of nodes, return a new array with any content elements expanded\n * to the nodes distributed to that content element. This rule is applied\n * recursively.\n *\n * If includeTextNodes is true, text nodes will be included, as in the\n * standard childNodes property; by default, this skips text nodes, like the\n * standard children property.\n */\nfunction expandContentElements(nodes, includeTextNodes) {\n  const expanded = Array.prototype.map.call(nodes, node => {\n    // We want to see if the node is an instanceof HTMLSlotELement, but\n    // that class won't exist if the browser that doesn't support native\n    // Shadow DOM and if the Shadow DOM polyfill hasn't been loaded. Instead,\n    // we do a simplistic check to see if the tag name is \"slot\".\n    const isSlot = typeof HTMLSlotElement !== 'undefined' ?\n      node instanceof HTMLSlotElement :\n      node.localName === 'slot';\n    if (isSlot) {\n      // Use the nodes assigned to this node instead.\n      const assignedNodes = node.assignedNodes({ flatten: true });\n      return assignedNodes ?\n        expandContentElements(assignedNodes, includeTextNodes) :\n        [];\n    } else if (node instanceof HTMLElement) {\n      // Plain element; use as is.\n      return [node];\n    } else if (node instanceof Text && includeTextNodes) {\n      // Text node.\n      return [node];\n    } else {\n      // Comment, processing instruction, etc.; skip.\n      return [];\n    }\n  });\n  const flattened = [].concat(...expanded);\n  return flattened;\n}\n","import createSymbol from './createSymbol';\n\n\n// Symbols for private data members on an element.\nconst selectedFractionSymbol = createSymbol('selectedFraction');\n\n\n/* Exported function extends a base class with FractionalSelection. */\nexport default function mixin(base) {\n\n  /**\n   * Adds support for fractional selection: treating a selection as a real\n   * number that combines an integer portion (an index into a list), and a\n   * fraction (indicating how far of the way we are to the next or previous\n   * item).\n   *\n   * This is useful in components that support incremental operations during\n   * dragging and swiping. Example: a carousel component has several items, and the\n   * currently selected item is item 3. The user begins swiping to the left,\n   * moving towards selecting item 4. Halfway through this operation, the\n   * fractional selection value is 3.5.\n   *\n   * This value permits communication between mixins like\n   * [SwipeDirectionMixin](./SwipeDirectionMixin.md) and\n   * [TrackpadDirectionMixin](./TrackpadDirectionMixin.md), which generate\n   * fractional selection values, and mixins like\n   * [SelectionAnimationMixin](./SelectionAnimationMixin.md), which can render\n   * selection at a fractional value.\n   */\n  class FractionalSelection extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      this.selectedFraction = 0;\n    }\n\n    /**\n     * A fractional value indicating how far the user has currently advanced to\n     * the next/previous item. E.g., a `selectedFraction` of 3.5 indicates the\n     * user is halfway between items 3 and 4.\n     *\n     * @type {number}\n     */\n    get selectedFraction() {\n      return this[selectedFractionSymbol];\n    }\n    set selectedFraction(value) {\n      this[selectedFractionSymbol] = value;\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      const event = new CustomEvent('selected-fraction-changed');\n      this.dispatchEvent(event);\n    }\n\n  }\n\n  return FractionalSelection;\n}\n\n\nmixin.helpers = {\n\n  /*\n   * Dampen a selection that goes past the beginning or end of a list. This is\n   * generally used to produce a visual effect of tension as the user tries to\n   * go further in a direction that has no more items.\n   *\n   * Example: suppose `itemCount` is 5, indicating a list of 5 items. The index of\n   * the last item is 4. If the `selection` parameter is 4.5, the user is trying\n   * to go past this last item. When a damping function is applied, the resulting\n   * value will be less than 4.5 (the actual value will be 4.25). When this\n   * selection state is rendered, the user will see that, each unit distance the\n   * drag travels has less and less visible effect. This is perceived as tension.\n   *\n   * @param {number} selection - A real number indicating a selection position\n   * @param {number} itemCount - An integer for the number of items in the list\n   * @returns {number} A real number representing the damped selection value.\n   */\n  dampedSelection(selection, itemCount) {\n    const bound = itemCount - 1;\n    let damped;\n    if (selection < 0) {\n      // Trying to go past beginning of list. Apply tension from the left edge.\n      damped = -mixin.helpers.damping(-selection);\n    } else if (selection >= bound) {\n      // Trying to go past end of list. Apply tension from the right edge.\n      damped = bound + mixin.helpers.damping(selection - bound);\n    } else {\n      // No damping required.\n      damped = selection;\n    }\n    return damped;\n  },\n\n  /*\n   * Calculate damping as a function of the distance past the minimum/maximum\n   * values.\n   *\n   * We want to asymptotically approach an absolute minimum of 1 unit\n   * below/above the actual minimum/maximum. This requires calculating a\n   * hyperbolic function.\n   *\n   * See http://www.wolframalpha.com/input/?i=y+%3D+-1%2F%28x%2B1%29+%2B+1\n   * for the one we use. The only portion of that function we care about is when\n   * x is zero or greater. An important consideration is that the curve be\n   * tangent to the diagonal line x=y at (0, 0). This ensures smooth continuity\n   * with the normal drag behavior, in which the visible sliding is linear with\n   * the distance the touchpoint has been dragged.\n   */\n  damping(x) {\n    const y = (-1 / (x + 1)) + 1;\n    return y;\n  },\n\n  /*\n   * Return the current fractional selection value for the given element.\n   *\n   * This simply adds the element's `selectedIndex` and `selectedFraction`\n   * properties.\n   *\n   * @param {HTMLElement} element - An element that supports selection\n   */\n  elementSelection(element) {\n    const selectedIndex = element.selectedIndex;\n    if (selectedIndex < 0) {\n      // No selection\n      return;\n    }\n    const selectedFraction = element.selectedFraction || 0;\n    return selectedIndex + selectedFraction;\n  },\n\n  /*\n   * Breaks a fractional selection into its integer and fractional parts.\n   *\n   * Example: if passed 3.5, this returns { index: 3, fraction: 5 }.\n   *\n   * @param {number} selection – A real number representing a selection point\n   * @returns {object} - An object with an `index` property holding the\n   * selection's integer component, and a `fraction` property holding the\n   * selection's fractional component.\n   */\n  selectionParts(selection) {\n    // Stupid IE doesn't have Math.trunc.\n    // const index = Math.trunc(selection);\n    const index = selection < 0 ? Math.ceil(selection) : Math.floor(selection);\n    const fraction = selection - index;\n    return { index, fraction };\n  },\n\n  /*\n   * Returns a fractional selection point after accounting for wrapping, ensuring\n   * that the integer portion of the selection stays between 0 and `itemCount`-1.\n   * That is, the integer portion will always be a valid index into the list.\n   *\n   * Example of wrapping past the end of the list: if `selection` is 5.5 and\n   * `itemCount` is 5, this returns 0.5. Example of wrapping past the beginning of\n   * the list: if `selection` is 0.5 and `itemCount` is 5, this returns 4.5.\n   *\n   * @param {number} selection - A real number representing a selection point\n   * @param {number} itemCount - The number of items in the list\n   * @returns {number} - The result of wrapping the selection point\n   */\n  wrappedSelection(selection, itemCount) {\n    // Handles possibility of negative mod.\n    // See http://stackoverflow.com/a/18618250/76472\n    return ((selection % itemCount) + itemCount) % itemCount;\n  },\n\n  /*\n   * Return the parts of a selection, first wrapping if necessary.\n   *\n   * @param {number} selection – A real number representing a selection point\n   * @param {number} itemCount - The number of items in the list\n   * @param {boolean} wrap – True if the selection should wrap to stay within the\n   * list\n   * @returns {object} – The parts of the selection, using the same format as\n   * `selectionParts`.\n   */\n  wrappedSelectionParts(selection, itemCount, wrap) {\n    if (wrap) {\n      selection = mixin.helpers.wrappedSelection(selection, itemCount);\n    }\n    return mixin.helpers.selectionParts(selection);\n  }\n\n};\n","import DirectionSelectionMixin from '../../basic-component-mixins/src/DirectionSelectionMixin';\nimport KeyboardDirectionMixin from '../../basic-component-mixins/src/KeyboardDirectionMixin';\nimport KeyboardMixin from '../../basic-component-mixins/src/KeyboardMixin';\nimport SwipeDirectionMixin from '../../basic-component-mixins/src/SwipeDirectionMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\nimport TrackpadDirectionMixin from '../../basic-component-mixins/src/TrackpadDirectionMixin';\n\n\nexport default (base) => {\n\n  const mixins = [\n    DirectionSelectionMixin,\n    KeyboardMixin,\n    KeyboardDirectionMixin,\n    SwipeDirectionMixin,\n    TrackpadDirectionMixin\n  ];\n\n  // Don't assume base class uses ComposableMixin. Do composition by hand.\n  const baseWithMixins = mixins.reduce((c, mixin) => mixin(c), base);\n\n  /**\n   * @mixes KeyboardMixin\n   * @mixes KeyboardDirectionMixin\n   * @mixes SwipeDirectionMixin\n   * @mixes TrackpadDirectionMixin\n   */\n  class HorizontalNavigation extends baseWithMixins {\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.navigationAxis = 'horizontal';\n      defaults.selectionAnimationEffect = 'slideWithGap';\n      // defaults.selectionRequired = true;\n      return defaults;\n    }\n\n  }\n\n  return HorizontalNavigation;\n\n};\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst navigationAxisSymbol = createSymbol('navigationAxis');\n\n\n/* Exported function extends a base class with KeyboardDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps direction keys (Left, Right, etc.) to direction semantics\n   * (go left, go right, etc.).\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   *\n   * This mixin calls methods such as `goLeft` and `goRight`. You can define\n   * what that means by implementing those methods yourself. If you want to use\n   * direction keys to navigate a selection, use this mixin with\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n   */\n  class KeyboardDirection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.navigationAxis === 'undefined') {\n        this.navigationAxis = this[symbols.defaults].navigationAxis;\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.navigationAxis = 'both';\n      return defaults;\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate down.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { return super[symbols.goDown](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the end (e.g., of a list).\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { return super[symbols.goEnd](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the start (e.g., of a\n     * list). The default implementation of this method does nothing.\n     */\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { return super[symbols.goStart](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate up.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { return super[symbols.goUp](); }\n    }\n\n    /**\n     * Indicates the direction of permitted navigation with the keyboard.\n     *\n     * Accepted values are \"horizontal\", \"vertical\", or \"both\" (the default).\n     * If this property is \"horizontal\", the Up Arrow and Down Arrow keys will\n     * be ignored. Conversely, if this is \"vertical\", the Left Arrow and Right\n     * Arrow keys will be ignored.\n     *\n     * @type {string}\n     */\n    get navigationAxis() {\n      return this[navigationAxisSymbol];\n    }\n    set navigationAxis(value) {\n      this[navigationAxisSymbol] = value;\n      if ('navigationAxis' in base.prototype) { super.navigationAxis = value; }\n    }\n\n    [symbols.keydown](event) {\n      let handled;\n\n      const axis = this.navigationAxis;\n      const horizontal = (axis === 'horizontal' || axis === 'both');\n      const vertical = (axis === 'vertical' || axis === 'both');\n\n      // Ignore Left/Right keys when metaKey or altKey modifier is also pressed,\n      // as the user may be trying to navigate back or forward in the browser.\n      switch (event.keyCode) {\n        case 35: // End\n          handled = this[symbols.goEnd]();\n          break;\n        case 36: // Home\n          handled = this[symbols.goStart]();\n          break;\n        case 37: // Left\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goLeft]();\n          }\n          break;\n        case 38: // Up\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goStart]() : this[symbols.goUp]();\n          }\n          break;\n        case 39: // Right\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goRight]();\n          }\n          break;\n        case 40: // Down\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goEnd]() : this[symbols.goDown]();\n          }\n          break;\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n  }\n\n  return KeyboardDirection;\n};\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with Keyboard. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages the keydown handling for a component.\n   *\n   * This mixin handles several keyboard-related features.\n   *\n   * First, it wires up a single keydown event handler that can be shared by\n   * multiple mixins on a component. The event handler will invoke a `keydown`\n   * method with the event object, and any mixin along the prototype chain that\n   * wants to handle that method can do so.\n   *\n   * If a mixin wants to indicate that keyboard event has been handled, and that\n   * other mixins should *not* handle it, the mixin's `keydown` handler should\n   * return a value of true. The convention that seems to work well is that a\n   * mixin should see if it wants to handle the event and, if not, then ask the\n   * superclass to see if it wants to handle the event. This has the effect of\n   * giving the mixin that was applied last the first chance at handling a\n   * keyboard event.\n   *\n   * Example:\n   *\n   *     [symbols.keydown](event) {\n   *       let handled;\n   *       switch (event.keyCode) {\n   *         // Handle the keys you want, setting handled = true if appropriate.\n   *       }\n   *       // Prefer mixin result if it's defined, otherwise use base result.\n   *       return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n   *     }\n   *\n   * A second feature provided by this mixin is that it implicitly makes the\n   * component a tab stop if it isn't already, by setting `tabIndex` to 0. This\n   * has the effect of adding the component to the tab order in document order.\n   */\n  class Keyboard extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('keydown', event => {\n        const handled = this[symbols.keydown](event);\n        if (handled) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      });\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (this.getAttribute('tabindex') == null && this[symbols.defaults].tabindex !== null) {\n        this.setAttribute('tabindex', this[symbols.defaults].tabindex);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      // The default tab index is 0 (document order).\n      defaults.tabindex = 0;\n      return defaults;\n    }\n\n    /**\n     * Handle the indicated keyboard event.\n     *\n     * The default implementation of this method does nothing. This will\n     * typically be handled by other mixins.\n     *\n     * @param {KeyboardEvent} event - the keyboard event\n     * @return {boolean} true if the event was handled\n     */\n    [symbols.keydown](event) {\n      if (super[symbols.keydown]) { return super[symbols.keydown](event); }\n    }\n\n  }\n\n  return Keyboard;\n};\n","import renderArrayAsElements from '../../basic-component-mixins/src/renderArrayAsElements';\nimport symbols from '../../basic-component-mixins/src/symbols';\nimport toggleClass from '../../basic-component-mixins/src/toggleClass';\n\n\n/* Exported function extends a base class with PageDots. */\nexport default (base) => {\n\n  /**\n   * Template mixin which adds small dots to show the number of items and let\n   * the user select a specific item.\n   *\n   * You can see a\n   * [live demo](http://basicwebcomponents.org/basic-web-components/packages/demos/carousel-with-dots.html)\n   * of this mixin applied to a carousel.\n   *\n   * There will be one dot for each item, and the dot for the currently selected\n   * item will be shown selected.\n   *\n   * Typical usage:\n   *\n   *     class CarouselWithDots extends PageDotsMixin(Carousel) {}\n   *     customElements.define('carousel-with-dots', CarouselWithDots);\n   *\n   * Although the dots are quite small by default, clicking/tapping a dot will\n   * will select the corresponding list item.\n   */\n  class PageDots extends base {\n\n    constructor() {\n      super();\n\n      this.$.dots.addEventListener('click', event => {\n        const dot = event.target;\n        const dotIndex = this.dots.indexOf(dot);\n        if (dotIndex >= 0) {\n          this.selectedIndex = dotIndex;\n        }\n      });\n    }\n\n    get dots() {\n      return [].slice.call(this.$.dots.querySelectorAll('.dot'));\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n      renderArrayAsElements(this.items, this.$.dots, (item, element) => {\n        // We don't use the item parameter, because any item will produce an\n        // identical corresponding dot.\n        if (!element) {\n          element = document.createElement('div');\n          element.classList.add('dot');\n          element.classList.add('style-scope');\n          element.classList.add('basic-page-dots');\n          element.setAttribute('role', 'none');\n          return element;\n        }\n      });\n      refreshDots(this);\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      const index = this.items.indexOf(item);\n      // See if the corresponding dot has already been created.\n      // If not, the correct dot will be selected when it gets created.\n      const dots = this.dots;\n      if (dots && dots.length > index) {\n        const dot = this.dots[index];\n        if (dot) {\n          toggleClass(dot, 'selected', selected);\n        }\n      }\n    }\n\n    /**\n     * The distance the user has moved the first touchpoint since the beginning\n     * of a drag, expressed as a fraction of the element's width.\n     *\n     * @type number\n     */\n    get selectedFraction() {\n      return super.selectedFraction;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      renderTransition(this, this.selectedIndex, value);\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n      refreshDots(this);\n    }\n\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n        :host {\n          display: -webkit-flex;\n          display: flex;\n          position: relative;\n        }\n\n        #dots {\n          bottom: 0;\n          display: -webkit-flex;\n          display: flex;\n          -webkit-justify-content: center;\n          justify-content: center;\n          position: absolute;\n          width: 100%;\n          z-index: 1;\n        }\n\n        #dotNavigationContainer {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          position: relative;\n          z-index: 0;\n        }\n\n        #container ::slotted(*) {\n          -webkit-flex: 1;\n          flex: 1;\n        }\n\n        .dot {\n          background: rgb(255, 255, 255);\n          border-radius: 7px;\n          box-shadow: 0 0 1px 1px rgba(0, 0, 0, 0.5);\n          box-sizing: border-box;\n          cursor: pointer;\n          height: 8px;\n          margin: 7px 5px;\n          opacity: 0.4;\n          padding: 0;\n          transition: background 0.2s box-shadow 0.2s;\n          width: 8px;\n        }\n\n        .dot:hover {\n          background: rgba(0, 0, 0, 0.75);\n          box-shadow: 0 0 1px 3px rgba(255, 255, 255, 0.5);\n        }\n\n        .dot.selected {\n          opacity: 0.95;\n        }\n\n        @media (min-width: 768px) {\n          .dot {\n            height: 12px;\n            width: 12px;\n          }\n        }\n        </style>\n\n        <div id=\"dots\" role=\"none\"></div>\n        <div id=\"dotNavigationContainer\" role=\"none\">\n          ${baseTemplate}\n        </div>\n      `;\n    }\n\n  }\n\n  return PageDots;\n};\n\n\n// Return the index, ensuring it stays between 0 and the given length.\nfunction keepIndexWithinBounds(length, index) {\n  // Handle possibility of negative mod.\n  // See http://stackoverflow.com/a/18618250/76472\n  return ((index % length) + length) % length;\n}\n\nfunction renderTransition(element, selectedIndex, selectedFraction) {\n  const dots = element.dots;\n  if (!dots || dots.length === 0) {\n    return;\n  }\n  const dotCount = dots.length;\n  const opacityMinimum = 0.4;\n  const opacityMaximum = 0.95;\n  const opacityRange = opacityMaximum - opacityMinimum;\n  const fractionalIndex = selectedIndex + selectedFraction;\n  const leftIndex = Math.floor(fractionalIndex);\n  const rightIndex = Math.ceil(fractionalIndex);\n  const selectionWraps = element.selectionWraps;\n  let awayIndex = selectedFraction >= 0 ? leftIndex : rightIndex;\n  let towardIndex = selectedFraction >= 0 ? rightIndex : leftIndex;\n  if (selectionWraps) {\n    awayIndex = keepIndexWithinBounds(dotCount, awayIndex);\n    towardIndex = keepIndexWithinBounds(dotCount, towardIndex);\n  }\n  // Stupid IE doesn't have Math.trunc.\n  // const truncatedSelectedFraction = Math.trunc(selectedFraction);\n  const truncatedSelectedFraction = selectedFraction < 0 ? Math.ceil(selectedFraction) : Math.floor(selectedFraction);\n  const progress = selectedFraction - truncatedSelectedFraction;\n  const opacityProgressThroughRange = Math.abs(progress) * opacityRange;\n  dots.forEach((dot, index) => {\n    let dotOpacity;\n    if (selectedFraction === 0) {\n      // Remove explicit opacity and rely on styling.\n      dotOpacity = '';\n    } else if (index === awayIndex) {\n      dotOpacity = opacityMaximum - opacityProgressThroughRange;\n    } else if (index === towardIndex) {\n      dotOpacity = opacityMinimum + opacityProgressThroughRange;\n    } else {\n      dotOpacity = opacityMinimum;\n    }\n    dot.style.opacity = dotOpacity;\n  });\n}\n\nfunction refreshDots(element) {\n  const selectedIndex = element.selectedIndex;\n  element.dots.forEach((dot, i) => {\n    toggleClass(dot, 'selected', i === selectedIndex);\n  });\n}\n","import createSymbol from './createSymbol';\nimport FractionalSelectionMixin from './FractionalSelectionMixin';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst animationSymbol = createSymbol('animation');\nconst draggingSymbol = createSymbol('dragging');\nconst lastAnimationSymbol = createSymbol('lastAnimation');\nconst playingAnimationSymbol = createSymbol('animatingSelection');\nconst previousSelectionSymbol = createSymbol('previousSelection');\nconst selectionAnimationDurationSymbol = createSymbol('selectionAnimationDuration');\nconst selectionAnimationEffectSymbol = createSymbol('selectionAnimationEffect');\nconst selectionAnimationKeyframesSymbol = createSymbol('selectionAnimationKeyframes');\nconst resetAnimationsOnNextRenderSymbol = createSymbol('resetAnimationsOnNextRender');\n\n\n/* Exported function extends a base class with SelectionAnimation. */\nexport default function mixin(base) {\n\n  /**\n   * Mixin which uses animation to show transitions between selection states.\n   *\n   * This mixin can be used by components that want to provide visible\n   * animations when changing the selection. For example, a carousel component\n   * may want to define a sliding animation effect shown when moving between\n   * items.\n   *\n   * The animation is defined by a `selectionAnimationKeyframes` property; see\n   * that property for details on how to define these keyframes. This animation\n   * will be used in two ways. First, when moving strictly between items, the\n   * animation will play smoothly to show the selection changing. Second, the\n   * animation can be used to render the selection at a fixed point in the\n   * transition between states. E.g., if the user pauses halfway through\n   * dragging an element using [SwipeDirectionMixin](SwipeDirectionMixin.md)\n   * or [TrackpadDirectionMixin](TrackpadDirectionMixin.md)s, then the selection\n   * animation will be shown at the point exactly halfway through.\n   *\n   * This mixin expects a component to provide an `items` array of all elements\n   * in the list, which can be provided via\n   * [ContentItemsMixin](ContentItemsMixin.md). This mixin also expects\n   * `selectedIndex` and `selectedItem` properties, which can be provided via\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   *\n   * This mixin supports a `selectionWraps` property. When true, the user can\n   * navigate forward from the last item in the list and wrap around to the\n   * first item, or navigate backward from the first item and wrap around to the\n   * last item.\n   *\n   * This mixin uses the Web Animations API. For use on browsers which\n   * do not support that API natively, you will need to load the\n   * [Web Animations polyfill](https://github.com/web-animations/web-animations-js).\n   */\n  class SelectionAnimation extends base {\n\n    constructor() {\n      super();\n\n      // Set defaults.\n      if (typeof this.selectionAnimationDuration === 'undefined') {\n        this.selectionAnimationDuration = this[symbols.defaults].selectionAnimationDuration;\n      }\n      if (typeof this.selectionAnimationEffect === 'undefined' && this.selectionAnimationKeyframes == null) {\n        this.selectionAnimationEffect = this[symbols.defaults].selectionAnimationEffect;\n      }\n\n      this[symbols.dragging] = false;\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionAnimationDuration = 250;\n      defaults.selectionAnimationEffect = 'slide';\n      return defaults;\n    }\n\n    /*\n     * Provide backing for the dragging property.\n     * Also, when a drag begins, reset the animations.\n     */\n    get [symbols.dragging]() {\n      return this[draggingSymbol];\n    }\n    set [symbols.dragging](value) {\n      const previousValue = this[symbols.dragging];\n      this[draggingSymbol] = value;\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n      if (value && !previousValue) {\n        // Have begun a drag.\n        this[resetAnimationsOnNextRenderSymbol] = true;\n      }\n    }\n\n    [symbols.itemAdded](item) {\n      // We mark new items in the list as explicitly visible to ARIA. Otherwise,\n      // when an item isn't visible on the screen, ARIA will assume the item is\n      // of no interest to the user, and leave it out of the accessibility tree.\n      // If the list contains 10 items, but only 3 are visible, a screen reader\n      // might then announce the list only has 3 items. To ensure that screen\n      // readers and other assistive technologies announce the correct total\n      // number of items, we explicitly mark all items as not hidden. This will\n      // expose them all in the accessibility tree, even the items which are\n      // currently not rendered.\n      //\n      // TODO: Generally speaking, this entire mixin assumes that the user can\n      // navigate through all items in a list. But an app could style an item as\n      // display:none or visibility:hidden because the user is not allowed to\n      // interact with that item at the moment. Support for this scenario should\n      // be added. This would entail changing all locations where a mixin\n      // function is counting items, iterating over the (visible) items, and\n      // showing or hiding items. Among other things, the code below to make\n      // items visible to ARIA would need to discriminate between items which\n      // are invisible because of animation state, or invisible because the user\n      // shouldn't interact with them.\n      item.setAttribute('aria-hidden', false);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      resetAnimations(this);\n\n      // TODO: Also reset our notion of the last rendered selection? This comes\n      // up when a DOM removal causes the selected item to change position.\n      // this[previousSelectionSymbol] = null;\n\n      renderSelection(this);\n    }\n\n    resetAnimations() {\n      resetAnimations(this);\n    }\n\n    /**\n     * A fractional value indicating how far the user has currently advanced to\n     * the next/previous item. E.g., a `selectedFraction` of 3.5 indicates the\n     * user is halfway between items 3 and 4.\n     *\n     * For more details, see [FractionalSelectionMixin](FractionalSelectionMixin.md)\n     * mixin.\n     *\n     * @type {number}\n     */\n    get selectedFraction() {\n      return super.selectedFraction || 0;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      renderSelection(this, this.selectedIndex, value);\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n      renderSelection(this, index, 0);\n    }\n\n    /**\n     * The duration of a selection animation in milliseconds.\n     *\n     * This measures the amount of time required for a selection animation to\n     * complete. This number remains constant, even if the number of items being\n     * animated increases.\n     *\n     * The default value is 250 milliseconds (a quarter a second).\n     *\n     * @type {number}\n     * @default 250\n     */\n    get selectionAnimationDuration() {\n      return this[selectionAnimationDurationSymbol];\n    }\n    set selectionAnimationDuration(value) {\n      this[selectionAnimationDurationSymbol] = value;\n      if ('selectionAnimationDuration' in base.prototype) { super.selectionAnimationDuration = value; }\n    }\n\n    /**\n     * The name of a standard selection animation effect.\n     *\n     * This is a shorthand for setting the `selectionAnimationKeyframes`\n     * property to standard keyframes. Supported string values:\n     *\n     * * \"crossfade\"\n     * * \"reveal\"\n     * * \"revealWithFade\"\n     * * \"showAdjacent\"\n     * * \"slide\"\n     * * \"slideWithGap\"\n     *\n     * @type {string}\n     * @default \"slide\"\n     */\n    get selectionAnimationEffect() {\n      return this[selectionAnimationEffectSymbol];\n    }\n    set selectionAnimationEffect(value) {\n      this[selectionAnimationEffectSymbol] = value;\n      if ('selectionAnimationEffect' in base.prototype) { super.selectionAnimationEffect = value; }\n      this.selectionAnimationKeyframes = mixin.standardEffectKeyframes[value];\n    }\n\n    /**\n     * The keyframes that define an animation that plays for an item when moving\n     * forward in the sequence.\n     *\n     * This is an array of CSS rules that will be applied. These are used as\n     * [keyframes](http://w3c.github.io/web-animations/#keyframes-section)\n     * to animate the item with the\n     * [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/animation).\n     *\n     * The animation represents the state of the next item as it moves from\n     * completely unselected (offstage, usually right), to selected (center\n     * stage), to completely unselected (offstage, usually left). The center time\n     * of the animation should correspond to the item's quiscent selected state,\n     * typically in the center of the stage and at the item's largest size.\n     *\n     * The default forward animation is a smooth slide at full size from right to\n     * left.\n     *\n     * When moving the selection backward, this animation is played in reverse.\n     *\n     * @type {cssRules[]}\n     */\n    get selectionAnimationKeyframes() {\n      // Standard animation slides left/right, keeps adjacent items out of view.\n      return this[selectionAnimationKeyframesSymbol];\n    }\n    set selectionAnimationKeyframes(value) {\n      this[selectionAnimationKeyframesSymbol] = value;\n      if ('selectionAnimationKeyframes' in base.prototype) { super.selectionAnimationKeyframes = value; }\n      resetAnimations(this);\n      renderSelection(this);\n    }\n\n    get selectionWraps() {\n      return super.selectionWraps;\n    }\n    set selectionWraps(value) {\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      resetAnimations(this);\n      renderSelection(this);\n    }\n  }\n\n  return SelectionAnimation;\n}\n\n\n// We expose helpers on the mixin function that we want to be able to unit test.\n// Since these are on the function, not on the class emitted by the function,\n// they don't end up getting exposed on actual element instances.\nmixin.helpers = {\n\n  /*\n   * Calculate the animation fractions for an element's items at the given\n   * selection point. This is used when rendering the element's selection state\n   * instantaneously.\n   *\n   * This function considers the selectedIndex parameter, which can be a whole\n   * or fractional number, and determines which items will be visible at that\n   * index. This function then calculates a corresponding animation fraction: a\n   * number between 0 and 1 indicating how far through the selection animation\n   * an item should be shown, or null if the item should not be visible at that\n   * selection index. These fractions are returned as an array, where the\n   * animation fraction at position N corresponds to how item N should be shown.\n   */\n  animationFractionsForSelection(element, selection) {\n\n    const items = element.items;\n    if (!items) {\n      return;\n    }\n\n    const itemCount = items.length;\n    const selectionWraps = element.selectionWraps;\n\n    return items.map((item, itemIndex) => {\n      // How many steps from the selection point to this item?\n      const steps = stepsToIndex(itemCount, selectionWraps, selection, itemIndex);\n      // To convert steps to animation fraction:\n      // steps      animation fraction\n      //  1         0     (stage right)\n      //  0         0.5   (center stage)\n      // -1         1     (stage left)\n      const animationFraction = (1 - steps) / 2;\n      return (animationFraction >= 0 && animationFraction <= 1) ?\n        animationFraction :\n        null; // Outside animation range\n    });\n  },\n\n  /*\n   * Calculate the animation timings that should be used to smoothly animate the\n   * element's items from one selection state to another.\n   *\n   * This returns an array of timings, where the timing at position N should be\n   * used to animate item N. If an item's timing is null, then that item should\n   * not take place in the animation, and should be hidden instead.\n   */\n  effectTimingsForSelectionAnimation(element, fromSelection, toSelection) {\n\n    const items = element.items;\n    if (!items) {\n      return;\n    }\n    const itemCount = items.length;\n    const selectionWraps = element.selectionWraps;\n    const toIndex = FractionalSelectionMixin.helpers.wrappedSelectionParts(toSelection, itemCount, selectionWraps).index;\n    const totalSteps = stepsToIndex(itemCount, selectionWraps, fromSelection, toSelection);\n    const direction = totalSteps >= 0 ? 'normal': 'reverse';\n    const fill = 'both';\n    const totalDuration = element.selectionAnimationDuration;\n    const stepDuration = totalSteps !== 0 ?\n      totalDuration * 2 / Math.ceil(Math.abs(totalSteps)) :\n      0;  // No steps required, animation will be instantenous.\n\n    const timings = items.map((item, itemIndex) => {\n      const steps = stepsToIndex(itemCount, selectionWraps, itemIndex, toSelection);\n      // If we include this item in the staggered sequence of animations we're\n      // creating, where would the item appear in the sequence?\n      let positionInSequence = totalSteps - steps;\n      if (totalSteps < 0) {\n        positionInSequence = -positionInSequence;\n      }\n      // So, is this item really included in the sequence?\n      if (Math.ceil(positionInSequence) >= 0 && positionInSequence <= Math.abs(totalSteps)) {\n        // Note that delay for first item will be negative. That will cause\n        // the animation to start halfway through, which is what we want.\n        const delay = stepDuration * (positionInSequence - 1)/2;\n        const endDelay = itemIndex === toIndex ?\n          -stepDuration/2 :   // Stop halfway through.\n          0;              // Play animation until end.\n        return { duration: stepDuration, direction, fill, delay, endDelay };\n      } else {\n        return null;\n      }\n    });\n\n    return timings;\n  }\n\n};\n\n\n// Keyframes for standard selection animation effects.\nmixin.standardEffectKeyframes = {\n\n  // Simple crossfade\n  crossfade: [\n    { opacity: 0 },\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n\n  // Reveal, as if sliding the top card off a deck of cards\n  reveal: [\n    { transform: 'translateX(0%)', zIndex: 0 },\n    { transform: 'translateX(0%)', zIndex: 1 },\n    { transform: 'translateX(-100%)', zIndex: 2 }\n  ],\n\n  // Google Photos-style reveal-with-fade animation\n  revealWithFade: [\n    { transform: 'translateX(0%) scale(0.75)', opacity: 0, zIndex: 0 },\n    { transform: 'translateX(0%) scale(1.0)', opacity: 1, zIndex: 1 },\n    { transform: 'translateX(-100%) scale(1.0)', opacity: 1, zIndex: 2 }\n  ],\n\n  // Carousel variant with a bit of off-stage elements showing\n  showAdjacent: [\n    { transform: 'translateX(78%) scale(0.7)', zIndex: 0 },\n    { transform: 'translateX(0%) scale(0.82)', zIndex: 1 },\n    { transform: 'translateX(-78%) scale(0.7)', zIndex: 0 }\n  ],\n\n  // Simple slide\n  slide: [\n    { transform: 'translateX(100%)' },\n    { transform: 'translateX(-100%)' }\n  ],\n\n  // Slide, with a gap between\n  slideWithGap: [\n    { transform: 'translateX(110%)' },\n    { transform: 'translateX(-110%)' }\n  ]\n\n};\n\n\n/*\n * Smoothly animate the selection between the indicated \"from\" and \"to\"\n * indices. The former can be a fraction, e.g., when the user releases a finger\n * to complete a touch drag, and the selection will snap to the closest whole\n * index.\n */\nfunction animateSelection(element, fromSelection, toSelection) {\n\n  resetAnimations(element);\n\n  // Calculate the animation timings.\n  const items = element.items;\n  const keyframes = element.selectionAnimationKeyframes;\n  element[playingAnimationSymbol] = true;\n  const timings = mixin.helpers.effectTimingsForSelectionAnimation(element, fromSelection, toSelection);\n\n  // Figure out which item will be the one *after* the one we're selecting.\n  const itemCount = items.length;\n  const selectionWraps = element.selectionWraps;\n  const selectionIndex = FractionalSelectionMixin.helpers.selectionParts(toSelection, itemCount, selectionWraps).index;\n  const totalSteps = stepsToIndex(itemCount, selectionWraps, fromSelection, toSelection);\n  const forward = totalSteps >= 0;\n  let nextUpIndex = selectionIndex + (forward ? 1 : - 1);\n  if (selectionWraps) {\n    nextUpIndex = FractionalSelectionMixin.helpers.wrappedSelection(nextUpIndex, itemCount);\n  } else if (!isItemIndexInBounds(element, nextUpIndex)) {\n    nextUpIndex = null; // At start/end of list; don't have a next item to show.\n  }\n\n  // Play the animations using those timings.\n  let lastAnimationDetails;\n  timings.forEach((timing, index) => {\n    const item = items[index];\n    if (timing) {\n      showItem(item, true);\n      const animation = item.animate(keyframes, timing);\n      element[animationSymbol][index] = animation;\n      if (index === nextUpIndex) {\n        // This item will be animated, so will already be in the desired state\n        // after the animation completes.\n        nextUpIndex = null;\n      }\n      if (timing.endDelay !== 0) {\n        // This is the animation for the item that will be left selected.\n        // We want to clean up when this animation completes.\n        lastAnimationDetails = { animation, index, timing, forward };\n      }\n    } else {\n      // This item doesn't participate in the animation.\n      showItem(item, false);\n    }\n  });\n\n  if (lastAnimationDetails != null) {\n    // Arrange for clean-up work to be performed.\n    lastAnimationDetails.nextUpIndex = nextUpIndex;\n    lastAnimationDetails.animation.onfinish = event => selectionAnimationFinished(element, lastAnimationDetails);\n    element[lastAnimationSymbol] = lastAnimationDetails.animation;\n  } else {\n    // Shouldn't happen -- we should always have at least one animation.\n    element[playingAnimationSymbol] = false;\n  }\n}\n\n\nfunction getAnimationForItemIndex(element, index) {\n  if (element[animationSymbol] == null) {\n    // Not ready yet;\n    return null;\n  }\n  let animation = element[animationSymbol][index];\n  if (!animation) {\n    const item = element.items[index];\n    animation = item.animate(element.selectionAnimationKeyframes, {\n      duration: element.selectionAnimationDuration,\n      fill: 'both'\n    });\n    animation.pause();\n    element[animationSymbol][index] = animation;\n  }\n  return animation;\n}\n\nfunction isItemIndexInBounds(element, index) {\n  return index >= 0 && element.items && index < element.items.length;\n}\n\n/*\n * Render the selection state of the element.\n *\n * This can be used to re-render a previous selection state (if the\n * selectedIndex param is omitted), render the selection instantly at a given\n * whole or fractional selection index, or animate to a given selection index.\n *\n * There are several distinct scenarios we need to cover:\n *\n * 1. Initial positioning, or repositioning after changing a property like\n *    selectionAnimationKeyframes that affects rendering.\n * 2. Animate on selectedIndex change. This should override any animation/swipe\n *    already in progress.\n * 3. Instantly render the current position of a drag operation in progress.\n * 4. Complete a drag operation. If the drag wasn't far enough to affect\n *    selection, we'll just be restoring the selectedFraction to 0.\n *\n * If the list does not wrap, any selection position outside the list's bounds\n * will be damped to produce a visual effect of tension.\n */\nfunction renderSelection(element, selectedIndex=element.selectedIndex, selectedFraction=element.selectedFraction) {\n  const itemCount = element.items ? element.items.length : 0;\n  if (itemCount === 0) {\n    // Nothing to render.\n    return;\n  }\n  if (selectedIndex < 0) {\n    // TODO: Handle no selection.\n    return;\n  }\n  let selection = selectedIndex + selectedFraction;\n  if (element.selectionWraps) {\n    // Apply wrapping to ensure consistent representation of selection.\n    selection = FractionalSelectionMixin.helpers.wrappedSelection(selection, itemCount);\n  } else {\n    // Apply damping if necessary.\n    selection = FractionalSelectionMixin.helpers.dampedSelection(selection, itemCount);\n  }\n  const previousSelection = element[previousSelectionSymbol];\n  // TODO: If an item changes position in the DOM, we end up animating from\n  // its old index to its new index, but we really don't want to animate at all.\n  if (!element[symbols.dragging] && previousSelection != null &&\n      previousSelection !== selection) {\n    // Animate selection from previous state to new state.\n    animateSelection(element, previousSelection, selection);\n  } else if (selectedFraction === 0 && element[playingAnimationSymbol]) {\n    // Already in process of animating to fraction 0. During that process,\n    // ignore subsequent attempts to renderSelection to fraction 0.\n    return;\n  } else {\n    // Render current selection state instantly.\n    renderSelectionInstantly(element, selection);\n  }\n  element[previousSelectionSymbol] = selection;\n}\n\n/*\n * Instantly render (don't animate) the element's items at the given whole or\n * fractional selection index.\n */\nfunction renderSelectionInstantly(element, toSelection) {\n  if (element[resetAnimationsOnNextRenderSymbol]) {\n    resetAnimations(element);\n    element[resetAnimationsOnNextRenderSymbol] = false;\n  }\n  const animationFractions = mixin.helpers.animationFractionsForSelection(element, toSelection);\n  animationFractions.map((animationFraction, index) => {\n    const item = element.items[index];\n    if (animationFraction != null) {\n      showItem(item, true);\n      setAnimationFraction(element, index, animationFraction);\n    } else {\n      showItem(item, false);\n    }\n  });\n}\n\n/*\n * We maintain an array containing an animation per item. This is used for two\n * reasons:\n *\n * * During a drag operation, we want to be able to reuse animations between\n *   drag updates.\n * * When a selection animation completes, we need to be able to leave the\n *   visibile items in a paused state. Later, we'll want to be able to clean up\n *   those animations.\n *\n * Note that this array is sparse: it will only hold up from 0–3 animations at\n * any given point.\n */\nfunction resetAnimations(element) {\n  const animations = element[animationSymbol];\n  if (animations) {\n    // Cancel existing animations to remove the effects they're applying.\n    animations.forEach((animation, index) => {\n      if (animation) {\n        animation.cancel();\n        animations[index] = null;\n      }\n    });\n  }\n  const itemCount = element.items ? element.items.length : 0;\n  if (!animations || animations.length !== itemCount) {\n    // Haven't animated before with this number of items; (re)create array.\n    element[animationSymbol] = new Array(itemCount);\n  }\n}\n\n/*\n * The last animation in our selection animation has completed. Clean up.\n */\nfunction selectionAnimationFinished(element, details) {\n\n  // When the last animation completes, show the next item in the direction\n  // we're going. Waiting to that until this point is a bit of a hack to avoid\n  // having a next item that's higher in the natural z-order obscure other items\n  // during animation.\n  const nextUpIndex = details.nextUpIndex;\n  if (nextUpIndex != null) {\n    if (element[animationSymbol][nextUpIndex]) {\n      // Cancel existing selection animation so we can construct a new one.\n      element[animationSymbol][nextUpIndex].cancel();\n      element[animationSymbol][nextUpIndex] = null;\n    }\n    const animationFraction = details.forward ? 0 : 1;\n    setAnimationFraction(element, nextUpIndex, animationFraction);\n    showItem(element.items[nextUpIndex], true);\n  }\n\n  element[lastAnimationSymbol].onfinish = null;\n  element[playingAnimationSymbol] = false;\n}\n\n/*\n * Pause the indicated animation and have it show the animation at the given\n * fraction (between 0 and 1) of the way through the animation.\n */\nfunction setAnimationFraction(element, itemIndex, fraction) {\n  const animation = getAnimationForItemIndex(element, itemIndex);\n  if (animation) {\n    const duration = element.selectionAnimationDuration;\n    if (duration) {\n      animation.currentTime = fraction * duration;\n    }\n  }\n}\n\nfunction showItem(item, flag) {\n  item.style.visibility = flag ? 'visible' : 'hidden';\n}\n\n/*\n * Figure out how many steps it will take to go from fromSelection to\n * toSelection. To go from item 3 to item 4 is one step.\n *\n * If wrapping is allowed, then going from the last item to the first will take\n * one step (forward), and going from the first item to the last will take one\n * step (backward).\n */\nfunction stepsToIndex(length, allowWrap, fromSelection, toSelection) {\n  let steps = toSelection - fromSelection;\n  // Wrapping only kicks in when list has more than 1 item.\n  if (allowWrap && length > 1) {\n    const wrapSteps = length - Math.abs(steps);\n    if (wrapSteps <= 1) {\n      // Special case\n      steps = steps < 0 ?\n        wrapSteps :   // Wrap forward from last item to first.\n        -wrapSteps;   // Wrap backward from first item to last.\n    }\n  }\n  return steps;\n}\n","import symbols from './symbols';\n\n\n// Used to assign unique IDs to item elements without IDs.\nlet idCount = 0;\n\n\n/* Exported function extends a base class with SelectionAriaActive. */\nexport default (base) => {\n\n  /**\n   * Mixin which treats the selected item in a list as the active item in ARIA\n   * accessibility terms.\n   *\n   * Handling ARIA selection state properly is actually quite complex:\n   *\n   * * The items in the list need to be indicated as possible items via an ARIA\n   *   `role` attribute value such as \"option\".\n   * * The selected item need to be marked as selected by setting the item's\n   *   `aria-selected` attribute to true *and* the other items need be marked as\n   *   *not* selected by setting `aria-selected` to false.\n   * * The outermost element with the keyboard focus needs to have attributes\n   *   set on it so that the selection is knowable at the list level via the\n   *   `aria-activedescendant` attribute.\n   * * Use of `aria-activedescendant` in turn requires that all items in the\n   *   list have ID attributes assigned to them.\n   *\n   * This mixin tries to address all of the above requirements. To that end,\n   * this mixin will assign generated IDs to any item that doesn't already have\n   * an ID.\n   *\n   * ARIA relies on elements to provide `role` attributes. This mixin will apply\n   * a default role of \"listbox\" on the outer list if it doesn't already have an\n   * explicit role. Similarly, this mixin will apply a default role of \"option\"\n   * to any list item that does not already have a role specified.\n   *\n   * This mixin expects a set of members that manage the state of the selection:\n   * `[symbols.itemSelected]`, `itemAdded`, and `selectedIndex`. You can\n   * supply these yourself, or do so via\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class SelectionAriaActive extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      // Set default ARIA role.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'listbox';\n      return defaults;\n    }\n\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n\n      if (!item.getAttribute('role')) {\n        // Assign a default ARIA role.\n        item.setAttribute('role', 'option');\n      }\n\n      // Ensure each item has an ID so we can set aria-activedescendant on the\n      // overall list whenever the selection changes.\n      //\n      // The ID will take the form of a base ID plus a unique integer. The base\n      // ID will be incorporate the component's own ID. E.g., if a component has\n      // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n      // the compnent has no ID itself, its items will get IDs that look like\n      // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n      // them from manually-assigned IDs, and to minimize the potential for ID\n      // conflicts.\n      if (!item.id) {\n        const baseId = this.id ?\n            \"_\" + this.id + \"Option\" :\n            \"_option\";\n        item.id = baseId + idCount++;\n      }\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      item.setAttribute('aria-selected', selected);\n      const itemId = item.id;\n      if (itemId && selected) {\n        this.setAttribute('aria-activedescendant', itemId);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item == null) {\n        // Selection was removed.\n        this.removeAttribute('aria-activedescendant');\n      }\n    }\n\n  }\n\n  return SelectionAriaActive;\n};\n","/* Exported function extends a base class with ShadowElementReferences. */\nexport default (base) => {\n\n  /**\n   * Mixin to create references to elements in a component's Shadow DOM subtree.\n   *\n   * This adds a member on the component called `this.$` that can be used to\n   * reference shadow elements with IDs. E.g., if component's shadow contains an\n   * element `<button id=\"foo\">`, then this mixin will create a member\n   * `this.$.foo` that points to that button.\n   *\n   * Such references simplify a component's access to its own elements. In\n   * exchange, this mixin trades off a one-time cost of querying all elements in\n   * the shadow tree instead of paying an ongoing cost to query for an element\n   * each time the component wants to inspect or manipulate it.\n   *\n   * This mixin expects the component to define a Shadow DOM subtree. You can\n   * create that tree yourself, or make use of\n   * [ShadowTemplateMixin](ShadowTemplateMixin.md).\n   *\n   * This mixin is inspired by Polymer's [automatic\n   * node finding](https://www.polymer-project.org/1.0/docs/devguide/local-dom.html#node-finding)\n   * feature.\n   */\n  class ShadowElementReferences extends base {\n\n    constructor() {\n      super();\n      if (this.shadowRoot) {\n        // Look for elements in the shadow subtree that have id attributes.\n        // An alternatively implementation of this mixin would be to just define\n        // a this.$ getter that lazily does this search the first time someone\n        // tries to access this.$. That might introduce some complexity – if the\n        // the tree changed after it was first populated, the result of\n        // searching for a node might be somewhat unpredictable.\n        this.$ = {};\n        const nodesWithIds = this.shadowRoot.querySelectorAll('[id]');\n        [].forEach.call(nodesWithIds, node => {\n          const id = node.getAttribute('id');\n          this.$[id] = node;\n        });\n      }\n    }\n\n    /**\n     * The collection of references to the elements with IDs in a component's\n     * Shadow DOM subtree.\n     *\n     * @type {object}\n     * @member $\n     */\n  }\n\n  return ShadowElementReferences;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with ShadowTemplate. */\nexport default (base) => {\n\n  /**\n   * Mixin for stamping a template into a Shadow DOM subtree upon component\n   * instantiation.\n   *\n   * To use this mixin, define a `template` property as a string or HTML\n   * `<template>` element:\n   *\n   *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n   *       get [symbols.template]() {\n   *         return `Hello, <em>world</em>.`;\n   *       }\n   *     }\n   *\n   * When your component class is instantiated, a shadow root will be created on\n   * the instance, and the contents of the template will be cloned into the\n   * shadow root. If your component does not define a `template` property, this\n   * mixin has no effect.\n   *\n   * For the time being, this extension retains support for Shadow DOM v0. That\n   * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n   * implement Shadow DOM v1.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n      let template = this[symbols.template];\n      // TODO: Save the processed template with the component's class prototype\n      // so it doesn't need to be processed with every instantiation.\n      if (template) {\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          template = createTemplateWithInnerHTML(template);\n        }\n\n        if (window.ShadowDOMPolyfill) {\n          shimTemplateStyles(template, this.localName);\n        }\n\n        const root = this.attachShadow({ mode: 'open' });\n        const clone = document.importNode(template.content, true);\n        root.appendChild(clone);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n};\n\n\n// Convert a plain string of HTML into a real template element.\nfunction createTemplateWithInnerHTML(innerHTML) {\n  const template = document.createElement('template');\n  // REVIEW: Is there an easier way to do this?\n  // We'd like to just set innerHTML on the template content, but since it's\n  // a DocumentFragment, that doesn't work.\n  const div = document.createElement('div');\n  div.innerHTML = innerHTML;\n  while (div.childNodes.length > 0) {\n    template.content.appendChild(div.childNodes[0]);\n  }\n  return template;\n}\n\n// Invoke basic style shimming with ShadowCSS.\nfunction shimTemplateStyles(template, tag) {\n  window.WebComponents.ShadowCSS.shimStyling(template.content, tag);\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = createSymbol('canSelectNext');\nconst canSelectPreviousSymbol = createSymbol('canSelectPrevious');\nconst selectionRequiredSymbol = createSymbol('selectionRequired');\nconst selectionWrapsSymbol = createSymbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = createSymbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = createSymbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = createSymbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = createSymbol('internalSelectedItem');\n\n\n/* Exported function extends a base class with SingleSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages single-selection semantics for items in a list.\n   *\n   * This mixin expects a component to provide an `items` Array or NodeList of\n   * all elements in the list. A standard way to do that with is the\n   * [ContentItemsMixin](ContentItemsMixin.md), which takes a component's\n   * content (typically its distributed children) as the set of list items; see\n   * that mixin for details.\n   *\n   * This mixin tracks a single selected item in the list, and provides means to\n   * get and set that state by item position (`selectedIndex`) or item identity\n   * (`selectedItem`). The selection can be moved in the list via the methods\n   * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n   *\n   * This mixin does not produce any user-visible effects to represent\n   * selection. Other mixins, such as\n   * [SelectionAriaActiveMixin](SelectionAriaActiveMixin.md),\n   * [SelectionHighlightMixin](SelectionHighlightMixin.md) and\n   * [SelectionInViewMixin](SelectionInViewMixin.md), modify the selected item\n   * in common ways to let the user know a given item is selected or not\n   * selected.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const previousCanSelectNext = this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (canSelectNext !== previousCanSelectNext) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const previousCanSelectPrevious = this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (canSelectPrevious !== previousCanSelectPrevious) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedIndex = this[internalSelectedIndexSymbol];\n      let item;\n      if (index !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && index >= 0 && index < items.length)) {\n          index = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = index;\n        item = hasItems && index >= 0 ? items[index] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (index !== previousSelectedIndex) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = index;\n\n        const event = new CustomEvent('selected-index-changed', {\n          detail: {\n            selectedIndex: index,\n            value: index // for Polymer binding. TODO: Verify still necessary\n          }\n        });\n        this.dispatchEvent(event);\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (item !== previousSelectedItem) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        const event = new CustomEvent('selected-item-changed', {\n          detail: {\n            selectedItem: item,\n            value: item // for Polymer binding\n          }\n        });\n        this.dispatchEvent(event);\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      this[selectionRequiredSymbol] = selectionRequired;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      trackSelectedItem(this);\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(value) {\n      this[selectionWrapsSymbol] = String(value) === 'true';\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Select the last item in the list.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the selectedItem property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     * @param {HTMLElement} detail.previousItem The previously selected item.\n     */\n\n    /**\n     * Fires when the selectedIndex property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n  }\n\n  return SingleSelection;\n};\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n  const count = element.items.length;\n\n  const boundedIndex = (element.selectionWraps) ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst deltaXSymbol = createSymbol('deltaX');\nconst deltaYSymbol = createSymbol('deltaY');\nconst multiTouchSymbol = createSymbol('multiTouch');\nconst previousXSymbol = createSymbol('previousX');\nconst previousYSymbol = createSymbol('previousY');\nconst startXSymbol = createSymbol('startX');\nconst travelFractionSymbol = createSymbol('travelFraction');\n\n\n/* Exported function extends a base class with SwipeDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps touch gestures (swipe left, swipe right) to direction\n   * semantics (go right, go left).\n   *\n   * By default, this mixin presents no user-visible effects; it just indicates\n   * a direction in which the user is currently swiping or has finished swiping.\n   * To map the direction to a change in selection, use\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n   */\n  class SwipeDirection extends base {\n\n    constructor() {\n      super();\n\n      this.travelFraction = 0;\n\n      // In all touch events, only handle single touches. We don't want to\n      // inadvertently do work when the user's trying to pinch-zoom for example.\n      // TODO: Even better approach than below would be to ignore touches after\n      // the first if the user has already begun a swipe.\n      // TODO: Touch events should probably be factored out into its own mixin.\n      if (window.PointerEvent) {\n        // Prefer listening to standard pointer events.\n        this.addEventListener('pointerdown', event => {\n          if (isEventForPenOrPrimaryTouch(event)) {\n            touchStart(this, event.clientX, event.clientY);\n          }\n        });\n        this.addEventListener('pointermove', event => {\n          if (isEventForPenOrPrimaryTouch(event)) {\n            const handled = touchMove(this, event.clientX, event.clientY);\n            if (handled) {\n              event.preventDefault();\n            }\n          }\n        });\n        this.addEventListener('pointerup', event => {\n          if (isEventForPenOrPrimaryTouch(event)) {\n            touchEnd(this, event.clientX, event.clientY);\n          }\n        });\n      } else {\n        // Pointer events not supported -- listen to older touch events.\n        this.addEventListener('touchstart', event => {\n          if (this[multiTouchSymbol]) {\n            return;\n          } else if (event.touches.length === 1) {\n            const clientX = event.changedTouches[0].clientX;\n            const clientY = event.changedTouches[0].clientY;\n            touchStart(this, clientX, clientY);\n          } else {\n            this[multiTouchSymbol] = true;\n          }\n        });\n        this.addEventListener('touchmove', event => {\n          if (!this[multiTouchSymbol] && event.touches.length === 1) {\n            const clientX = event.changedTouches[0].clientX;\n            const clientY = event.changedTouches[0].clientY;\n            const handled = touchMove(this, clientX, clientY);\n            if (handled) {\n              event.preventDefault();\n            }\n          }\n        });\n        this.addEventListener('touchend', event => {\n          if (event.touches.length === 0) {\n            // All touches removed; gesture is complete.\n            if (!this[multiTouchSymbol]) {\n              // Single-touch swipe has finished.\n              const clientX = event.changedTouches[0].clientX;\n              const clientY = event.changedTouches[0].clientY;\n              touchEnd(this, clientX, clientY);\n            }\n            this[multiTouchSymbol] = false;\n          }\n        });\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // For the component to receive PointerEvents in IE/Edge, we need to set\n      // touch-action: none. Only make this change if touch-action is currently\n      // the default value (\"auto\"), in case the developer knows better than we\n      // do what they want in their particular context.\n      if (getComputedStyle(this).touchAction === 'auto') {\n        this.style.touchAction = 'none';\n      }\n    }\n\n    // Default implementation.\n    get [symbols.dragging]() {\n      return super[symbols.dragging];\n    }\n    set [symbols.dragging](value) {\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * The distance the first touchpoint has traveled since the beginning of a\n     * drag, expressed as a fraction of the element's width.\n     *\n     * @type number\n     */\n    get travelFraction() {\n      return this[travelFractionSymbol];\n    }\n    set travelFraction(value) {\n      this[travelFractionSymbol] = value;\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n    }\n\n  }\n\n  return SwipeDirection;\n};\n\n\n// Return true if the pointer event is for the pen, or the primary touch point.\nfunction isEventForPenOrPrimaryTouch(event) {\n  return event.pointerType === 'pen' ||\n      (event.pointerType === 'touch' && event.isPrimary);\n}\n\n/*\n * Invoked when the user has finished a touch operation.\n */\nfunction touchEnd(element, clientX, clientY) {\n  element[symbols.dragging] = false;\n  if (element[deltaXSymbol] >= 20) {\n    // Finished going right at high speed.\n    element[symbols.goLeft]();\n  } else if (element[deltaXSymbol] <= -20) {\n    // Finished going left at high speed.\n    element[symbols.goRight]();\n  } else {\n    // Finished at low speed.\n    trackTo(element, clientX);\n    const travelFraction = element.travelFraction;\n    if (travelFraction >= 0.5) {\n      element[symbols.goRight]();\n    } else if (travelFraction <= -0.5) {\n      element[symbols.goLeft]();\n    }\n  }\n  element.travelFraction = 0;\n  element[deltaXSymbol] = null;\n  element[deltaYSymbol] = null;\n}\n\n/*\n * Invoked when the user has moved during a touch operation.\n */\nfunction touchMove(element, clientX, clientY) {\n\n  element[deltaXSymbol] = clientX - element[previousXSymbol];\n  element[deltaYSymbol] = clientY - element[previousYSymbol];\n  element[previousXSymbol] = clientX;\n  element[previousYSymbol] = clientY;\n  if (Math.abs(element[deltaXSymbol]) > Math.abs(element[deltaYSymbol])) {\n    // Move was mostly horizontal.\n    trackTo(element, clientX);\n    // Indicate that the event was handled. It'd be nicer if we didn't have\n    // to do this so that, e.g., a user could be swiping left and right\n    // while simultaneously scrolling up and down. (Native touch apps can do\n    // that.) However, Mobile Safari wants to handle swipe events near the\n    // page and interpret them as navigations. To avoid having a horiziontal\n    // swipe misintepreted as a navigation, we indicate that we've handled\n    // the event, and prevent default behavior.\n    return true;\n  } else {\n    // Move was mostly vertical.\n    return false; // Not handled\n  }\n}\n\n/*\n * Invoked when the user has begun a touch operation.\n */\nfunction touchStart(element, clientX, clientY) {\n  element[symbols.dragging] = true;\n  element[startXSymbol] = clientX;\n  element[previousXSymbol] = clientX;\n  element[previousYSymbol] = clientY;\n  element[deltaXSymbol] = 0;\n  element[deltaYSymbol] = 0;\n}\n\nfunction trackTo(element, x) {\n  const width = element.offsetWidth;\n  const dragDistance = element[startXSymbol] - x;\n  const fraction = width > 0 ?\n    dragDistance / width :\n    0;\n  element.travelFraction = fraction;\n}\n","import createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst absorbDecelerationSymbol = createSymbol('absorbDeceleration');\nconst lastDeltaXSymbol = createSymbol('lastDeltaX');\nconst lastWheelTimeoutSymbol = createSymbol('lastWheelTimeout');\nconst postNavigateDelayCompleteSymbol = createSymbol('postNavigateDelayComplete');\nconst wheelDistanceSymbol = createSymbol('wheelDistance');\n\n\n/* Exported function extends a base class with TrackpadDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps a horizontal trackpad swipe gestures (or horizontal mouse\n   * wheel actions) to direction semantics.\n   *\n   * You can use this mixin with a mixin like\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md) to let the user\n   * change the selection with the trackpad or mouse wheel.\n   *\n   * To respond to the trackpad, we can listen to the DOM's \"wheel\" events.\n   * These events are fired as the user drags their fingers across a trackpad.\n   * Unfortunately, browsers are missing a critical event — there is no event\n   * when the user *stops* a gestured on the trackpad or mouse wheel.\n   *\n   * To make things worse, the mainstream browsers continue to generate fake\n   * wheel events even after the user has stopped dragging their fingers. These\n   * fake events simulate the user gradually slowing down the drag until they\n   * come to a smooth stop. In some contexts, these fake wheel events might be\n   * helpful, but in trying to supply typical trackpad swipe navigation, these\n   * fake events get in the way.\n   *\n   * This component uses heuristics to work around these problems, but the\n   * complex nature of the problem make it extremely difficult to achieve the\n   * same degree of trackpad responsiveness possible with native applications.\n   */\n  class TrackpadDirection extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('wheel', event => {\n        const handled = wheel(this, event);\n        if (handled) {\n          event.preventDefault();\n        }\n      });\n      resetWheelTracking(this);\n    }\n\n    // Default implementation.\n    get [symbols.dragging]() {\n      return super[symbols.dragging];\n    }\n    set [symbols.dragging](value) {\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * The distance the user has moved the first touchpoint since the beginning\n     * of a trackpad/wheel operation, expressed as a fraction of the element's\n     * width.\n     *\n     * @type number\n     */\n    get travelFraction() {\n      return super.travelFraction;\n    }\n    set travelFraction(value) {\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n    }\n\n  }\n\n  return TrackpadDirection;\n};\n\n\n// Time we wait following a navigation before paying attention to wheel\n// events again.\nconst POST_NAVIGATE_TIME = 250;\n\n// Time we wait after the last wheel event before we reset things.\nconst WHEEL_TIME = 100;\n\n\n// Following a navigation, partially reset our wheel tracking.\nfunction postNavigate(element) {\n  element.travelFraction = 0;\n  element[wheelDistanceSymbol] = 0;\n  element[postNavigateDelayCompleteSymbol] = true;\n  element[absorbDecelerationSymbol] = true;\n  setTimeout(() => {\n    element[postNavigateDelayCompleteSymbol] = false;\n  }, POST_NAVIGATE_TIME);\n}\n\n// Reset all state related to the tracking of the wheel.\nfunction resetWheelTracking(element) {\n  element.travelFraction = 0;\n  element[wheelDistanceSymbol] = 0;\n  element[lastDeltaXSymbol] = 0;\n  element[absorbDecelerationSymbol] = false;\n  element[postNavigateDelayCompleteSymbol] = false;\n  if (element[lastWheelTimeoutSymbol]) {\n    clearTimeout(element[lastWheelTimeoutSymbol]);\n    element[lastWheelTimeoutSymbol] = null;\n  }\n}\n\n// Define our own sign function, since (as of May 2015), Safari and IE don't\n// supply Math.sign().\nfunction sign(x) {\n  return (x === 0) ?\n    0 :\n    (x > 0) ?\n      1 :\n      -1;\n}\n\n// TODO: Damping, or some other treatment for going past the ends.\n\n/*\n * A wheel event has been generated. This could be a real wheel event, or it\n * could be fake (see notes in the header).\n *\n * This handler uses several strategies to try to approximate native trackpad\n * swipe navigation.\n *\n * If the user has dragged enough to cause a navigation, then for a short\n * delay following that navigation, subsequent wheel events will be ignored.\n *\n * Furthermore, follwowing a navigation, we ignore all wheel events until we\n * receive at least one event where the event's deltaX (distance traveled) is\n * *greater* than the previous event's deltaX. This helps us filter out the\n * fake wheel events generated by the browser to simulate deceleration.\n *\n */\nfunction wheel(element, event) {\n\n  // Since we have a new wheel event, reset our timer waiting for the last\n  // wheel event to pass.\n  if (element[lastWheelTimeoutSymbol]) {\n    clearTimeout(element[lastWheelTimeoutSymbol]);\n  }\n  element[lastWheelTimeoutSymbol] = setTimeout(() => {\n    wheelTimedOut(element);\n  }, WHEEL_TIME);\n\n  const deltaX = event.deltaX;\n  const deltaY = event.deltaY;\n\n  // See if element event represents acceleration or deceleration.\n  const acceleration = sign(deltaX) * (deltaX - element[lastDeltaXSymbol]);\n  element[lastDeltaXSymbol] = deltaX;\n\n  if (Math.abs(deltaX) < Math.abs(deltaY)) {\n    // Move was mostly vertical. The user may be trying scroll with the\n    // trackpad/wheel. To be on the safe, we ignore such events.\n    return false;\n  }\n\n  if (element[postNavigateDelayCompleteSymbol]) {\n    // It's too soon after a navigation; ignore the event.\n    return true;\n  }\n\n  if (acceleration > 0) {\n    // The events are not (or are no longer) decelerating, so we can start\n    // paying attention to them again.\n    element[absorbDecelerationSymbol] = false;\n  } else if (element[absorbDecelerationSymbol]) {\n    // The wheel event was likely faked to simulate deceleration; ignore it.\n    return true;\n  }\n\n  element[wheelDistanceSymbol] += deltaX;\n\n  // Update the travel fraction of the element being navigated.\n  const width = element.offsetWidth;\n  let travelFraction = width > 0 ?\n    element[wheelDistanceSymbol] / width :\n    0;\n  element[symbols.dragging] = true;\n  travelFraction = sign(travelFraction) * Math.min(Math.abs(travelFraction), 1);\n  element.travelFraction = travelFraction;\n\n  // If the user has dragged enough to reach the previous/next item, then\n  // complete a navigation to that item.\n  if (travelFraction === 1) {\n    element[symbols.dragging] = false;\n    element[symbols.goRight]();\n    postNavigate(element);\n  } else if (travelFraction === -1) {\n    element[symbols.dragging] = false;\n    element[symbols.goLeft]();\n    postNavigate(element);\n  }\n\n  return true;\n}\n\n// A sufficiently long period of time has passed since the last wheel event.\n// We snap the selection to the closest item, then reset our state.\nfunction wheelTimedOut(element) {\n\n  // Snap to the closest item.\n  element[symbols.dragging] = false;\n  const travelFraction = element.travelFraction;\n  if (travelFraction >= 0.5) {\n    element[symbols.goRight]();\n  } else if (travelFraction <= -0.5) {\n    element[symbols.goLeft]();\n  }\n\n  // TODO: Listen for the transition to complete, and then restore\n  // dragging to false (or the previous value).\n\n  resetWheelTracking(element);\n}\n","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n","/*\n * Microtask helper for IE 11.\n *\n * Executing a function as a microtask is trivial in browsers that support\n * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n * promises, but does support MutationObservers, which are also executed as\n * microtasks. So this helper uses an MutationObserver to achieve microtask\n * timing.\n *\n * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * Inspired by Polymer's async() function.\n */\n\n\n// The queue of pending callbacks to be executed as microtasks.\nconst callbacks = [];\n\n// Create an element that we will modify to force observable mutations.\nconst element = document.createTextNode('');\n\n// A monotonically-increasing value.\nlet counter = 0;\n\n\n/**\n * Add a callback to the microtask queue.\n *\n * This uses a MutationObserver so that it works on IE 11.\n *\n * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n * needs more investigation.\n *\n * @function microtask\n * @param {function} callback\n */\nexport default function microtask(callback) {\n  callbacks.push(callback);\n  // Force a mutation.\n  element.textContent = ++counter;\n}\n\n\n// Execute any pending callbacks.\nfunction executeCallbacks() {\n  while (callbacks.length > 0) {\n    const callback = callbacks.shift();\n    callback();\n  }\n}\n\n\n// Create the observer.\nconst observer = new MutationObserver(executeCallbacks);\nobserver.observe(element, {\n  characterData: true\n});\n","/**\n * Helper function for rendering an array of items as elements.\n *\n * This is not a mixin, but a function components can use if they need to\n * generate a set of elements for the items in an array.\n *\n * This function will reuse existing elements if possible. E.g., if it is called\n * to render an array of 4 items, and later called to render an array of 5\n * items, it can reuse the existing 4 items, creating just one new element.\n * Note, however, that this re-rendering is not automatic. If, after calling\n * this function, you manipulate the array you used, you must still call this\n * function again to re-render the array.\n *\n * The `renderItem` parameter takes a function of two arguments: an item to\n * to render, and an existing element (if one exists) which can be repurposed to\n * render that item. If the latter argument is null, the `renderItem()` function\n * should create a new element and return it. The function should do the same\n * if the supplied existing element is not suitable for rendering the given\n * item; the returned element will be used to replace the existing one. If the\n * existing element *is* suitable, the function can simply update it and return\n * it as is.\n *\n * Example: The following will render an array of strings in divs as children\n * of the `container` element:\n *\n *     let strings = ['a', 'b', 'c', ...];\n *     let container = this.querySelector(...);\n *     renderArrayAsElements(strings, container, (string, element) => {\n *       if (!element) {\n *         // No element exists yet, so create a new one.\n *         element = document.createElement('div');\n *       }\n *       // Set/update the text content of the element.\n *       element.textContent = string;\n *       return element;\n *     });\n *\n * @param {Array} items - the items to render\n * @param {HTMLElement} container - the parent that will hold the elements\n * @param {function} renderItem - returns a new element for an item, or\n *                                repurposes an existing element for an item\n */\nfunction renderArrayAsElements(items, container, renderItem) {\n  // Create a new set of elements for the current items.\n  items.forEach((item, index) => {\n    const oldElement = container.childNodes[index];\n    const newElement = renderItem(item, oldElement);\n    if (newElement) {\n      if (!oldElement) {\n        container.appendChild(newElement);\n      } else if (newElement !== oldElement) {\n        container.replaceChild(newElement, oldElement);\n      }\n    }\n  });\n\n  // If the array shrank, remove the extra elements which are no longer needed.\n  while (container.childNodes.length > items.length) {\n    container.removeChild(container.childNodes[items.length]);\n  }\n}\n\nexport default renderArrayAsElements;\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\n\n\n// Symbols for private data members on an element.\nconst safeToSetAttributesSymbol = createSymbol('safeToSetAttributes');\nconst pendingAttributesSymbol = createSymbol('pendingAttributes');\nconst pendingClassesSymbol = createSymbol('pendingClasses');\n\n\n/**\n * Helper functions for updating attributes, including the `class` attribute.\n */\nexport default {\n\n  /**\n   * Perform any pending updates to attributes and classes.\n   *\n   * This writes any `setAttribute` or `toggleClass` values that were performed\n   * before an element was attached to the document for the first time.\n   *\n   * This method should be called by mixins/components in their\n   * `connectedCallback`. If mulitple mixins/components invoke this during the\n   * same `connectedCallback`, only the first call will have any effect. The\n   * subsequent calls will be harmless.\n   *\n   * @param {HTMLElement} element - The element being added to the document.\n   */\n  connected(element) {\n    element[safeToSetAttributesSymbol] = true;\n\n    // Set any pending attributes.\n    if (element[pendingAttributesSymbol]) {\n      for (let attribute in element[pendingAttributesSymbol]) {\n        const value = element[pendingAttributesSymbol][attribute];\n        setAttributeToElement(element, attribute, value);\n      }\n      element[pendingAttributesSymbol] = null;\n    }\n\n    // Set any pending classes.\n    if (element[pendingClassesSymbol]) {\n      for (let className in element[pendingClassesSymbol]) {\n        const value = element[pendingClassesSymbol][className];\n        toggleClass(element, className, value);\n      }\n      element[pendingClassesSymbol] = null;\n    }\n  },\n\n  /**\n   * Set/unset the attribute with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as an attribute. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes. A call to `setAttribute` during the constructor will\n   * be deferred until the element is connected to the document.\n   *\n   * @param {string} attribute - The name of the *attribute* (not property) to set.\n   * @param {object} value - The value to set. If null, the attribute will be removed.\n   */\n  setAttribute(element, attribute, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set attributes immediately.\n      setAttributeToElement(element, attribute, value);\n    } else {\n      // Defer setting attributes until the first time we're connected.\n      if (!element[pendingAttributesSymbol]) {\n        element[pendingAttributesSymbol] = {};\n      }\n      element[pendingAttributesSymbol][attribute] = value;\n    }\n  },\n\n  /**\n   * Set/unset the class with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as as class. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes, including the `class` attribute. A call to\n   * `toggleClass` during the constructor will be deferred until the element\n   * is connected to the document.\n   *\n   * @param {string} className - The name of the class to set.\n   * @param {object} value - True to set the class, false to remove it.\n   */\n  toggleClass(element, className, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set class immediately.\n      toggleClass(element, className, value);\n    } else {\n      // Defer setting class until the first time we're connected.\n      if (!element[pendingClassesSymbol]) {\n        element[pendingClassesSymbol] = {};\n      }\n      element[pendingClassesSymbol][className] = value;\n    }\n  }\n\n};\n\n\n// Reflect the attribute to the given element.\n// If the value is null, remove the attribute.\nfunction setAttributeToElement(element, attributeName, value) {\n  if (value === null || typeof value === 'undefined') {\n    element.removeAttribute(attributeName);\n  } else {\n    const text = String(value);\n    // Avoid recursive attributeChangedCallback calls.\n    if (element.getAttribute(attributeName) !== text) {\n      element.setAttribute(attributeName, value);\n    }\n  }\n}\n","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'basic-component-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'basic-component-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `dragging` property.\n   *\n   * Components like carousels often define animated CSS transitions for\n   * sliding effects. Such a transition should usually *not* be applied while\n   * the user is dragging, because a CSS animation will introduce a lag that\n   * makes the swipe feel sluggish. Instead, as long as the user is dragging\n   * with their finger down, the transition should be suppressed. When the\n   * user releases their finger, the transition can be restored, allowing the\n   * animation to show the carousel sliding into its final position.\n   *\n   * @type {boolean} true if a drag is in progress, false if not.\n   */\n  dragging: createSymbol('dragging'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: createSymbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: createSymbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: createSymbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: createSymbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: createSymbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: createSymbol('goUp'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: createSymbol('keydown'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLElement}\n   */\n  template: createSymbol('template')\n};\n\nexport default symbols;\n","/**\n * Helper function for standard classList.toggle() behavior on old browsers,\n * namely IE 11.\n *\n * The standard\n * [classlist](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)\n * object has a `toggle()` function that supports a second Boolean parameter\n * that can be used to succinctly turn a class on or off. This feature is often\n * useful in designing custom elements, which may want to externally reflect\n * component state in a CSS class that can be used for styling purposes.\n *\n * Unfortunately, IE 11 does not support the Boolean parameter to\n * `classList.toggle()`. This helper function behaves like the standard\n * `toggle()`, including support for the Boolean parameter, so that it can be\n * used even on IE 11.\n *\n * @function toggleClass\n * @param {HTMLElement} element - The element to modify\n * @param {string} className - The class to add/remove\n * @param {boolean} [force] - Force the class to be added (if true) or removed\n *                            (if false)\n */\nexport default function toggleClass(element, className, force) {\n  const classList = element.classList;\n  const addClass = (typeof force === 'undefined') ?\n    !classList.contains(className) :\n    force;\n  if (addClass) {\n    classList.add(className);\n  } else {\n    classList.remove(className);\n  }\n  return addClass;\n}\n","import AttributeMarshallingMixin from '../../basic-component-mixins/src/AttributeMarshallingMixin';\nimport ComposableMixin from '../../basic-component-mixins/src/ComposableMixin';\nimport DistributedChildrenMixin from '../../basic-component-mixins/src/DistributedChildrenMixin';\nimport ShadowElementReferencesMixin from '../../basic-component-mixins/src/ShadowElementReferencesMixin';\nimport ShadowTemplateMixin from '../../basic-component-mixins/src/ShadowTemplateMixin';\n\n\n/**\n * A sample general-purpose base class for defining custom elements that mixes\n * in some common features: template stamping into a shadow root, shadow element\n * references, marshalling attributes to properties, and retrieving the children\n * distributed to a component.\n *\n * This base class is not special in any way, and is defined only as a\n * convenient shorthand for applying the mixins listed above. You can use this\n * class as a base class for your own elements, or easily create your own base\n * class by applying the same set of mixins.\n *\n * The ElementBase base class does not register itself as a custom element with\n * the browser, and hence cannot be independently instantiated.\n *\n * @mixes AttributeMarshallingMixin\n * @mixes ComposableMixin\n * @mixes DistributedChildrenMixin\n * @mixes ShadowElementReferencesMixin\n * @mixes ShadowTemplateMixin\n */\nclass ElementBase extends ComposableMixin(HTMLElement).compose(\n  ShadowTemplateMixin,          // before node finding, so shadow root is populated\n  ShadowElementReferencesMixin, // before marshalling, so properties can use refs\n  AttributeMarshallingMixin,\n  DistributedChildrenMixin\n) {}\n\nexport default ElementBase;\n","import HorizontalNavigationMixin from '../../basic-component-mixins/src/HorizontalNavigationMixin';\nimport SlidingViewport from '../../basic-sliding-viewport/src/SlidingViewport';\n\n\n/**\n * Lets the user navigate laterally through a sequence of child elements\n * using a simple CSS transition effect to show horizontal movement.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-sliding-carousel/)\n *\n * basic-sliding-carousel is an implementation of the carousel user interface\n * pattern, commonly used for navigating between images, pages, and other\n * elements. This pattern presents the user with a linear sequence of elements,\n * only one of which is shown at a time. The user can navigate to the\n * next/previous element with a variety of input methods.\n *\n * basic-sliding-carousel is a simpler variation of the more sophisticated\n * [basic-carousel](../basic-carousel) component. The latter includes support\n * for wrapping (going forward from the last item to the first, and vice versa),\n * and more complex visual transitions. Those transitions entail use of the Web\n * Animation API, which requires a polyfill in older browsers. Hence, the\n * simpler basic-sliding-carousel may be a more appropriate choice if factors\n * such as download size are critical.\n *\n * Beyond those differences, basic-sliding-carousel offers the same API, usage\n * recommendations, and support for keyboard/touch/mouse and assistive devices.\n * See that component for more details on use.\n *\n * @extends SlidingViewport\n * @mixes HorizontalNavigationMixin\n */\nclass SlidingCarousel extends SlidingViewport.compose(\n  HorizontalNavigationMixin\n) {}\n\n\ncustomElements.define('basic-sliding-carousel', SlidingCarousel);\nexport default SlidingCarousel;\n","import ContentItemsMixin from '../../basic-component-mixins/src/ContentItemsMixin';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport ElementBase from '../../basic-element-base/src/ElementBase';\nimport FractionalSelectionMixin from '../../basic-component-mixins/src/FractionalSelectionMixin';\nimport SelectionAriaActiveMixin from '../../basic-component-mixins/src/SelectionAriaActiveMixin';\nimport SingleSelectionMixin from '../../basic-component-mixins/src/SingleSelectionMixin';\nimport SpreadItems from '../../basic-spread-items/src/SpreadItems'; // jshint ignore:line\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\nconst base = ElementBase.compose(\n  ContentItemsMixin,\n  DistributedChildrenContentMixin,\n  FractionalSelectionMixin,\n  SelectionAriaActiveMixin,\n  SingleSelectionMixin\n);\n\n\n/**\n * Presents list items in a viewport such that only a single item is visible at\n * a time.\n *\n * Navigating between items will be represented with a horizontal visual\n * sliding effect. For more complex visual effects, see\n * [basic-animation-stage](../basic-animation-stage), which takes advantage of\n * the Web Animations API.\n *\n * This component handles the rendering responsibilities for the basic-carousel\n * component.\n *\n * This component currently requires that you explicitly apply a size to it.\n *\n * @extends ElementBase\n * @mixes ContentItemsMixin\n * @mixes DistributedChildrenContentMixin\n * @mixes FractionalSelectionMixin\n * @mixes SelectionAriaActiveMixin\n * @mixes SingleSelectionMixin\n */\nclass SlidingViewport extends base {\n\n  constructor() {\n    super();\n    this[symbols.dragging] = false;\n  }\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.selectionRequired = true;\n    return defaults;\n  }\n\n  /*\n   * During drags, don't show CSS transitions.\n   */\n  get [symbols.dragging]() {\n    return !this.showTransition;\n  }\n  set [symbols.dragging](value) {\n    if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n    this.reflectClass('showTransition', !value);\n  }\n\n  get selectedFraction() {\n    return super.selectedFraction;\n  }\n  set selectedFraction(value) {\n    if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n    render(this);\n  }\n\n  get selectedItem() {\n    return super.selectedItem;\n  }\n  set selectedItem(item) {\n    if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n    render(this);\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        display: block;\n        overflow: hidden;\n        position: relative;\n      }\n\n      #slidingContainer {\n        height: 100%;\n        position: absolute;\n        /*\n         Set width for IE/Edge. It's not clear why they need this, and the other\n         browsers don't.\n         */\n        width: 100%;\n        will-change: transform;\n      }\n\n      :host(.showTransition) #slidingContainer {\n        -webkit-transition: -webkit-transform 0.2s ease-out;\n        transition: transform 0.2s ease-out;\n      }\n      </style>\n\n      <basic-spread-items id=\"slidingContainer\" role=\"none\">\n        <slot></slot>\n      </basic-spread-items>\n    `;\n  }\n\n}\n\n\n\nfunction render(element) {\n  requestAnimationFrame(renderSelection.bind(element));\n}\n\n// Note: In this routine, \"this\" is bound to an element instance.\nfunction renderSelection() {\n  if (!this.selectedItem) {\n    return;\n  }\n  const selection = FractionalSelectionMixin.helpers.elementSelection(this);\n  const itemCount = this.items ? this.items.length : 0;\n  const damped = FractionalSelectionMixin.helpers.dampedSelection(selection, itemCount);\n  // Use a percentage so the transform will still work if screen size changes\n  // (e.g., if device orientation changes).\n  const left = -damped * 100;\n  const transform = 'translateX(' + left + '%)';\n  this.$.slidingContainer.style.webkitTransform = transform;\n  this.$.slidingContainer.style.transform = transform;\n}\n\n\ncustomElements.define('basic-sliding-viewport', SlidingViewport);\nexport default SlidingViewport;\n","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/**\n * Spreads out a set of items horizontally so they take equal space.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-spread-items/)\n *\n * This component is used, for example, by the basic-sliding-viewport component\n * to ensure that children of different size will take up the same amount of\n * horizontal space.\n *\n * This component currently requires an explicit size by applied to it.\n *\n * @extends ElementBase\n * @mixes DistributedChildrenContentMixin\n */\nclass SpreadItems extends ElementBase.compose(\n  DistributedChildrenContentMixin\n) {\n\n  connectedCallback() {\n    if (super.connectedCallback) { super.connectedCallback(); }\n    // HACK\n    this[symbols.itemsChanged]();\n  }\n\n  get items() {\n    return this.content;\n  }\n\n  // TODO: Should also handle contentChanged(), but need to rationalize with\n  // invocation of [symbols.itemsChanged] in connectedCallback.\n  [symbols.itemsChanged]() {\n    if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n    const items = this.items;\n    const count = items.length;\n    this.$.spreadContainer.style.width = (count * 100) + '%';\n    const itemWidth = (100 / count) + \"%\";\n    [].forEach.call(items, item => {\n      item.style.width = itemWidth;\n    });\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        display: block;\n      }\n\n      #spreadContainer {\n        display: -webkit-flex;\n        display: flex;\n        height: 100%;\n        position: relative;\n      }\n\n      #spreadContainer ::slotted(*) {\n        object-fit: contain;\n        object-fit: var(--basic-item-object-fit, contain);\n        height: 100%;\n        -webkit-user-drag: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n      </style>\n\n      <div id=\"spreadContainer\" role=\"none\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n}\n\n\ncustomElements.define('basic-spread-items', SpreadItems);\nexport default SpreadItems;\n","import AnimationStage from '../../basic-animation-stage/src/AnimationStage';\nimport PageDotsMixin from '../../basic-component-mixins/src/PageDotsMixin';\n\nclass AnimationStageWithDots extends PageDotsMixin(AnimationStage) {}\ncustomElements.define('animation-stage-with-dots', AnimationStageWithDots);\n\nexport default AnimationStageWithDots;\n","import ArrowSelectionMixin from '../../basic-component-mixins/src/ArrowSelectionMixin';\nimport Carousel from '../../basic-carousel/src/Carousel';\n\nclass CarouselWithArrows extends ArrowSelectionMixin(Carousel) {}\ncustomElements.define('carousel-with-arrows', CarouselWithArrows);\n\nexport default CarouselWithArrows;\n","import ArrowSelectionMixin from '../../basic-component-mixins/src/ArrowSelectionMixin';\nimport Carousel from '../../basic-carousel/src/Carousel';\nimport PageDotsMixin from '../../basic-component-mixins/src/PageDotsMixin';\n\nclass CarouselWithArrows extends Carousel.compose(\n  ArrowSelectionMixin,\n  PageDotsMixin\n) {}\ncustomElements.define('carousel-with-arrows-and-dots', CarouselWithArrows);\n\nexport default CarouselWithArrows;\n","import Carousel from '../../basic-carousel/src/Carousel';\nimport PageDotsMixin from '../../basic-component-mixins/src/PageDotsMixin';\n\nclass CarouselWithDots extends PageDotsMixin(Carousel) {}\ncustomElements.define('carousel-with-dots', CarouselWithDots);\n\nexport default CarouselWithDots;\n","import ArrowSelectionMixin from '../../basic-component-mixins/src/ArrowSelectionMixin';\nimport SlidingCarousel from '../../basic-sliding-carousel/src/SlidingCarousel';\nimport PageDotsMixin from '../../basic-component-mixins/src/PageDotsMixin';\n\nclass SlidingCarouselWithArrowsAndDots extends SlidingCarousel.compose(\n  ArrowSelectionMixin,\n  PageDotsMixin\n) {}\n\ncustomElements.define('sliding-carousel-with-arrows-and-dots', SlidingCarouselWithArrowsAndDots);\nexport default SlidingCarouselWithArrowsAndDots;\n"],"preExisting":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJwYWNrYWdlcy9iYXNpYy1hbmltYXRpb24tc3RhZ2Uvc3JjL0FuaW1hdGlvblN0YWdlLmpzIiwicGFja2FnZXMvYmFzaWMtY2Fyb3VzZWwvc3JjL0Nhcm91c2VsLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQXJyb3dTZWxlY3Rpb25NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0F0dHJpYnV0ZU1hcnNoYWxsaW5nTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9Db21wb3NhYmxlTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9Db250ZW50SXRlbXNNaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0RpcmVjdGlvblNlbGVjdGlvbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0Rpc3RyaWJ1dGVkQ2hpbGRyZW5NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0ZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0hvcml6b250YWxOYXZpZ2F0aW9uTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9LZXlib2FyZERpcmVjdGlvbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvS2V5Ym9hcmRNaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1BhZ2VEb3RzTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TZWxlY3Rpb25BbmltYXRpb25NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NlbGVjdGlvbkFyaWFBY3RpdmVNaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NoYWRvd0VsZW1lbnRSZWZlcmVuY2VzTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TaGFkb3dUZW1wbGF0ZU1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2luZ2xlU2VsZWN0aW9uTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9Td2lwZURpcmVjdGlvbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvVHJhY2twYWREaXJlY3Rpb25NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL2NyZWF0ZVN5bWJvbC5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL21pY3JvdGFzay5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3JlbmRlckFycmF5QXNFbGVtZW50cy5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3NhZmVBdHRyaWJ1dGVzLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc3ltYm9scy5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3RvZ2dsZUNsYXNzLmpzIiwicGFja2FnZXMvYmFzaWMtZWxlbWVudC1iYXNlL3NyYy9FbGVtZW50QmFzZS5qcyIsInBhY2thZ2VzL2Jhc2ljLXNsaWRpbmctY2Fyb3VzZWwvc3JjL1NsaWRpbmdDYXJvdXNlbC5qcyIsInBhY2thZ2VzL2Jhc2ljLXNsaWRpbmctdmlld3BvcnQvc3JjL1NsaWRpbmdWaWV3cG9ydC5qcyIsInBhY2thZ2VzL2Jhc2ljLXNwcmVhZC1pdGVtcy9zcmMvU3ByZWFkSXRlbXMuanMiLCJwYWNrYWdlcy9kZW1vcy9zcmMvQW5pbWF0aW9uU3RhZ2VXaXRoRG90cy5qcyIsInBhY2thZ2VzL2RlbW9zL3NyYy9DYXJvdXNlbFdpdGhBcnJvd3MuanMiLCJwYWNrYWdlcy9kZW1vcy9zcmMvQ2Fyb3VzZWxXaXRoQXJyb3dzQW5kRG90cy5qcyIsInBhY2thZ2VzL2RlbW9zL3NyYy9DYXJvdXNlbFdpdGhEb3RzLmpzIiwicGFja2FnZXMvZGVtb3Mvc3JjL1NsaWRpbmdDYXJvdXNlbFdpdGhBcnJvd3NBbmREb3RzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztBQ0FBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUdBLElBQU0sT0FBTyxzQkFBWSxPQUFaLG1OQUFiOztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUEwQk0sYzs7Ozs7Ozs7OztTQUVDLGtCQUFRLFE7d0JBQVk7QUFDdkIsVUFBTSxXQUFXLDRGQUFNLGtCQUFRLFFBQWQsV0FBMkIsRUFBNUM7QUFDQSxlQUFTLGlCQUFULEdBQTZCLElBQTdCO0FBQ0EsYUFBTyxRQUFQO0FBQ0Q7O1NBRUksa0JBQVEsUTt3QkFBWTtBQUN2QjtBQW9CRDs7OztFQTdCMEIsSTs7QUFrQzdCLGVBQWUsTUFBZixDQUFzQix1QkFBdEIsRUFBK0MsY0FBL0M7a0JBQ2UsYzs7Ozs7Ozs7O0FDaEZmOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb0dNLFE7Ozs7Ozs7Ozs7RUFBaUIs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Ozs7Ozs7QUNOZjs7OztBQUNBOzs7Ozs7Ozs7Ozs7SUFFTSxrQjs7Ozs7Ozs7OztFQUEyQixzRDs7QUFDakMsZUFBZSxNQUFmLENBQXNCLHNCQUF0QixFQUE4QyxrQkFBOUM7O2tCQUVlLGtCOzs7Ozs7Ozs7QUNOZjs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztJQUVNLGtCOzs7Ozs7Ozs7O0VBQTJCLG1CQUFTLE9BQVQsd0Q7O0FBSWpDLGVBQWUsTUFBZixDQUFzQiwrQkFBdEIsRUFBdUQsa0JBQXZEOztrQkFFZSxrQjs7Ozs7Ozs7O0FDVmY7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRU0sZ0I7Ozs7Ozs7Ozs7RUFBeUIsZ0Q7O0FBQy9CLGVBQWUsTUFBZixDQUFzQixvQkFBdEIsRUFBNEMsZ0JBQTVDOztrQkFFZSxnQjs7Ozs7Ozs7O0FDTmY7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7SUFFTSxnQzs7Ozs7Ozs7OztFQUF5QywwQkFBZ0IsT0FBaEIsd0Q7O0FBSy9DLGVBQWUsTUFBZixDQUFzQix1Q0FBdEIsRUFBK0QsZ0NBQS9EO2tCQUNlLGdDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImltcG9ydCBFbGVtZW50QmFzZSBmcm9tICcuLi8uLi9iYXNpYy1lbGVtZW50LWJhc2Uvc3JjL0VsZW1lbnRCYXNlJztcbmltcG9ydCBDb250ZW50SXRlbXNNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9Db250ZW50SXRlbXNNaXhpbic7XG5pbXBvcnQgRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9EaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluJztcbmltcG9ydCBGcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluJztcbmltcG9ydCBTZWxlY3Rpb25BbmltYXRpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TZWxlY3Rpb25BbmltYXRpb25NaXhpbic7XG5pbXBvcnQgU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NlbGVjdGlvbkFyaWFBY3RpdmVNaXhpbic7XG5pbXBvcnQgU2luZ2xlU2VsZWN0aW9uTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2luZ2xlU2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc3ltYm9scyc7XG5cblxuY29uc3QgYmFzZSA9IEVsZW1lbnRCYXNlLmNvbXBvc2UoXG4gIENvbnRlbnRJdGVtc01peGluLFxuICBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluLFxuICBGcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4sXG4gIFNlbGVjdGlvbkFuaW1hdGlvbk1peGluLFxuICBTZWxlY3Rpb25BcmlhQWN0aXZlTWl4aW4sXG4gIFNpbmdsZVNlbGVjdGlvbk1peGluXG4pO1xuXG4vKipcbiAqIFByZXNlbnRzIGEgc2luZ2xlIGl0ZW0gYXMgc2VsZWN0ZWQsIHByb3ZpZGluZyBhbmltYXRlZCB0cmFuc2l0aW9ucyB3aGVuIHRoZVxuICogc2VsZWN0aW9uIGNoYW5nZXMuIFRoZSBzYW1lIGFuaW1hdGlvbiBjYW4gYmUgc2hvd24gYXQgYW4gYXJiaXRyYXJ5IHBvaW50LFxuICogZ2VuZXJhbGx5IHVzZWQgdG8gcmVmbGVjdCBhIHVzZXItY29udHJvbGxlZCB0b3VjaCBvciB0cmFja3BhZCBkcmFnIG9wZXJhdGlvblxuICogaW4gcHJvZ3Jlc3MuXG4gKlxuICogW0xpdmUgZGVtb10oaHR0cDovL2Jhc2ljd2ViY29tcG9uZW50cy5vcmcvYmFzaWMtd2ViLWNvbXBvbmVudHMvcGFja2FnZXMvYmFzaWMtYW5pbWF0aW9uLXN0YWdlLylcbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIGEgcHJvZ3JhbW1hdGljIHJlbmRlcmluZyBzdXJmYWNlIGZvclxuICogY29tcG9uZW50cyB3aGljaCB3YW50IHRvIHNob3cgdHJhbnNpdGlvbmFsIGVmZmVjdHMuXG4gKlxuICogVGhlIGNvbXBvbmVudCB1c2VzIFtTZWxlY3Rpb25BbmltYXRpb25NaXhpbl0oLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9kb2NzL1NlbGVjdGlvbkFuaW1hdGlvbk1peGluLm1kKVxuICogbWl4aW4sIHdoaWNoIGluIHR1cm4gdXNlcyB0aGUgV2ViIEFuaW1hdGlvbnMgQVBJLiBGb3IgdXNlIG9uIGJyb3dzZXJzIHdoaWNoXG4gKiBkbyBub3Qgc3VwcG9ydCB0aGF0IEFQSSBuYXRpdmVseSwgeW91IHdpbGwgbmVlZCB0byBsb2FkIHRoZVxuICogW1dlYiBBbmltYXRpb25zIHBvbHlmaWxsXShodHRwczovL2dpdGh1Yi5jb20vd2ViLWFuaW1hdGlvbnMvd2ViLWFuaW1hdGlvbnMtanMpLlxuICpcbiAqIEZvciBhIHNpbXBsZXIgY29tcG9uZW50IHRoYXQgZXhoaWJpdHMgb25seSBhIHNsaWRpbmcgZWZmZWN0LCBidXQgZG9lcyBub3RcbiAqIHJlcXVpcmUgdGhlIFdlYiBBbmltYXRpb25zIEFQSSwgc2VlIFtiYXNpYy1zbGlkaW5nLXZpZXdwb3J0XSguLi9iYXNpYy1zbGlkaW5nLXZpZXdwb3J0KS5cbiAqXG4gKiBAZXh0ZW5kcyBFbGVtZW50QmFzZVxuICogQG1peGVzIENvbnRlbnRJdGVtc01peGluXG4gKiBAbWl4ZXMgRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpblxuICogQG1peGVzIFNlbGVjdGlvbkFuaW1hdGlvbk1peGluXG4gKiBAbWl4ZXMgU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluXG4gKiBAbWl4ZXMgU2luZ2xlU2VsZWN0aW9uTWl4aW5cbiAqL1xuY2xhc3MgQW5pbWF0aW9uU3RhZ2UgZXh0ZW5kcyBiYXNlIHtcblxuICBnZXQgW3N5bWJvbHMuZGVmYXVsdHNdKCkge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gc3VwZXJbc3ltYm9scy5kZWZhdWx0c10gfHwge307XG4gICAgZGVmYXVsdHMuc2VsZWN0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIHJldHVybiBkZWZhdWx0cztcbiAgfVxuXG4gIGdldCBbc3ltYm9scy50ZW1wbGF0ZV0oKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICAjY29udGFpbmVyIDo6c2xvdHRlZCgqKSB7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG5cbiAgICAgIDxkaXYgaWQ9XCJjb250YWluZXJcIiByb2xlPVwibm9uZVwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICB9XG5cbn1cblxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2Jhc2ljLWFuaW1hdGlvbi1zdGFnZScsIEFuaW1hdGlvblN0YWdlKTtcbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGlvblN0YWdlO1xuIiwiaW1wb3J0IEFuaW1hdGlvblN0YWdlIGZyb20gJy4uLy4uL2Jhc2ljLWFuaW1hdGlvbi1zdGFnZS9zcmMvQW5pbWF0aW9uU3RhZ2UnO1xuaW1wb3J0IEhvcml6b250YWxOYXZpZ2F0aW9uTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvSG9yaXpvbnRhbE5hdmlnYXRpb25NaXhpbic7XG5cblxuLyoqXG4gKiBMZXRzIHRoZSB1c2VyIG5hdmlnYXRlIGxhdGVyYWxseSB0aHJvdWdoIGEgc2VxdWVuY2Ugb2YgY2hpbGQgZWxlbWVudHMuXG4gKlxuICogYmFzaWMtY2Fyb3VzZWwgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGNhcm91c2VsIHVzZXIgaW50ZXJmYWNlIHBhdHRlcm4sXG4gKiBjb21tb25seSB1c2VkIGZvciBuYXZpZ2F0aW5nIGJldHdlZW4gaW1hZ2VzLCBwYWdlcywgYW5kIG90aGVyIGVsZW1lbnRzLiBUaGlzXG4gKiBwYXR0ZXJuIHByZXNlbnRzIHRoZSB1c2VyIHdpdGggYSBsaW5lYXIgc2VxdWVuY2Ugb2YgZWxlbWVudHMsIG9ubHkgb25lIG9mXG4gKiB3aGljaCBpcyBzaG93biBhdCBhIHRpbWUuIFRoZSB1c2VyIGNhbiBuYXZpZ2F0ZSB0byB0aGUgbmV4dC9wcmV2aW91cyBlbGVtZW50XG4gKiB3aXRoIGEgdmFyaWV0eSBvZiBpbnB1dCBtZXRob2RzLlxuICpcbiAqIFtMaXZlIGRlbW9dKGh0dHA6Ly9iYXNpY3dlYmNvbXBvbmVudHMub3JnL2Jhc2ljLXdlYi1jb21wb25lbnRzL3BhY2thZ2VzL2Jhc2ljLWNhcm91c2VsLylcbiAqXG4gKiBUaGUgYWJvdmUgZGVtbyBpcyBhIHBsYWluIGNhcm91c2VsLiBJdCdzIG9mdGVuIGNvbWJpbmVkLCBob3dldmVyLCB3aXRoXG4gKiBtaXhpbnMgbGlrZVxuICogW0Fycm93U2VsZWN0aW9uTWl4aW5dKC4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvZG9jcy9BcnJvd1NlbGVjdGlvbk1peGluLm1kKSxcbiAqIFtQYWdlRG90c01peGluXSguLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL2RvY3MvUGFnZURvdHNNaXhpbi5tZCksXG4gKiBbVGltZXJTZWxlY3Rpb25NaXhpbl0oLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9kb2NzL1RpbWVyU2VsZWN0aW9uTWl4aW4ubWQpLlxuICogRm9yIGV4YW1wbGUsIHlvdSBjYW4gdmlldyBhXG4gKiBbZGVtbyB3aXRoIGFycm93cyBhbmQgcGFnZSBkb3RzXShodHRwOi8vYmFzaWN3ZWJjb21wb25lbnRzLm9yZy9iYXNpYy13ZWItY29tcG9uZW50cy9wYWNrYWdlcy9kZW1vcy9jYXJvdXNlbC13aXRoLWFycm93cy1hbmQtZG90cy5odG1sKS5cbiAqIFNlZSB0aGUgc3BlY2lmaWMgbWl4aW5zIGZvciBvdGhlciBjYXJvdXNlbCBkZW1vcy5cbiAqXG4gKiBiYXNpYy1jYXJvdXNlbCB1c2VzIGl0cyBjaGlsZHJlbiBhcyB0aGUgZWxlbWVudHMgdGhlIHVzZXIgd2lsbCBuYXZpZ2F0ZVxuICogdGhyb3VnaC4gSW4gYSB0eXBpY2FsIHVzZSwgYSBiYXNpYy1jYXJvdXNlbCBjYW4gYmUgdXNlZCB0byBuYXZpZ2F0ZSBiZXR3ZWVuIGFcbiAqIHNlcXVlbmNlIG9mIGltYWdlczpcbiAqXG4gKiAgICAgPGJhc2ljLWNhcm91c2VsPlxuICogICAgICAgPGltZyBzcmM9XCJpbWFnZTEuanBnXCI+XG4gKiAgICAgICA8aW1nIHNyYz1cImltYWdlMi5qcGdcIj5cbiAqICAgICAgIDxpbWcgc3JjPVwiaW1hZ2UzLmpwZ1wiPlxuICogICAgIDwvYmFzaWMtY2Fyb3VzZWw+XG4gKlxuICogVGhlIGNoaWxkIGVsZW1lbnRzIGNhbiBiZSBvZiBhbnkgdHlwZSDigJTCoHRoZXkgYXJlIG5vdCByZXN0cmljdGVkIHRvIGltYWdlcy5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBhdHRlbXB0cyB0byBtZWV0IHRoZSBbR29sZCBTdGFuZGFyZCBmb3Igd2ViIGNvbXBvbmVudHNdXG4gKiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvZ29sZC1zdGFuZGFyZC93aWtpKSBzbyB0aGF0IGl0IGlzIGdlbmVyYWxseVxuICogYXMgZmxleGlibGUgYW5kIHJvYnVzdCBhcyBzdGFuZGFyZCBIVE1MIGVsZW1lbnRzLiBGb3IgZXhhbXBsZSwgaXQgbWVldHMgdGhlXG4gKiBcIkNvbnRlbnQgQ2hhbmdlc1wiIGNyaXRlcmlhOiB0aGUgY2Fyb3VzZWwgd2lsbCBhZGFwdCB0byBuZXcgY2hpbGQgZWxlbWVudHNcbiAqIGFkZGVkIG9yIHJlbW92ZWQgYXQgcnVudGltZS5cbiAqXG4gKiBDdXJyZW50bHksIHRoaXMgY29tcG9uZW50IGRvZXMgbm90IG1lZXQgdGhlIEdvbGQgU3RhbmRhcmQgY3JpdGVyaWEgXCJTaXplIHRvXG4gKiBDb250ZW50XCIuIEFzIGEgcmVzdWx0LCBmb3IgdGhlIHRpbWUgYmVpbmcsICoqeW91IG11c3QgbWFudWFsbHkgc2V0IGEgc2l6ZSBvblxuICogdGhpcyBjb21wb25lbnQqKi4gVHdvIGFwcHJvYWNoZXMgYXJlIHRvOiAxKSBzdHJldGNoIHRoZSBjb21wb25lbnQgYWNyb3NzXG4gKiB3aGF0ZXZlciBzdXJmYWNlIGl0IGlzIGNvbnRhaW5lZCB3aXRoaW4sIG9yIDIpIHNldCBpdCB0byBiZSBsYXJnZXIgdGhhbiB0aGVcbiAqIGxhcmdlc3QgY2hpbGQgZWxlbWVudCB5b3Ugd2FudCB0byBkaXNwbGF5LiBUaGUgZm9ybWVyIGFwcHJvYWNoIGlzIG1vcmVcbiAqIGNvbW1vbiwgYW5kIGNhbiBiZSBhY2hpZXZlZCB3aXRoIENTUyBzdHlsaW5nIHN1Y2ggYXM6XG4gKlxuICogICAgIGh0bWwge1xuICogICAgICAgaGVpZ2h0OiAxMDAlO1xuICogICAgIH1cbiAqXG4gKiAgICAgYm9keSB7XG4gKiAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gKiAgICAgICBkaXNwbGF5OiBmbGV4O1xuICogICAgICAgaGVpZ2h0OiAxMDAlO1xuICogICAgICAgbWFyZ2luOiAwO1xuICogICAgIH1cbiAqXG4gKiAgICAgYmFzaWMtY2Fyb3VzZWwge1xuICogICAgICAgLXdlYmtpdC1mbGV4OiAxO1xuICogICAgICAgZmxleDogMTtcbiAqICAgICB9XG4gKlxuICogVGhlIHN0YW5kYXJkIGJhc2ljLWNhcm91c2VsIGNvbXBvbmVudCBzdXBwb3J0cyBuYXZpZ2F0aW9uIHZpYSB0aGUgZm9sbG93aW5nXG4gKiBpbnB1dCBtZXRob2RzOlxuICpcbiAqICogS2V5Ym9hcmQuIFdoZW4gdGhlIGNhcm91c2VsIGhhcyBmb2N1cywgdGhlIHVzZXIgY2FuIHByZXNzIExlZnQsIFJpZ2h0LFxuICogICBIb21lLCBvciBFbmQuIFRoZXNlIG5hdmlnYXRlIHRvIHRoZSBleHBlY3RlZCBlbGVtZW50LlxuICogKiBUb3VjaC4gT24gbW9iaWxlIGFuZCBvdGhlciB0b3VjaC1lbmFibGVkIGRldmljZXMsIHRoZSB1c2VyIGNhbiBkcmFnIGxlZnQgb3JcbiAqICAgcmlnaHQuXG4gKiAqIFRyYWNrcGFkLiBUaGUgdXNlciBjYW4gc3dpcGUgbGVmdCBvciByaWdodCBvbiBhIHRyYWNrcGFkIHRvIG5hdmlnYXRlLlxuICpcbiAqIEJlY2F1c2UgY2Fyb3VzZWxzIGFyZSB1c2VkIGluIGEgd2lkZSB2YXJpZXR5IG9mIGNpcmN1bXN0YW5jZXMsIGJ5IGRlZmF1bHRcbiAqIGJhc2ljLWNhcm91c2VsIHByb3ZpZGVzIGEgbWluaW1hbCBhcHBlYXJhbmNlIGFuZCBubyBzZXBhcmF0ZWx5IGludGVyYWN0aXZlXG4gKiBlbGVtZW50cyBzdWNoIGFzIGFycm93IGJ1dHRvbnMgb24gdGhlIHNpZGUgb3IgZG90cyBhbG9uZyB0aGUgYm90dG9tLiBUaG9zZVxuICogZWxlbWVudHMgY2FuIGJlIGFkZGVkIGJ5IHdyYXBwaW5nIGEgQ2Fyb3VzZWwgaW4gb3B0aW9uYWwgbWl4aW5zOlxuICpcbiAqICogW0Fycm93U2VsZWN0aW9uTWl4aW5dKC4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvZG9jcy9BcnJvd1NlbGVjdGlvbk1peGluLm1kKS5cbiAqICAgQWRkcyBwcm9taW5lbnQgbGVmdCBhbmQgcmlnaHQgYXJyb3cgYnV0dG9ucyBvbiB0aGUgc2lkZSBvZiB0aGUgY2Fyb3VzZWwuXG4gKiAqIFtQYWdlRG90c01peGluXSguLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL2RvY3MvUGFnZURvdHNNaXhpbi5tZCkuXG4gKiAgIEFkZHMgYSBzZXJpZXMgb2Ygc21hbGwgZG90cyBiZWxvdyB0aGUgY2Fyb3VzZWwgdG8gaW5kaWNhdGUgdGhlIHVzZXInc1xuICogICBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZS5cbiAqICogW1RpbWVyU2VsZWN0aW9uTWl4aW5dKC4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvZG9jcy9UaW1lclNlbGVjdGlvbk1peGluLm1kKS5cbiAqICAgQWR2YW5jZXMgdG8gdGhlIG5leHQgaXRlbSBvbiBhIHRpbWVyLlxuICogKiBbVGFiU3RyaXBNaXhpbl0oLi4vYmFzaWMtdGFiLXN0cmlwKS5cbiAqICAgQWRkcyBhIHN0cmlwIG9mIHRyYWRpdGlvbmFsIHRhYiBidXR0b25zLlxuICpcbiAqIFNlZSB0aG9zZSBjb21wb25lbnRzIGZvciBtb3JlIGRldGFpbHMsIGJ1dCBpbiBnZW5lcmFsIHlvdSBjYW4gY29uc3RydWN0IGFcbiAqIGNvbW1vbiBjYXJvdXNlbCB3aXRoIGJvdGggYXJyb3cgYnV0dG9ucyBhbmQgZG90cyBsaWtlIHNvOlxuICpcbiAqICAgICBjbGFzcyBNeUNhcm91c2VsIGV4dGVuZHNcbiAqICAgICAgICAgQXJyb3dTZWxlY3Rpb25NaXhpbihQYWdlRG90c01peGluKENhcm91c2VsKSkge31cbiAqICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ215LWNhcm91c2VsJywgTXlDYXJvdXNlbCk7XG4gKlxuICogRm9yIHVuaXZlcnNhbCBhY2Nlc3MsIGJhc2ljLWNhcm91c2VsIGF1dG9tYXRpY2FsbHkgYWRkcyBhIHZhcmlldHkgb2ZcbiAqIFtBUklBXShodHRwOi8vd3d3LnczLm9yZy9XQUkvaW50cm8vYXJpYSkgcHJvcGVydGllcyB0byBpdHNlbGYgYW5kIHRvIGNoaWxkXG4gKiBlbGVtZW50cy4gVGhpcyBoZWxwcyB1c2VycyBuYXZpZ2F0ZSB0aGUgc2VxdWVuY2Ugb2YgZWxlbWVudHMgaW4gdGhlIGNhcm91c2VsXG4gKiB1c2luZyBhc3Npc3RpdmUgdGVjaG5vbG9naWVzLlxuICpcbiAqIEBleHRlbmRzIEFuaW1hdGlvblN0YWdlXG4gKiBAbWl4ZXMgSG9yaXpvbnRhbE5hdmlnYXRpb25NaXhpblxuICovXG5jbGFzcyBDYXJvdXNlbCBleHRlbmRzIEFuaW1hdGlvblN0YWdlLmNvbXBvc2UoXG4gIEhvcml6b250YWxOYXZpZ2F0aW9uTWl4aW5cbikge31cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdiYXNpYy1jYXJvdXNlbCcsIENhcm91c2VsKTtcbmV4cG9ydCBkZWZhdWx0IENhcm91c2VsO1xuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc3ltYm9scyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IG1vdXNlZG93bkxpc3RlbmVyU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdtb3VzZWRvd25MaXN0ZW5lcicpO1xuY29uc3QgbW91c2Vtb3ZlTGlzdGVuZXJTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ21vdXNlbW92ZUxpc3RlbmVyJyk7XG5jb25zdCBsYXN0TW91c2VYU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdsYXN0TW91c2VYJyk7XG5jb25zdCBsYXN0TW91c2VZU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdsYXN0TW91c2VZJyk7XG5jb25zdCBtb3VzZVRpbWVvdXRTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ21vdXNlVGltZW91dCcpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggQXJyb3dTZWxlY3Rpb24uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBUZW1wbGF0ZSBtaXhpbiB3aGljaCBhZGRzIHByb21pbmVudCBsZWZ0IGFuZCByaWdodCBhcnJvdyBidXR0b25zIHRvIGFcbiAgICogd3JhcHBlZCBjaGlsZCBzdWNoIGFzIGEgY2Fyb3VzZWwuXG4gICAqXG4gICAqIFlvdSBjYW4gc2VlIGFcbiAgICogW2xpdmUgZGVtb10oaHR0cDovL2Jhc2ljd2ViY29tcG9uZW50cy5vcmcvYmFzaWMtd2ViLWNvbXBvbmVudHMvcGFja2FnZXMvZGVtb3MvY2Fyb3VzZWwtd2l0aC1hcnJvd3MuaHRtbClcbiAgICogb2YgdGhpcyBtaXhpbiBhcHBsaWVkIHRvIGEgY2Fyb3VzZWwuXG4gICAqXG4gICAqIENsaWNraW5nIHRoZSBsZWZ0L3JpZ2h0IGJ1dHRvbnMgc2VsZWN0cyB0aGUgcHJldmlvdXMvbmV4dCBpdGVtLlxuICAgKlxuICAgKiBUeXBpY2FsIHVzYWdlOlxuICAgKlxuICAgKiAgICAgY2xhc3MgQ2Fyb3VzZWxXaXRoQXJyb3dzIGV4dGVuZHMgQXJyb3dTZWxlY3Rpb25NaXhpbihDYXJvdXNlbCkge31cbiAgICogICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnY2Fyb3VzZWwtd2l0aC1hcnJvd3MnLCBDYXJvdXNlbFdpdGhBcnJvd3MpO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgYXJyb3cgYnV0dG9ucyBhcmUgc2hvd24gb24gZGV2aWNlcyB3aXRoIGEgbW91c2Ugb3IgbW91c2UtbGlrZVxuICAgKiBwb2ludGluZyBkZXZpY2UuIFRoZXkgYXJlIG5vdCBzaG93biBvbiBhIHRvdWNoLWNhcGFibGUgZGV2aWNlIHVubGVzcyBtb3VzZVxuICAgKiBtb3ZlbWVudCBpcyBkZXRlY3RlZC4gVG8gY2F1c2UgdGhlIGJ1dHRvbnMgdG8gYWx3YXlzIGFwcGVhciwgYXBwbHkgdGhlXG4gICAqICdzaG93QXJyb3dzJyBDU1MgY2xhc3MuXG4gICAqL1xuICBjbGFzcyBBcnJvd1NlbGVjdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICB0aGlzLiQuYnV0dG9uTGVmdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kLmJ1dHRvblJpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnNlbGVjdE5leHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIGFzc3VtZUJ1dHRvbkZvY3VzKHRoaXMsIHRoaXMuJC5idXR0b25MZWZ0KTtcbiAgICAgIGFzc3VtZUJ1dHRvbkZvY3VzKHRoaXMsIHRoaXMuJC5idXR0b25SaWdodCk7XG4gICAgfVxuXG4gICAgZ2V0IGNhblNlbGVjdE5leHQoKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY2FuU2VsZWN0TmV4dDtcbiAgICB9XG4gICAgc2V0IGNhblNlbGVjdE5leHQoY2FuU2VsZWN0TmV4dCkge1xuICAgICAgaWYgKCdjYW5TZWxlY3ROZXh0JyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5jYW5TZWxlY3ROZXh0ID0gY2FuU2VsZWN0TmV4dDsgfVxuICAgICAgdGhpcy4kLmJ1dHRvblJpZ2h0LmRpc2FibGVkID0gIWNhblNlbGVjdE5leHQ7XG4gICAgfVxuXG4gICAgZ2V0IGNhblNlbGVjdFByZXZpb3VzKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLmNhblNlbGVjdFByZXZpb3VzO1xuICAgIH1cbiAgICBzZXQgY2FuU2VsZWN0UHJldmlvdXMoY2FuU2VsZWN0UHJldmlvdXMpIHtcbiAgICAgIGlmICgnY2FuU2VsZWN0UHJldmlvdXMnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLmNhblNlbGVjdFByZXZpb3VzID0gY2FuU2VsZWN0UHJldmlvdXM7IH1cbiAgICAgIHRoaXMuJC5idXR0b25MZWZ0LmRpc2FibGVkID0gIWNhblNlbGVjdFByZXZpb3VzO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgaWYgKHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKSB7IHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7IH1cblxuICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucygnc2hvd0Fycm93cycpKSB7XG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHdlIHNob3VsZCBzaG93IGFycm93IGJ1dHRvbnMgb3Igbm90LlxuICAgICAgICBpZiAoZGV2aWNlU3VwcG9ydHNUb3VjaCgpKSB7XG4gICAgICAgICAgLy8gQSB0b3VjaCBkZXZpY2UgbWlnaHQgYWxzbyBzdXBwb3J0IGEgbW91c2UsIGJ1dCB3ZSBjYW4ndCBrbm93IHdoZXRoZXJcbiAgICAgICAgICAvLyB0aGVyZSdzIGFjdHVhbGx5IGEgbW91c2UgdW50aWwgd2UgaGVhciBmcm9tIGl0LlxuICAgICAgICAgIGxpc3RlbkZvck1vdXNlKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSBkZXZpY2UgZG9lc24ndCBzdXBwb3J0IHRvdWNoLCBzbyBhc3N1bWUgaXQgaGFzIGEgbW91c2UuXG4gICAgICAgICAgc2hvd0Fycm93cyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMubmF2aWdhdGlvbkF4aXMgPSAnaG9yaXpvbnRhbCc7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBUaGUgdGVtcGxhdGUgdXNlcyB0aGUgY2hldnJvbi1sZWZ0IGFuZCBjaGV2cm9uLXJpZ2h0IFNWRyBpY29ucyBmcm9tXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXJFbGVtZW50cy9pcm9uLWljb25zL2Jsb2IvbWFzdGVyL2lyb24taWNvbnMuaHRtbC5cbiAgICAgKi9cbiAgICBnZXQgW3N5bWJvbHMudGVtcGxhdGVdKCkge1xuICAgICAgY29uc3QgYmFzZVRlbXBsYXRlID0gc3VwZXJbc3ltYm9scy50ZW1wbGF0ZV0gfHwgJyc7XG4gICAgICByZXR1cm4gYFxuICAgICAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICAtd2Via2l0LWFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIC13ZWJraXQtZmxleDogMTtcbiAgICAgICAgICBmbGV4OiAxO1xuICAgICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIH1cblxuICAgICAgICAjYXJyb3dOYXZpZ2F0aW9uQ29udGFpbmVyIHtcbiAgICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAtd2Via2l0LWZsZXg6IDE7XG4gICAgICAgICAgZmxleDogMTtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cblxuICAgICAgICAubmF2aWdhdGlvbkJ1dHRvbiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xuICAgICAgICAgIGZpbGw6IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgICAgICBvdXRsaW5lOiBub25lOyAvKiBSRVZJRVc6IEFjY2Vzc2liaWxpdHkgc2hvdWxkIGJlIHByb3ZpZGVkIGJ5IG90aGVyIGVsZW1lbnRzLiAqL1xuICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAxcztcbiAgICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLm5hdmlnYXRpb25CdXR0b246aG92ZXI6bm90KDpkaXNhYmxlZCkge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC41KTtcbiAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjgpO1xuICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgfVxuICAgICAgICAubmF2aWdhdGlvbkJ1dHRvbjphY3RpdmU6bm90KDpkaXNhYmxlZCkge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjkpO1xuICAgICAgICB9XG4gICAgICAgIC5uYXZpZ2F0aW9uQnV0dG9uOmRpc2FibGVkIHtcbiAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgOmhvc3QoOm5vdCguc2hvd0Fycm93cykpIC5uYXZpZ2F0aW9uQnV0dG9uIHtcbiAgICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC5uYXZpZ2F0aW9uQnV0dG9uIC5pY29uIHtcbiAgICAgICAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgICAgICAgd2lkdGg6IDQ4cHg7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBPdmVybGF5IHZhcmlhbnQgKi9cbiAgICAgICAgOmhvc3QoLm92ZXJsYXlBcnJvd3MpIHtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QoLm92ZXJsYXlBcnJvd3MpIC5uYXZpZ2F0aW9uQnV0dG9uIHtcbiAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KTtcbiAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgIDpob3N0KC5vdmVybGF5QXJyb3dzKSAjYnV0dG9uTGVmdCB7XG4gICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdCgub3ZlcmxheUFycm93cykgI2J1dHRvblJpZ2h0IHtcbiAgICAgICAgICByaWdodDogMDtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdCgub3ZlcmxheUFycm93cykgLm5hdmlnYXRpb25CdXR0b246aG92ZXI6bm90KDpkaXNhYmxlZCkge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcbiAgICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuICAgICAgICB9XG4gICAgICAgIDpob3N0KC5vdmVybGF5QXJyb3dzKSAubmF2aWdhdGlvbkJ1dHRvbjphY3RpdmU6bm90KDpkaXNhYmxlZCkge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC40KTtcbiAgICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xuICAgICAgICB9XG4gICAgICAgIDpob3N0KC5vdmVybGF5QXJyb3dzKSAubmF2aWdhdGlvbkJ1dHRvbjpkaXNhYmxlZCB7XG4gICAgICAgICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcbiAgICAgICAgfVxuICAgICAgICA8L3N0eWxlPlxuXG4gICAgICAgIDwhLS1cbiAgICAgICAgQWNjZXNzaWJpbGl0eSBub3RlOiBzaW5jZSB0aGUgbmF2aWdhdGlvbiBvZmZlcmVkIGJ5IHRoZSBhcnJvdyBidXR0b25zIHNob3VsZFxuICAgICAgICBiZSByZWR1bmRhbnQgKHRoYXQgaXMsIHRoZXJlIHNob3VsZCBiZSBvdGhlciB3YXlzIG9mIG5hdmlnYXRpbmcgdGhlIGxpc3QpLFxuICAgICAgICB3ZSBtYXJrIHRoZSBidXR0b24gYXMgYXJpYS1oaWRkZW4gc28gdGhhdCBhc3Npc3RpdmUgZGV2aWNlcyBpZ25vcmUgdGhlbS5cbiAgICAgICAgLS0+XG4gICAgICAgIDxidXR0b24gaWQ9XCJidXR0b25MZWZ0XCIgY2xhc3M9XCJuYXZpZ2F0aW9uQnV0dG9uXCIgZGlzYWJsZWQgdGFiaW5kZXg9XCItMVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgICAgIDxzdmcgY2xhc3M9XCJpY29uXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCI+XG4gICAgICAgICAgICA8ZyBpZD1cImNoZXZyb24tbGVmdFwiPlxuICAgICAgICAgICAgICA8cGF0aCBkPVwiTTE1LjQxIDcuNDFMMTQgNmwtNiA2IDYgNiAxLjQxLTEuNDFMMTAuODMgMTJ6XCIvPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGRpdiBpZD1cImFycm93TmF2aWdhdGlvbkNvbnRhaW5lclwiIHJvbGU9XCJub25lXCI+XG4gICAgICAgICAgJHtiYXNlVGVtcGxhdGV9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8YnV0dG9uIGlkPVwiYnV0dG9uUmlnaHRcIiBjbGFzcz1cIm5hdmlnYXRpb25CdXR0b25cIiBkaXNhYmxlZCB0YWJpbmRleD1cIi0xXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICAgICAgPHN2ZyBjbGFzcz1cImljb25cIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIj5cbiAgICAgICAgICAgIDxnIGlkPVwiY2hldnJvbi1yaWdodFwiPlxuICAgICAgICAgICAgICA8cGF0aCBkPVwiTTEwIDZMOC41OSA3LjQxIDEzLjE3IDEybC00LjU4IDQuNTlMMTAgMThsNi02elwiLz5cbiAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICBgO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEFycm93U2VsZWN0aW9uO1xufTtcblxuXG4vKlxuICogQnkgZGVmYXVsdCwgYSBidXR0b24gd2lsbCBhbHdheXMgdGFrZSBmb2N1cyBvbiBtb3VzZWRvd24uIEZvciB0aGlzIGNvbXBvbmVudCxcbiAqIHdlIHdhbnQgdG8gb3ZlcnJpZGUgdGhhdCBiZWhhdmlvciwgc3VjaCB0aGF0IGEgbW91c2Vkb3duIG9uIGEgYnV0dG9uIGtlZXBzXG4gKiB0aGUgZm9jdXMgb24gdGhlIG91dGVyIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gYXNzdW1lQnV0dG9uRm9jdXMoZWxlbWVudCwgYnV0dG9uKSB7XG4gIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBldmVudCA9PiB7XG4gICAgLy8gR2l2ZW4gdGhlIG1haW4gZWxlbWVudCB0aGUgZm9jdXMgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGhhdmUgaXQuXG4gICAgZWxlbWVudC5mb2N1cygpO1xuICAgIC8vIFByZXZlbnQgdGhlIGRlZmF1bHQgZm9jdXMtb24tbW91c2Vkb3duIGJlaGF2aW9yLlxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZXZpY2VTdXBwb3J0c1RvdWNoKCkge1xuICByZXR1cm4gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8XG4gICAgICAod2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCk7XG59XG5cbi8vIFdlIHRyeSB0byBkZXRlY3QgdGhlIHByZXNlbmNlIG9mIGEgbW91c2UgYnkgbGlzdGVuaW5nIGZvciBtb3VzZW1vdmUgZXZlbnRzXG4vLyB3aGljaCBhcmUgKm5vdCogdGhlIHJlc3VsdCBvZiBhIG1vdXNlZG93bi4gT24gYSB0b3VjaCBkZXZpY2UsIGEgdGFwIG9uIHRoZVxuLy8gcGFnZSB3aWxsIGdlbmVyYXRlIGEgZmFrZSBtb3VzZW1vdmUsIGZvbGxvd2VkIGJ5IGEgbW91c2Vkb3duLiBXZSBkb24ndCB3YW50XG4vLyB0byByZXNwb25kIHRvIHRob3NlIGZha2UgbW91c2Vtb3ZlIGV2ZW50cy4gVG8gZGlzY3JpbWluYXRlIGJldHdlZW4gZmFrZSBhbmRcbi8vIHJlYWwgbW91c2Vtb3ZlIGV2ZW50cywgd2hlbiB3ZSBnZXQgYSBtb3VzZW1vdmUgZXZlbnQsIHdlIHdhaXQgZm9yIGEgYml0IHRvXG4vLyBzZWUgaWYgdGhlIHNhbWUgbG9jYXRpb24gaXMgcmVwb3J0ZWQgYXMgdGhlIGxvY2F0aW9uIG9mIGEgc3Vic2VxdWVudFxuLy8gbW91c2Vkb3duLlxuZnVuY3Rpb24gbGlzdGVuRm9yTW91c2UoZWxlbWVudCkge1xuXG4gIGVsZW1lbnRbbW91c2Vkb3duTGlzdGVuZXJTeW1ib2xdID0gZXZlbnQgPT4ge1xuICAgIGlmIChlbGVtZW50W21vdXNlVGltZW91dFN5bWJvbF0pIHtcbiAgICAgIGNsZWFyVGltZW91dChlbGVtZW50W21vdXNlVGltZW91dFN5bWJvbF0pO1xuICAgIH1cbiAgICBlbGVtZW50W2xhc3RNb3VzZVhTeW1ib2xdID0gZXZlbnQucGFnZVg7XG4gICAgZWxlbWVudFtsYXN0TW91c2VZU3ltYm9sXSA9IGV2ZW50LnBhZ2VZO1xuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZWxlbWVudFttb3VzZWRvd25MaXN0ZW5lclN5bWJvbF0pO1xuXG4gIGVsZW1lbnRbbW91c2Vtb3ZlTGlzdGVuZXJTeW1ib2xdID0gZXZlbnQgPT4ge1xuICAgIC8vIFBvc3Rwb25lIGNoZWNraW5nIHRoZSBtb3VzZW1vdmUgbG9jYXRpb24gdG8gZ2l2ZSB0aGUgbW91c2Vkb3duIGV2ZW50IGFcbiAgICAvLyBjaGFuY2UgdG8gZmlyZS4gVGhlIDI1MCBtcyBkZWxheSBpcyBqdXN0IGd1ZXNzd29yazsgYSBzaG9ydGVyIGRlbGF5XG4gICAgLy8gZG9lc24ndCBzZWVtIHRvIHdvcmsuXG4gICAgZWxlbWVudFttb3VzZVRpbWVvdXRTeW1ib2xdID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoZWxlbWVudFtsYXN0TW91c2VYU3ltYm9sXSAhPSBudWxsICYmIGV2ZW50LnBhZ2VYICE9PSBlbGVtZW50W2xhc3RNb3VzZVhTeW1ib2xdIHx8XG4gICAgICAgICAgZWxlbWVudFtsYXN0TW91c2VZU3ltYm9sXSAhPSBudWxsICYmIGV2ZW50LnBhZ2VZICE9PSBlbGVtZW50W2xhc3RNb3VzZVlTeW1ib2xdKSB7XG4gICAgICAgIC8vIG1vdXNlbW92ZSBldmVudCB3YXMgYXQgYSBsb2NhdGlvbiBvdGhlciB0aGFuIHRoZSBsYXN0IG1vdXNlZG93bixcbiAgICAgICAgLy8gYW5kIGhlbmNlIG1vc3QgbGlrZWx5IGEgcmVhbCBtb3VzZW1vdmUgZXZlbnQuXG4gICAgICAgIG1vdXNlRGV0ZWN0ZWQoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50W2xhc3RNb3VzZVhTeW1ib2xdID0gZXZlbnQucGFnZVg7XG4gICAgICAgIGVsZW1lbnRbbGFzdE1vdXNlWVN5bWJvbF0gPSBldmVudC5wYWdlWTtcbiAgICAgIH1cbiAgICB9LCAyNTApO1xuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZWxlbWVudFttb3VzZW1vdmVMaXN0ZW5lclN5bWJvbF0pO1xufVxuXG5mdW5jdGlvbiBtb3VzZURldGVjdGVkKGVsZW1lbnQpIHtcbiAgc2hvd0Fycm93cyhlbGVtZW50KTtcblxuICAvLyBXZSBjYW4gc3RvcCBsaXN0ZW5pbmcgZm9yIG1vdXNlIGV2ZW50cyBub3cuXG4gIGlmIChlbGVtZW50W21vdXNlVGltZW91dFN5bWJvbF0pIHtcbiAgICBjbGVhclRpbWVvdXQoZWxlbWVudFttb3VzZVRpbWVvdXRTeW1ib2xdKTtcbiAgfVxuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZWxlbWVudFttb3VzZWRvd25MaXN0ZW5lclN5bWJvbF0pO1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZWxlbWVudFttb3VzZW1vdmVMaXN0ZW5lclN5bWJvbF0pO1xuICBlbGVtZW50W21vdXNlZG93bkxpc3RlbmVyU3ltYm9sXSA9IG51bGw7XG4gIGVsZW1lbnRbbW91c2Vtb3ZlTGlzdGVuZXJTeW1ib2xdID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2hvd0Fycm93cyhlbGVtZW50KSB7XG4gIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2hvd0Fycm93cycpO1xufVxuIiwiaW1wb3J0IHNhZmVBdHRyaWJ1dGVzIGZyb20gJy4vc2FmZUF0dHJpYnV0ZXMnO1xuXG5cbi8vIE1lbW9pemVkIG1hcHMgb2YgYXR0cmlidXRlIHRvIHByb3BlcnR5IG5hbWVzIGFuZCB2aWNlIHZlcnNhLlxuY29uc3QgYXR0cmlidXRlVG9Qcm9wZXJ0eU5hbWVzID0ge307XG5jb25zdCBwcm9wZXJ0eU5hbWVzVG9BdHRyaWJ1dGVzID0ge307XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBBdHRyaWJ1dGVNYXJzaGFsbGluZy4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIG1hcnNoYWxscyBhdHRyaWJ1dGVzIHRvIHByb3BlcnRpZXMgYW5kIHZpY2UgdmVyc2EuXG4gICAqXG4gICAqIElmIHlvdXIgY29tcG9uZW50IGV4cG9zZXMgYSBzZXR0ZXIgZm9yIGEgcHJvcGVydHksIGl0J3MgZ2VuZXJhbGx5IGEgZ29vZFxuICAgKiBpZGVhIHRvIGxldCBkZXZzIHVzaW5nIHlvdXIgY29tcG9uZW50IGJlIGFibGUgdG8gc2V0IHRoYXQgcHJvcGVydHkgaW4gSFRNTFxuICAgKiB2aWEgYW4gZWxlbWVudCBhdHRyaWJ1dGUuIFlvdSBjYW4gY29kZSB0aGF0IHlvdXJzZWxmIGJ5IHdyaXRpbmcgYW5cbiAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AsIG9yIHlvdSBjYW4gdXNlIHRoaXMgbWl4aW4gdG8gZ2V0IGEgZGVncmVlIG9mXG4gICAqIGF1dG9tYXRpYyBzdXBwb3J0LlxuICAgKlxuICAgKiBUaGlzIG1peGluIGltcGxlbWVudHMgYW4gYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgdGhhdCB3aWxsIGF0dGVtcHQgdG9cbiAgICogY29udmVydCBhIGNoYW5nZSBpbiBhbiBlbGVtZW50IGF0dHJpYnV0ZSBpbnRvIGEgY2FsbCB0byB0aGUgY29ycmVzcG9uZGluZ1xuICAgKiBwcm9wZXJ0eSBzZXR0ZXIuIEF0dHJpYnV0ZXMgdHlwaWNhbGx5IGZvbGxvdyBoeXBoZW5hdGVkIG5hbWVzIChcImZvby1iYXJcIiksXG4gICAqIHdoZXJlYXMgcHJvcGVydGllcyB0eXBpY2FsbHkgdXNlIGNhbWVsQ2FzZSBuYW1lcyAoXCJmb29CYXJcIikuIFRoaXMgbWl4aW5cbiAgICogcmVzcGVjdHMgdGhhdCBjb252ZW50aW9uLCBhdXRvbWF0aWNhbGx5IG1hcHBpbmcgdGhlIGh5cGhlbmF0ZWQgYXR0cmlidXRlXG4gICAqIG5hbWUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2FtZWxDYXNlIHByb3BlcnR5IG5hbWUuXG4gICAqXG4gICAqIEV4YW1wbGU6IFlvdSBkZWZpbmUgYSBjb21wb25lbnQgdXNpbmcgdGhpcyBtaXhpbjpcbiAgICpcbiAgICogICAgIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIEF0dHJpYnV0ZU1hcnNoYWxsaW5nTWl4aW4oSFRNTEVsZW1lbnQpIHtcbiAgICogICAgICAgZ2V0IGZvb0JhcigpIHsgcmV0dXJuIHRoaXMuX2Zvb0JhcjsgfVxuICAgKiAgICAgICBzZXQgZm9vQmFyKHZhbHVlKSB7IHRoaXMuX2Zvb0JhciA9IHZhbHVlOyB9XG4gICAqICAgICB9XG4gICAqICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ215LWVsZW1lbnQnLCBNeUVsZW1lbnQpO1xuICAgKlxuICAgKiBJZiBzb21lb25lIHRoZW4gaW5zdGFudGlhdGVzIHlvdXIgY29tcG9uZW50IGluIEhUTUw6XG4gICAqXG4gICAqICAgICA8bXktZWxlbWVudCBmb28tYmFyPVwiSGVsbG9cIj48L215LWVsZW1lbnQ+XG4gICAqXG4gICAqIFRoZW4sIGFmdGVyIHRoZSBlbGVtZW50IGhhcyBiZWVuIHVwZ3JhZGVkLCB0aGUgYGZvb0JhcmAgc2V0dGVyIHdpbGxcbiAgICogYXV0b21hdGljYWxseSBiZSBpbnZva2VkIHdpdGggdGhlIGluaXRpYWwgdmFsdWUgXCJIZWxsb1wiLlxuICAgKlxuICAgKiBGb3IgdGhlIHRpbWUgYmVpbmcsIHRoaXMgbWl4aW4gb25seSBzdXBwb3J0cyBzdHJpbmctdmFsdWVkIHByb3BlcnRpZXMuXG4gICAqIElmIHlvdSdkIGxpa2UgdG8gY29udmVydCBzdHJpbmcgYXR0cmlidXRlcyB0byBvdGhlciB0eXBlcyAobnVtYmVycyxcbiAgICogYm9vbGVhbnMpLCB5b3UgbmVlZCB0byBpbXBsZW1lbnQgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgeW91cnNlbGYuXG4gICAqL1xuICBjbGFzcyBBdHRyaWJ1dGVNYXJzaGFsbGluZyBleHRlbmRzIGJhc2Uge1xuXG4gICAgLypcbiAgICAgKiBIYW5kbGUgYSBjaGFuZ2UgdG8gdGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyaWJ1dGVOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgIGlmIChzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spIHsgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCk7IH1cbiAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGF0dHJpYnV0ZVRvUHJvcGVydHlOYW1lKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgLy8gSWYgdGhlIGF0dHJpYnV0ZSBuYW1lIGNvcnJlc3BvbmRzIHRvIGEgcHJvcGVydHkgbmFtZSwgc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICAgIC8vIElnbm9yZSBzdGFuZGFyZCBIVE1MRWxlbWVudCBwcm9wZXJ0aWVzIGhhbmRsZWQgYnkgdGhlIERPTS5cbiAgICAgIGlmIChwcm9wZXJ0eU5hbWUgaW4gdGhpcyAmJiAhKHByb3BlcnR5TmFtZSBpbiBIVE1MRWxlbWVudC5wcm90b3R5cGUpKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgaWYgKHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKSB7IHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7IH1cbiAgICAgIHNhZmVBdHRyaWJ1dGVzLmNvbm5lY3RlZCh0aGlzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzRm9yQ2xhc3ModGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0L3Vuc2V0IHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgaW5kaWNhdGVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBleGlzdHMgcHJpbWFyaWx5IHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbiBlbGVtZW50IHdhbnRzIHRvXG4gICAgICogc2V0IGEgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZSB0aGF0IHNob3VsZCBiZSByZWZsZWN0ZWQgYXMgYW4gYXR0cmlidXRlLiBBblxuICAgICAqIGltcG9ydGFudCBsaW1pdGF0aW9uIG9mIGN1c3RvbSBlbGVtZW50IGNvbnN0dXJjdG9ycyBpcyB0aGF0IHRoZXkgY2Fubm90XG4gICAgICogc2V0IGF0dHJpYnV0ZXMuIEEgY2FsbCB0byBgcmVmbGVjdEF0dHJpYnV0ZWAgZHVyaW5nIHRoZSBjb25zdHJ1Y3RvciB3aWxsXG4gICAgICogYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVsZW1lbnQgaXMgY29ubmVjdGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgLSBUaGUgbmFtZSBvZiB0aGUgKmF0dHJpYnV0ZSogKG5vdCBwcm9wZXJ0eSkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQuIElmIG51bGwsIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlZmxlY3RBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNhZmVBdHRyaWJ1dGVzLnNldEF0dHJpYnV0ZSh0aGlzLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQvdW5zZXQgdGhlIGNsYXNzIHdpdGggdGhlIGluZGljYXRlZCBuYW1lLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZXhpc3RzIHByaW1hcmlseSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYW4gZWxlbWVudCB3YW50cyB0b1xuICAgICAqIHNldCBhIGRlZmF1bHQgcHJvcGVydHkgdmFsdWUgdGhhdCBzaG91bGQgYmUgcmVmbGVjdGVkIGFzIGFzIGNsYXNzLiBBblxuICAgICAqIGltcG9ydGFudCBsaW1pdGF0aW9uIG9mIGN1c3RvbSBlbGVtZW50IGNvbnN0dXJjdG9ycyBpcyB0aGF0IHRoZXkgY2Fubm90XG4gICAgICogc2V0IGF0dHJpYnV0ZXMsIGluY2x1ZGluZyB0aGUgYGNsYXNzYCBhdHRyaWJ1dGUuIEEgY2FsbCB0b1xuICAgICAqIGByZWZsZWN0Q2xhc3NgIGR1cmluZyB0aGUgY29uc3RydWN0b3Igd2lsbCBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgZWxlbWVudFxuICAgICAqIGlzIGNvbm5lY3RlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNsYXNzIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgLSBUcnVlIHRvIHNldCB0aGUgY2xhc3MsIGZhbHNlIHRvIHJlbW92ZSBpdC5cbiAgICAgKi9cbiAgICByZWZsZWN0Q2xhc3MoY2xhc3NOYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNhZmVBdHRyaWJ1dGVzLnRvZ2dsZUNsYXNzKHRoaXMsIGNsYXNzTmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEF0dHJpYnV0ZU1hcnNoYWxsaW5nO1xufTtcblxuXG4vLyBDb252ZXJ0IGh5cGhlbmF0ZWQgZm9vLWJhciBhdHRyaWJ1dGUgbmFtZSB0byBjYW1lbCBjYXNlIGZvb0JhciBwcm9wZXJ0eSBuYW1lLlxuZnVuY3Rpb24gYXR0cmlidXRlVG9Qcm9wZXJ0eU5hbWUoYXR0cmlidXRlTmFtZSkge1xuICBsZXQgcHJvcGVydHlOYW1lID0gYXR0cmlidXRlVG9Qcm9wZXJ0eU5hbWVzW2F0dHJpYnV0ZU5hbWVdO1xuICBpZiAoIXByb3BlcnR5TmFtZSkge1xuICAgIC8vIENvbnZlcnQgYW5kIG1lbW9pemUuXG4gICAgY29uc3QgaHlwZW5SZWdFeCA9IC8tKFthLXpdKS9nO1xuICAgIHByb3BlcnR5TmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShoeXBlblJlZ0V4LFxuICAgICAgICBtYXRjaCA9PiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpKTtcbiAgICBhdHRyaWJ1dGVUb1Byb3BlcnR5TmFtZXNbYXR0cmlidXRlTmFtZV0gPSBwcm9wZXJ0eU5hbWU7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5TmFtZTtcbn1cblxuZnVuY3Rpb24gYXR0cmlidXRlc0ZvckNsYXNzKGNsYXNzRm4pIHtcblxuICAvLyBXZSB0cmVhdCB0aGUgZWxlbWVudCBiYXNlIGNsYXNzZXMgYXMgaWYgdGhleSBoYXZlIG5vIGF0dHJpYnV0ZXMsIHNpbmNlIHdlXG4gIC8vIGRvbid0IHdhbnQgdG8gcmVjZWl2ZSBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgZm9yIHRoZW0uXG4gIGlmIChjbGFzc0ZuID09PSBIVE1MRWxlbWVudCB8fCBjbGFzc0ZuID09PSBPYmplY3QpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyBHZXQgYXR0cmlidXRlcyBmb3IgcGFyZW50IGNsYXNzLlxuICBjb25zdCBiYXNlQ2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2xhc3NGbi5wcm90b3R5cGUpLmNvbnN0cnVjdG9yO1xuICBjb25zdCBiYXNlQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXNGb3JDbGFzcyhiYXNlQ2xhc3MpO1xuXG4gIC8vIEdldCBhdHRyaWJ1dGVzIGZvciB0aGlzIGNsYXNzLlxuICBjb25zdCBwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2xhc3NGbi5wcm90b3R5cGUpO1xuICBjb25zdCBzZXR0ZXJOYW1lcyA9IHByb3BlcnR5TmFtZXMuZmlsdGVyKHByb3BlcnR5TmFtZSA9PlxuICAgIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICBjbGFzc0ZuLnByb3RvdHlwZSwgcHJvcGVydHlOYW1lKS5zZXQgPT09ICdmdW5jdGlvbicpO1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc2V0dGVyTmFtZXMubWFwKHNldHRlck5hbWUgPT5cbiAgICAgIHByb3BlcnR5TmFtZVRvQXR0cmlidXRlKHNldHRlck5hbWUpKTtcblxuICAvLyBNZXJnZS5cbiAgY29uc3QgZGlmZiA9IGF0dHJpYnV0ZXMuZmlsdGVyKGF0dHJpYnV0ZSA9PlxuICAgICAgYmFzZUF0dHJpYnV0ZXMuaW5kZXhPZihhdHRyaWJ1dGUpIDwgMCk7XG4gIHJldHVybiBiYXNlQXR0cmlidXRlcy5jb25jYXQoZGlmZik7XG59XG5cbi8vIENvbnZlcnQgYSBjYW1lbCBjYXNlIGZvb0JhciBwcm9wZXJ0eSBuYW1lIHRvIGEgaHlwaGVuYXRlZCBmb28tYmFyIGF0dHJpYnV0ZS5cbmZ1bmN0aW9uIHByb3BlcnR5TmFtZVRvQXR0cmlidXRlKHByb3BlcnR5TmFtZSkge1xuICBsZXQgYXR0cmlidXRlID0gcHJvcGVydHlOYW1lc1RvQXR0cmlidXRlc1twcm9wZXJ0eU5hbWVdO1xuICBpZiAoIWF0dHJpYnV0ZSkge1xuICAgIC8vIENvbnZlcnQgYW5kIG1lbW9pemUuXG4gICAgY29uc3QgdXBwZXJjYXNlUmVnRXggPSAvKFtBLVpdKS9nO1xuICAgIGF0dHJpYnV0ZSA9IHByb3BlcnR5TmFtZS5yZXBsYWNlKHVwcGVyY2FzZVJlZ0V4LCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuICByZXR1cm4gYXR0cmlidXRlO1xufVxuIiwiLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBDb21wb3NhYmxlLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gdG8gbWFrZSBhIGNsYXNzIG1vcmUgZWFzaWx5IGNvbXBvc2FibGUgd2l0aCBvdGhlciBtaXhpbnMuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gY29udHJpYnV0ZXMgYSBgY29tcG9zZWAgbWV0aG9kIHRoYXQgYXBwbGllcyBhIHNldCBvZiBtaXhpblxuICAgKiBmdW5jdGlvbnMgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBuZXcgY2xhc3MuIFRoaXMgc3VnYXIgY2FuIG1ha2UgdGhlXG4gICAqIGFwcGxpY2F0aW9uIG9mIG1hbnkgbWl4aW5zIGF0IG9uY2UgZWFzaWVyIHRvIHJlYWQuXG4gICAqL1xuICBjbGFzcyBDb21wb3NhYmxlIGV4dGVuZHMgYmFzZSB7XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBhIHNldCBvZiBtaXhpbiBmdW5jdGlvbnMgb3IgbWl4aW4gb2JqZWN0cyB0byB0aGUgcHJlc2VudCBjbGFzcyBhbmRcbiAgICAgKiByZXR1cm4gdGhlIG5ldyBjbGFzcy5cbiAgICAgKlxuICAgICAqIEluc3RlYWQgb2Ygd3JpdGluZzpcbiAgICAgKlxuICAgICAqICAgICBsZXQgTXlDbGFzcyA9IE1peGluMShNaXhpbjIoTWl4aW4zKE1peGluNChNaXhpbjUoQmFzZUNsYXNzKSkpKSk7XG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHdyaXRlOlxuICAgICAqXG4gICAgICogICAgIGxldCBNeUNsYXNzID0gQ29tcG9zYWJsZU1peGluKEJhc2VDbGFzcykuY29tcG9zZShcbiAgICAgKiAgICAgICBNaXhpbjEsXG4gICAgICogICAgICAgTWl4aW4yLFxuICAgICAqICAgICAgIE1peGluMyxcbiAgICAgKiAgICAgICBNaXhpbjQsXG4gICAgICogICAgICAgTWl4aW41XG4gICAgICogICAgICk7XG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBhbHNvIHRha2UgbWl4aW4gb2JqZWN0cy4gQSBtaXhpbiBvYmplY3QgaXMganVzdCBhXG4gICAgICogc2hvcnRoYW5kIGZvciBhIG1peGluIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBzdWJjbGFzcyB3aXRoIHRoZSBnaXZlblxuICAgICAqIG1lbWJlcnMuIFRoZSBtaXhpbiBvYmplY3QncyBtZW1iZXJzIGFyZSAqbm90KiBjb3BpZWQgZGlyZWN0bHkgb250byB0aGVcbiAgICAgKiBwcm90b3R5cGUgb2YgdGhlIGJhc2UgY2xhc3MsIGFzIHdpdGggdHJhZGl0aW9uYWwgbWl4aW5zLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gcHJvdmlkaW5nIHN5bnRhY3RpYyBzdWdhciwgdGhpcyBtaXhpbiBjYW4gYmUgdXNlZCB0b1xuICAgICAqIGRlZmluZSBhIGNsYXNzIGluIEVTNSwgd2hpY2ggbGFja3MgRVM2J3MgYGNsYXNzYCBrZXl3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi5taXhpbnN9IG1peGlucyAtIEEgc2V0IG9mIG1peGluIGZ1bmN0aW9ucyBvciBvYmplY3RzIHRvIGFwcGx5LlxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wb3NlKC4uLm1peGlucykge1xuICAgICAgLy8gV2UgY3JlYXRlIGEgbmV3IHN1YmNsYXNzIGZvciBlYWNoIG1peGluIGluIHR1cm4uIFRoZSByZXN1bHQgYmVjb21lc1xuICAgICAgLy8gdGhlIGJhc2UgY2xhc3MgZXh0ZW5kZWQgYnkgYW55IHN1YnNlcXVlbnQgbWl4aW5zLiBJdCB0dXJucyBvdXQgdGhhdFxuICAgICAgLy8gd2UgY2FuIHVzZSBBcnJheS5yZWR1Y2UoKSB0byBjb25jaXNlbHkgZXhwcmVzcyB0aGlzLCB1c2luZyB0aGUgY3VycmVudFxuICAgICAgLy8gb2JqZWN0IGFzIHRoZSBzZWVkIGZvciByZWR1Y2UoKS5cbiAgICAgIHJldHVybiBtaXhpbnMucmVkdWNlKGNvbXBvc2VDbGFzcywgdGhpcyk7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQ29tcG9zYWJsZTtcbn07XG5cblxuLy8gUHJvcGVydGllcyBkZWZpbmVkIGJ5IE9iamVjdCB0aGF0IHdlIGRvbid0IHdhbnQgdG8gbWl4aW4uXG5jb25zdCBOT05fTUlYQUJMRV9PQkpFQ1RfUFJPUEVSVElFUyA9IFtcbiAgJ2NvbnN0cnVjdG9yJ1xuXTtcblxuLypcbiAqIEFwcGx5IHRoZSBtaXhpbiB0byB0aGUgZ2l2ZW4gYmFzZSBjbGFzcyB0byByZXR1cm4gYSBuZXcgY2xhc3MuXG4gKiBUaGUgbWl4aW4gY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbW9kaWZpZWQgY2xhc3MsIG9yIGFcbiAqIHBsYWluIG9iamVjdCB3aG9zZSBtZW1iZXJzIHdpbGwgYmUgY29waWVkIHRvIHRoZSBuZXcgY2xhc3MnIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gY29tcG9zZUNsYXNzKGJhc2UsIG1peGluKSB7XG4gIGlmICh0eXBlb2YgbWl4aW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBNaXhpbiBmdW5jdGlvblxuICAgIHJldHVybiBtaXhpbihiYXNlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBNaXhpbiBvYmplY3RcbiAgICBjbGFzcyBTdWJjbGFzcyBleHRlbmRzIGJhc2Uge31cbiAgICBjb3B5T3duUHJvcGVydGllcyhtaXhpbiwgU3ViY2xhc3MucHJvdG90eXBlLCBOT05fTUlYQUJMRV9PQkpFQ1RfUFJPUEVSVElFUyk7XG4gICAgcmV0dXJuIFN1YmNsYXNzO1xuICB9XG59XG5cblxuLypcbiAqIENvcHkgdGhlIGdpdmVuIHByb3BlcnRpZXMvbWV0aG9kcyB0byB0aGUgdGFyZ2V0LlxuICogUmV0dXJuIHRoZSB1cGRhdGVkIHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gY29weU93blByb3BlcnRpZXMoc291cmNlLCB0YXJnZXQsIGlnbm9yZVByb3BlcnR5TmFtZXMgPSBbXSkge1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgaWYgKGlnbm9yZVByb3BlcnR5TmFtZXMuaW5kZXhPZihuYW1lKSA8IDApIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgbmFtZSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuL2NyZWF0ZVN5bWJvbCc7XG5pbXBvcnQgdG9nZ2xlQ2xhc3MgZnJvbSAnLi90b2dnbGVDbGFzcyc7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuL3N5bWJvbHMnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBpdGVtc1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnaXRlbXMnKTtcbmNvbnN0IGl0ZW1Jbml0aWFsaXplZFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnaXRlbUluaXRpYWxpemVkJyk7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBDb250ZW50SXRlbXMuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYXBzIGNvbnRlbnQgc2VtYW50aWNzIChlbGVtZW50cykgdG8gbGlzdCBpdGVtIHNlbWFudGljcy5cbiAgICpcbiAgICogSXRlbXMgZGlmZmVyIGZyb20gZWxlbWVudCBjb250ZW50cyBpbiBzZXZlcmFsIHdheXM6XG4gICAqXG4gICAqICogVGhleSBhcmUgb2Z0ZW4gcmVmZXJlbmNlZCB2aWEgaW5kZXguXG4gICAqICogVGhleSBtYXkgaGF2ZSBhIHNlbGVjdGlvbiBzdGF0ZS5cbiAgICogKiBJdCdzIGNvbW1vbiB0byBkbyB3b3JrIHRvIGluaXRpYWxpemUgdGhlIGFwcGVhcmFuY2Ugb3Igc3RhdGUgb2YgYSBuZXdcbiAgICogICBpdGVtLlxuICAgKiAqIEF1eGlsaWFyeSBpbnZpc2libGUgY2hpbGQgZWxlbWVudHMgYXJlIGZpbHRlcmVkIG91dCBhbmQgbm90IGNvdW50ZWQgYXNcbiAgICogICBpdGVtcy4gQXV4aWxpYXJ5IGVsZW1lbnRzIGluY2x1ZGUgbGluaywgc2NyaXB0LCBzdHlsZSwgYW5kIHRlbXBsYXRlXG4gICAqICAgZWxlbWVudHMuIFRoaXMgZmlsdGVyaW5nIGVuc3VyZXMgdGhhdCB0aG9zZSBhdXhpbGlhcnkgZWxlbWVudHMgY2FuIGJlXG4gICAqICAgdXNlZCBpbiBtYXJrdXAgaW5zaWRlIG9mIGEgbGlzdCB3aXRob3V0IGJlaW5nIHRyZWF0ZWQgYXMgbGlzdCBpdGVtcy5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBleHBlY3RzIGEgY29tcG9uZW50IHRvIHByb3ZpZGUgYSBgY29udGVudGAgcHJvcGVydHkgcmV0dXJuaW5nIGFcbiAgICogcmF3IHNldCBvZiBlbGVtZW50cy4gWW91IGNhbiBwcm92aWRlIHRoYXQgeW91cnNlbGYsIG9yIHVzZVxuICAgKiBbRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbl0oRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbi5tZCkuXG4gICAqXG4gICAqIFRoZSBtb3N0IGNvbW1vbmx5IHJlZmVyZW5jZWQgcHJvcGVydHkgZGVmaW5lZCBieSB0aGlzIG1peGluIGlzIHRoZSBgaXRlbXNgXG4gICAqIHByb3BlcnR5LiBUbyBhdm9pZCBoYXZpbmcgdG8gZG8gd29yayBlYWNoIHRpbWUgdGhhdCBwcm9wZXJ0eSBpcyByZXF1ZXN0ZWQsXG4gICAqIHRoaXMgbWl4aW4gc3VwcG9ydHMgYW4gb3B0aW1pemVkIG1vZGUuIElmIHlvdSBpbnZva2UgdGhlIGBjb250ZW50Q2hhbmdlZGBcbiAgICogbWV0aG9kIHdoZW4gdGhlIHNldCBvZiBpdGVtcyBjaGFuZ2VzLCB0aGUgbWl4aW4gY29uY2x1ZGVzIHRoYXQgeW91J2xsIHRha2VcbiAgICogY2FyZSBvZiBub3RpZnlpbmcgaXQgb2YgZnV0dXJlIGNoYW5nZXMsIGFuZCB0dXJucyBvbiB0aGUgb3B0aW1pemF0aW9uLiBXaXRoXG4gICAqIHRoYXQgb24sIHRoZSBtaXhpbiBzYXZlcyBhIHJlZmVyZW5jZSB0byB0aGUgY29tcHV0ZWQgc2V0IG9mIGl0ZW1zLCBhbmQgd2lsbFxuICAgKiByZXR1cm4gdGhhdCBpbW1lZGlhdGVseSBvbiBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSBgaXRlbXNgIHByb3BlcnR5LiBJZiB5b3VcbiAgICogdXNlIHRoaXMgbWl4aW4gaW4gY29uanVuY3Rpb24gd2l0aFxuICAgKiBbRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbl0oRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbi5tZCksIHRoZVxuICAgKiBgY29udGVudENoYW5nZWRgIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgZm9yIHlvdSB3aGVuIHRoZSBlbGVtZW50J3MgY2hpbGRyZW5cbiAgICogY2hhbmdlLCB0dXJuaW5nIG9uIHRoZSBvcHRpbWl6YXRpb24gYXV0b21hdGljYWxseS5cbiAgICovXG4gIGNsYXNzIENvbnRlbnRJdGVtcyBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29udGVudENoYW5nZWQoKSB7XG4gICAgICBpZiAoc3VwZXIuY29udGVudENoYW5nZWQpIHsgc3VwZXIuY29udGVudENoYW5nZWQoKTsgfVxuXG4gICAgICAvLyBTaW5jZSB3ZSBnb3QgdGhlIGNvbnRlbnRDaGFuZ2VkIGNhbGwsIHdlJ2xsIGFzc3VtZSB3ZSdsbCBiZSBub3RpZmllZCBpZlxuICAgICAgLy8gdGhlIHNldCBvZiBpdGVtcyBjaGFuZ2VzIGxhdGVyLiBXZSB0dXJuIG9uIG1lbW9pemF0aW9uIG9mIHRoZSBpdGVtc1xuICAgICAgLy8gcHJvcGVydHkgYnkgc2V0dGluZyBvdXIgaW50ZXJuYWwgcHJvcGVydHkgdG8gbnVsbCAoaW5zdGVhZCBvZlxuICAgICAgLy8gdW5kZWZpbmVkKS5cbiAgICAgIHRoaXNbaXRlbXNTeW1ib2xdID0gbnVsbDtcblxuICAgICAgdGhpc1tzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW5ldmVyIGEgbmV3IGl0ZW0gaXMgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuIFlvdSBjYW4gb3ZlcnJpZGVcbiAgICAgKiB0aGlzIHRvIHBlcmZvcm0gcGVyLWl0ZW0gaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIC0gVGhlIGl0ZW0gdGhhdCB3YXMgYWRkZWQuXG4gICAgICovXG4gICAgW3N5bWJvbHMuaXRlbUFkZGVkXShpdGVtKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtQWRkZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbUFkZGVkXShpdGVtKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3Rpb24gc3RhdGUgZm9yIGEgc2luZ2xlIGl0ZW0gaGFzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBJbnZva2UgdGhpcyBtZXRob2QgdG8gc2lnbmFsIHRoYXQgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIHRoZSBpbmRpY2F0ZWQgaXRlbVxuICAgICAqIGhhcyBjaGFuZ2VkLiBCeSBkZWZhdWx0LCB0aGlzIGFwcGxpZXMgYSBgc2VsZWN0ZWRgIENTUyBjbGFzcyBpZiB0aGUgaXRlbVxuICAgICAqIGlzIHNlbGVjdGVkLCBhbmQgcmVtb3ZlZCBpdCBpZiBub3Qgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIC0gVGhlIGl0ZW0gd2hvc2Ugc2VsZWN0aW9uIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgLSBUcnVlIGlmIHRoZSBpdGVtIGlzIHNlbGVjdGVkLCBmYWxzZSBpZiBub3QuXG4gICAgICovXG4gICAgW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuaXRlbVNlbGVjdGVkXSkgeyBzdXBlcltzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgc2VsZWN0ZWQpOyB9XG4gICAgICB0b2dnbGVDbGFzcyhpdGVtLCAnc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc2V0IG9mIGl0ZW1zIGluIHRoZSBsaXN0LiBTZWUgdGhlIHRvcC1sZXZlbCBkb2N1bWVudGF0aW9uIGZvclxuICAgICAqIG1peGluIGZvciBhIGRlc2NyaXB0aW9uIG9mIGhvdyBpdGVtcyBkaWZmZXIgZnJvbSBwbGFpbiBjb250ZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XG4gICAgICovXG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgbGV0IGl0ZW1zO1xuICAgICAgaWYgKHRoaXNbaXRlbXNTeW1ib2xdID09IG51bGwpIHtcbiAgICAgICAgaXRlbXMgPSBmaWx0ZXJBdXhpbGlhcnlFbGVtZW50cyh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAvLyBOb3RlOiB0ZXN0IGZvciAqZXF1YWxpdHkqIHdpdGggbnVsbDsgZG9uJ3QgdHJlYXQgdW5kZWZpbmVkIGFzIGEgbWF0Y2guXG4gICAgICAgIGlmICh0aGlzW2l0ZW1zU3ltYm9sXSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIE1lbW9pemUgdGhlIHNldCBvZiBpdGVtcy5cbiAgICAgICAgICB0aGlzW2l0ZW1zU3ltYm9sXSA9IGl0ZW1zO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIG1lbW9pemVkIGl0ZW1zLlxuICAgICAgICBpdGVtcyA9IHRoaXNbaXRlbXNTeW1ib2xdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdW5kZXJseWluZyBjb250ZW50cyBjaGFuZ2UuIEl0IGlzIGFsc29cbiAgICAgKiBpbnZva2VkIG9uIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbiDigJMgc2luY2UgdGhlIGl0ZW1zIGhhdmUgXCJjaGFuZ2VkXCIgZnJvbVxuICAgICAqIGJlaW5nIG5vdGhpbmcuXG4gICAgICovXG4gICAgW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1zQ2hhbmdlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtc0NoYW5nZWRdKCk7IH1cblxuICAgICAgLy8gUGVyZm9ybSBwZXItaXRlbSBpbml0aWFsaXphdGlvbi5cbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodGhpcy5pdGVtcywgaXRlbSA9PiB7XG4gICAgICAgIGlmICghaXRlbVtpdGVtSW5pdGlhbGl6ZWRTeW1ib2xdKSB7XG4gICAgICAgICAgdGhpc1tzeW1ib2xzLml0ZW1BZGRlZF0oaXRlbSk7XG4gICAgICAgICAgaXRlbVtpdGVtSW5pdGlhbGl6ZWRTeW1ib2xdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2l0ZW1zLWNoYW5nZWQnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgaXRlbXMgaW4gdGhlIGxpc3QgY2hhbmdlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvbnRlbnRJdGVtc1xuICAgICAqIEBldmVudCBpdGVtcy1jaGFuZ2VkXG4gICAgICovXG4gIH1cblxuICByZXR1cm4gQ29udGVudEl0ZW1zO1xufTtcblxuXG4vLyBSZXR1cm4gdGhlIGdpdmVuIGVsZW1lbnRzLCBmaWx0ZXJpbmcgb3V0IGF1eGlsaWFyeSBlbGVtZW50cyB0aGF0IGFyZW4ndFxuLy8gdHlwaWNhbGx5IHZpc2libGUuIEl0ZW1zIHdoaWNoIGFyZSBub3QgZWxlbWVudHMgYXJlIHJldHVybmVkIGFzIGlzLlxuZnVuY3Rpb24gZmlsdGVyQXV4aWxpYXJ5RWxlbWVudHMoaXRlbXMpIHtcbiAgY29uc3QgYXV4aWxpYXJ5VGFncyA9IFtcbiAgICAnbGluaycsXG4gICAgJ3NjcmlwdCcsXG4gICAgJ3N0eWxlJyxcbiAgICAndGVtcGxhdGUnXG4gIF07XG4gIHJldHVybiBbXS5maWx0ZXIuY2FsbChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiAhaXRlbS5sb2NhbE5hbWUgfHwgYXV4aWxpYXJ5VGFncy5pbmRleE9mKGl0ZW0ubG9jYWxOYW1lKSA8IDA7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi9zeW1ib2xzJztcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIERpcmVjdGlvblNlbGVjdGlvbi4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIG1hcHMgZGlyZWN0aW9uIHNlbWFudGljcyAoZ29MZWZ0LCBnb1JpZ2h0LCBldGMuKSB0byBzZWxlY3Rpb25cbiAgICogc2VtYW50aWNzIChzZWxlY3RQcmV2aW91cywgc2VsZWN0TmV4dCwgZXRjLikuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aFxuICAgKiBbS2V5Ym9hcmREaXJlY3Rpb25NaXhpbl0oS2V5Ym9hcmREaXJlY3Rpb25NaXhpbi5tZCkgKHdoaWNoIG1hcHMga2V5Ym9hcmRcbiAgICogZXZlbnRzIHRvIGRpcmVjdGlvbnMpIGFuZCBhIG1peGluIHRoYXQgaGFuZGxlcyBzZWxlY3Rpb24gbGlrZVxuICAgKiBbU2luZ2xlU2VsZWN0aW9uTWl4aW5dKFNpbmdsZVNlbGVjdGlvbk1peGluLm1kKS5cbiAgICovXG4gIGNsYXNzIERpcmVjdGlvblNlbGVjdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgW3N5bWJvbHMuZ29Eb3duXSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvRG93bl0pIHsgc3VwZXJbc3ltYm9scy5nb0Rvd25dKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdE5leHQoKTtcbiAgICB9XG5cbiAgICBbc3ltYm9scy5nb0VuZF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0VuZF0pIHsgc3VwZXJbc3ltYm9scy5nb0VuZF0oKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0TGFzdCgpO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLmdvTGVmdF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0xlZnRdKSB7IHN1cGVyW3N5bWJvbHMuZ29MZWZ0XSgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RQcmV2aW91cygpO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLmdvUmlnaHRdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuZ29SaWdodF0pIHsgc3VwZXJbc3ltYm9scy5nb1JpZ2h0XSgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3ROZXh0KCk7XG4gICAgfVxuXG4gICAgW3N5bWJvbHMuZ29TdGFydF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb1N0YXJ0XSkgeyBzdXBlcltzeW1ib2xzLmdvU3RhcnRdKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdEZpcnN0KCk7XG4gICAgfVxuXG4gICAgW3N5bWJvbHMuZ29VcF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb1VwXSkgeyBzdXBlcltzeW1ib2xzLmdvVXBdKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbi4gVGhpcyB3aWxsIHR5cGljYWxseSBiZSBoYW5kbGVkIGJ5IG90aGVyIG1peGlucy5cbiAgICBnZXQgc2VsZWN0ZWRGcmFjdGlvbigpIHtcbiAgICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEZyYWN0aW9uO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWRGcmFjdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCdzZWxlY3RlZEZyYWN0aW9uJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3RlZEZyYWN0aW9uID0gdmFsdWU7IH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uLiBUaGlzIHdpbGwgdHlwaWNhbGx5IGJlIGhhbmRsZWQgYnkgb3RoZXIgbWl4aW5zLlxuICAgIHNlbGVjdEZpcnN0KCkge1xuICAgICAgaWYgKHN1cGVyLnNlbGVjdEZpcnN0KSB7IHJldHVybiBzdXBlci5zZWxlY3RGaXJzdCgpOyB9XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbi4gVGhpcyB3aWxsIHR5cGljYWxseSBiZSBoYW5kbGVkIGJ5IG90aGVyIG1peGlucy5cbiAgICBzZWxlY3RMYXN0KCkge1xuICAgICAgaWYgKHN1cGVyLnNlbGVjdExhc3QpIHsgcmV0dXJuIHN1cGVyLnNlbGVjdExhc3QoKTsgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24uIFRoaXMgd2lsbCB0eXBpY2FsbHkgYmUgaGFuZGxlZCBieSBvdGhlciBtaXhpbnMuXG4gICAgc2VsZWN0TmV4dCgpIHtcbiAgICAgIGlmIChzdXBlci5zZWxlY3ROZXh0KSB7IHJldHVybiBzdXBlci5zZWxlY3ROZXh0KCk7IH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uLiBUaGlzIHdpbGwgdHlwaWNhbGx5IGJlIGhhbmRsZWQgYnkgb3RoZXIgbWl4aW5zLlxuICAgIHNlbGVjdFByZXZpb3VzKCkge1xuICAgICAgaWYgKHN1cGVyLnNlbGVjdFByZXZpb3VzKSB7IHJldHVybiBzdXBlci5zZWxlY3RQcmV2aW91cygpOyB9XG4gICAgfVxuXG4gICAgLy8gTWFwIGRyYWcgdHJhdmVsIGZyYWN0aW9uIHRvIHNlbGVjdGlvbiBmcmFjdGlvbi5cbiAgICBnZXQgdHJhdmVsRnJhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3VwZXIudHJhdmVsRnJhY3Rpb247XG4gICAgfVxuICAgIHNldCB0cmF2ZWxGcmFjdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCd0cmF2ZWxGcmFjdGlvbicgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIudHJhdmVsRnJhY3Rpb24gPSB2YWx1ZTsgfVxuICAgICAgdGhpcy5zZWxlY3RlZEZyYWN0aW9uID0gdmFsdWU7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gRGlyZWN0aW9uU2VsZWN0aW9uO1xufTtcbiIsImltcG9ydCBtaWNyb3Rhc2sgZnJvbSAnLi9taWNyb3Rhc2snO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnQuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBkZWZpbmVzIGEgY29tcG9uZW50J3MgY29udGVudCBhcyBpdHMgY2hpbGRyZW4sIGV4cGFuZGluZyBhbnlcbiAgICogbm9kZXMgZGlzdHJpYnV0ZWQgdG8gdGhlIGNvbXBvbmVudCdzIHNsb3RzLlxuICAgKlxuICAgKiBUaGlzIGFsc28gcHJvdmlkZXMgbm90aWZpY2F0aW9uIG9mIGNoYW5nZXMgdG8gYSBjb21wb25lbnQncyBjb250ZW50LiBJdFxuICAgKiB3aWxsIGludm9rZSBhIGBjb250ZW50Q2hhbmdlZGAgbWV0aG9kIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBmaXJzdFxuICAgKiBpbnN0YW50aWF0ZWQsIGFuZCB3aGVuZXZlciBpdHMgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gY2hhbmdlLiBUaGlzIGlzIGFuXG4gICAqIGVhc3kgd2F5IHRvIHNhdGlzZnkgdGhlIEdvbGQgU3RhbmRhcmQgY2hlY2tsaXN0IGl0ZW0gZm9yIG1vbml0b3JpbmdcbiAgICogW0NvbnRlbnQgQ2hhbmdlc10oaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvZ29sZC1zdGFuZGFyZC93aWtpL0NvbnRlbnQtQ2hhbmdlcykuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYFxuICAgKiBsZXQgYmFzZSA9IERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4oRGlzdHJpYnV0ZWRDaGlsZHJlbk1peGluKEhUTUxFbGVtZW50KSk7XG4gICAqIGNsYXNzIENvdW50aW5nRWxlbWVudCBleHRlbmRzIGJhc2Uge1xuICAgKlxuICAgKiAgIGNvbnN0cnVjdG9yKCkge1xuICAgKiAgICAgc3VwZXIoKTtcbiAgICogICAgIGxldCByb290ID0gdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAqICAgICByb290LmlubmVySFRNTCA9IGA8c2xvdD48L3Nsb3Q+YDtcbiAgICogICB9XG4gICAqXG4gICAqICAgY29udGVudENoYW5nZWQoKSB7XG4gICAqICAgICAvLyBDb3VudCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4sIGJvdGggaW5pdGlhbGx5IGFuZCB3aGVuIGNoYW5nZWQuXG4gICAqICAgICB0aGlzLmNvdW50ID0gdGhpcy5kaXN0cmlidXRlZENoaWxkcmVuLmxlbmd0aDtcbiAgICogICB9XG4gICAqXG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIE5vdGUgdGhhdCBjb250ZW50IGNoYW5nZSBkZXRlY3Rpb24gZGVwZW5kcyB1cG9uIHRoZSBlbGVtZW50IGhhdmluZyBhdCBsZWFzdFxuICAgKiBvbmUgYHNsb3RgIGVsZW1lbnQgaW4gaXRzIHNoYWRvdyBzdWJ0cmVlLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGlzIGludGVuZGVkIGZvciB1c2Ugd2l0aCB0aGVcbiAgICogW0Rpc3RyaWJ1dGVkQ2hpbGRyZW5NaXhpbl0oRGlzdHJpYnV0ZWRDaGlsZHJlbk1peGluLm1kKS4gU2VlIHRoYXQgbWl4aW4gZm9yXG4gICAqIGEgZGlzY3Vzc2lvbiBvZiBob3cgdGhhdCB3b3Jrcy4gVGhpcyBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluXG4gICAqIHByb3ZpZGVzIGFuIGVhc3kgd2F5IG9mIGRlZmluaW5nIHRoZSBcImNvbnRlbnRcIiBvZiBhIGNvbXBvbmVudCBhcyB0aGVcbiAgICogY29tcG9uZW50J3MgZGlzdHJpYnV0ZWQgY2hpbGRyZW4uIFRoYXQgaW4gdHVybiBsZXRzIG1peGlucyBsaWtlXG4gICAqIFtDb250ZW50SXRlbXNNaXhpbl0oQ29udGVudEl0ZW1zTWl4aW4ubWQpIG1hbmlwdWxhdGUgdGhlIGNoaWxkcmVuIGFzIGxpc3RcbiAgICogaXRlbXMuXG4gICAqL1xuICBjbGFzcyBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudCBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICBpZiAodGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIC8vIExpc3RlbiB0byBjaGFuZ2VzIG9uIGFsbCBzbG90cy5cbiAgICAgICAgY29uc3Qgc2xvdHMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnc2xvdCcpO1xuICAgICAgICBzbG90cy5mb3JFYWNoKHNsb3QgPT4gc2xvdC5hZGRFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgZXZlbnQgPT4ge1xuICAgICAgICAgIHRoaXMuY29udGVudENoYW5nZWQoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIGFuIGluaXRpYWwgY2FsbCB0byBjb250ZW50Q2hhbmdlZCgpIHNvIHRoYXQgdGhlIGNvbXBvbmVudCBjYW4gZG9cbiAgICAgIC8vIGluaXRpYWxpemF0aW9uIHRoYXQgaXQgbm9ybWFsbHkgZG9lcyB3aGVuIGNvbnRlbnQgY2hhbmdlcy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIHdpbGwgaW52b2tlIGNvbnRlbnRDaGFuZ2VkKCkgaGFuZGxlcnMgaW4gb3RoZXIgbWl4aW5zLiBJbiBvcmRlclxuICAgICAgLy8gdGhhdCB0aG9zZSBtaXhpbnMgaGF2ZSBhIGNoYW5jZSB0byBjb21wbGV0ZSB0aGVpciBvd24gaW5pdGlhbGl6YXRpb24sXG4gICAgICAvLyB3ZSBhZGQgdGhlIGNvbnRlbnRDaGFuZ2VkKCkgY2FsbCB0byB0aGUgbWljcm90YXNrIHF1ZXVlLlxuICAgICAgbWljcm90YXNrKCgpID0+IHRoaXMuY29udGVudENoYW5nZWQoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb250ZW50cyBvZiB0aGUgY29tcG9uZW50IChpbmNsdWRpbmcgZGlzdHJpYnV0ZWRcbiAgICAgKiBjaGlsZHJlbikgaGF2ZSBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgYWxzbyBpbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgZmlyc3QgaW5zdGFudGlhdGVkOyB0aGVcbiAgICAgKiBjb250ZW50cyBoYXZlIGVzc2VudGlhbGx5IFwiY2hhbmdlZFwiIGZyb20gYmVpbmcgbm90aGluZy4gVGhpcyBhbGxvd3MgdGhlXG4gICAgICogY29tcG9uZW50IHRvIHBlcmZvcm0gaW5pdGlhbCBwcm9jZXNzaW5nIG9mIGl0cyBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBjb250ZW50Q2hhbmdlZCgpIHtcbiAgICAgIGlmIChzdXBlci5jb250ZW50Q2hhbmdlZCkgeyBzdXBlci5jb250ZW50Q2hhbmdlZCgpOyB9XG4gICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY29udGVudC1jaGFuZ2VkJyk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IG9mIHRoaXMgY29tcG9uZW50LCBkZWZpbmVkIHRvIGJlIHRoZSBmbGF0dGVuZWQgYXJyYXkgb2ZcbiAgICAgKiBjaGlsZHJlbiBkaXN0cmlidXRlZCB0byB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XG4gICAgICovXG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICBjb25zdCBkaXN0cmlidXRlZENoaWxkcmVuID0gdGhpcy5kaXN0cmlidXRlZENoaWxkcmVuO1xuICAgICAgaWYgKHR5cGVvZiBkaXN0cmlidXRlZENoaWxkcmVuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLndhcm4oYERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4gZXhwZWN0cyB0aGUgY29tcG9uZW50IHRvIGRlZmluZSBhIFwiZGlzdHJpYnV0ZWRDaGlsZHJlblwiIHByb3BlcnR5LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpc3RyaWJ1dGVkQ2hpbGRyZW47XG4gICAgfVxuICAgIHNldCBjb250ZW50KHZhbHVlKSB7XG4gICAgICBpZiAoJ2NvbnRlbnQnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLmNvbnRlbnQgPSB2YWx1ZTsgfVxuICAgICAgLy8gVE9ETzogU2V0IHRoZSBjaGlsZHJlbiB0byB0aGUgZ2l2ZW4gdmFsdWUgKHdoaWNoIHNob3VsZCBiZSBhbiBhcnJheSBvZlxuICAgICAgLy8gZWxlbWVudHMpP1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgcmFpc2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIGNvbnRlbnRzIChpbmNsdWRpbmcgZGlzdHJpYnV0ZWRcbiAgICAgKiBjaGlsZHJlbikgaGF2ZSBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50XG4gICAgICogQGV2ZW50IGNvbnRlbnQtY2hhbmdlZFxuICAgICAqL1xuICB9XG5cbiAgcmV0dXJuIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50O1xufTtcbiIsIi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggRGlzdHJpYnV0ZWRDaGlsZHJlbi4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIGRlZmluZXMgaGVscGVycyBmb3IgYWNjZXNzaW5nIGEgY29tcG9uZW50J3MgZGlzdHJpYnV0ZWRcbiAgICogY2hpbGRyZW4gYXMgYSBmbGF0dGVuZWQgYXJyYXkgb3Igc3RyaW5nLlxuICAgKlxuICAgKiBUaGUgc3RhbmRhcmQgRE9NIEFQSSBwcm92aWRlcyBzZXZlcmFsIHdheXMgb2YgYWNjZXNzaW5nIGNoaWxkIGNvbnRlbnQ6XG4gICAqIGBjaGlsZHJlbmAsIGBjaGlsZE5vZGVzYCwgYW5kIGB0ZXh0Q29udGVudGAuIE5vbmUgb2YgdGhlc2UgZnVuY3Rpb25zIGFyZVxuICAgKiBTaGFkb3cgRE9NIGF3YXJlLiBUaGlzIG1peGluIGRlZmluZXMgdmFyaWF0aW9ucyBvZiB0aG9zZSBmdW5jdGlvbnMgdGhhdFxuICAgKiAqYXJlKiBTaGFkb3cgRE9NIGF3YXJlLlxuICAgKlxuICAgKiBFeGFtcGxlOiB5b3UgY3JlYXRlIGEgY29tcG9uZW50IGA8Y291bnQtY2hpbGRyZW4+YCB0aGF0IGRpc3BsYXlzIGEgbnVtYmVyXG4gICAqIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gcGxhY2VkIGluc2lkZSB0aGF0IGNvbXBvbmVudC4gSWYgc29tZW9uZVxuICAgKiBpbnN0YW50aWF0ZXMgeW91ciBjb21wb25lbnQgbGlrZTpcbiAgICpcbiAgICogICAgIDxjb3VudC1jaGlsZHJlbj5cbiAgICogICAgICAgPGRpdj48L2Rpdj5cbiAgICogICAgICAgPGRpdj48L2Rpdj5cbiAgICogICAgICAgPGRpdj48L2Rpdj5cbiAgICogICAgIDwvY291bnQtY2hpbGRyZW4+XG4gICAqXG4gICAqIFRoZW4gdGhlIGNvbXBvbmVudCBzaG91bGQgc2hvdyBcIjNcIiwgYmVjYXVzZSB0aGVyZSBhcmUgdGhyZWUgY2hpbGRyZW4uIFRvXG4gICAqIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuLCB0aGUgY29tcG9uZW50IGNhbiBqdXN0IGNhbGN1bGF0ZVxuICAgKiBgdGhpcy5jaGlsZHJlbi5sZW5ndGhgLiBIb3dldmVyLCBzdXBwb3NlIHNvbWVvbmUgaW5zdGFudGlhdGVzIHlvdXJcbiAgICogY29tcG9uZW50IGluc2lkZSBvbmUgb2YgdGhlaXIgb3duIGNvbXBvbmVudHMsIGFuZCBwdXRzIGEgYDxzbG90PmAgZWxlbWVudFxuICAgKiBpbnNpZGUgeW91ciBjb21wb25lbnQ6XG4gICAqXG4gICAqICAgICA8Y291bnQtY2hpbGRyZW4+XG4gICAqICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICogICAgIDwvY291bnQtY2hpbGRyZW4+XG4gICAqXG4gICAqIElmIHlvdXIgY29tcG9uZW50IG9ubHkgbG9va3MgYXQgYHRoaXMuY2hpbGRyZW5gLCBpdCB3aWxsIGFsd2F5cyBzZWUgZXhhY3RseVxuICAgKiBvbmUgY2hpbGQg4oCUwqB0aGUgYDxzbG90PmAgZWxlbWVudC4gQnV0IHRoZSB1c2VyIGxvb2tpbmcgYXQgdGhlIHBhZ2Ugd2lsbFxuICAgKiAqc2VlKiBhbnkgbm9kZXMgZGlzdHJpYnV0ZWQgdG8gdGhhdCBzbG90LiBUbyBtYXRjaCB3aGF0IHRoZSB1c2VyIHNlZXMsIHlvdXJcbiAgICogY29tcG9uZW50IHNob3VsZCBleHBhbmQgYW55IGA8c2xvdD5gIGVsZW1lbnRzIGl0IGNvbnRhaW5zLlxuICAgKlxuICAgKiBUaGF0IGlzIHRoZSBwcm9ibGVtIHRoaXMgbWl4aW4gc29sdmVzLiBBZnRlciBhcHBseWluZyB0aGlzIG1peGluLCB5b3VyXG4gICAqIGNvbXBvbmVudCBjb2RlIGhhcyBhY2Nlc3MgdG8gYHRoaXMuZGlzdHJpYnV0ZWRDaGlsZHJlbmAsIHdob3NlIGBsZW5ndGhgXG4gICAqIHdpbGwgcmV0dXJuIHRoZSB0b3RhbCBudW1iZXIgb2YgYWxsIGNoaWxkcmVuIGRpc3RyaWJ1dGVkIHRvIHlvdXIgY29tcG9uZW50XG4gICAqIGluIHRoZSBjb21wb3NlZCB0cmVlLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgbGF0ZXN0IEN1c3RvbSBFbGVtZW50cyBBUEkgZGVzaWduIGNhbGxzIGZvciBhIG5ldyBmdW5jdGlvbixcbiAgICogYGdldEFzc2lnbmVkTm9kZXNgIHRoYXQgdGFrZXMgYW4gb3B0aW9uYWwgYGRlZXBgIHBhcmFtZXRlciwgdGhhdCB3aWxsIHNvbHZlXG4gICAqIHRoaXMgcHJvYmxlbSBhdCB0aGUgQVBJIGxldmVsLlxuICAgKi9cbiAgY2xhc3MgRGlzdHJpYnV0ZWRDaGlsZHJlbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgLyoqXG4gICAgICogQW4gaW4tb3JkZXIgY29sbGVjdGlvbiBvZiBkaXN0cmlidXRlZCBjaGlsZHJlbiwgZXhwYW5kaW5nIGFueSBzbG90XG4gICAgICogZWxlbWVudHMuIExpa2UgdGhlIHN0YW5kYXJkIGNoaWxkcmVuIHByb3BlcnR5LCB0aGlzIHNraXBzIHRleHQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX1cbiAgICAgKi9cbiAgICBnZXQgZGlzdHJpYnV0ZWRDaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBleHBhbmRDb250ZW50RWxlbWVudHModGhpcy5jaGlsZHJlbiwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGluLW9yZGVyIGNvbGxlY3Rpb24gb2YgZGlzdHJpYnV0ZWQgY2hpbGQgbm9kZXMsIGV4cGFuZGluZyBhbnkgc2xvdFxuICAgICAqIGVsZW1lbnRzLiBMaWtlIHRoZSBzdGFuZGFyZCBjaGlsZE5vZGVzIHByb3BlcnR5LCB0aGlzIGluY2x1ZGVzIHRleHRcbiAgICAgKiBub2Rlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOb2RlW119XG4gICAgICovXG4gICAgZ2V0IGRpc3RyaWJ1dGVkQ2hpbGROb2RlcygpIHtcbiAgICAgIHJldHVybiBleHBhbmRDb250ZW50RWxlbWVudHModGhpcy5jaGlsZE5vZGVzLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uY2F0ZW5hdGVkIHRleHQgY29udGVudCBvZiBhbGwgZGlzdHJpYnV0ZWQgY2hpbGQgbm9kZXMsIGV4cGFuZGluZ1xuICAgICAqIGFueSBzbG90IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgZGlzdHJpYnV0ZWRUZXh0Q29udGVudCgpIHtcbiAgICAgIGNvbnN0IHN0cmluZ3MgPSB0aGlzLmRpc3RyaWJ1dGVkQ2hpbGROb2Rlcy5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLnRleHRDb250ZW50O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3RyaW5ncy5qb2luKCcnKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBEaXN0cmlidXRlZENoaWxkcmVuO1xufTtcblxuXG4vKlxuICogR2l2ZW4gYSBhcnJheSBvZiBub2RlcywgcmV0dXJuIGEgbmV3IGFycmF5IHdpdGggYW55IGNvbnRlbnQgZWxlbWVudHMgZXhwYW5kZWRcbiAqIHRvIHRoZSBub2RlcyBkaXN0cmlidXRlZCB0byB0aGF0IGNvbnRlbnQgZWxlbWVudC4gVGhpcyBydWxlIGlzIGFwcGxpZWRcbiAqIHJlY3Vyc2l2ZWx5LlxuICpcbiAqIElmIGluY2x1ZGVUZXh0Tm9kZXMgaXMgdHJ1ZSwgdGV4dCBub2RlcyB3aWxsIGJlIGluY2x1ZGVkLCBhcyBpbiB0aGVcbiAqIHN0YW5kYXJkIGNoaWxkTm9kZXMgcHJvcGVydHk7IGJ5IGRlZmF1bHQsIHRoaXMgc2tpcHMgdGV4dCBub2RlcywgbGlrZSB0aGVcbiAqIHN0YW5kYXJkIGNoaWxkcmVuIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBleHBhbmRDb250ZW50RWxlbWVudHMobm9kZXMsIGluY2x1ZGVUZXh0Tm9kZXMpIHtcbiAgY29uc3QgZXhwYW5kZWQgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwobm9kZXMsIG5vZGUgPT4ge1xuICAgIC8vIFdlIHdhbnQgdG8gc2VlIGlmIHRoZSBub2RlIGlzIGFuIGluc3RhbmNlb2YgSFRNTFNsb3RFTGVtZW50LCBidXRcbiAgICAvLyB0aGF0IGNsYXNzIHdvbid0IGV4aXN0IGlmIHRoZSBicm93c2VyIHRoYXQgZG9lc24ndCBzdXBwb3J0IG5hdGl2ZVxuICAgIC8vIFNoYWRvdyBET00gYW5kIGlmIHRoZSBTaGFkb3cgRE9NIHBvbHlmaWxsIGhhc24ndCBiZWVuIGxvYWRlZC4gSW5zdGVhZCxcbiAgICAvLyB3ZSBkbyBhIHNpbXBsaXN0aWMgY2hlY2sgdG8gc2VlIGlmIHRoZSB0YWcgbmFtZSBpcyBcInNsb3RcIi5cbiAgICBjb25zdCBpc1Nsb3QgPSB0eXBlb2YgSFRNTFNsb3RFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICBub2RlIGluc3RhbmNlb2YgSFRNTFNsb3RFbGVtZW50IDpcbiAgICAgIG5vZGUubG9jYWxOYW1lID09PSAnc2xvdCc7XG4gICAgaWYgKGlzU2xvdCkge1xuICAgICAgLy8gVXNlIHRoZSBub2RlcyBhc3NpZ25lZCB0byB0aGlzIG5vZGUgaW5zdGVhZC5cbiAgICAgIGNvbnN0IGFzc2lnbmVkTm9kZXMgPSBub2RlLmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuIGFzc2lnbmVkTm9kZXMgP1xuICAgICAgICBleHBhbmRDb250ZW50RWxlbWVudHMoYXNzaWduZWROb2RlcywgaW5jbHVkZVRleHROb2RlcykgOlxuICAgICAgICBbXTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgLy8gUGxhaW4gZWxlbWVudDsgdXNlIGFzIGlzLlxuICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBUZXh0ICYmIGluY2x1ZGVUZXh0Tm9kZXMpIHtcbiAgICAgIC8vIFRleHQgbm9kZS5cbiAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbW1lbnQsIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24sIGV0Yy47IHNraXAuXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZmxhdHRlbmVkID0gW10uY29uY2F0KC4uLmV4cGFuZGVkKTtcbiAgcmV0dXJuIGZsYXR0ZW5lZDtcbn1cbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi9jcmVhdGVTeW1ib2wnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBzZWxlY3RlZEZyYWN0aW9uU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdzZWxlY3RlZEZyYWN0aW9uJyk7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBGcmFjdGlvbmFsU2VsZWN0aW9uLiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWl4aW4oYmFzZSkge1xuXG4gIC8qKlxuICAgKiBBZGRzIHN1cHBvcnQgZm9yIGZyYWN0aW9uYWwgc2VsZWN0aW9uOiB0cmVhdGluZyBhIHNlbGVjdGlvbiBhcyBhIHJlYWxcbiAgICogbnVtYmVyIHRoYXQgY29tYmluZXMgYW4gaW50ZWdlciBwb3J0aW9uIChhbiBpbmRleCBpbnRvIGEgbGlzdCksIGFuZCBhXG4gICAqIGZyYWN0aW9uIChpbmRpY2F0aW5nIGhvdyBmYXIgb2YgdGhlIHdheSB3ZSBhcmUgdG8gdGhlIG5leHQgb3IgcHJldmlvdXNcbiAgICogaXRlbSkuXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIGluIGNvbXBvbmVudHMgdGhhdCBzdXBwb3J0IGluY3JlbWVudGFsIG9wZXJhdGlvbnMgZHVyaW5nXG4gICAqIGRyYWdnaW5nIGFuZCBzd2lwaW5nLiBFeGFtcGxlOiBhIGNhcm91c2VsIGNvbXBvbmVudCBoYXMgc2V2ZXJhbCBpdGVtcywgYW5kIHRoZVxuICAgKiBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSBpcyBpdGVtIDMuIFRoZSB1c2VyIGJlZ2lucyBzd2lwaW5nIHRvIHRoZSBsZWZ0LFxuICAgKiBtb3ZpbmcgdG93YXJkcyBzZWxlY3RpbmcgaXRlbSA0LiBIYWxmd2F5IHRocm91Z2ggdGhpcyBvcGVyYXRpb24sIHRoZVxuICAgKiBmcmFjdGlvbmFsIHNlbGVjdGlvbiB2YWx1ZSBpcyAzLjUuXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgcGVybWl0cyBjb21tdW5pY2F0aW9uIGJldHdlZW4gbWl4aW5zIGxpa2VcbiAgICogW1N3aXBlRGlyZWN0aW9uTWl4aW5dKC4vU3dpcGVEaXJlY3Rpb25NaXhpbi5tZCkgYW5kXG4gICAqIFtUcmFja3BhZERpcmVjdGlvbk1peGluXSguL1RyYWNrcGFkRGlyZWN0aW9uTWl4aW4ubWQpLCB3aGljaCBnZW5lcmF0ZVxuICAgKiBmcmFjdGlvbmFsIHNlbGVjdGlvbiB2YWx1ZXMsIGFuZCBtaXhpbnMgbGlrZVxuICAgKiBbU2VsZWN0aW9uQW5pbWF0aW9uTWl4aW5dKC4vU2VsZWN0aW9uQW5pbWF0aW9uTWl4aW4ubWQpLCB3aGljaCBjYW4gcmVuZGVyXG4gICAqIHNlbGVjdGlvbiBhdCBhIGZyYWN0aW9uYWwgdmFsdWUuXG4gICAqL1xuICBjbGFzcyBGcmFjdGlvbmFsU2VsZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgICB0aGlzLnNlbGVjdGVkRnJhY3Rpb24gPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZnJhY3Rpb25hbCB2YWx1ZSBpbmRpY2F0aW5nIGhvdyBmYXIgdGhlIHVzZXIgaGFzIGN1cnJlbnRseSBhZHZhbmNlZCB0b1xuICAgICAqIHRoZSBuZXh0L3ByZXZpb3VzIGl0ZW0uIEUuZy4sIGEgYHNlbGVjdGVkRnJhY3Rpb25gIG9mIDMuNSBpbmRpY2F0ZXMgdGhlXG4gICAgICogdXNlciBpcyBoYWxmd2F5IGJldHdlZW4gaXRlbXMgMyBhbmQgNC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkRnJhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpc1tzZWxlY3RlZEZyYWN0aW9uU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkRnJhY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXNbc2VsZWN0ZWRGcmFjdGlvblN5bWJvbF0gPSB2YWx1ZTtcbiAgICAgIGlmICgnc2VsZWN0ZWRGcmFjdGlvbicgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRGcmFjdGlvbiA9IHZhbHVlOyB9XG4gICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc2VsZWN0ZWQtZnJhY3Rpb24tY2hhbmdlZCcpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBGcmFjdGlvbmFsU2VsZWN0aW9uO1xufVxuXG5cbm1peGluLmhlbHBlcnMgPSB7XG5cbiAgLypcbiAgICogRGFtcGVuIGEgc2VsZWN0aW9uIHRoYXQgZ29lcyBwYXN0IHRoZSBiZWdpbm5pbmcgb3IgZW5kIG9mIGEgbGlzdC4gVGhpcyBpc1xuICAgKiBnZW5lcmFsbHkgdXNlZCB0byBwcm9kdWNlIGEgdmlzdWFsIGVmZmVjdCBvZiB0ZW5zaW9uIGFzIHRoZSB1c2VyIHRyaWVzIHRvXG4gICAqIGdvIGZ1cnRoZXIgaW4gYSBkaXJlY3Rpb24gdGhhdCBoYXMgbm8gbW9yZSBpdGVtcy5cbiAgICpcbiAgICogRXhhbXBsZTogc3VwcG9zZSBgaXRlbUNvdW50YCBpcyA1LCBpbmRpY2F0aW5nIGEgbGlzdCBvZiA1IGl0ZW1zLiBUaGUgaW5kZXggb2ZcbiAgICogdGhlIGxhc3QgaXRlbSBpcyA0LiBJZiB0aGUgYHNlbGVjdGlvbmAgcGFyYW1ldGVyIGlzIDQuNSwgdGhlIHVzZXIgaXMgdHJ5aW5nXG4gICAqIHRvIGdvIHBhc3QgdGhpcyBsYXN0IGl0ZW0uIFdoZW4gYSBkYW1waW5nIGZ1bmN0aW9uIGlzIGFwcGxpZWQsIHRoZSByZXN1bHRpbmdcbiAgICogdmFsdWUgd2lsbCBiZSBsZXNzIHRoYW4gNC41ICh0aGUgYWN0dWFsIHZhbHVlIHdpbGwgYmUgNC4yNSkuIFdoZW4gdGhpc1xuICAgKiBzZWxlY3Rpb24gc3RhdGUgaXMgcmVuZGVyZWQsIHRoZSB1c2VyIHdpbGwgc2VlIHRoYXQsIGVhY2ggdW5pdCBkaXN0YW5jZSB0aGVcbiAgICogZHJhZyB0cmF2ZWxzIGhhcyBsZXNzIGFuZCBsZXNzIHZpc2libGUgZWZmZWN0LiBUaGlzIGlzIHBlcmNlaXZlZCBhcyB0ZW5zaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2VsZWN0aW9uIC0gQSByZWFsIG51bWJlciBpbmRpY2F0aW5nIGEgc2VsZWN0aW9uIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtQ291bnQgLSBBbiBpbnRlZ2VyIGZvciB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEEgcmVhbCBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBkYW1wZWQgc2VsZWN0aW9uIHZhbHVlLlxuICAgKi9cbiAgZGFtcGVkU2VsZWN0aW9uKHNlbGVjdGlvbiwgaXRlbUNvdW50KSB7XG4gICAgY29uc3QgYm91bmQgPSBpdGVtQ291bnQgLSAxO1xuICAgIGxldCBkYW1wZWQ7XG4gICAgaWYgKHNlbGVjdGlvbiA8IDApIHtcbiAgICAgIC8vIFRyeWluZyB0byBnbyBwYXN0IGJlZ2lubmluZyBvZiBsaXN0LiBBcHBseSB0ZW5zaW9uIGZyb20gdGhlIGxlZnQgZWRnZS5cbiAgICAgIGRhbXBlZCA9IC1taXhpbi5oZWxwZXJzLmRhbXBpbmcoLXNlbGVjdGlvbik7XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rpb24gPj0gYm91bmQpIHtcbiAgICAgIC8vIFRyeWluZyB0byBnbyBwYXN0IGVuZCBvZiBsaXN0LiBBcHBseSB0ZW5zaW9uIGZyb20gdGhlIHJpZ2h0IGVkZ2UuXG4gICAgICBkYW1wZWQgPSBib3VuZCArIG1peGluLmhlbHBlcnMuZGFtcGluZyhzZWxlY3Rpb24gLSBib3VuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGRhbXBpbmcgcmVxdWlyZWQuXG4gICAgICBkYW1wZWQgPSBzZWxlY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBkYW1wZWQ7XG4gIH0sXG5cbiAgLypcbiAgICogQ2FsY3VsYXRlIGRhbXBpbmcgYXMgYSBmdW5jdGlvbiBvZiB0aGUgZGlzdGFuY2UgcGFzdCB0aGUgbWluaW11bS9tYXhpbXVtXG4gICAqIHZhbHVlcy5cbiAgICpcbiAgICogV2Ugd2FudCB0byBhc3ltcHRvdGljYWxseSBhcHByb2FjaCBhbiBhYnNvbHV0ZSBtaW5pbXVtIG9mIDEgdW5pdFxuICAgKiBiZWxvdy9hYm92ZSB0aGUgYWN0dWFsIG1pbmltdW0vbWF4aW11bS4gVGhpcyByZXF1aXJlcyBjYWxjdWxhdGluZyBhXG4gICAqIGh5cGVyYm9saWMgZnVuY3Rpb24uXG4gICAqXG4gICAqIFNlZSBodHRwOi8vd3d3LndvbGZyYW1hbHBoYS5jb20vaW5wdXQvP2k9eSslM0QrLTElMkYlMjh4JTJCMSUyOSslMkIrMVxuICAgKiBmb3IgdGhlIG9uZSB3ZSB1c2UuIFRoZSBvbmx5IHBvcnRpb24gb2YgdGhhdCBmdW5jdGlvbiB3ZSBjYXJlIGFib3V0IGlzIHdoZW5cbiAgICogeCBpcyB6ZXJvIG9yIGdyZWF0ZXIuIEFuIGltcG9ydGFudCBjb25zaWRlcmF0aW9uIGlzIHRoYXQgdGhlIGN1cnZlIGJlXG4gICAqIHRhbmdlbnQgdG8gdGhlIGRpYWdvbmFsIGxpbmUgeD15IGF0ICgwLCAwKS4gVGhpcyBlbnN1cmVzIHNtb290aCBjb250aW51aXR5XG4gICAqIHdpdGggdGhlIG5vcm1hbCBkcmFnIGJlaGF2aW9yLCBpbiB3aGljaCB0aGUgdmlzaWJsZSBzbGlkaW5nIGlzIGxpbmVhciB3aXRoXG4gICAqIHRoZSBkaXN0YW5jZSB0aGUgdG91Y2hwb2ludCBoYXMgYmVlbiBkcmFnZ2VkLlxuICAgKi9cbiAgZGFtcGluZyh4KSB7XG4gICAgY29uc3QgeSA9ICgtMSAvICh4ICsgMSkpICsgMTtcbiAgICByZXR1cm4geTtcbiAgfSxcblxuICAvKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgZnJhY3Rpb25hbCBzZWxlY3Rpb24gdmFsdWUgZm9yIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBUaGlzIHNpbXBseSBhZGRzIHRoZSBlbGVtZW50J3MgYHNlbGVjdGVkSW5kZXhgIGFuZCBgc2VsZWN0ZWRGcmFjdGlvbmBcbiAgICogcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEFuIGVsZW1lbnQgdGhhdCBzdXBwb3J0cyBzZWxlY3Rpb25cbiAgICovXG4gIGVsZW1lbnRTZWxlY3Rpb24oZWxlbWVudCkge1xuICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBlbGVtZW50LnNlbGVjdGVkSW5kZXg7XG4gICAgaWYgKHNlbGVjdGVkSW5kZXggPCAwKSB7XG4gICAgICAvLyBObyBzZWxlY3Rpb25cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRGcmFjdGlvbiA9IGVsZW1lbnQuc2VsZWN0ZWRGcmFjdGlvbiB8fCAwO1xuICAgIHJldHVybiBzZWxlY3RlZEluZGV4ICsgc2VsZWN0ZWRGcmFjdGlvbjtcbiAgfSxcblxuICAvKlxuICAgKiBCcmVha3MgYSBmcmFjdGlvbmFsIHNlbGVjdGlvbiBpbnRvIGl0cyBpbnRlZ2VyIGFuZCBmcmFjdGlvbmFsIHBhcnRzLlxuICAgKlxuICAgKiBFeGFtcGxlOiBpZiBwYXNzZWQgMy41LCB0aGlzIHJldHVybnMgeyBpbmRleDogMywgZnJhY3Rpb246IDUgfS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlbGVjdGlvbiDigJPCoEEgcmVhbCBudW1iZXIgcmVwcmVzZW50aW5nIGEgc2VsZWN0aW9uIHBvaW50XG4gICAqIEByZXR1cm5zIHtvYmplY3R9IC0gQW4gb2JqZWN0IHdpdGggYW4gYGluZGV4YCBwcm9wZXJ0eSBob2xkaW5nIHRoZVxuICAgKiBzZWxlY3Rpb24ncyBpbnRlZ2VyIGNvbXBvbmVudCwgYW5kIGEgYGZyYWN0aW9uYCBwcm9wZXJ0eSBob2xkaW5nIHRoZVxuICAgKiBzZWxlY3Rpb24ncyBmcmFjdGlvbmFsIGNvbXBvbmVudC5cbiAgICovXG4gIHNlbGVjdGlvblBhcnRzKHNlbGVjdGlvbikge1xuICAgIC8vIFN0dXBpZCBJRSBkb2Vzbid0IGhhdmUgTWF0aC50cnVuYy5cbiAgICAvLyBjb25zdCBpbmRleCA9IE1hdGgudHJ1bmMoc2VsZWN0aW9uKTtcbiAgICBjb25zdCBpbmRleCA9IHNlbGVjdGlvbiA8IDAgPyBNYXRoLmNlaWwoc2VsZWN0aW9uKSA6IE1hdGguZmxvb3Ioc2VsZWN0aW9uKTtcbiAgICBjb25zdCBmcmFjdGlvbiA9IHNlbGVjdGlvbiAtIGluZGV4O1xuICAgIHJldHVybiB7IGluZGV4LCBmcmFjdGlvbiB9O1xuICB9LFxuXG4gIC8qXG4gICAqIFJldHVybnMgYSBmcmFjdGlvbmFsIHNlbGVjdGlvbiBwb2ludCBhZnRlciBhY2NvdW50aW5nIGZvciB3cmFwcGluZywgZW5zdXJpbmdcbiAgICogdGhhdCB0aGUgaW50ZWdlciBwb3J0aW9uIG9mIHRoZSBzZWxlY3Rpb24gc3RheXMgYmV0d2VlbiAwIGFuZCBgaXRlbUNvdW50YC0xLlxuICAgKiBUaGF0IGlzLCB0aGUgaW50ZWdlciBwb3J0aW9uIHdpbGwgYWx3YXlzIGJlIGEgdmFsaWQgaW5kZXggaW50byB0aGUgbGlzdC5cbiAgICpcbiAgICogRXhhbXBsZSBvZiB3cmFwcGluZyBwYXN0IHRoZSBlbmQgb2YgdGhlIGxpc3Q6IGlmIGBzZWxlY3Rpb25gIGlzIDUuNSBhbmRcbiAgICogYGl0ZW1Db3VudGAgaXMgNSwgdGhpcyByZXR1cm5zIDAuNS4gRXhhbXBsZSBvZiB3cmFwcGluZyBwYXN0IHRoZSBiZWdpbm5pbmcgb2ZcbiAgICogdGhlIGxpc3Q6IGlmIGBzZWxlY3Rpb25gIGlzIDAuNSBhbmQgYGl0ZW1Db3VudGAgaXMgNSwgdGhpcyByZXR1cm5zIDQuNS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlbGVjdGlvbiAtIEEgcmVhbCBudW1iZXIgcmVwcmVzZW50aW5nIGEgc2VsZWN0aW9uIHBvaW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtQ291bnQgLSBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIHJlc3VsdCBvZiB3cmFwcGluZyB0aGUgc2VsZWN0aW9uIHBvaW50XG4gICAqL1xuICB3cmFwcGVkU2VsZWN0aW9uKHNlbGVjdGlvbiwgaXRlbUNvdW50KSB7XG4gICAgLy8gSGFuZGxlcyBwb3NzaWJpbGl0eSBvZiBuZWdhdGl2ZSBtb2QuXG4gICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE4NjE4MjUwLzc2NDcyXG4gICAgcmV0dXJuICgoc2VsZWN0aW9uICUgaXRlbUNvdW50KSArIGl0ZW1Db3VudCkgJSBpdGVtQ291bnQ7XG4gIH0sXG5cbiAgLypcbiAgICogUmV0dXJuIHRoZSBwYXJ0cyBvZiBhIHNlbGVjdGlvbiwgZmlyc3Qgd3JhcHBpbmcgaWYgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2VsZWN0aW9uIOKAkyBBIHJlYWwgbnVtYmVyIHJlcHJlc2VudGluZyBhIHNlbGVjdGlvbiBwb2ludFxuICAgKiBAcGFyYW0ge251bWJlcn0gaXRlbUNvdW50IC0gVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdyYXAg4oCTIFRydWUgaWYgdGhlIHNlbGVjdGlvbiBzaG91bGQgd3JhcCB0byBzdGF5IHdpdGhpbiB0aGVcbiAgICogbGlzdFxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSDigJMgVGhlIHBhcnRzIG9mIHRoZSBzZWxlY3Rpb24sIHVzaW5nIHRoZSBzYW1lIGZvcm1hdCBhc1xuICAgKiBgc2VsZWN0aW9uUGFydHNgLlxuICAgKi9cbiAgd3JhcHBlZFNlbGVjdGlvblBhcnRzKHNlbGVjdGlvbiwgaXRlbUNvdW50LCB3cmFwKSB7XG4gICAgaWYgKHdyYXApIHtcbiAgICAgIHNlbGVjdGlvbiA9IG1peGluLmhlbHBlcnMud3JhcHBlZFNlbGVjdGlvbihzZWxlY3Rpb24sIGl0ZW1Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiBtaXhpbi5oZWxwZXJzLnNlbGVjdGlvblBhcnRzKHNlbGVjdGlvbik7XG4gIH1cblxufTtcbiIsImltcG9ydCBEaXJlY3Rpb25TZWxlY3Rpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9EaXJlY3Rpb25TZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgS2V5Ym9hcmREaXJlY3Rpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9LZXlib2FyZERpcmVjdGlvbk1peGluJztcbmltcG9ydCBLZXlib2FyZE1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0tleWJvYXJkTWl4aW4nO1xuaW1wb3J0IFN3aXBlRGlyZWN0aW9uTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU3dpcGVEaXJlY3Rpb25NaXhpbic7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zeW1ib2xzJztcbmltcG9ydCBUcmFja3BhZERpcmVjdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1RyYWNrcGFkRGlyZWN0aW9uTWl4aW4nO1xuXG5cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgY29uc3QgbWl4aW5zID0gW1xuICAgIERpcmVjdGlvblNlbGVjdGlvbk1peGluLFxuICAgIEtleWJvYXJkTWl4aW4sXG4gICAgS2V5Ym9hcmREaXJlY3Rpb25NaXhpbixcbiAgICBTd2lwZURpcmVjdGlvbk1peGluLFxuICAgIFRyYWNrcGFkRGlyZWN0aW9uTWl4aW5cbiAgXTtcblxuICAvLyBEb24ndCBhc3N1bWUgYmFzZSBjbGFzcyB1c2VzIENvbXBvc2FibGVNaXhpbi4gRG8gY29tcG9zaXRpb24gYnkgaGFuZC5cbiAgY29uc3QgYmFzZVdpdGhNaXhpbnMgPSBtaXhpbnMucmVkdWNlKChjLCBtaXhpbikgPT4gbWl4aW4oYyksIGJhc2UpO1xuXG4gIC8qKlxuICAgKiBAbWl4ZXMgS2V5Ym9hcmRNaXhpblxuICAgKiBAbWl4ZXMgS2V5Ym9hcmREaXJlY3Rpb25NaXhpblxuICAgKiBAbWl4ZXMgU3dpcGVEaXJlY3Rpb25NaXhpblxuICAgKiBAbWl4ZXMgVHJhY2twYWREaXJlY3Rpb25NaXhpblxuICAgKi9cbiAgY2xhc3MgSG9yaXpvbnRhbE5hdmlnYXRpb24gZXh0ZW5kcyBiYXNlV2l0aE1peGlucyB7XG5cbiAgICBnZXQgW3N5bWJvbHMuZGVmYXVsdHNdKCkge1xuICAgICAgY29uc3QgZGVmYXVsdHMgPSBzdXBlcltzeW1ib2xzLmRlZmF1bHRzXSB8fCB7fTtcbiAgICAgIGRlZmF1bHRzLm5hdmlnYXRpb25BeGlzID0gJ2hvcml6b250YWwnO1xuICAgICAgZGVmYXVsdHMuc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0ID0gJ3NsaWRlV2l0aEdhcCc7XG4gICAgICAvLyBkZWZhdWx0cy5zZWxlY3Rpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gSG9yaXpvbnRhbE5hdmlnYXRpb247XG5cbn07XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IG5hdmlnYXRpb25BeGlzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCduYXZpZ2F0aW9uQXhpcycpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggS2V5Ym9hcmREaXJlY3Rpb24uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYXBzIGRpcmVjdGlvbiBrZXlzIChMZWZ0LCBSaWdodCwgZXRjLikgdG8gZGlyZWN0aW9uIHNlbWFudGljc1xuICAgKiAoZ28gbGVmdCwgZ28gcmlnaHQsIGV0Yy4pLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGV4cGVjdHMgdGhlIGNvbXBvbmVudCB0byBpbnZva2UgYSBga2V5ZG93bmAgbWV0aG9kIHdoZW4gYSBrZXkgaXNcbiAgICogcHJlc3NlZC4gWW91IGNhbiB1c2UgW0tleWJvYXJkTWl4aW5dKEtleWJvYXJkTWl4aW4ubWQpIGZvciB0aGF0XG4gICAqIHB1cnBvc2UsIG9yIHdpcmUgdXAgeW91ciBvd24ga2V5Ym9hcmQgaGFuZGxpbmcgYW5kIGNhbGwgYGtleWRvd25gIHlvdXJzZWxmLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGNhbGxzIG1ldGhvZHMgc3VjaCBhcyBgZ29MZWZ0YCBhbmQgYGdvUmlnaHRgLiBZb3UgY2FuIGRlZmluZVxuICAgKiB3aGF0IHRoYXQgbWVhbnMgYnkgaW1wbGVtZW50aW5nIHRob3NlIG1ldGhvZHMgeW91cnNlbGYuIElmIHlvdSB3YW50IHRvIHVzZVxuICAgKiBkaXJlY3Rpb24ga2V5cyB0byBuYXZpZ2F0ZSBhIHNlbGVjdGlvbiwgdXNlIHRoaXMgbWl4aW4gd2l0aFxuICAgKiBbRGlyZWN0aW9uU2VsZWN0aW9uTWl4aW5dKERpcmVjdGlvblNlbGVjdGlvbk1peGluLm1kKS5cbiAgICovXG4gIGNsYXNzIEtleWJvYXJkRGlyZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICAvLyBTZXQgZGVmYXVsdHMuXG4gICAgICBpZiAodHlwZW9mIHRoaXMubmF2aWdhdGlvbkF4aXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkF4aXMgPSB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLm5hdmlnYXRpb25BeGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMubmF2aWdhdGlvbkF4aXMgPSAnYm90aCc7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIGRvd24uXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgICAqL1xuICAgIFtzeW1ib2xzLmdvRG93bl0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0Rvd25dKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvRG93bl0oKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSB0byB0aGUgZW5kIChlLmcuLCBvZiBhIGxpc3QpLlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBbc3ltYm9scy5nb0VuZF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0VuZF0pIHsgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZ29FbmRdKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgbGVmdC5cbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICovXG4gICAgW3N5bWJvbHMuZ29MZWZ0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvTGVmdF0pIHsgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZ29MZWZ0XSgpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIHJpZ2h0LlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBbc3ltYm9scy5nb1JpZ2h0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvUmlnaHRdKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvUmlnaHRdKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgdG8gdGhlIHN0YXJ0IChlLmcuLCBvZiBhXG4gICAgICogbGlzdCkuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBbc3ltYm9scy5nb1N0YXJ0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvU3RhcnRdKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvU3RhcnRdKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgdXAuXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgICAqL1xuICAgIFtzeW1ib2xzLmdvVXBdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuZ29VcF0pIHsgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZ29VcF0oKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgZGlyZWN0aW9uIG9mIHBlcm1pdHRlZCBuYXZpZ2F0aW9uIHdpdGggdGhlIGtleWJvYXJkLlxuICAgICAqXG4gICAgICogQWNjZXB0ZWQgdmFsdWVzIGFyZSBcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiLCBvciBcImJvdGhcIiAodGhlIGRlZmF1bHQpLlxuICAgICAqIElmIHRoaXMgcHJvcGVydHkgaXMgXCJob3Jpem9udGFsXCIsIHRoZSBVcCBBcnJvdyBhbmQgRG93biBBcnJvdyBrZXlzIHdpbGxcbiAgICAgKiBiZSBpZ25vcmVkLiBDb252ZXJzZWx5LCBpZiB0aGlzIGlzIFwidmVydGljYWxcIiwgdGhlIExlZnQgQXJyb3cgYW5kIFJpZ2h0XG4gICAgICogQXJyb3cga2V5cyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBuYXZpZ2F0aW9uQXhpcygpIHtcbiAgICAgIHJldHVybiB0aGlzW25hdmlnYXRpb25BeGlzU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IG5hdmlnYXRpb25BeGlzKHZhbHVlKSB7XG4gICAgICB0aGlzW25hdmlnYXRpb25BeGlzU3ltYm9sXSA9IHZhbHVlO1xuICAgICAgaWYgKCduYXZpZ2F0aW9uQXhpcycgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIubmF2aWdhdGlvbkF4aXMgPSB2YWx1ZTsgfVxuICAgIH1cblxuICAgIFtzeW1ib2xzLmtleWRvd25dKGV2ZW50KSB7XG4gICAgICBsZXQgaGFuZGxlZDtcblxuICAgICAgY29uc3QgYXhpcyA9IHRoaXMubmF2aWdhdGlvbkF4aXM7XG4gICAgICBjb25zdCBob3Jpem9udGFsID0gKGF4aXMgPT09ICdob3Jpem9udGFsJyB8fCBheGlzID09PSAnYm90aCcpO1xuICAgICAgY29uc3QgdmVydGljYWwgPSAoYXhpcyA9PT0gJ3ZlcnRpY2FsJyB8fCBheGlzID09PSAnYm90aCcpO1xuXG4gICAgICAvLyBJZ25vcmUgTGVmdC9SaWdodCBrZXlzIHdoZW4gbWV0YUtleSBvciBhbHRLZXkgbW9kaWZpZXIgaXMgYWxzbyBwcmVzc2VkLFxuICAgICAgLy8gYXMgdGhlIHVzZXIgbWF5IGJlIHRyeWluZyB0byBuYXZpZ2F0ZSBiYWNrIG9yIGZvcndhcmQgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAzNTogLy8gRW5kXG4gICAgICAgICAgaGFuZGxlZCA9IHRoaXNbc3ltYm9scy5nb0VuZF0oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNjogLy8gSG9tZVxuICAgICAgICAgIGhhbmRsZWQgPSB0aGlzW3N5bWJvbHMuZ29TdGFydF0oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNzogLy8gTGVmdFxuICAgICAgICAgIGlmIChob3Jpem9udGFsICYmICFldmVudC5tZXRhS2V5ICYmICFldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0aGlzW3N5bWJvbHMuZ29MZWZ0XSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzODogLy8gVXBcbiAgICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSBldmVudC5hbHRLZXkgPyB0aGlzW3N5bWJvbHMuZ29TdGFydF0oKSA6IHRoaXNbc3ltYm9scy5nb1VwXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOTogLy8gUmlnaHRcbiAgICAgICAgICBpZiAoaG9yaXpvbnRhbCAmJiAhZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdGhpc1tzeW1ib2xzLmdvUmlnaHRdKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOiAvLyBEb3duXG4gICAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gZXZlbnQuYWx0S2V5ID8gdGhpc1tzeW1ib2xzLmdvRW5kXSgpIDogdGhpc1tzeW1ib2xzLmdvRG93bl0oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBQcmVmZXIgbWl4aW4gcmVzdWx0IGlmIGl0J3MgZGVmaW5lZCwgb3RoZXJ3aXNlIHVzZSBiYXNlIHJlc3VsdC5cbiAgICAgIHJldHVybiBoYW5kbGVkIHx8IChzdXBlcltzeW1ib2xzLmtleWRvd25dICYmIHN1cGVyW3N5bWJvbHMua2V5ZG93bl0oZXZlbnQpKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBLZXlib2FyZERpcmVjdGlvbjtcbn07XG4iLCJpbXBvcnQgc3ltYm9scyBmcm9tICcuL3N5bWJvbHMnO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggS2V5Ym9hcmQuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYW5hZ2VzIHRoZSBrZXlkb3duIGhhbmRsaW5nIGZvciBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBoYW5kbGVzIHNldmVyYWwga2V5Ym9hcmQtcmVsYXRlZCBmZWF0dXJlcy5cbiAgICpcbiAgICogRmlyc3QsIGl0IHdpcmVzIHVwIGEgc2luZ2xlIGtleWRvd24gZXZlbnQgaGFuZGxlciB0aGF0IGNhbiBiZSBzaGFyZWQgYnlcbiAgICogbXVsdGlwbGUgbWl4aW5zIG9uIGEgY29tcG9uZW50LiBUaGUgZXZlbnQgaGFuZGxlciB3aWxsIGludm9rZSBhIGBrZXlkb3duYFxuICAgKiBtZXRob2Qgd2l0aCB0aGUgZXZlbnQgb2JqZWN0LCBhbmQgYW55IG1peGluIGFsb25nIHRoZSBwcm90b3R5cGUgY2hhaW4gdGhhdFxuICAgKiB3YW50cyB0byBoYW5kbGUgdGhhdCBtZXRob2QgY2FuIGRvIHNvLlxuICAgKlxuICAgKiBJZiBhIG1peGluIHdhbnRzIHRvIGluZGljYXRlIHRoYXQga2V5Ym9hcmQgZXZlbnQgaGFzIGJlZW4gaGFuZGxlZCwgYW5kIHRoYXRcbiAgICogb3RoZXIgbWl4aW5zIHNob3VsZCAqbm90KiBoYW5kbGUgaXQsIHRoZSBtaXhpbidzIGBrZXlkb3duYCBoYW5kbGVyIHNob3VsZFxuICAgKiByZXR1cm4gYSB2YWx1ZSBvZiB0cnVlLiBUaGUgY29udmVudGlvbiB0aGF0IHNlZW1zIHRvIHdvcmsgd2VsbCBpcyB0aGF0IGFcbiAgICogbWl4aW4gc2hvdWxkIHNlZSBpZiBpdCB3YW50cyB0byBoYW5kbGUgdGhlIGV2ZW50IGFuZCwgaWYgbm90LCB0aGVuIGFzayB0aGVcbiAgICogc3VwZXJjbGFzcyB0byBzZWUgaWYgaXQgd2FudHMgdG8gaGFuZGxlIHRoZSBldmVudC4gVGhpcyBoYXMgdGhlIGVmZmVjdCBvZlxuICAgKiBnaXZpbmcgdGhlIG1peGluIHRoYXQgd2FzIGFwcGxpZWQgbGFzdCB0aGUgZmlyc3QgY2hhbmNlIGF0IGhhbmRsaW5nIGFcbiAgICoga2V5Ym9hcmQgZXZlbnQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBbc3ltYm9scy5rZXlkb3duXShldmVudCkge1xuICAgKiAgICAgICBsZXQgaGFuZGxlZDtcbiAgICogICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAqICAgICAgICAgLy8gSGFuZGxlIHRoZSBrZXlzIHlvdSB3YW50LCBzZXR0aW5nIGhhbmRsZWQgPSB0cnVlIGlmIGFwcHJvcHJpYXRlLlxuICAgKiAgICAgICB9XG4gICAqICAgICAgIC8vIFByZWZlciBtaXhpbiByZXN1bHQgaWYgaXQncyBkZWZpbmVkLCBvdGhlcndpc2UgdXNlIGJhc2UgcmVzdWx0LlxuICAgKiAgICAgICByZXR1cm4gaGFuZGxlZCB8fCAoc3VwZXJbc3ltYm9scy5rZXlkb3duXSAmJiBzdXBlcltzeW1ib2xzLmtleWRvd25dKGV2ZW50KSk7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEEgc2Vjb25kIGZlYXR1cmUgcHJvdmlkZWQgYnkgdGhpcyBtaXhpbiBpcyB0aGF0IGl0IGltcGxpY2l0bHkgbWFrZXMgdGhlXG4gICAqIGNvbXBvbmVudCBhIHRhYiBzdG9wIGlmIGl0IGlzbid0IGFscmVhZHksIGJ5IHNldHRpbmcgYHRhYkluZGV4YCB0byAwLiBUaGlzXG4gICAqIGhhcyB0aGUgZWZmZWN0IG9mIGFkZGluZyB0aGUgY29tcG9uZW50IHRvIHRoZSB0YWIgb3JkZXIgaW4gZG9jdW1lbnQgb3JkZXIuXG4gICAqL1xuICBjbGFzcyBLZXlib2FyZCBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVkID0gdGhpc1tzeW1ib2xzLmtleWRvd25dKGV2ZW50KTtcbiAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgPT0gbnVsbCAmJiB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnRhYmluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRoaXNbc3ltYm9scy5kZWZhdWx0c10udGFiaW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgLy8gVGhlIGRlZmF1bHQgdGFiIGluZGV4IGlzIDAgKGRvY3VtZW50IG9yZGVyKS5cbiAgICAgIGRlZmF1bHRzLnRhYmluZGV4ID0gMDtcbiAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGluZGljYXRlZCBrZXlib2FyZCBldmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy4gVGhpcyB3aWxsXG4gICAgICogdHlwaWNhbGx5IGJlIGhhbmRsZWQgYnkgb3RoZXIgbWl4aW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIHRoZSBrZXlib2FyZCBldmVudFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGV2ZW50IHdhcyBoYW5kbGVkXG4gICAgICovXG4gICAgW3N5bWJvbHMua2V5ZG93bl0oZXZlbnQpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmtleWRvd25dKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmtleWRvd25dKGV2ZW50KTsgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEtleWJvYXJkO1xufTtcbiIsImltcG9ydCByZW5kZXJBcnJheUFzRWxlbWVudHMgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvcmVuZGVyQXJyYXlBc0VsZW1lbnRzJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3N5bWJvbHMnO1xuaW1wb3J0IHRvZ2dsZUNsYXNzIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3RvZ2dsZUNsYXNzJztcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIFBhZ2VEb3RzLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogVGVtcGxhdGUgbWl4aW4gd2hpY2ggYWRkcyBzbWFsbCBkb3RzIHRvIHNob3cgdGhlIG51bWJlciBvZiBpdGVtcyBhbmQgbGV0XG4gICAqIHRoZSB1c2VyIHNlbGVjdCBhIHNwZWNpZmljIGl0ZW0uXG4gICAqXG4gICAqIFlvdSBjYW4gc2VlIGFcbiAgICogW2xpdmUgZGVtb10oaHR0cDovL2Jhc2ljd2ViY29tcG9uZW50cy5vcmcvYmFzaWMtd2ViLWNvbXBvbmVudHMvcGFja2FnZXMvZGVtb3MvY2Fyb3VzZWwtd2l0aC1kb3RzLmh0bWwpXG4gICAqIG9mIHRoaXMgbWl4aW4gYXBwbGllZCB0byBhIGNhcm91c2VsLlxuICAgKlxuICAgKiBUaGVyZSB3aWxsIGJlIG9uZSBkb3QgZm9yIGVhY2ggaXRlbSwgYW5kIHRoZSBkb3QgZm9yIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICogaXRlbSB3aWxsIGJlIHNob3duIHNlbGVjdGVkLlxuICAgKlxuICAgKiBUeXBpY2FsIHVzYWdlOlxuICAgKlxuICAgKiAgICAgY2xhc3MgQ2Fyb3VzZWxXaXRoRG90cyBleHRlbmRzIFBhZ2VEb3RzTWl4aW4oQ2Fyb3VzZWwpIHt9XG4gICAqICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ2Nhcm91c2VsLXdpdGgtZG90cycsIENhcm91c2VsV2l0aERvdHMpO1xuICAgKlxuICAgKiBBbHRob3VnaCB0aGUgZG90cyBhcmUgcXVpdGUgc21hbGwgYnkgZGVmYXVsdCwgY2xpY2tpbmcvdGFwcGluZyBhIGRvdCB3aWxsXG4gICAqIHdpbGwgc2VsZWN0IHRoZSBjb3JyZXNwb25kaW5nIGxpc3QgaXRlbS5cbiAgICovXG4gIGNsYXNzIFBhZ2VEb3RzIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG5cbiAgICAgIHRoaXMuJC5kb3RzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBkb3QgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGRvdEluZGV4ID0gdGhpcy5kb3RzLmluZGV4T2YoZG90KTtcbiAgICAgICAgaWYgKGRvdEluZGV4ID49IDApIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBkb3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0IGRvdHMoKSB7XG4gICAgICByZXR1cm4gW10uc2xpY2UuY2FsbCh0aGlzLiQuZG90cy5xdWVyeVNlbGVjdG9yQWxsKCcuZG90JykpO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtc0NoYW5nZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpOyB9XG4gICAgICByZW5kZXJBcnJheUFzRWxlbWVudHModGhpcy5pdGVtcywgdGhpcy4kLmRvdHMsIChpdGVtLCBlbGVtZW50KSA9PiB7XG4gICAgICAgIC8vIFdlIGRvbid0IHVzZSB0aGUgaXRlbSBwYXJhbWV0ZXIsIGJlY2F1c2UgYW55IGl0ZW0gd2lsbCBwcm9kdWNlIGFuXG4gICAgICAgIC8vIGlkZW50aWNhbCBjb3JyZXNwb25kaW5nIGRvdC5cbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZG90Jyk7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzdHlsZS1zY29wZScpO1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYmFzaWMtcGFnZS1kb3RzJyk7XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbm9uZScpO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlZnJlc2hEb3RzKHRoaXMpO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgc2VsZWN0ZWQpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1TZWxlY3RlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIHNlbGVjdGVkKTsgfVxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAvLyBTZWUgaWYgdGhlIGNvcnJlc3BvbmRpbmcgZG90IGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZC5cbiAgICAgIC8vIElmIG5vdCwgdGhlIGNvcnJlY3QgZG90IHdpbGwgYmUgc2VsZWN0ZWQgd2hlbiBpdCBnZXRzIGNyZWF0ZWQuXG4gICAgICBjb25zdCBkb3RzID0gdGhpcy5kb3RzO1xuICAgICAgaWYgKGRvdHMgJiYgZG90cy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgICBjb25zdCBkb3QgPSB0aGlzLmRvdHNbaW5kZXhdO1xuICAgICAgICBpZiAoZG90KSB7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZG90LCAnc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGlzdGFuY2UgdGhlIHVzZXIgaGFzIG1vdmVkIHRoZSBmaXJzdCB0b3VjaHBvaW50IHNpbmNlIHRoZSBiZWdpbm5pbmdcbiAgICAgKiBvZiBhIGRyYWcsIGV4cHJlc3NlZCBhcyBhIGZyYWN0aW9uIG9mIHRoZSBlbGVtZW50J3Mgd2lkdGguXG4gICAgICpcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWRGcmFjdGlvbigpIHtcbiAgICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEZyYWN0aW9uO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWRGcmFjdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCdzZWxlY3RlZEZyYWN0aW9uJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3RlZEZyYWN0aW9uID0gdmFsdWU7IH1cbiAgICAgIHJlbmRlclRyYW5zaXRpb24odGhpcywgdGhpcy5zZWxlY3RlZEluZGV4LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IHNlbGVjdGVkSW5kZXgoKSB7XG4gICAgICByZXR1cm4gc3VwZXIuc2VsZWN0ZWRJbmRleDtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICAgIGlmICgnc2VsZWN0ZWRJbmRleCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRJbmRleCA9IGluZGV4OyB9XG4gICAgICByZWZyZXNoRG90cyh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgW3N5bWJvbHMudGVtcGxhdGVdKCkge1xuICAgICAgY29uc3QgYmFzZVRlbXBsYXRlID0gc3VwZXJbc3ltYm9scy50ZW1wbGF0ZV0gfHwgJyc7XG4gICAgICByZXR1cm4gYFxuICAgICAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cblxuICAgICAgICAjZG90cyB7XG4gICAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIHotaW5kZXg6IDE7XG4gICAgICAgIH1cblxuICAgICAgICAjZG90TmF2aWdhdGlvbkNvbnRhaW5lciB7XG4gICAgICAgICAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgLXdlYmtpdC1mbGV4OiAxO1xuICAgICAgICAgIGZsZXg6IDE7XG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgIHotaW5kZXg6IDA7XG4gICAgICAgIH1cblxuICAgICAgICAjY29udGFpbmVyIDo6c2xvdHRlZCgqKSB7XG4gICAgICAgICAgLXdlYmtpdC1mbGV4OiAxO1xuICAgICAgICAgIGZsZXg6IDE7XG4gICAgICAgIH1cblxuICAgICAgICAuZG90IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2IoMjU1LCAyNTUsIDI1NSk7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogN3B4O1xuICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAxcHggMXB4IHJnYmEoMCwgMCwgMCwgMC41KTtcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICBoZWlnaHQ6IDhweDtcbiAgICAgICAgICBtYXJnaW46IDdweCA1cHg7XG4gICAgICAgICAgb3BhY2l0eTogMC40O1xuICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAwLjJzIGJveC1zaGFkb3cgMC4ycztcbiAgICAgICAgICB3aWR0aDogOHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgLmRvdDpob3ZlciB7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMXB4IDNweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XG4gICAgICAgIH1cblxuICAgICAgICAuZG90LnNlbGVjdGVkIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLjk1O1xuICAgICAgICB9XG5cbiAgICAgICAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XG4gICAgICAgICAgLmRvdCB7XG4gICAgICAgICAgICBoZWlnaHQ6IDEycHg7XG4gICAgICAgICAgICB3aWR0aDogMTJweDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgPC9zdHlsZT5cblxuICAgICAgICA8ZGl2IGlkPVwiZG90c1wiIHJvbGU9XCJub25lXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9XCJkb3ROYXZpZ2F0aW9uQ29udGFpbmVyXCIgcm9sZT1cIm5vbmVcIj5cbiAgICAgICAgICAke2Jhc2VUZW1wbGF0ZX1cbiAgICAgICAgPC9kaXY+XG4gICAgICBgO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFBhZ2VEb3RzO1xufTtcblxuXG4vLyBSZXR1cm4gdGhlIGluZGV4LCBlbnN1cmluZyBpdCBzdGF5cyBiZXR3ZWVuIDAgYW5kIHRoZSBnaXZlbiBsZW5ndGguXG5mdW5jdGlvbiBrZWVwSW5kZXhXaXRoaW5Cb3VuZHMobGVuZ3RoLCBpbmRleCkge1xuICAvLyBIYW5kbGUgcG9zc2liaWxpdHkgb2YgbmVnYXRpdmUgbW9kLlxuICAvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTg2MTgyNTAvNzY0NzJcbiAgcmV0dXJuICgoaW5kZXggJSBsZW5ndGgpICsgbGVuZ3RoKSAlIGxlbmd0aDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVHJhbnNpdGlvbihlbGVtZW50LCBzZWxlY3RlZEluZGV4LCBzZWxlY3RlZEZyYWN0aW9uKSB7XG4gIGNvbnN0IGRvdHMgPSBlbGVtZW50LmRvdHM7XG4gIGlmICghZG90cyB8fCBkb3RzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkb3RDb3VudCA9IGRvdHMubGVuZ3RoO1xuICBjb25zdCBvcGFjaXR5TWluaW11bSA9IDAuNDtcbiAgY29uc3Qgb3BhY2l0eU1heGltdW0gPSAwLjk1O1xuICBjb25zdCBvcGFjaXR5UmFuZ2UgPSBvcGFjaXR5TWF4aW11bSAtIG9wYWNpdHlNaW5pbXVtO1xuICBjb25zdCBmcmFjdGlvbmFsSW5kZXggPSBzZWxlY3RlZEluZGV4ICsgc2VsZWN0ZWRGcmFjdGlvbjtcbiAgY29uc3QgbGVmdEluZGV4ID0gTWF0aC5mbG9vcihmcmFjdGlvbmFsSW5kZXgpO1xuICBjb25zdCByaWdodEluZGV4ID0gTWF0aC5jZWlsKGZyYWN0aW9uYWxJbmRleCk7XG4gIGNvbnN0IHNlbGVjdGlvbldyYXBzID0gZWxlbWVudC5zZWxlY3Rpb25XcmFwcztcbiAgbGV0IGF3YXlJbmRleCA9IHNlbGVjdGVkRnJhY3Rpb24gPj0gMCA/IGxlZnRJbmRleCA6IHJpZ2h0SW5kZXg7XG4gIGxldCB0b3dhcmRJbmRleCA9IHNlbGVjdGVkRnJhY3Rpb24gPj0gMCA/IHJpZ2h0SW5kZXggOiBsZWZ0SW5kZXg7XG4gIGlmIChzZWxlY3Rpb25XcmFwcykge1xuICAgIGF3YXlJbmRleCA9IGtlZXBJbmRleFdpdGhpbkJvdW5kcyhkb3RDb3VudCwgYXdheUluZGV4KTtcbiAgICB0b3dhcmRJbmRleCA9IGtlZXBJbmRleFdpdGhpbkJvdW5kcyhkb3RDb3VudCwgdG93YXJkSW5kZXgpO1xuICB9XG4gIC8vIFN0dXBpZCBJRSBkb2Vzbid0IGhhdmUgTWF0aC50cnVuYy5cbiAgLy8gY29uc3QgdHJ1bmNhdGVkU2VsZWN0ZWRGcmFjdGlvbiA9IE1hdGgudHJ1bmMoc2VsZWN0ZWRGcmFjdGlvbik7XG4gIGNvbnN0IHRydW5jYXRlZFNlbGVjdGVkRnJhY3Rpb24gPSBzZWxlY3RlZEZyYWN0aW9uIDwgMCA/IE1hdGguY2VpbChzZWxlY3RlZEZyYWN0aW9uKSA6IE1hdGguZmxvb3Ioc2VsZWN0ZWRGcmFjdGlvbik7XG4gIGNvbnN0IHByb2dyZXNzID0gc2VsZWN0ZWRGcmFjdGlvbiAtIHRydW5jYXRlZFNlbGVjdGVkRnJhY3Rpb247XG4gIGNvbnN0IG9wYWNpdHlQcm9ncmVzc1Rocm91Z2hSYW5nZSA9IE1hdGguYWJzKHByb2dyZXNzKSAqIG9wYWNpdHlSYW5nZTtcbiAgZG90cy5mb3JFYWNoKChkb3QsIGluZGV4KSA9PiB7XG4gICAgbGV0IGRvdE9wYWNpdHk7XG4gICAgaWYgKHNlbGVjdGVkRnJhY3Rpb24gPT09IDApIHtcbiAgICAgIC8vIFJlbW92ZSBleHBsaWNpdCBvcGFjaXR5IGFuZCByZWx5IG9uIHN0eWxpbmcuXG4gICAgICBkb3RPcGFjaXR5ID0gJyc7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gYXdheUluZGV4KSB7XG4gICAgICBkb3RPcGFjaXR5ID0gb3BhY2l0eU1heGltdW0gLSBvcGFjaXR5UHJvZ3Jlc3NUaHJvdWdoUmFuZ2U7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gdG93YXJkSW5kZXgpIHtcbiAgICAgIGRvdE9wYWNpdHkgPSBvcGFjaXR5TWluaW11bSArIG9wYWNpdHlQcm9ncmVzc1Rocm91Z2hSYW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG90T3BhY2l0eSA9IG9wYWNpdHlNaW5pbXVtO1xuICAgIH1cbiAgICBkb3Quc3R5bGUub3BhY2l0eSA9IGRvdE9wYWNpdHk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWZyZXNoRG90cyhlbGVtZW50KSB7XG4gIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBlbGVtZW50LnNlbGVjdGVkSW5kZXg7XG4gIGVsZW1lbnQuZG90cy5mb3JFYWNoKChkb3QsIGkpID0+IHtcbiAgICB0b2dnbGVDbGFzcyhkb3QsICdzZWxlY3RlZCcsIGkgPT09IHNlbGVjdGVkSW5kZXgpO1xuICB9KTtcbn1cbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IEZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbiBmcm9tICcuL0ZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuL3N5bWJvbHMnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBhbmltYXRpb25TeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2FuaW1hdGlvbicpO1xuY29uc3QgZHJhZ2dpbmdTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2RyYWdnaW5nJyk7XG5jb25zdCBsYXN0QW5pbWF0aW9uU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdsYXN0QW5pbWF0aW9uJyk7XG5jb25zdCBwbGF5aW5nQW5pbWF0aW9uU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdhbmltYXRpbmdTZWxlY3Rpb24nKTtcbmNvbnN0IHByZXZpb3VzU2VsZWN0aW9uU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdwcmV2aW91c1NlbGVjdGlvbicpO1xuY29uc3Qgc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb25TeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3NlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uJyk7XG5jb25zdCBzZWxlY3Rpb25BbmltYXRpb25FZmZlY3RTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3NlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdCcpO1xuY29uc3Qgc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdzZWxlY3Rpb25BbmltYXRpb25LZXlmcmFtZXMnKTtcbmNvbnN0IHJlc2V0QW5pbWF0aW9uc09uTmV4dFJlbmRlclN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncmVzZXRBbmltYXRpb25zT25OZXh0UmVuZGVyJyk7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTZWxlY3Rpb25BbmltYXRpb24uICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaXhpbihiYXNlKSB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIHVzZXMgYW5pbWF0aW9uIHRvIHNob3cgdHJhbnNpdGlvbnMgYmV0d2VlbiBzZWxlY3Rpb24gc3RhdGVzLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGNhbiBiZSB1c2VkIGJ5IGNvbXBvbmVudHMgdGhhdCB3YW50IHRvIHByb3ZpZGUgdmlzaWJsZVxuICAgKiBhbmltYXRpb25zIHdoZW4gY2hhbmdpbmcgdGhlIHNlbGVjdGlvbi4gRm9yIGV4YW1wbGUsIGEgY2Fyb3VzZWwgY29tcG9uZW50XG4gICAqIG1heSB3YW50IHRvIGRlZmluZSBhIHNsaWRpbmcgYW5pbWF0aW9uIGVmZmVjdCBzaG93biB3aGVuIG1vdmluZyBiZXR3ZWVuXG4gICAqIGl0ZW1zLlxuICAgKlxuICAgKiBUaGUgYW5pbWF0aW9uIGlzIGRlZmluZWQgYnkgYSBgc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzYCBwcm9wZXJ0eTsgc2VlXG4gICAqIHRoYXQgcHJvcGVydHkgZm9yIGRldGFpbHMgb24gaG93IHRvIGRlZmluZSB0aGVzZSBrZXlmcmFtZXMuIFRoaXMgYW5pbWF0aW9uXG4gICAqIHdpbGwgYmUgdXNlZCBpbiB0d28gd2F5cy4gRmlyc3QsIHdoZW4gbW92aW5nIHN0cmljdGx5IGJldHdlZW4gaXRlbXMsIHRoZVxuICAgKiBhbmltYXRpb24gd2lsbCBwbGF5IHNtb290aGx5IHRvIHNob3cgdGhlIHNlbGVjdGlvbiBjaGFuZ2luZy4gU2Vjb25kLCB0aGVcbiAgICogYW5pbWF0aW9uIGNhbiBiZSB1c2VkIHRvIHJlbmRlciB0aGUgc2VsZWN0aW9uIGF0IGEgZml4ZWQgcG9pbnQgaW4gdGhlXG4gICAqIHRyYW5zaXRpb24gYmV0d2VlbiBzdGF0ZXMuIEUuZy4sIGlmIHRoZSB1c2VyIHBhdXNlcyBoYWxmd2F5IHRocm91Z2hcbiAgICogZHJhZ2dpbmcgYW4gZWxlbWVudCB1c2luZyBbU3dpcGVEaXJlY3Rpb25NaXhpbl0oU3dpcGVEaXJlY3Rpb25NaXhpbi5tZClcbiAgICogb3IgW1RyYWNrcGFkRGlyZWN0aW9uTWl4aW5dKFRyYWNrcGFkRGlyZWN0aW9uTWl4aW4ubWQpcywgdGhlbiB0aGUgc2VsZWN0aW9uXG4gICAqIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duIGF0IHRoZSBwb2ludCBleGFjdGx5IGhhbGZ3YXkgdGhyb3VnaC5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBleHBlY3RzIGEgY29tcG9uZW50IHRvIHByb3ZpZGUgYW4gYGl0ZW1zYCBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICogaW4gdGhlIGxpc3QsIHdoaWNoIGNhbiBiZSBwcm92aWRlZCB2aWFcbiAgICogW0NvbnRlbnRJdGVtc01peGluXShDb250ZW50SXRlbXNNaXhpbi5tZCkuIFRoaXMgbWl4aW4gYWxzbyBleHBlY3RzXG4gICAqIGBzZWxlY3RlZEluZGV4YCBhbmQgYHNlbGVjdGVkSXRlbWAgcHJvcGVydGllcywgd2hpY2ggY2FuIGJlIHByb3ZpZGVkIHZpYVxuICAgKiBbU2luZ2xlU2VsZWN0aW9uTWl4aW5dKFNpbmdsZVNlbGVjdGlvbk1peGluLm1kKS5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBzdXBwb3J0cyBhIGBzZWxlY3Rpb25XcmFwc2AgcHJvcGVydHkuIFdoZW4gdHJ1ZSwgdGhlIHVzZXIgY2FuXG4gICAqIG5hdmlnYXRlIGZvcndhcmQgZnJvbSB0aGUgbGFzdCBpdGVtIGluIHRoZSBsaXN0IGFuZCB3cmFwIGFyb3VuZCB0byB0aGVcbiAgICogZmlyc3QgaXRlbSwgb3IgbmF2aWdhdGUgYmFja3dhcmQgZnJvbSB0aGUgZmlyc3QgaXRlbSBhbmQgd3JhcCBhcm91bmQgdG8gdGhlXG4gICAqIGxhc3QgaXRlbS5cbiAgICpcbiAgICogVGhpcyBtaXhpbiB1c2VzIHRoZSBXZWIgQW5pbWF0aW9ucyBBUEkuIEZvciB1c2Ugb24gYnJvd3NlcnMgd2hpY2hcbiAgICogZG8gbm90IHN1cHBvcnQgdGhhdCBBUEkgbmF0aXZlbHksIHlvdSB3aWxsIG5lZWQgdG8gbG9hZCB0aGVcbiAgICogW1dlYiBBbmltYXRpb25zIHBvbHlmaWxsXShodHRwczovL2dpdGh1Yi5jb20vd2ViLWFuaW1hdGlvbnMvd2ViLWFuaW1hdGlvbnMtanMpLlxuICAgKi9cbiAgY2xhc3MgU2VsZWN0aW9uQW5pbWF0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG5cbiAgICAgIC8vIFNldCBkZWZhdWx0cy5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvbiA9IHRoaXNbc3ltYm9scy5kZWZhdWx0c10uc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb247XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0ID09PSAndW5kZWZpbmVkJyAmJiB0aGlzLnNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lcyA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0ID0gdGhpc1tzeW1ib2xzLmRlZmF1bHRzXS5zZWxlY3Rpb25BbmltYXRpb25FZmZlY3Q7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbc3ltYm9scy5kcmFnZ2luZ10gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgW3N5bWJvbHMuZGVmYXVsdHNdKCkge1xuICAgICAgY29uc3QgZGVmYXVsdHMgPSBzdXBlcltzeW1ib2xzLmRlZmF1bHRzXSB8fCB7fTtcbiAgICAgIGRlZmF1bHRzLnNlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uID0gMjUwO1xuICAgICAgZGVmYXVsdHMuc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0ID0gJ3NsaWRlJztcbiAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFByb3ZpZGUgYmFja2luZyBmb3IgdGhlIGRyYWdnaW5nIHByb3BlcnR5LlxuICAgICAqIEFsc28sIHdoZW4gYSBkcmFnIGJlZ2lucywgcmVzZXQgdGhlIGFuaW1hdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IFtzeW1ib2xzLmRyYWdnaW5nXSgpIHtcbiAgICAgIHJldHVybiB0aGlzW2RyYWdnaW5nU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IFtzeW1ib2xzLmRyYWdnaW5nXSh2YWx1ZSkge1xuICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXNbc3ltYm9scy5kcmFnZ2luZ107XG4gICAgICB0aGlzW2RyYWdnaW5nU3ltYm9sXSA9IHZhbHVlO1xuICAgICAgaWYgKHN5bWJvbHMuZHJhZ2dpbmcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXJbc3ltYm9scy5kcmFnZ2luZ10gPSB2YWx1ZTsgfVxuICAgICAgaWYgKHZhbHVlICYmICFwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgIC8vIEhhdmUgYmVndW4gYSBkcmFnLlxuICAgICAgICB0aGlzW3Jlc2V0QW5pbWF0aW9uc09uTmV4dFJlbmRlclN5bWJvbF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIFtzeW1ib2xzLml0ZW1BZGRlZF0oaXRlbSkge1xuICAgICAgLy8gV2UgbWFyayBuZXcgaXRlbXMgaW4gdGhlIGxpc3QgYXMgZXhwbGljaXRseSB2aXNpYmxlIHRvIEFSSUEuIE90aGVyd2lzZSxcbiAgICAgIC8vIHdoZW4gYW4gaXRlbSBpc24ndCB2aXNpYmxlIG9uIHRoZSBzY3JlZW4sIEFSSUEgd2lsbCBhc3N1bWUgdGhlIGl0ZW0gaXNcbiAgICAgIC8vIG9mIG5vIGludGVyZXN0IHRvIHRoZSB1c2VyLCBhbmQgbGVhdmUgaXQgb3V0IG9mIHRoZSBhY2Nlc3NpYmlsaXR5IHRyZWUuXG4gICAgICAvLyBJZiB0aGUgbGlzdCBjb250YWlucyAxMCBpdGVtcywgYnV0IG9ubHkgMyBhcmUgdmlzaWJsZSwgYSBzY3JlZW4gcmVhZGVyXG4gICAgICAvLyBtaWdodCB0aGVuIGFubm91bmNlIHRoZSBsaXN0IG9ubHkgaGFzIDMgaXRlbXMuIFRvIGVuc3VyZSB0aGF0IHNjcmVlblxuICAgICAgLy8gcmVhZGVycyBhbmQgb3RoZXIgYXNzaXN0aXZlIHRlY2hub2xvZ2llcyBhbm5vdW5jZSB0aGUgY29ycmVjdCB0b3RhbFxuICAgICAgLy8gbnVtYmVyIG9mIGl0ZW1zLCB3ZSBleHBsaWNpdGx5IG1hcmsgYWxsIGl0ZW1zIGFzIG5vdCBoaWRkZW4uIFRoaXMgd2lsbFxuICAgICAgLy8gZXhwb3NlIHRoZW0gYWxsIGluIHRoZSBhY2Nlc3NpYmlsaXR5IHRyZWUsIGV2ZW4gdGhlIGl0ZW1zIHdoaWNoIGFyZVxuICAgICAgLy8gY3VycmVudGx5IG5vdCByZW5kZXJlZC5cbiAgICAgIC8vXG4gICAgICAvLyBUT0RPOiBHZW5lcmFsbHkgc3BlYWtpbmcsIHRoaXMgZW50aXJlIG1peGluIGFzc3VtZXMgdGhhdCB0aGUgdXNlciBjYW5cbiAgICAgIC8vIG5hdmlnYXRlIHRocm91Z2ggYWxsIGl0ZW1zIGluIGEgbGlzdC4gQnV0IGFuIGFwcCBjb3VsZCBzdHlsZSBhbiBpdGVtIGFzXG4gICAgICAvLyBkaXNwbGF5Om5vbmUgb3IgdmlzaWJpbGl0eTpoaWRkZW4gYmVjYXVzZSB0aGUgdXNlciBpcyBub3QgYWxsb3dlZCB0b1xuICAgICAgLy8gaW50ZXJhY3Qgd2l0aCB0aGF0IGl0ZW0gYXQgdGhlIG1vbWVudC4gU3VwcG9ydCBmb3IgdGhpcyBzY2VuYXJpbyBzaG91bGRcbiAgICAgIC8vIGJlIGFkZGVkLiBUaGlzIHdvdWxkIGVudGFpbCBjaGFuZ2luZyBhbGwgbG9jYXRpb25zIHdoZXJlIGEgbWl4aW5cbiAgICAgIC8vIGZ1bmN0aW9uIGlzIGNvdW50aW5nIGl0ZW1zLCBpdGVyYXRpbmcgb3ZlciB0aGUgKHZpc2libGUpIGl0ZW1zLCBhbmRcbiAgICAgIC8vIHNob3dpbmcgb3IgaGlkaW5nIGl0ZW1zLiBBbW9uZyBvdGhlciB0aGluZ3MsIHRoZSBjb2RlIGJlbG93IHRvIG1ha2VcbiAgICAgIC8vIGl0ZW1zIHZpc2libGUgdG8gQVJJQSB3b3VsZCBuZWVkIHRvIGRpc2NyaW1pbmF0ZSBiZXR3ZWVuIGl0ZW1zIHdoaWNoXG4gICAgICAvLyBhcmUgaW52aXNpYmxlIGJlY2F1c2Ugb2YgYW5pbWF0aW9uIHN0YXRlLCBvciBpbnZpc2libGUgYmVjYXVzZSB0aGUgdXNlclxuICAgICAgLy8gc2hvdWxkbid0IGludGVyYWN0IHdpdGggdGhlbS5cbiAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBbc3ltYm9scy5pdGVtc0NoYW5nZWRdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSkgeyBzdXBlcltzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKTsgfVxuXG4gICAgICByZXNldEFuaW1hdGlvbnModGhpcyk7XG5cbiAgICAgIC8vIFRPRE86IEFsc28gcmVzZXQgb3VyIG5vdGlvbiBvZiB0aGUgbGFzdCByZW5kZXJlZCBzZWxlY3Rpb24/IFRoaXMgY29tZXNcbiAgICAgIC8vIHVwIHdoZW4gYSBET00gcmVtb3ZhbCBjYXVzZXMgdGhlIHNlbGVjdGVkIGl0ZW0gdG8gY2hhbmdlIHBvc2l0aW9uLlxuICAgICAgLy8gdGhpc1twcmV2aW91c1NlbGVjdGlvblN5bWJvbF0gPSBudWxsO1xuXG4gICAgICByZW5kZXJTZWxlY3Rpb24odGhpcyk7XG4gICAgfVxuXG4gICAgcmVzZXRBbmltYXRpb25zKCkge1xuICAgICAgcmVzZXRBbmltYXRpb25zKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZnJhY3Rpb25hbCB2YWx1ZSBpbmRpY2F0aW5nIGhvdyBmYXIgdGhlIHVzZXIgaGFzIGN1cnJlbnRseSBhZHZhbmNlZCB0b1xuICAgICAqIHRoZSBuZXh0L3ByZXZpb3VzIGl0ZW0uIEUuZy4sIGEgYHNlbGVjdGVkRnJhY3Rpb25gIG9mIDMuNSBpbmRpY2F0ZXMgdGhlXG4gICAgICogdXNlciBpcyBoYWxmd2F5IGJldHdlZW4gaXRlbXMgMyBhbmQgNC5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSBbRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluXShGcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4ubWQpXG4gICAgICogbWl4aW4uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZEZyYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnNlbGVjdGVkRnJhY3Rpb24gfHwgMDtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkRnJhY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICgnc2VsZWN0ZWRGcmFjdGlvbicgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRGcmFjdGlvbiA9IHZhbHVlOyB9XG4gICAgICByZW5kZXJTZWxlY3Rpb24odGhpcywgdGhpcy5zZWxlY3RlZEluZGV4LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IHNlbGVjdGVkSW5kZXgoKSB7XG4gICAgICByZXR1cm4gc3VwZXIuc2VsZWN0ZWRJbmRleDtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICAgIGlmICgnc2VsZWN0ZWRJbmRleCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRJbmRleCA9IGluZGV4OyB9XG4gICAgICByZW5kZXJTZWxlY3Rpb24odGhpcywgaW5kZXgsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkdXJhdGlvbiBvZiBhIHNlbGVjdGlvbiBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogVGhpcyBtZWFzdXJlcyB0aGUgYW1vdW50IG9mIHRpbWUgcmVxdWlyZWQgZm9yIGEgc2VsZWN0aW9uIGFuaW1hdGlvbiB0b1xuICAgICAqIGNvbXBsZXRlLiBUaGlzIG51bWJlciByZW1haW5zIGNvbnN0YW50LCBldmVuIGlmIHRoZSBudW1iZXIgb2YgaXRlbXMgYmVpbmdcbiAgICAgKiBhbmltYXRlZCBpbmNyZWFzZXMuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAyNTAgbWlsbGlzZWNvbmRzIChhIHF1YXJ0ZXIgYSBzZWNvbmQpLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAyNTBcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpc1tzZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvblN5bWJvbF07XG4gICAgfVxuICAgIHNldCBzZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvbih2YWx1ZSkge1xuICAgICAgdGhpc1tzZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvblN5bWJvbF0gPSB2YWx1ZTtcbiAgICAgIGlmICgnc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb24nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uID0gdmFsdWU7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiBhIHN0YW5kYXJkIHNlbGVjdGlvbiBhbmltYXRpb24gZWZmZWN0LlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIHNob3J0aGFuZCBmb3Igc2V0dGluZyB0aGUgYHNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lc2BcbiAgICAgKiBwcm9wZXJ0eSB0byBzdGFuZGFyZCBrZXlmcmFtZXMuIFN1cHBvcnRlZCBzdHJpbmcgdmFsdWVzOlxuICAgICAqXG4gICAgICogKiBcImNyb3NzZmFkZVwiXG4gICAgICogKiBcInJldmVhbFwiXG4gICAgICogKiBcInJldmVhbFdpdGhGYWRlXCJcbiAgICAgKiAqIFwic2hvd0FkamFjZW50XCJcbiAgICAgKiAqIFwic2xpZGVcIlxuICAgICAqICogXCJzbGlkZVdpdGhHYXBcIlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcInNsaWRlXCJcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0U3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdCh2YWx1ZSkge1xuICAgICAgdGhpc1tzZWxlY3Rpb25BbmltYXRpb25FZmZlY3RTeW1ib2xdID0gdmFsdWU7XG4gICAgICBpZiAoJ3NlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0ID0gdmFsdWU7IH1cbiAgICAgIHRoaXMuc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzID0gbWl4aW4uc3RhbmRhcmRFZmZlY3RLZXlmcmFtZXNbdmFsdWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBrZXlmcmFtZXMgdGhhdCBkZWZpbmUgYW4gYW5pbWF0aW9uIHRoYXQgcGxheXMgZm9yIGFuIGl0ZW0gd2hlbiBtb3ZpbmdcbiAgICAgKiBmb3J3YXJkIGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gYXJyYXkgb2YgQ1NTIHJ1bGVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkLiBUaGVzZSBhcmUgdXNlZCBhc1xuICAgICAqIFtrZXlmcmFtZXNdKGh0dHA6Ly93M2MuZ2l0aHViLmlvL3dlYi1hbmltYXRpb25zLyNrZXlmcmFtZXMtc2VjdGlvbilcbiAgICAgKiB0byBhbmltYXRlIHRoZSBpdGVtIHdpdGggdGhlXG4gICAgICogW1dlYiBBbmltYXRpb25zIEFQSV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2FuaW1hdGlvbikuXG4gICAgICpcbiAgICAgKiBUaGUgYW5pbWF0aW9uIHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBuZXh0IGl0ZW0gYXMgaXQgbW92ZXMgZnJvbVxuICAgICAqIGNvbXBsZXRlbHkgdW5zZWxlY3RlZCAob2Zmc3RhZ2UsIHVzdWFsbHkgcmlnaHQpLCB0byBzZWxlY3RlZCAoY2VudGVyXG4gICAgICogc3RhZ2UpLCB0byBjb21wbGV0ZWx5IHVuc2VsZWN0ZWQgKG9mZnN0YWdlLCB1c3VhbGx5IGxlZnQpLiBUaGUgY2VudGVyIHRpbWVcbiAgICAgKiBvZiB0aGUgYW5pbWF0aW9uIHNob3VsZCBjb3JyZXNwb25kIHRvIHRoZSBpdGVtJ3MgcXVpc2NlbnQgc2VsZWN0ZWQgc3RhdGUsXG4gICAgICogdHlwaWNhbGx5IGluIHRoZSBjZW50ZXIgb2YgdGhlIHN0YWdlIGFuZCBhdCB0aGUgaXRlbSdzIGxhcmdlc3Qgc2l6ZS5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvcndhcmQgYW5pbWF0aW9uIGlzIGEgc21vb3RoIHNsaWRlIGF0IGZ1bGwgc2l6ZSBmcm9tIHJpZ2h0IHRvXG4gICAgICogbGVmdC5cbiAgICAgKlxuICAgICAqIFdoZW4gbW92aW5nIHRoZSBzZWxlY3Rpb24gYmFja3dhcmQsIHRoaXMgYW5pbWF0aW9uIGlzIHBsYXllZCBpbiByZXZlcnNlLlxuICAgICAqXG4gICAgICogQHR5cGUge2Nzc1J1bGVzW119XG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lcygpIHtcbiAgICAgIC8vIFN0YW5kYXJkIGFuaW1hdGlvbiBzbGlkZXMgbGVmdC9yaWdodCwga2VlcHMgYWRqYWNlbnQgaXRlbXMgb3V0IG9mIHZpZXcuXG4gICAgICByZXR1cm4gdGhpc1tzZWxlY3Rpb25BbmltYXRpb25LZXlmcmFtZXNTeW1ib2xdO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzKHZhbHVlKSB7XG4gICAgICB0aGlzW3NlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lc1N5bWJvbF0gPSB2YWx1ZTtcbiAgICAgIGlmICgnc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3Rpb25BbmltYXRpb25LZXlmcmFtZXMgPSB2YWx1ZTsgfVxuICAgICAgcmVzZXRBbmltYXRpb25zKHRoaXMpO1xuICAgICAgcmVuZGVyU2VsZWN0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3Rpb25XcmFwcygpIHtcbiAgICAgIHJldHVybiBzdXBlci5zZWxlY3Rpb25XcmFwcztcbiAgICB9XG4gICAgc2V0IHNlbGVjdGlvbldyYXBzKHZhbHVlKSB7XG4gICAgICBpZiAoJ3NlbGVjdGlvbldyYXBzJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3Rpb25XcmFwcyA9IHZhbHVlOyB9XG4gICAgICByZXNldEFuaW1hdGlvbnModGhpcyk7XG4gICAgICByZW5kZXJTZWxlY3Rpb24odGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFNlbGVjdGlvbkFuaW1hdGlvbjtcbn1cblxuXG4vLyBXZSBleHBvc2UgaGVscGVycyBvbiB0aGUgbWl4aW4gZnVuY3Rpb24gdGhhdCB3ZSB3YW50IHRvIGJlIGFibGUgdG8gdW5pdCB0ZXN0LlxuLy8gU2luY2UgdGhlc2UgYXJlIG9uIHRoZSBmdW5jdGlvbiwgbm90IG9uIHRoZSBjbGFzcyBlbWl0dGVkIGJ5IHRoZSBmdW5jdGlvbixcbi8vIHRoZXkgZG9uJ3QgZW5kIHVwIGdldHRpbmcgZXhwb3NlZCBvbiBhY3R1YWwgZWxlbWVudCBpbnN0YW5jZXMuXG5taXhpbi5oZWxwZXJzID0ge1xuXG4gIC8qXG4gICAqIENhbGN1bGF0ZSB0aGUgYW5pbWF0aW9uIGZyYWN0aW9ucyBmb3IgYW4gZWxlbWVudCdzIGl0ZW1zIGF0IHRoZSBnaXZlblxuICAgKiBzZWxlY3Rpb24gcG9pbnQuIFRoaXMgaXMgdXNlZCB3aGVuIHJlbmRlcmluZyB0aGUgZWxlbWVudCdzIHNlbGVjdGlvbiBzdGF0ZVxuICAgKiBpbnN0YW50YW5lb3VzbHkuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gY29uc2lkZXJzIHRoZSBzZWxlY3RlZEluZGV4IHBhcmFtZXRlciwgd2hpY2ggY2FuIGJlIGEgd2hvbGVcbiAgICogb3IgZnJhY3Rpb25hbCBudW1iZXIsIGFuZCBkZXRlcm1pbmVzIHdoaWNoIGl0ZW1zIHdpbGwgYmUgdmlzaWJsZSBhdCB0aGF0XG4gICAqIGluZGV4LiBUaGlzIGZ1bmN0aW9uIHRoZW4gY2FsY3VsYXRlcyBhIGNvcnJlc3BvbmRpbmcgYW5pbWF0aW9uIGZyYWN0aW9uOiBhXG4gICAqIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgaW5kaWNhdGluZyBob3cgZmFyIHRocm91Z2ggdGhlIHNlbGVjdGlvbiBhbmltYXRpb25cbiAgICogYW4gaXRlbSBzaG91bGQgYmUgc2hvd24sIG9yIG51bGwgaWYgdGhlIGl0ZW0gc2hvdWxkIG5vdCBiZSB2aXNpYmxlIGF0IHRoYXRcbiAgICogc2VsZWN0aW9uIGluZGV4LiBUaGVzZSBmcmFjdGlvbnMgYXJlIHJldHVybmVkIGFzIGFuIGFycmF5LCB3aGVyZSB0aGVcbiAgICogYW5pbWF0aW9uIGZyYWN0aW9uIGF0IHBvc2l0aW9uIE4gY29ycmVzcG9uZHMgdG8gaG93IGl0ZW0gTiBzaG91bGQgYmUgc2hvd24uXG4gICAqL1xuICBhbmltYXRpb25GcmFjdGlvbnNGb3JTZWxlY3Rpb24oZWxlbWVudCwgc2VsZWN0aW9uKSB7XG5cbiAgICBjb25zdCBpdGVtcyA9IGVsZW1lbnQuaXRlbXM7XG4gICAgaWYgKCFpdGVtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1Db3VudCA9IGl0ZW1zLmxlbmd0aDtcbiAgICBjb25zdCBzZWxlY3Rpb25XcmFwcyA9IGVsZW1lbnQuc2VsZWN0aW9uV3JhcHM7XG5cbiAgICByZXR1cm4gaXRlbXMubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgIC8vIEhvdyBtYW55IHN0ZXBzIGZyb20gdGhlIHNlbGVjdGlvbiBwb2ludCB0byB0aGlzIGl0ZW0/XG4gICAgICBjb25zdCBzdGVwcyA9IHN0ZXBzVG9JbmRleChpdGVtQ291bnQsIHNlbGVjdGlvbldyYXBzLCBzZWxlY3Rpb24sIGl0ZW1JbmRleCk7XG4gICAgICAvLyBUbyBjb252ZXJ0IHN0ZXBzIHRvIGFuaW1hdGlvbiBmcmFjdGlvbjpcbiAgICAgIC8vIHN0ZXBzICAgICAgYW5pbWF0aW9uIGZyYWN0aW9uXG4gICAgICAvLyAgMSAgICAgICAgIDAgICAgIChzdGFnZSByaWdodClcbiAgICAgIC8vICAwICAgICAgICAgMC41ICAgKGNlbnRlciBzdGFnZSlcbiAgICAgIC8vIC0xICAgICAgICAgMSAgICAgKHN0YWdlIGxlZnQpXG4gICAgICBjb25zdCBhbmltYXRpb25GcmFjdGlvbiA9ICgxIC0gc3RlcHMpIC8gMjtcbiAgICAgIHJldHVybiAoYW5pbWF0aW9uRnJhY3Rpb24gPj0gMCAmJiBhbmltYXRpb25GcmFjdGlvbiA8PSAxKSA/XG4gICAgICAgIGFuaW1hdGlvbkZyYWN0aW9uIDpcbiAgICAgICAgbnVsbDsgLy8gT3V0c2lkZSBhbmltYXRpb24gcmFuZ2VcbiAgICB9KTtcbiAgfSxcblxuICAvKlxuICAgKiBDYWxjdWxhdGUgdGhlIGFuaW1hdGlvbiB0aW1pbmdzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gc21vb3RobHkgYW5pbWF0ZSB0aGVcbiAgICogZWxlbWVudCdzIGl0ZW1zIGZyb20gb25lIHNlbGVjdGlvbiBzdGF0ZSB0byBhbm90aGVyLlxuICAgKlxuICAgKiBUaGlzIHJldHVybnMgYW4gYXJyYXkgb2YgdGltaW5ncywgd2hlcmUgdGhlIHRpbWluZyBhdCBwb3NpdGlvbiBOIHNob3VsZCBiZVxuICAgKiB1c2VkIHRvIGFuaW1hdGUgaXRlbSBOLiBJZiBhbiBpdGVtJ3MgdGltaW5nIGlzIG51bGwsIHRoZW4gdGhhdCBpdGVtIHNob3VsZFxuICAgKiBub3QgdGFrZSBwbGFjZSBpbiB0aGUgYW5pbWF0aW9uLCBhbmQgc2hvdWxkIGJlIGhpZGRlbiBpbnN0ZWFkLlxuICAgKi9cbiAgZWZmZWN0VGltaW5nc0ZvclNlbGVjdGlvbkFuaW1hdGlvbihlbGVtZW50LCBmcm9tU2VsZWN0aW9uLCB0b1NlbGVjdGlvbikge1xuXG4gICAgY29uc3QgaXRlbXMgPSBlbGVtZW50Lml0ZW1zO1xuICAgIGlmICghaXRlbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbUNvdW50ID0gaXRlbXMubGVuZ3RoO1xuICAgIGNvbnN0IHNlbGVjdGlvbldyYXBzID0gZWxlbWVudC5zZWxlY3Rpb25XcmFwcztcbiAgICBjb25zdCB0b0luZGV4ID0gRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluLmhlbHBlcnMud3JhcHBlZFNlbGVjdGlvblBhcnRzKHRvU2VsZWN0aW9uLCBpdGVtQ291bnQsIHNlbGVjdGlvbldyYXBzKS5pbmRleDtcbiAgICBjb25zdCB0b3RhbFN0ZXBzID0gc3RlcHNUb0luZGV4KGl0ZW1Db3VudCwgc2VsZWN0aW9uV3JhcHMsIGZyb21TZWxlY3Rpb24sIHRvU2VsZWN0aW9uKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0b3RhbFN0ZXBzID49IDAgPyAnbm9ybWFsJzogJ3JldmVyc2UnO1xuICAgIGNvbnN0IGZpbGwgPSAnYm90aCc7XG4gICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IGVsZW1lbnQuc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb247XG4gICAgY29uc3Qgc3RlcER1cmF0aW9uID0gdG90YWxTdGVwcyAhPT0gMCA/XG4gICAgICB0b3RhbER1cmF0aW9uICogMiAvIE1hdGguY2VpbChNYXRoLmFicyh0b3RhbFN0ZXBzKSkgOlxuICAgICAgMDsgIC8vIE5vIHN0ZXBzIHJlcXVpcmVkLCBhbmltYXRpb24gd2lsbCBiZSBpbnN0YW50ZW5vdXMuXG5cbiAgICBjb25zdCB0aW1pbmdzID0gaXRlbXMubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHN0ZXBzID0gc3RlcHNUb0luZGV4KGl0ZW1Db3VudCwgc2VsZWN0aW9uV3JhcHMsIGl0ZW1JbmRleCwgdG9TZWxlY3Rpb24pO1xuICAgICAgLy8gSWYgd2UgaW5jbHVkZSB0aGlzIGl0ZW0gaW4gdGhlIHN0YWdnZXJlZCBzZXF1ZW5jZSBvZiBhbmltYXRpb25zIHdlJ3JlXG4gICAgICAvLyBjcmVhdGluZywgd2hlcmUgd291bGQgdGhlIGl0ZW0gYXBwZWFyIGluIHRoZSBzZXF1ZW5jZT9cbiAgICAgIGxldCBwb3NpdGlvbkluU2VxdWVuY2UgPSB0b3RhbFN0ZXBzIC0gc3RlcHM7XG4gICAgICBpZiAodG90YWxTdGVwcyA8IDApIHtcbiAgICAgICAgcG9zaXRpb25JblNlcXVlbmNlID0gLXBvc2l0aW9uSW5TZXF1ZW5jZTtcbiAgICAgIH1cbiAgICAgIC8vIFNvLCBpcyB0aGlzIGl0ZW0gcmVhbGx5IGluY2x1ZGVkIGluIHRoZSBzZXF1ZW5jZT9cbiAgICAgIGlmIChNYXRoLmNlaWwocG9zaXRpb25JblNlcXVlbmNlKSA+PSAwICYmIHBvc2l0aW9uSW5TZXF1ZW5jZSA8PSBNYXRoLmFicyh0b3RhbFN0ZXBzKSkge1xuICAgICAgICAvLyBOb3RlIHRoYXQgZGVsYXkgZm9yIGZpcnN0IGl0ZW0gd2lsbCBiZSBuZWdhdGl2ZS4gVGhhdCB3aWxsIGNhdXNlXG4gICAgICAgIC8vIHRoZSBhbmltYXRpb24gdG8gc3RhcnQgaGFsZndheSB0aHJvdWdoLCB3aGljaCBpcyB3aGF0IHdlIHdhbnQuXG4gICAgICAgIGNvbnN0IGRlbGF5ID0gc3RlcER1cmF0aW9uICogKHBvc2l0aW9uSW5TZXF1ZW5jZSAtIDEpLzI7XG4gICAgICAgIGNvbnN0IGVuZERlbGF5ID0gaXRlbUluZGV4ID09PSB0b0luZGV4ID9cbiAgICAgICAgICAtc3RlcER1cmF0aW9uLzIgOiAgIC8vIFN0b3AgaGFsZndheSB0aHJvdWdoLlxuICAgICAgICAgIDA7ICAgICAgICAgICAgICAvLyBQbGF5IGFuaW1hdGlvbiB1bnRpbCBlbmQuXG4gICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiBzdGVwRHVyYXRpb24sIGRpcmVjdGlvbiwgZmlsbCwgZGVsYXksIGVuZERlbGF5IH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aW1pbmdzO1xuICB9XG5cbn07XG5cblxuLy8gS2V5ZnJhbWVzIGZvciBzdGFuZGFyZCBzZWxlY3Rpb24gYW5pbWF0aW9uIGVmZmVjdHMuXG5taXhpbi5zdGFuZGFyZEVmZmVjdEtleWZyYW1lcyA9IHtcblxuICAvLyBTaW1wbGUgY3Jvc3NmYWRlXG4gIGNyb3NzZmFkZTogW1xuICAgIHsgb3BhY2l0eTogMCB9LFxuICAgIHsgb3BhY2l0eTogMSB9LFxuICAgIHsgb3BhY2l0eTogMCB9XG4gIF0sXG5cbiAgLy8gUmV2ZWFsLCBhcyBpZiBzbGlkaW5nIHRoZSB0b3AgY2FyZCBvZmYgYSBkZWNrIG9mIGNhcmRzXG4gIHJldmVhbDogW1xuICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwJSknLCB6SW5kZXg6IDAgfSxcbiAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCUpJywgekluZGV4OiAxIH0sXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC0xMDAlKScsIHpJbmRleDogMiB9XG4gIF0sXG5cbiAgLy8gR29vZ2xlIFBob3Rvcy1zdHlsZSByZXZlYWwtd2l0aC1mYWRlIGFuaW1hdGlvblxuICByZXZlYWxXaXRoRmFkZTogW1xuICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwJSkgc2NhbGUoMC43NSknLCBvcGFjaXR5OiAwLCB6SW5kZXg6IDAgfSxcbiAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCUpIHNjYWxlKDEuMCknLCBvcGFjaXR5OiAxLCB6SW5kZXg6IDEgfSxcbiAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTEwMCUpIHNjYWxlKDEuMCknLCBvcGFjaXR5OiAxLCB6SW5kZXg6IDIgfVxuICBdLFxuXG4gIC8vIENhcm91c2VsIHZhcmlhbnQgd2l0aCBhIGJpdCBvZiBvZmYtc3RhZ2UgZWxlbWVudHMgc2hvd2luZ1xuICBzaG93QWRqYWNlbnQ6IFtcbiAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoNzglKSBzY2FsZSgwLjcpJywgekluZGV4OiAwIH0sXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDAlKSBzY2FsZSgwLjgyKScsIHpJbmRleDogMSB9LFxuICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNzglKSBzY2FsZSgwLjcpJywgekluZGV4OiAwIH1cbiAgXSxcblxuICAvLyBTaW1wbGUgc2xpZGVcbiAgc2xpZGU6IFtcbiAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMTAwJSknIH0sXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC0xMDAlKScgfVxuICBdLFxuXG4gIC8vIFNsaWRlLCB3aXRoIGEgZ2FwIGJldHdlZW5cbiAgc2xpZGVXaXRoR2FwOiBbXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDExMCUpJyB9LFxuICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtMTEwJSknIH1cbiAgXVxuXG59O1xuXG5cbi8qXG4gKiBTbW9vdGhseSBhbmltYXRlIHRoZSBzZWxlY3Rpb24gYmV0d2VlbiB0aGUgaW5kaWNhdGVkIFwiZnJvbVwiIGFuZCBcInRvXCJcbiAqIGluZGljZXMuIFRoZSBmb3JtZXIgY2FuIGJlIGEgZnJhY3Rpb24sIGUuZy4sIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgYSBmaW5nZXJcbiAqIHRvIGNvbXBsZXRlIGEgdG91Y2ggZHJhZywgYW5kIHRoZSBzZWxlY3Rpb24gd2lsbCBzbmFwIHRvIHRoZSBjbG9zZXN0IHdob2xlXG4gKiBpbmRleC5cbiAqL1xuZnVuY3Rpb24gYW5pbWF0ZVNlbGVjdGlvbihlbGVtZW50LCBmcm9tU2VsZWN0aW9uLCB0b1NlbGVjdGlvbikge1xuXG4gIHJlc2V0QW5pbWF0aW9ucyhlbGVtZW50KTtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGFuaW1hdGlvbiB0aW1pbmdzLlxuICBjb25zdCBpdGVtcyA9IGVsZW1lbnQuaXRlbXM7XG4gIGNvbnN0IGtleWZyYW1lcyA9IGVsZW1lbnQuc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzO1xuICBlbGVtZW50W3BsYXlpbmdBbmltYXRpb25TeW1ib2xdID0gdHJ1ZTtcbiAgY29uc3QgdGltaW5ncyA9IG1peGluLmhlbHBlcnMuZWZmZWN0VGltaW5nc0ZvclNlbGVjdGlvbkFuaW1hdGlvbihlbGVtZW50LCBmcm9tU2VsZWN0aW9uLCB0b1NlbGVjdGlvbik7XG5cbiAgLy8gRmlndXJlIG91dCB3aGljaCBpdGVtIHdpbGwgYmUgdGhlIG9uZSAqYWZ0ZXIqIHRoZSBvbmUgd2UncmUgc2VsZWN0aW5nLlxuICBjb25zdCBpdGVtQ291bnQgPSBpdGVtcy5sZW5ndGg7XG4gIGNvbnN0IHNlbGVjdGlvbldyYXBzID0gZWxlbWVudC5zZWxlY3Rpb25XcmFwcztcbiAgY29uc3Qgc2VsZWN0aW9uSW5kZXggPSBGcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4uaGVscGVycy5zZWxlY3Rpb25QYXJ0cyh0b1NlbGVjdGlvbiwgaXRlbUNvdW50LCBzZWxlY3Rpb25XcmFwcykuaW5kZXg7XG4gIGNvbnN0IHRvdGFsU3RlcHMgPSBzdGVwc1RvSW5kZXgoaXRlbUNvdW50LCBzZWxlY3Rpb25XcmFwcywgZnJvbVNlbGVjdGlvbiwgdG9TZWxlY3Rpb24pO1xuICBjb25zdCBmb3J3YXJkID0gdG90YWxTdGVwcyA+PSAwO1xuICBsZXQgbmV4dFVwSW5kZXggPSBzZWxlY3Rpb25JbmRleCArIChmb3J3YXJkID8gMSA6IC0gMSk7XG4gIGlmIChzZWxlY3Rpb25XcmFwcykge1xuICAgIG5leHRVcEluZGV4ID0gRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluLmhlbHBlcnMud3JhcHBlZFNlbGVjdGlvbihuZXh0VXBJbmRleCwgaXRlbUNvdW50KTtcbiAgfSBlbHNlIGlmICghaXNJdGVtSW5kZXhJbkJvdW5kcyhlbGVtZW50LCBuZXh0VXBJbmRleCkpIHtcbiAgICBuZXh0VXBJbmRleCA9IG51bGw7IC8vIEF0IHN0YXJ0L2VuZCBvZiBsaXN0OyBkb24ndCBoYXZlIGEgbmV4dCBpdGVtIHRvIHNob3cuXG4gIH1cblxuICAvLyBQbGF5IHRoZSBhbmltYXRpb25zIHVzaW5nIHRob3NlIHRpbWluZ3MuXG4gIGxldCBsYXN0QW5pbWF0aW9uRGV0YWlscztcbiAgdGltaW5ncy5mb3JFYWNoKCh0aW1pbmcsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IGl0ZW1zW2luZGV4XTtcbiAgICBpZiAodGltaW5nKSB7XG4gICAgICBzaG93SXRlbShpdGVtLCB0cnVlKTtcbiAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IGl0ZW0uYW5pbWF0ZShrZXlmcmFtZXMsIHRpbWluZyk7XG4gICAgICBlbGVtZW50W2FuaW1hdGlvblN5bWJvbF1baW5kZXhdID0gYW5pbWF0aW9uO1xuICAgICAgaWYgKGluZGV4ID09PSBuZXh0VXBJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gd2lsbCBiZSBhbmltYXRlZCwgc28gd2lsbCBhbHJlYWR5IGJlIGluIHRoZSBkZXNpcmVkIHN0YXRlXG4gICAgICAgIC8vIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzLlxuICAgICAgICBuZXh0VXBJbmRleCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGltaW5nLmVuZERlbGF5ICE9PSAwKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGFuaW1hdGlvbiBmb3IgdGhlIGl0ZW0gdGhhdCB3aWxsIGJlIGxlZnQgc2VsZWN0ZWQuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY2xlYW4gdXAgd2hlbiB0aGlzIGFuaW1hdGlvbiBjb21wbGV0ZXMuXG4gICAgICAgIGxhc3RBbmltYXRpb25EZXRhaWxzID0geyBhbmltYXRpb24sIGluZGV4LCB0aW1pbmcsIGZvcndhcmQgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpdGVtIGRvZXNuJ3QgcGFydGljaXBhdGUgaW4gdGhlIGFuaW1hdGlvbi5cbiAgICAgIHNob3dJdGVtKGl0ZW0sIGZhbHNlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChsYXN0QW5pbWF0aW9uRGV0YWlscyAhPSBudWxsKSB7XG4gICAgLy8gQXJyYW5nZSBmb3IgY2xlYW4tdXAgd29yayB0byBiZSBwZXJmb3JtZWQuXG4gICAgbGFzdEFuaW1hdGlvbkRldGFpbHMubmV4dFVwSW5kZXggPSBuZXh0VXBJbmRleDtcbiAgICBsYXN0QW5pbWF0aW9uRGV0YWlscy5hbmltYXRpb24ub25maW5pc2ggPSBldmVudCA9PiBzZWxlY3Rpb25BbmltYXRpb25GaW5pc2hlZChlbGVtZW50LCBsYXN0QW5pbWF0aW9uRGV0YWlscyk7XG4gICAgZWxlbWVudFtsYXN0QW5pbWF0aW9uU3ltYm9sXSA9IGxhc3RBbmltYXRpb25EZXRhaWxzLmFuaW1hdGlvbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBTaG91bGRuJ3QgaGFwcGVuIC0tIHdlIHNob3VsZCBhbHdheXMgaGF2ZSBhdCBsZWFzdCBvbmUgYW5pbWF0aW9uLlxuICAgIGVsZW1lbnRbcGxheWluZ0FuaW1hdGlvblN5bWJvbF0gPSBmYWxzZTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGdldEFuaW1hdGlvbkZvckl0ZW1JbmRleChlbGVtZW50LCBpbmRleCkge1xuICBpZiAoZWxlbWVudFthbmltYXRpb25TeW1ib2xdID09IG51bGwpIHtcbiAgICAvLyBOb3QgcmVhZHkgeWV0O1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBhbmltYXRpb24gPSBlbGVtZW50W2FuaW1hdGlvblN5bWJvbF1baW5kZXhdO1xuICBpZiAoIWFuaW1hdGlvbikge1xuICAgIGNvbnN0IGl0ZW0gPSBlbGVtZW50Lml0ZW1zW2luZGV4XTtcbiAgICBhbmltYXRpb24gPSBpdGVtLmFuaW1hdGUoZWxlbWVudC5zZWxlY3Rpb25BbmltYXRpb25LZXlmcmFtZXMsIHtcbiAgICAgIGR1cmF0aW9uOiBlbGVtZW50LnNlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgZmlsbDogJ2JvdGgnXG4gICAgfSk7XG4gICAgYW5pbWF0aW9uLnBhdXNlKCk7XG4gICAgZWxlbWVudFthbmltYXRpb25TeW1ib2xdW2luZGV4XSA9IGFuaW1hdGlvbjtcbiAgfVxuICByZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5mdW5jdGlvbiBpc0l0ZW1JbmRleEluQm91bmRzKGVsZW1lbnQsIGluZGV4KSB7XG4gIHJldHVybiBpbmRleCA+PSAwICYmIGVsZW1lbnQuaXRlbXMgJiYgaW5kZXggPCBlbGVtZW50Lml0ZW1zLmxlbmd0aDtcbn1cblxuLypcbiAqIFJlbmRlciB0aGUgc2VsZWN0aW9uIHN0YXRlIG9mIHRoZSBlbGVtZW50LlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gcmUtcmVuZGVyIGEgcHJldmlvdXMgc2VsZWN0aW9uIHN0YXRlIChpZiB0aGVcbiAqIHNlbGVjdGVkSW5kZXggcGFyYW0gaXMgb21pdHRlZCksIHJlbmRlciB0aGUgc2VsZWN0aW9uIGluc3RhbnRseSBhdCBhIGdpdmVuXG4gKiB3aG9sZSBvciBmcmFjdGlvbmFsIHNlbGVjdGlvbiBpbmRleCwgb3IgYW5pbWF0ZSB0byBhIGdpdmVuIHNlbGVjdGlvbiBpbmRleC5cbiAqXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCBkaXN0aW5jdCBzY2VuYXJpb3Mgd2UgbmVlZCB0byBjb3ZlcjpcbiAqXG4gKiAxLiBJbml0aWFsIHBvc2l0aW9uaW5nLCBvciByZXBvc2l0aW9uaW5nIGFmdGVyIGNoYW5naW5nIGEgcHJvcGVydHkgbGlrZVxuICogICAgc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzIHRoYXQgYWZmZWN0cyByZW5kZXJpbmcuXG4gKiAyLiBBbmltYXRlIG9uIHNlbGVjdGVkSW5kZXggY2hhbmdlLiBUaGlzIHNob3VsZCBvdmVycmlkZSBhbnkgYW5pbWF0aW9uL3N3aXBlXG4gKiAgICBhbHJlYWR5IGluIHByb2dyZXNzLlxuICogMy4gSW5zdGFudGx5IHJlbmRlciB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiBhIGRyYWcgb3BlcmF0aW9uIGluIHByb2dyZXNzLlxuICogNC4gQ29tcGxldGUgYSBkcmFnIG9wZXJhdGlvbi4gSWYgdGhlIGRyYWcgd2Fzbid0IGZhciBlbm91Z2ggdG8gYWZmZWN0XG4gKiAgICBzZWxlY3Rpb24sIHdlJ2xsIGp1c3QgYmUgcmVzdG9yaW5nIHRoZSBzZWxlY3RlZEZyYWN0aW9uIHRvIDAuXG4gKlxuICogSWYgdGhlIGxpc3QgZG9lcyBub3Qgd3JhcCwgYW55IHNlbGVjdGlvbiBwb3NpdGlvbiBvdXRzaWRlIHRoZSBsaXN0J3MgYm91bmRzXG4gKiB3aWxsIGJlIGRhbXBlZCB0byBwcm9kdWNlIGEgdmlzdWFsIGVmZmVjdCBvZiB0ZW5zaW9uLlxuICovXG5mdW5jdGlvbiByZW5kZXJTZWxlY3Rpb24oZWxlbWVudCwgc2VsZWN0ZWRJbmRleD1lbGVtZW50LnNlbGVjdGVkSW5kZXgsIHNlbGVjdGVkRnJhY3Rpb249ZWxlbWVudC5zZWxlY3RlZEZyYWN0aW9uKSB7XG4gIGNvbnN0IGl0ZW1Db3VudCA9IGVsZW1lbnQuaXRlbXMgPyBlbGVtZW50Lml0ZW1zLmxlbmd0aCA6IDA7XG4gIGlmIChpdGVtQ291bnQgPT09IDApIHtcbiAgICAvLyBOb3RoaW5nIHRvIHJlbmRlci5cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNlbGVjdGVkSW5kZXggPCAwKSB7XG4gICAgLy8gVE9ETzogSGFuZGxlIG5vIHNlbGVjdGlvbi5cbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHNlbGVjdGlvbiA9IHNlbGVjdGVkSW5kZXggKyBzZWxlY3RlZEZyYWN0aW9uO1xuICBpZiAoZWxlbWVudC5zZWxlY3Rpb25XcmFwcykge1xuICAgIC8vIEFwcGx5IHdyYXBwaW5nIHRvIGVuc3VyZSBjb25zaXN0ZW50IHJlcHJlc2VudGF0aW9uIG9mIHNlbGVjdGlvbi5cbiAgICBzZWxlY3Rpb24gPSBGcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4uaGVscGVycy53cmFwcGVkU2VsZWN0aW9uKHNlbGVjdGlvbiwgaXRlbUNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBseSBkYW1waW5nIGlmIG5lY2Vzc2FyeS5cbiAgICBzZWxlY3Rpb24gPSBGcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4uaGVscGVycy5kYW1wZWRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpdGVtQ291bnQpO1xuICB9XG4gIGNvbnN0IHByZXZpb3VzU2VsZWN0aW9uID0gZWxlbWVudFtwcmV2aW91c1NlbGVjdGlvblN5bWJvbF07XG4gIC8vIFRPRE86IElmIGFuIGl0ZW0gY2hhbmdlcyBwb3NpdGlvbiBpbiB0aGUgRE9NLCB3ZSBlbmQgdXAgYW5pbWF0aW5nIGZyb21cbiAgLy8gaXRzIG9sZCBpbmRleCB0byBpdHMgbmV3IGluZGV4LCBidXQgd2UgcmVhbGx5IGRvbid0IHdhbnQgdG8gYW5pbWF0ZSBhdCBhbGwuXG4gIGlmICghZWxlbWVudFtzeW1ib2xzLmRyYWdnaW5nXSAmJiBwcmV2aW91c1NlbGVjdGlvbiAhPSBudWxsICYmXG4gICAgICBwcmV2aW91c1NlbGVjdGlvbiAhPT0gc2VsZWN0aW9uKSB7XG4gICAgLy8gQW5pbWF0ZSBzZWxlY3Rpb24gZnJvbSBwcmV2aW91cyBzdGF0ZSB0byBuZXcgc3RhdGUuXG4gICAgYW5pbWF0ZVNlbGVjdGlvbihlbGVtZW50LCBwcmV2aW91c1NlbGVjdGlvbiwgc2VsZWN0aW9uKTtcbiAgfSBlbHNlIGlmIChzZWxlY3RlZEZyYWN0aW9uID09PSAwICYmIGVsZW1lbnRbcGxheWluZ0FuaW1hdGlvblN5bWJvbF0pIHtcbiAgICAvLyBBbHJlYWR5IGluIHByb2Nlc3Mgb2YgYW5pbWF0aW5nIHRvIGZyYWN0aW9uIDAuIER1cmluZyB0aGF0IHByb2Nlc3MsXG4gICAgLy8gaWdub3JlIHN1YnNlcXVlbnQgYXR0ZW1wdHMgdG8gcmVuZGVyU2VsZWN0aW9uIHRvIGZyYWN0aW9uIDAuXG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlciBjdXJyZW50IHNlbGVjdGlvbiBzdGF0ZSBpbnN0YW50bHkuXG4gICAgcmVuZGVyU2VsZWN0aW9uSW5zdGFudGx5KGVsZW1lbnQsIHNlbGVjdGlvbik7XG4gIH1cbiAgZWxlbWVudFtwcmV2aW91c1NlbGVjdGlvblN5bWJvbF0gPSBzZWxlY3Rpb247XG59XG5cbi8qXG4gKiBJbnN0YW50bHkgcmVuZGVyIChkb24ndCBhbmltYXRlKSB0aGUgZWxlbWVudCdzIGl0ZW1zIGF0IHRoZSBnaXZlbiB3aG9sZSBvclxuICogZnJhY3Rpb25hbCBzZWxlY3Rpb24gaW5kZXguXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNlbGVjdGlvbkluc3RhbnRseShlbGVtZW50LCB0b1NlbGVjdGlvbikge1xuICBpZiAoZWxlbWVudFtyZXNldEFuaW1hdGlvbnNPbk5leHRSZW5kZXJTeW1ib2xdKSB7XG4gICAgcmVzZXRBbmltYXRpb25zKGVsZW1lbnQpO1xuICAgIGVsZW1lbnRbcmVzZXRBbmltYXRpb25zT25OZXh0UmVuZGVyU3ltYm9sXSA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGFuaW1hdGlvbkZyYWN0aW9ucyA9IG1peGluLmhlbHBlcnMuYW5pbWF0aW9uRnJhY3Rpb25zRm9yU2VsZWN0aW9uKGVsZW1lbnQsIHRvU2VsZWN0aW9uKTtcbiAgYW5pbWF0aW9uRnJhY3Rpb25zLm1hcCgoYW5pbWF0aW9uRnJhY3Rpb24sIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IGVsZW1lbnQuaXRlbXNbaW5kZXhdO1xuICAgIGlmIChhbmltYXRpb25GcmFjdGlvbiAhPSBudWxsKSB7XG4gICAgICBzaG93SXRlbShpdGVtLCB0cnVlKTtcbiAgICAgIHNldEFuaW1hdGlvbkZyYWN0aW9uKGVsZW1lbnQsIGluZGV4LCBhbmltYXRpb25GcmFjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3dJdGVtKGl0ZW0sIGZhbHNlKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKlxuICogV2UgbWFpbnRhaW4gYW4gYXJyYXkgY29udGFpbmluZyBhbiBhbmltYXRpb24gcGVyIGl0ZW0uIFRoaXMgaXMgdXNlZCBmb3IgdHdvXG4gKiByZWFzb25zOlxuICpcbiAqICogRHVyaW5nIGEgZHJhZyBvcGVyYXRpb24sIHdlIHdhbnQgdG8gYmUgYWJsZSB0byByZXVzZSBhbmltYXRpb25zIGJldHdlZW5cbiAqICAgZHJhZyB1cGRhdGVzLlxuICogKiBXaGVuIGEgc2VsZWN0aW9uIGFuaW1hdGlvbiBjb21wbGV0ZXMsIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBsZWF2ZSB0aGVcbiAqICAgdmlzaWJpbGUgaXRlbXMgaW4gYSBwYXVzZWQgc3RhdGUuIExhdGVyLCB3ZSdsbCB3YW50IHRvIGJlIGFibGUgdG8gY2xlYW4gdXBcbiAqICAgdGhvc2UgYW5pbWF0aW9ucy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBhcnJheSBpcyBzcGFyc2U6IGl0IHdpbGwgb25seSBob2xkIHVwIGZyb20gMOKAkzMgYW5pbWF0aW9ucyBhdFxuICogYW55IGdpdmVuIHBvaW50LlxuICovXG5mdW5jdGlvbiByZXNldEFuaW1hdGlvbnMoZWxlbWVudCkge1xuICBjb25zdCBhbmltYXRpb25zID0gZWxlbWVudFthbmltYXRpb25TeW1ib2xdO1xuICBpZiAoYW5pbWF0aW9ucykge1xuICAgIC8vIENhbmNlbCBleGlzdGluZyBhbmltYXRpb25zIHRvIHJlbW92ZSB0aGUgZWZmZWN0cyB0aGV5J3JlIGFwcGx5aW5nLlxuICAgIGFuaW1hdGlvbnMuZm9yRWFjaCgoYW5pbWF0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIGFuaW1hdGlvbnNbaW5kZXhdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCBpdGVtQ291bnQgPSBlbGVtZW50Lml0ZW1zID8gZWxlbWVudC5pdGVtcy5sZW5ndGggOiAwO1xuICBpZiAoIWFuaW1hdGlvbnMgfHwgYW5pbWF0aW9ucy5sZW5ndGggIT09IGl0ZW1Db3VudCkge1xuICAgIC8vIEhhdmVuJ3QgYW5pbWF0ZWQgYmVmb3JlIHdpdGggdGhpcyBudW1iZXIgb2YgaXRlbXM7IChyZSljcmVhdGUgYXJyYXkuXG4gICAgZWxlbWVudFthbmltYXRpb25TeW1ib2xdID0gbmV3IEFycmF5KGl0ZW1Db3VudCk7XG4gIH1cbn1cblxuLypcbiAqIFRoZSBsYXN0IGFuaW1hdGlvbiBpbiBvdXIgc2VsZWN0aW9uIGFuaW1hdGlvbiBoYXMgY29tcGxldGVkLiBDbGVhbiB1cC5cbiAqL1xuZnVuY3Rpb24gc2VsZWN0aW9uQW5pbWF0aW9uRmluaXNoZWQoZWxlbWVudCwgZGV0YWlscykge1xuXG4gIC8vIFdoZW4gdGhlIGxhc3QgYW5pbWF0aW9uIGNvbXBsZXRlcywgc2hvdyB0aGUgbmV4dCBpdGVtIGluIHRoZSBkaXJlY3Rpb25cbiAgLy8gd2UncmUgZ29pbmcuIFdhaXRpbmcgdG8gdGhhdCB1bnRpbCB0aGlzIHBvaW50IGlzIGEgYml0IG9mIGEgaGFjayB0byBhdm9pZFxuICAvLyBoYXZpbmcgYSBuZXh0IGl0ZW0gdGhhdCdzIGhpZ2hlciBpbiB0aGUgbmF0dXJhbCB6LW9yZGVyIG9ic2N1cmUgb3RoZXIgaXRlbXNcbiAgLy8gZHVyaW5nIGFuaW1hdGlvbi5cbiAgY29uc3QgbmV4dFVwSW5kZXggPSBkZXRhaWxzLm5leHRVcEluZGV4O1xuICBpZiAobmV4dFVwSW5kZXggIT0gbnVsbCkge1xuICAgIGlmIChlbGVtZW50W2FuaW1hdGlvblN5bWJvbF1bbmV4dFVwSW5kZXhdKSB7XG4gICAgICAvLyBDYW5jZWwgZXhpc3Rpbmcgc2VsZWN0aW9uIGFuaW1hdGlvbiBzbyB3ZSBjYW4gY29uc3RydWN0IGEgbmV3IG9uZS5cbiAgICAgIGVsZW1lbnRbYW5pbWF0aW9uU3ltYm9sXVtuZXh0VXBJbmRleF0uY2FuY2VsKCk7XG4gICAgICBlbGVtZW50W2FuaW1hdGlvblN5bWJvbF1bbmV4dFVwSW5kZXhdID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uRnJhY3Rpb24gPSBkZXRhaWxzLmZvcndhcmQgPyAwIDogMTtcbiAgICBzZXRBbmltYXRpb25GcmFjdGlvbihlbGVtZW50LCBuZXh0VXBJbmRleCwgYW5pbWF0aW9uRnJhY3Rpb24pO1xuICAgIHNob3dJdGVtKGVsZW1lbnQuaXRlbXNbbmV4dFVwSW5kZXhdLCB0cnVlKTtcbiAgfVxuXG4gIGVsZW1lbnRbbGFzdEFuaW1hdGlvblN5bWJvbF0ub25maW5pc2ggPSBudWxsO1xuICBlbGVtZW50W3BsYXlpbmdBbmltYXRpb25TeW1ib2xdID0gZmFsc2U7XG59XG5cbi8qXG4gKiBQYXVzZSB0aGUgaW5kaWNhdGVkIGFuaW1hdGlvbiBhbmQgaGF2ZSBpdCBzaG93IHRoZSBhbmltYXRpb24gYXQgdGhlIGdpdmVuXG4gKiBmcmFjdGlvbiAoYmV0d2VlbiAwIGFuZCAxKSBvZiB0aGUgd2F5IHRocm91Z2ggdGhlIGFuaW1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2V0QW5pbWF0aW9uRnJhY3Rpb24oZWxlbWVudCwgaXRlbUluZGV4LCBmcmFjdGlvbikge1xuICBjb25zdCBhbmltYXRpb24gPSBnZXRBbmltYXRpb25Gb3JJdGVtSW5kZXgoZWxlbWVudCwgaXRlbUluZGV4KTtcbiAgaWYgKGFuaW1hdGlvbikge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gZWxlbWVudC5zZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvbjtcbiAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgIGFuaW1hdGlvbi5jdXJyZW50VGltZSA9IGZyYWN0aW9uICogZHVyYXRpb247XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNob3dJdGVtKGl0ZW0sIGZsYWcpIHtcbiAgaXRlbS5zdHlsZS52aXNpYmlsaXR5ID0gZmxhZyA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nO1xufVxuXG4vKlxuICogRmlndXJlIG91dCBob3cgbWFueSBzdGVwcyBpdCB3aWxsIHRha2UgdG8gZ28gZnJvbSBmcm9tU2VsZWN0aW9uIHRvXG4gKiB0b1NlbGVjdGlvbi4gVG8gZ28gZnJvbSBpdGVtIDMgdG8gaXRlbSA0IGlzIG9uZSBzdGVwLlxuICpcbiAqIElmIHdyYXBwaW5nIGlzIGFsbG93ZWQsIHRoZW4gZ29pbmcgZnJvbSB0aGUgbGFzdCBpdGVtIHRvIHRoZSBmaXJzdCB3aWxsIHRha2VcbiAqIG9uZSBzdGVwIChmb3J3YXJkKSwgYW5kIGdvaW5nIGZyb20gdGhlIGZpcnN0IGl0ZW0gdG8gdGhlIGxhc3Qgd2lsbCB0YWtlIG9uZVxuICogc3RlcCAoYmFja3dhcmQpLlxuICovXG5mdW5jdGlvbiBzdGVwc1RvSW5kZXgobGVuZ3RoLCBhbGxvd1dyYXAsIGZyb21TZWxlY3Rpb24sIHRvU2VsZWN0aW9uKSB7XG4gIGxldCBzdGVwcyA9IHRvU2VsZWN0aW9uIC0gZnJvbVNlbGVjdGlvbjtcbiAgLy8gV3JhcHBpbmcgb25seSBraWNrcyBpbiB3aGVuIGxpc3QgaGFzIG1vcmUgdGhhbiAxIGl0ZW0uXG4gIGlmIChhbGxvd1dyYXAgJiYgbGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IHdyYXBTdGVwcyA9IGxlbmd0aCAtIE1hdGguYWJzKHN0ZXBzKTtcbiAgICBpZiAod3JhcFN0ZXBzIDw9IDEpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZVxuICAgICAgc3RlcHMgPSBzdGVwcyA8IDAgP1xuICAgICAgICB3cmFwU3RlcHMgOiAgIC8vIFdyYXAgZm9yd2FyZCBmcm9tIGxhc3QgaXRlbSB0byBmaXJzdC5cbiAgICAgICAgLXdyYXBTdGVwczsgICAvLyBXcmFwIGJhY2t3YXJkIGZyb20gZmlyc3QgaXRlbSB0byBsYXN0LlxuICAgIH1cbiAgfVxuICByZXR1cm4gc3RlcHM7XG59XG4iLCJpbXBvcnQgc3ltYm9scyBmcm9tICcuL3N5bWJvbHMnO1xuXG5cbi8vIFVzZWQgdG8gYXNzaWduIHVuaXF1ZSBJRHMgdG8gaXRlbSBlbGVtZW50cyB3aXRob3V0IElEcy5cbmxldCBpZENvdW50ID0gMDtcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIFNlbGVjdGlvbkFyaWFBY3RpdmUuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCB0cmVhdHMgdGhlIHNlbGVjdGVkIGl0ZW0gaW4gYSBsaXN0IGFzIHRoZSBhY3RpdmUgaXRlbSBpbiBBUklBXG4gICAqIGFjY2Vzc2liaWxpdHkgdGVybXMuXG4gICAqXG4gICAqIEhhbmRsaW5nIEFSSUEgc2VsZWN0aW9uIHN0YXRlIHByb3Blcmx5IGlzIGFjdHVhbGx5IHF1aXRlIGNvbXBsZXg6XG4gICAqXG4gICAqICogVGhlIGl0ZW1zIGluIHRoZSBsaXN0IG5lZWQgdG8gYmUgaW5kaWNhdGVkIGFzIHBvc3NpYmxlIGl0ZW1zIHZpYSBhbiBBUklBXG4gICAqICAgYHJvbGVgIGF0dHJpYnV0ZSB2YWx1ZSBzdWNoIGFzIFwib3B0aW9uXCIuXG4gICAqICogVGhlIHNlbGVjdGVkIGl0ZW0gbmVlZCB0byBiZSBtYXJrZWQgYXMgc2VsZWN0ZWQgYnkgc2V0dGluZyB0aGUgaXRlbSdzXG4gICAqICAgYGFyaWEtc2VsZWN0ZWRgIGF0dHJpYnV0ZSB0byB0cnVlICphbmQqIHRoZSBvdGhlciBpdGVtcyBuZWVkIGJlIG1hcmtlZCBhc1xuICAgKiAgICpub3QqIHNlbGVjdGVkIGJ5IHNldHRpbmcgYGFyaWEtc2VsZWN0ZWRgIHRvIGZhbHNlLlxuICAgKiAqIFRoZSBvdXRlcm1vc3QgZWxlbWVudCB3aXRoIHRoZSBrZXlib2FyZCBmb2N1cyBuZWVkcyB0byBoYXZlIGF0dHJpYnV0ZXNcbiAgICogICBzZXQgb24gaXQgc28gdGhhdCB0aGUgc2VsZWN0aW9uIGlzIGtub3dhYmxlIGF0IHRoZSBsaXN0IGxldmVsIHZpYSB0aGVcbiAgICogICBgYXJpYS1hY3RpdmVkZXNjZW5kYW50YCBhdHRyaWJ1dGUuXG4gICAqICogVXNlIG9mIGBhcmlhLWFjdGl2ZWRlc2NlbmRhbnRgIGluIHR1cm4gcmVxdWlyZXMgdGhhdCBhbGwgaXRlbXMgaW4gdGhlXG4gICAqICAgbGlzdCBoYXZlIElEIGF0dHJpYnV0ZXMgYXNzaWduZWQgdG8gdGhlbS5cbiAgICpcbiAgICogVGhpcyBtaXhpbiB0cmllcyB0byBhZGRyZXNzIGFsbCBvZiB0aGUgYWJvdmUgcmVxdWlyZW1lbnRzLiBUbyB0aGF0IGVuZCxcbiAgICogdGhpcyBtaXhpbiB3aWxsIGFzc2lnbiBnZW5lcmF0ZWQgSURzIHRvIGFueSBpdGVtIHRoYXQgZG9lc24ndCBhbHJlYWR5IGhhdmVcbiAgICogYW4gSUQuXG4gICAqXG4gICAqIEFSSUEgcmVsaWVzIG9uIGVsZW1lbnRzIHRvIHByb3ZpZGUgYHJvbGVgIGF0dHJpYnV0ZXMuIFRoaXMgbWl4aW4gd2lsbCBhcHBseVxuICAgKiBhIGRlZmF1bHQgcm9sZSBvZiBcImxpc3Rib3hcIiBvbiB0aGUgb3V0ZXIgbGlzdCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgaGF2ZSBhblxuICAgKiBleHBsaWNpdCByb2xlLiBTaW1pbGFybHksIHRoaXMgbWl4aW4gd2lsbCBhcHBseSBhIGRlZmF1bHQgcm9sZSBvZiBcIm9wdGlvblwiXG4gICAqIHRvIGFueSBsaXN0IGl0ZW0gdGhhdCBkb2VzIG5vdCBhbHJlYWR5IGhhdmUgYSByb2xlIHNwZWNpZmllZC5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBleHBlY3RzIGEgc2V0IG9mIG1lbWJlcnMgdGhhdCBtYW5hZ2UgdGhlIHN0YXRlIG9mIHRoZSBzZWxlY3Rpb246XG4gICAqIGBbc3ltYm9scy5pdGVtU2VsZWN0ZWRdYCwgYGl0ZW1BZGRlZGAsIGFuZCBgc2VsZWN0ZWRJbmRleGAuIFlvdSBjYW5cbiAgICogc3VwcGx5IHRoZXNlIHlvdXJzZWxmLCBvciBkbyBzbyB2aWFcbiAgICogW1NpbmdsZVNlbGVjdGlvbk1peGluXShTaW5nbGVTZWxlY3Rpb25NaXhpbi5tZCkuXG4gICAqL1xuICBjbGFzcyBTZWxlY3Rpb25BcmlhQWN0aXZlIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgICAvLyBTZXQgZGVmYXVsdCBBUklBIHJvbGUuXG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PSBudWxsICYmIHRoaXNbc3ltYm9scy5kZWZhdWx0c10ucm9sZSkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgncm9sZScsIHRoaXNbc3ltYm9scy5kZWZhdWx0c10ucm9sZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IFtzeW1ib2xzLmRlZmF1bHRzXSgpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRzID0gc3VwZXJbc3ltYm9scy5kZWZhdWx0c10gfHwge307XG4gICAgICBkZWZhdWx0cy5yb2xlID0gJ2xpc3Rib3gnO1xuICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLml0ZW1BZGRlZF0oaXRlbSkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuaXRlbUFkZGVkXSkgeyBzdXBlcltzeW1ib2xzLml0ZW1BZGRlZF0oaXRlbSk7IH1cblxuICAgICAgaWYgKCFpdGVtLmdldEF0dHJpYnV0ZSgncm9sZScpKSB7XG4gICAgICAgIC8vIEFzc2lnbiBhIGRlZmF1bHQgQVJJQSByb2xlLlxuICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgncm9sZScsICdvcHRpb24nKTtcbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIGVhY2ggaXRlbSBoYXMgYW4gSUQgc28gd2UgY2FuIHNldCBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQgb24gdGhlXG4gICAgICAvLyBvdmVyYWxsIGxpc3Qgd2hlbmV2ZXIgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBJRCB3aWxsIHRha2UgdGhlIGZvcm0gb2YgYSBiYXNlIElEIHBsdXMgYSB1bmlxdWUgaW50ZWdlci4gVGhlIGJhc2VcbiAgICAgIC8vIElEIHdpbGwgYmUgaW5jb3Jwb3JhdGUgdGhlIGNvbXBvbmVudCdzIG93biBJRC4gRS5nLiwgaWYgYSBjb21wb25lbnQgaGFzXG4gICAgICAvLyBJRCBcImZvb1wiLCB0aGVuIGl0cyBpdGVtcyB3aWxsIGhhdmUgSURzIHRoYXQgbG9vayBsaWtlIFwiX2Zvb09wdGlvbjFcIi4gSWZcbiAgICAgIC8vIHRoZSBjb21wbmVudCBoYXMgbm8gSUQgaXRzZWxmLCBpdHMgaXRlbXMgd2lsbCBnZXQgSURzIHRoYXQgbG9vayBsaWtlXG4gICAgICAvLyBcIl9vcHRpb24xXCIuIEl0ZW0gSURzIGFyZSBwcmVmaXhlZCB3aXRoIGFuIHVuZGVyc2NvcmUgdG8gZGlmZmVyZW50aWF0ZVxuICAgICAgLy8gdGhlbSBmcm9tIG1hbnVhbGx5LWFzc2lnbmVkIElEcywgYW5kIHRvIG1pbmltaXplIHRoZSBwb3RlbnRpYWwgZm9yIElEXG4gICAgICAvLyBjb25mbGljdHMuXG4gICAgICBpZiAoIWl0ZW0uaWQpIHtcbiAgICAgICAgY29uc3QgYmFzZUlkID0gdGhpcy5pZCA/XG4gICAgICAgICAgICBcIl9cIiArIHRoaXMuaWQgKyBcIk9wdGlvblwiIDpcbiAgICAgICAgICAgIFwiX29wdGlvblwiO1xuICAgICAgICBpdGVtLmlkID0gYmFzZUlkICsgaWRDb3VudCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIFtzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgc2VsZWN0ZWQpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1TZWxlY3RlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIHNlbGVjdGVkKTsgfVxuICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG4gICAgICBjb25zdCBpdGVtSWQgPSBpdGVtLmlkO1xuICAgICAgaWYgKGl0ZW1JZCAmJiBzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgaXRlbUlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRJdGVtKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnNlbGVjdGVkSXRlbTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkSXRlbShpdGVtKSB7XG4gICAgICBpZiAoJ3NlbGVjdGVkSXRlbScgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRJdGVtID0gaXRlbTsgfVxuICAgICAgaWYgKGl0ZW0gPT0gbnVsbCkge1xuICAgICAgICAvLyBTZWxlY3Rpb24gd2FzIHJlbW92ZWQuXG4gICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBTZWxlY3Rpb25BcmlhQWN0aXZlO1xufTtcbiIsIi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggU2hhZG93RWxlbWVudFJlZmVyZW5jZXMuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB0byBjcmVhdGUgcmVmZXJlbmNlcyB0byBlbGVtZW50cyBpbiBhIGNvbXBvbmVudCdzIFNoYWRvdyBET00gc3VidHJlZS5cbiAgICpcbiAgICogVGhpcyBhZGRzIGEgbWVtYmVyIG9uIHRoZSBjb21wb25lbnQgY2FsbGVkIGB0aGlzLiRgIHRoYXQgY2FuIGJlIHVzZWQgdG9cbiAgICogcmVmZXJlbmNlIHNoYWRvdyBlbGVtZW50cyB3aXRoIElEcy4gRS5nLiwgaWYgY29tcG9uZW50J3Mgc2hhZG93IGNvbnRhaW5zIGFuXG4gICAqIGVsZW1lbnQgYDxidXR0b24gaWQ9XCJmb29cIj5gLCB0aGVuIHRoaXMgbWl4aW4gd2lsbCBjcmVhdGUgYSBtZW1iZXJcbiAgICogYHRoaXMuJC5mb29gIHRoYXQgcG9pbnRzIHRvIHRoYXQgYnV0dG9uLlxuICAgKlxuICAgKiBTdWNoIHJlZmVyZW5jZXMgc2ltcGxpZnkgYSBjb21wb25lbnQncyBhY2Nlc3MgdG8gaXRzIG93biBlbGVtZW50cy4gSW5cbiAgICogZXhjaGFuZ2UsIHRoaXMgbWl4aW4gdHJhZGVzIG9mZiBhIG9uZS10aW1lIGNvc3Qgb2YgcXVlcnlpbmcgYWxsIGVsZW1lbnRzIGluXG4gICAqIHRoZSBzaGFkb3cgdHJlZSBpbnN0ZWFkIG9mIHBheWluZyBhbiBvbmdvaW5nIGNvc3QgdG8gcXVlcnkgZm9yIGFuIGVsZW1lbnRcbiAgICogZWFjaCB0aW1lIHRoZSBjb21wb25lbnQgd2FudHMgdG8gaW5zcGVjdCBvciBtYW5pcHVsYXRlIGl0LlxuICAgKlxuICAgKiBUaGlzIG1peGluIGV4cGVjdHMgdGhlIGNvbXBvbmVudCB0byBkZWZpbmUgYSBTaGFkb3cgRE9NIHN1YnRyZWUuIFlvdSBjYW5cbiAgICogY3JlYXRlIHRoYXQgdHJlZSB5b3Vyc2VsZiwgb3IgbWFrZSB1c2Ugb2ZcbiAgICogW1NoYWRvd1RlbXBsYXRlTWl4aW5dKFNoYWRvd1RlbXBsYXRlTWl4aW4ubWQpLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGlzIGluc3BpcmVkIGJ5IFBvbHltZXIncyBbYXV0b21hdGljXG4gICAqIG5vZGUgZmluZGluZ10oaHR0cHM6Ly93d3cucG9seW1lci1wcm9qZWN0Lm9yZy8xLjAvZG9jcy9kZXZndWlkZS9sb2NhbC1kb20uaHRtbCNub2RlLWZpbmRpbmcpXG4gICAqIGZlYXR1cmUuXG4gICAqL1xuICBjbGFzcyBTaGFkb3dFbGVtZW50UmVmZXJlbmNlcyBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgaWYgKHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICAvLyBMb29rIGZvciBlbGVtZW50cyBpbiB0aGUgc2hhZG93IHN1YnRyZWUgdGhhdCBoYXZlIGlkIGF0dHJpYnV0ZXMuXG4gICAgICAgIC8vIEFuIGFsdGVybmF0aXZlbHkgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtaXhpbiB3b3VsZCBiZSB0byBqdXN0IGRlZmluZVxuICAgICAgICAvLyBhIHRoaXMuJCBnZXR0ZXIgdGhhdCBsYXppbHkgZG9lcyB0aGlzIHNlYXJjaCB0aGUgZmlyc3QgdGltZSBzb21lb25lXG4gICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyB0aGlzLiQuIFRoYXQgbWlnaHQgaW50cm9kdWNlIHNvbWUgY29tcGxleGl0eSDigJMgaWYgdGhlXG4gICAgICAgIC8vIHRoZSB0cmVlIGNoYW5nZWQgYWZ0ZXIgaXQgd2FzIGZpcnN0IHBvcHVsYXRlZCwgdGhlIHJlc3VsdCBvZlxuICAgICAgICAvLyBzZWFyY2hpbmcgZm9yIGEgbm9kZSBtaWdodCBiZSBzb21ld2hhdCB1bnByZWRpY3RhYmxlLlxuICAgICAgICB0aGlzLiQgPSB7fTtcbiAgICAgICAgY29uc3Qgbm9kZXNXaXRoSWRzID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZF0nKTtcbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKG5vZGVzV2l0aElkcywgbm9kZSA9PiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBub2RlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICB0aGlzLiRbaWRdID0gbm9kZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbGxlY3Rpb24gb2YgcmVmZXJlbmNlcyB0byB0aGUgZWxlbWVudHMgd2l0aCBJRHMgaW4gYSBjb21wb25lbnQnc1xuICAgICAqIFNoYWRvdyBET00gc3VidHJlZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG1lbWJlciAkXG4gICAgICovXG4gIH1cblxuICByZXR1cm4gU2hhZG93RWxlbWVudFJlZmVyZW5jZXM7XG59O1xuIiwiaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi4vc3JjL3N5bWJvbHMnO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggU2hhZG93VGVtcGxhdGUuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiBmb3Igc3RhbXBpbmcgYSB0ZW1wbGF0ZSBpbnRvIGEgU2hhZG93IERPTSBzdWJ0cmVlIHVwb24gY29tcG9uZW50XG4gICAqIGluc3RhbnRpYXRpb24uXG4gICAqXG4gICAqIFRvIHVzZSB0aGlzIG1peGluLCBkZWZpbmUgYSBgdGVtcGxhdGVgIHByb3BlcnR5IGFzIGEgc3RyaW5nIG9yIEhUTUxcbiAgICogYDx0ZW1wbGF0ZT5gIGVsZW1lbnQ6XG4gICAqXG4gICAqICAgICBjbGFzcyBNeUVsZW1lbnQgZXh0ZW5kcyBTaGFkb3dUZW1wbGF0ZU1peGluKEhUTUxFbGVtZW50KSB7XG4gICAqICAgICAgIGdldCBbc3ltYm9scy50ZW1wbGF0ZV0oKSB7XG4gICAqICAgICAgICAgcmV0dXJuIGBIZWxsbywgPGVtPndvcmxkPC9lbT4uYDtcbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKlxuICAgKiBXaGVuIHlvdXIgY29tcG9uZW50IGNsYXNzIGlzIGluc3RhbnRpYXRlZCwgYSBzaGFkb3cgcm9vdCB3aWxsIGJlIGNyZWF0ZWQgb25cbiAgICogdGhlIGluc3RhbmNlLCBhbmQgdGhlIGNvbnRlbnRzIG9mIHRoZSB0ZW1wbGF0ZSB3aWxsIGJlIGNsb25lZCBpbnRvIHRoZVxuICAgKiBzaGFkb3cgcm9vdC4gSWYgeW91ciBjb21wb25lbnQgZG9lcyBub3QgZGVmaW5lIGEgYHRlbXBsYXRlYCBwcm9wZXJ0eSwgdGhpc1xuICAgKiBtaXhpbiBoYXMgbm8gZWZmZWN0LlxuICAgKlxuICAgKiBGb3IgdGhlIHRpbWUgYmVpbmcsIHRoaXMgZXh0ZW5zaW9uIHJldGFpbnMgc3VwcG9ydCBmb3IgU2hhZG93IERPTSB2MC4gVGhhdFxuICAgKiB3aWxsIGV2ZW50dWFsbHkgYmUgZGVwcmVjYXRlZCBhcyBicm93c2VycyAoYW5kIHRoZSBTaGFkb3cgRE9NIHBvbHlmaWxsKVxuICAgKiBpbXBsZW1lbnQgU2hhZG93IERPTSB2MS5cbiAgICovXG4gIGNsYXNzIFNoYWRvd1RlbXBsYXRlIGV4dGVuZHMgYmFzZSB7XG5cbiAgICAvKlxuICAgICAqIElmIHRoZSBjb21wb25lbnQgZGVmaW5lcyBhIHRlbXBsYXRlLCBhIHNoYWRvdyByb290IHdpbGwgYmUgY3JlYXRlZCBvbiB0aGVcbiAgICAgKiBjb21wb25lbnQgaW5zdGFuY2UsIGFuZCB0aGUgdGVtcGxhdGUgc3RhbXBlZCBpbnRvIGl0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXNbc3ltYm9scy50ZW1wbGF0ZV07XG4gICAgICAvLyBUT0RPOiBTYXZlIHRoZSBwcm9jZXNzZWQgdGVtcGxhdGUgd2l0aCB0aGUgY29tcG9uZW50J3MgY2xhc3MgcHJvdG90eXBlXG4gICAgICAvLyBzbyBpdCBkb2Vzbid0IG5lZWQgdG8gYmUgcHJvY2Vzc2VkIHdpdGggZXZlcnkgaW5zdGFudGlhdGlvbi5cbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gVXBncmFkZSBwbGFpbiBzdHJpbmcgdG8gcmVhbCB0ZW1wbGF0ZS5cbiAgICAgICAgICB0ZW1wbGF0ZSA9IGNyZWF0ZVRlbXBsYXRlV2l0aElubmVySFRNTCh0ZW1wbGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2luZG93LlNoYWRvd0RPTVBvbHlmaWxsKSB7XG4gICAgICAgICAgc2hpbVRlbXBsYXRlU3R5bGVzKHRlbXBsYXRlLCB0aGlzLmxvY2FsTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb290ID0gdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgIGNvbnN0IGNsb25lID0gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0ZW1wbGF0ZS5jb250ZW50LCB0cnVlKTtcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gU2hhZG93VGVtcGxhdGU7XG59O1xuXG5cbi8vIENvbnZlcnQgYSBwbGFpbiBzdHJpbmcgb2YgSFRNTCBpbnRvIGEgcmVhbCB0ZW1wbGF0ZSBlbGVtZW50LlxuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVXaXRoSW5uZXJIVE1MKGlubmVySFRNTCkge1xuICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gIC8vIFJFVklFVzogSXMgdGhlcmUgYW4gZWFzaWVyIHdheSB0byBkbyB0aGlzP1xuICAvLyBXZSdkIGxpa2UgdG8ganVzdCBzZXQgaW5uZXJIVE1MIG9uIHRoZSB0ZW1wbGF0ZSBjb250ZW50LCBidXQgc2luY2UgaXQnc1xuICAvLyBhIERvY3VtZW50RnJhZ21lbnQsIHRoYXQgZG9lc24ndCB3b3JrLlxuICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGlubmVySFRNTDtcbiAgd2hpbGUgKGRpdi5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICB0ZW1wbGF0ZS5jb250ZW50LmFwcGVuZENoaWxkKGRpdi5jaGlsZE5vZGVzWzBdKTtcbiAgfVxuICByZXR1cm4gdGVtcGxhdGU7XG59XG5cbi8vIEludm9rZSBiYXNpYyBzdHlsZSBzaGltbWluZyB3aXRoIFNoYWRvd0NTUy5cbmZ1bmN0aW9uIHNoaW1UZW1wbGF0ZVN0eWxlcyh0ZW1wbGF0ZSwgdGFnKSB7XG4gIHdpbmRvdy5XZWJDb21wb25lbnRzLlNoYWRvd0NTUy5zaGltU3R5bGluZyh0ZW1wbGF0ZS5jb250ZW50LCB0YWcpO1xufVxuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuL2NyZWF0ZVN5bWJvbCc7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuL3N5bWJvbHMnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBjYW5TZWxlY3ROZXh0U3ltYm9sID0gY3JlYXRlU3ltYm9sKCdjYW5TZWxlY3ROZXh0Jyk7XG5jb25zdCBjYW5TZWxlY3RQcmV2aW91c1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnY2FuU2VsZWN0UHJldmlvdXMnKTtcbmNvbnN0IHNlbGVjdGlvblJlcXVpcmVkU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdzZWxlY3Rpb25SZXF1aXJlZCcpO1xuY29uc3Qgc2VsZWN0aW9uV3JhcHNTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3NlbGVjdGlvbldyYXBzJyk7XG5cbi8vIFdlIHdhbnQgdG8gZXhwb3NlIGJvdGggc2VsZWN0ZWRJbmRleCBhbmQgc2VsZWN0ZWRJdGVtIGFzIGluZGVwZW5kZW50XG4vLyBwcm9wZXJ0aWVzIGJ1dCBrZWVwIHRoZW0gaW4gc3luYy4gVGhpcyBhbGxvd3MgYSBjb21wb25lbnQgdXNlciB0byByZWZlcmVuY2Vcbi8vIHRoZSBzZWxlY3Rpb24gYnkgd2hhdGV2ZXIgbWVhbnMgaXMgbW9zdCBuYXR1cmFsIGZvciB0aGVpciBzaXR1YXRpb24uXG4vL1xuLy8gVG8gZWZmaWNpZW50bHkga2VlcCB0aGVzZSBwcm9wZXJ0aWVzIGluIHN5bmMsIHdlIHRyYWNrIFwiZXh0ZXJuYWxcIiBhbmRcbi8vIFwiaW50ZXJuYWxcIiByZWZlcmVuY2VzIGZvciBlYWNoIHByb3BlcnR5OlxuLy9cbi8vIFRoZSBleHRlcm5hbCBpbmRleCBvciBpdGVtIGlzIHRoZSBvbmUgd2UgcmVwb3J0IHRvIHRoZSBvdXRzaWRlIHdvcmxkIHdoZW5cbi8vIGFza2VkIGZvciBzZWxlY3Rpb24uICBXaGVuIGhhbmRsaW5nIGEgY2hhbmdlIHRvIGluZGV4IG9yIGl0ZW0sIHdlIHVwZGF0ZSB0aGVcbi8vIGV4dGVybmFsIHJlZmVyZW5jZSBhcyBzb29uIGFzIHBvc3NpYmxlLCBzbyB0aGF0IGlmIGFueW9uZSBpbW1lZGlhdGVseSBhc2tzXG4vLyBmb3IgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLCB0aGV5IHdpbGwgcmVjZWl2ZSBhIHN0YWJsZSBhbnN3ZXIuXG4vL1xuLy8gVGhlIGludGVybmFsIGluZGV4IG9yIGl0ZW0gdHJhY2tzIHdoaWNoZXZlciBpbmRleCBvciBpdGVtIGxhc3QgcmVjZWl2ZWQgdGhlXG4vLyBmdWxsIHNldCBvZiBwcm9jZXNzaW5nLiBQcm9jZXNzaW5nIGluY2x1ZGVzIHJhaXNpbmcgYSBjaGFuZ2UgZXZlbnQgZm9yIHRoZVxuLy8gbmV3IHZhbHVlLiBPbmNlIHdlJ3ZlIGJlZ3VuIHRoYXQgcHJvY2Vzc2luZywgd2Ugc3RvcmUgdGhlIG5ldyB2YWx1ZSBhcyB0aGVcbi8vIGludGVybmFsIHZhbHVlIHRvIGluZGljYXRlIHdlJ3ZlIGhhbmRsZWQgaXQuXG4vL1xuY29uc3QgZXh0ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sID0gY3JlYXRlU3ltYm9sKCdleHRlcm5hbFNlbGVjdGVkSW5kZXgnKTtcbmNvbnN0IGV4dGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdleHRlcm5hbFNlbGVjdGVkSXRlbScpO1xuY29uc3QgaW50ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sID0gY3JlYXRlU3ltYm9sKCdpbnRlcm5hbFNlbGVjdGVkSW5kZXgnKTtcbmNvbnN0IGludGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdpbnRlcm5hbFNlbGVjdGVkSXRlbScpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggU2luZ2xlU2VsZWN0aW9uLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gd2hpY2ggbWFuYWdlcyBzaW5nbGUtc2VsZWN0aW9uIHNlbWFudGljcyBmb3IgaXRlbXMgaW4gYSBsaXN0LlxuICAgKlxuICAgKiBUaGlzIG1peGluIGV4cGVjdHMgYSBjb21wb25lbnQgdG8gcHJvdmlkZSBhbiBgaXRlbXNgIEFycmF5IG9yIE5vZGVMaXN0IG9mXG4gICAqIGFsbCBlbGVtZW50cyBpbiB0aGUgbGlzdC4gQSBzdGFuZGFyZCB3YXkgdG8gZG8gdGhhdCB3aXRoIGlzIHRoZVxuICAgKiBbQ29udGVudEl0ZW1zTWl4aW5dKENvbnRlbnRJdGVtc01peGluLm1kKSwgd2hpY2ggdGFrZXMgYSBjb21wb25lbnQnc1xuICAgKiBjb250ZW50ICh0eXBpY2FsbHkgaXRzIGRpc3RyaWJ1dGVkIGNoaWxkcmVuKSBhcyB0aGUgc2V0IG9mIGxpc3QgaXRlbXM7IHNlZVxuICAgKiB0aGF0IG1peGluIGZvciBkZXRhaWxzLlxuICAgKlxuICAgKiBUaGlzIG1peGluIHRyYWNrcyBhIHNpbmdsZSBzZWxlY3RlZCBpdGVtIGluIHRoZSBsaXN0LCBhbmQgcHJvdmlkZXMgbWVhbnMgdG9cbiAgICogZ2V0IGFuZCBzZXQgdGhhdCBzdGF0ZSBieSBpdGVtIHBvc2l0aW9uIChgc2VsZWN0ZWRJbmRleGApIG9yIGl0ZW0gaWRlbnRpdHlcbiAgICogKGBzZWxlY3RlZEl0ZW1gKS4gVGhlIHNlbGVjdGlvbiBjYW4gYmUgbW92ZWQgaW4gdGhlIGxpc3QgdmlhIHRoZSBtZXRob2RzXG4gICAqIGBzZWxlY3RGaXJzdGAsIGBzZWxlY3RMYXN0YCwgYHNlbGVjdE5leHRgLCBhbmQgYHNlbGVjdFByZXZpb3VzYC5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBkb2VzIG5vdCBwcm9kdWNlIGFueSB1c2VyLXZpc2libGUgZWZmZWN0cyB0byByZXByZXNlbnRcbiAgICogc2VsZWN0aW9uLiBPdGhlciBtaXhpbnMsIHN1Y2ggYXNcbiAgICogW1NlbGVjdGlvbkFyaWFBY3RpdmVNaXhpbl0oU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluLm1kKSxcbiAgICogW1NlbGVjdGlvbkhpZ2hsaWdodE1peGluXShTZWxlY3Rpb25IaWdobGlnaHRNaXhpbi5tZCkgYW5kXG4gICAqIFtTZWxlY3Rpb25JblZpZXdNaXhpbl0oU2VsZWN0aW9uSW5WaWV3TWl4aW4ubWQpLCBtb2RpZnkgdGhlIHNlbGVjdGVkIGl0ZW1cbiAgICogaW4gY29tbW9uIHdheXMgdG8gbGV0IHRoZSB1c2VyIGtub3cgYSBnaXZlbiBpdGVtIGlzIHNlbGVjdGVkIG9yIG5vdFxuICAgKiBzZWxlY3RlZC5cbiAgICovXG4gIGNsYXNzIFNpbmdsZVNlbGVjdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgLy8gU2V0IGRlZmF1bHRzLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlbGVjdGlvblJlcXVpcmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJlcXVpcmVkID0gdGhpc1tzeW1ib2xzLmRlZmF1bHRzXS5zZWxlY3Rpb25SZXF1aXJlZDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zZWxlY3Rpb25XcmFwcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25XcmFwcyA9IHRoaXNbc3ltYm9scy5kZWZhdWx0c10uc2VsZWN0aW9uV3JhcHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGNhbiBiZSBtb3ZlZCB0byB0aGUgbmV4dCBpdGVtLCBmYWxzZSBpZiBub3QgKHRoZVxuICAgICAqIHNlbGVjdGVkIGl0ZW0gaXMgdGhlIGxhc3QgaXRlbSBpbiB0aGUgbGlzdCkuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY2FuU2VsZWN0TmV4dCgpIHtcbiAgICAgIHJldHVybiB0aGlzW2NhblNlbGVjdE5leHRTeW1ib2xdO1xuICAgIH1cbiAgICBzZXQgY2FuU2VsZWN0TmV4dChjYW5TZWxlY3ROZXh0KSB7XG4gICAgICBjb25zdCBwcmV2aW91c0NhblNlbGVjdE5leHQgPSB0aGlzW2NhblNlbGVjdE5leHRTeW1ib2xdO1xuICAgICAgdGhpc1tjYW5TZWxlY3ROZXh0U3ltYm9sXSA9IGNhblNlbGVjdE5leHQ7XG4gICAgICBpZiAoJ2NhblNlbGVjdE5leHQnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLmNhblNlbGVjdE5leHQgPSBjYW5TZWxlY3ROZXh0OyB9XG4gICAgICBpZiAoY2FuU2VsZWN0TmV4dCAhPT0gcHJldmlvdXNDYW5TZWxlY3ROZXh0KSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2Nhbi1zZWxlY3QtbmV4dC1jaGFuZ2VkJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIHNlbGVjdGlvbiBjYW4gYmUgbW92ZWQgdG8gdGhlIHByZXZpb3VzIGl0ZW0sIGZhbHNlIGlmIG5vdFxuICAgICAqICh0aGUgc2VsZWN0ZWQgaXRlbSBpcyB0aGUgZmlyc3Qgb25lIGluIHRoZSBsaXN0KS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjYW5TZWxlY3RQcmV2aW91cygpIHtcbiAgICAgIHJldHVybiB0aGlzW2NhblNlbGVjdFByZXZpb3VzU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IGNhblNlbGVjdFByZXZpb3VzKGNhblNlbGVjdFByZXZpb3VzKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0NhblNlbGVjdFByZXZpb3VzID0gdGhpc1tjYW5TZWxlY3RQcmV2aW91c1N5bWJvbF07XG4gICAgICB0aGlzW2NhblNlbGVjdFByZXZpb3VzU3ltYm9sXSA9IGNhblNlbGVjdFByZXZpb3VzO1xuICAgICAgaWYgKCdjYW5TZWxlY3RQcmV2aW91cycgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuY2FuU2VsZWN0UHJldmlvdXMgPSBjYW5TZWxlY3RQcmV2aW91czsgfVxuICAgICAgaWYgKGNhblNlbGVjdFByZXZpb3VzICE9PSBwcmV2aW91c0NhblNlbGVjdFByZXZpb3VzKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2Nhbi1zZWxlY3QtcHJldmlvdXMtY2hhbmdlZCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgW3N5bWJvbHMuZGVmYXVsdHNdKCkge1xuICAgICAgY29uc3QgZGVmYXVsdHMgPSBzdXBlcltzeW1ib2xzLmRlZmF1bHRzXSB8fCB7fTtcbiAgICAgIGRlZmF1bHRzLnNlbGVjdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgICBkZWZhdWx0cy5zZWxlY3Rpb25XcmFwcyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIG5ldyBpdGVtIGJlaW5nIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2Qgc2ltcGx5IHNldHMgdGhlIGl0ZW0nc1xuICAgICAqIHNlbGVjdGlvbiBzdGF0ZSB0byBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGl0ZW0gLSB0aGUgaXRlbSBiZWluZyBhZGRlZFxuICAgICAqL1xuICAgIFtzeW1ib2xzLml0ZW1BZGRlZF0oaXRlbSkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuaXRlbUFkZGVkXSkgeyBzdXBlcltzeW1ib2xzLml0ZW1BZGRlZF0oaXRlbSk7IH1cbiAgICAgIHRoaXNbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIGl0ZW0gPT09IHRoaXMuc2VsZWN0ZWRJdGVtKTtcbiAgICB9XG5cbiAgICBbc3ltYm9scy5pdGVtc0NoYW5nZWRdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSkgeyBzdXBlcltzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKTsgfVxuXG4gICAgICAvLyBJbiBjYXNlIHNlbGVjdGVkIGl0ZW0gY2hhbmdlZCBwb3NpdGlvbiBvciB3YXMgcmVtb3ZlZC5cbiAgICAgIHRyYWNrU2VsZWN0ZWRJdGVtKHRoaXMpO1xuXG4gICAgICAvLyBJbiBjYXNlIHRoZSBjaGFuZ2UgaW4gaXRlbXMgYWZmZWN0ZWQgd2hpY2ggbmF2aWdhdGlvbnMgYXJlIHBvc3NpYmxlLlxuICAgICAgdXBkYXRlUG9zc2libGVOYXZpZ2F0aW9ucyh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgaW5kaWNhdGUgc2VsZWN0aW9uIHN0YXRlIHRvIHRoZSBpdGVtLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLiBVc2VyLXZpc2libGVcbiAgICAgKiBlZmZlY3RzIHdpbGwgdHlwaWNhbGx5IGJlIGhhbmRsZWQgYnkgb3RoZXIgbWl4aW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaXRlbSAtIHRoZSBpdGVtIGJlaW5nIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkIC0gdHJ1ZSBpZiB0aGUgaXRlbSBpcyBzZWxlY3RlZCwgZmFsc2UgaWYgbm90XG4gICAgICovXG4gICAgW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuaXRlbVNlbGVjdGVkXSkgeyBzdXBlcltzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgc2VsZWN0ZWQpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBpdGVtIHdoaWNoIGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEEgYHNlbGVjdGVkSW5kZXhgIG9mIC0xIGluZGljYXRlcyB0aGVyZSBpcyBubyBzZWxlY3Rpb24uIFNldHRpbmcgdGhpc1xuICAgICAqIHByb3BlcnR5IHRvIC0xIHdpbGwgcmVtb3ZlIGFueSBleGlzdGluZyBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgICAgcmV0dXJuIHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sXSAhPSBudWxsID9cbiAgICAgICAgdGhpc1tleHRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdIDpcbiAgICAgICAgLTE7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEluZGV4KGluZGV4KSB7XG4gICAgICAvLyBTZWUgbm90ZXMgYXQgdG9wIGFib3V0IGludGVybmFsIHZzLiBleHRlcm5hbCBjb3BpZXMgb2YgdGhpcyBwcm9wZXJ0eS5cbiAgICAgIGNvbnN0IHByZXZpb3VzU2VsZWN0ZWRJbmRleCA9IHRoaXNbaW50ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sXTtcbiAgICAgIGxldCBpdGVtO1xuICAgICAgaWYgKGluZGV4ICE9PSB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJbmRleFN5bWJvbF0pIHtcbiAgICAgICAgLy8gU3RvcmUgdGhlIG5ldyBpbmRleCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgaXRlbS5cbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICBjb25zdCBoYXNJdGVtcyA9IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmICghKGhhc0l0ZW1zICYmIGluZGV4ID49IDAgJiYgaW5kZXggPCBpdGVtcy5sZW5ndGgpKSB7XG4gICAgICAgICAgaW5kZXggPSAtMTsgLy8gTm8gaXRlbSBhdCB0aGF0IGluZGV4LlxuICAgICAgICB9XG4gICAgICAgIHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sXSA9IGluZGV4O1xuICAgICAgICBpdGVtID0gaGFzSXRlbXMgJiYgaW5kZXggPj0gMCA/IGl0ZW1zW2luZGV4XSA6IG51bGw7XG4gICAgICAgIHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2xdID0gaXRlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sXTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93IGxldCBzdXBlciBkbyBhbnkgd29yay5cbiAgICAgIGlmICgnc2VsZWN0ZWRJbmRleCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRJbmRleCA9IGluZGV4OyB9XG5cbiAgICAgIGlmIChpbmRleCAhPT0gcHJldmlvdXNTZWxlY3RlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoZSBzZWxlY3RlZCBpbmRleCBjaGFuZ2VkLlxuICAgICAgICB0aGlzW2ludGVybmFsU2VsZWN0ZWRJbmRleFN5bWJvbF0gPSBpbmRleDtcblxuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc2VsZWN0ZWQtaW5kZXgtY2hhbmdlZCcsIHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgdmFsdWU6IGluZGV4IC8vIGZvciBQb2x5bWVyIGJpbmRpbmcuIFRPRE86IFZlcmlmeSBzdGlsbCBuZWNlc3NhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tpbnRlcm5hbFNlbGVjdGVkSXRlbVN5bWJvbF0gIT09IGl0ZW0pIHtcbiAgICAgICAgLy8gVXBkYXRlIHNlbGVjdGVkSXRlbSBwcm9wZXJ0eSBzbyBpdCBjYW4gaGF2ZSBpdHMgb3duIGVmZmVjdHMuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0sIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uLlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIG51bGwgZGVzZWxlY3RzIGFueSBjdXJyZW50bHktc2VsZWN0ZWQgaXRlbS5cbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gYW4gb2JqZWN0IHRoYXQgaXMgbm90IGluIHRoZSBsaXN0IGhhcyBubyBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBUT0RPOiBFdmVuIGlmIHNlbGVjdGlvblJlcXVpcmVkLCBjYW4gc3RpbGwgZXhwbGljaXRseSBzZXQgc2VsZWN0ZWRJdGVtIHRvIG51bGwuXG4gICAgICogVE9ETzogSWYgc2VsZWN0aW9uUmVxdWlyZWQsIGxlYXZlIHNlbGVjdGlvbiBhbG9uZT9cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkSXRlbSgpIHtcbiAgICAgIHJldHVybiB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sXSB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWRJdGVtKGl0ZW0pIHtcbiAgICAgIC8vIFNlZSBub3RlcyBhdCB0b3AgYWJvdXQgaW50ZXJuYWwgdnMuIGV4dGVybmFsIGNvcGllcyBvZiB0aGlzIHByb3BlcnR5LlxuICAgICAgY29uc3QgcHJldmlvdXNTZWxlY3RlZEl0ZW0gPSB0aGlzW2ludGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sXTtcbiAgICAgIGxldCBpbmRleDtcbiAgICAgIGlmIChpdGVtICE9PSB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sXSkge1xuICAgICAgICAvLyBTdG9yZSBpdGVtIGFuZCBsb29rIHVwIGNvcnJlc3BvbmRpbmcgaW5kZXguXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICAgICAgY29uc3QgaGFzSXRlbXMgPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPiAwO1xuICAgICAgICBpbmRleCA9IGhhc0l0ZW1zID8gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChpdGVtcywgaXRlbSkgOiAtMTtcbiAgICAgICAgdGhpc1tleHRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdID0gaW5kZXg7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpdGVtID0gbnVsbDsgLy8gVGhlIGluZGljYXRlZCBpdGVtIGlzbid0IGFjdHVhbGx5IGluIGBpdGVtc2AuXG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tleHRlcm5hbFNlbGVjdGVkSXRlbVN5bWJvbF0gPSBpdGVtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJbmRleFN5bWJvbF07XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyBsZXQgc3VwZXIgZG8gYW55IHdvcmsuXG4gICAgICBpZiAoJ3NlbGVjdGVkSXRlbScgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRJdGVtID0gaXRlbTsgfVxuXG4gICAgICBpZiAoaXRlbSAhPT0gcHJldmlvdXNTZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdGVkIGl0ZW0gY2hhbmdlZC5cbiAgICAgICAgdGhpc1tpbnRlcm5hbFNlbGVjdGVkSXRlbVN5bWJvbF0gPSBpdGVtO1xuXG4gICAgICAgIGlmIChwcmV2aW91c1NlbGVjdGVkSXRlbSkge1xuICAgICAgICAgIC8vIFVwZGF0ZSBzZWxlY3Rpb24gc3RhdGUgb2Ygb2xkIGl0ZW0uXG4gICAgICAgICAgdGhpc1tzeW1ib2xzLml0ZW1TZWxlY3RlZF0ocHJldmlvdXNTZWxlY3RlZEl0ZW0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgIC8vIFVwZGF0ZSBzZWxlY3Rpb24gc3RhdGUgdG8gbmV3IGl0ZW0uXG4gICAgICAgICAgdGhpc1tzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVQb3NzaWJsZU5hdmlnYXRpb25zKHRoaXMpO1xuXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzZWxlY3RlZC1pdGVtLWNoYW5nZWQnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBzZWxlY3RlZEl0ZW06IGl0ZW0sXG4gICAgICAgICAgICB2YWx1ZTogaXRlbSAvLyBmb3IgUG9seW1lciBiaW5kaW5nXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbaW50ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sXSAhPT0gaW5kZXgpIHtcbiAgICAgICAgLy8gVXBkYXRlIHNlbGVjdGVkSW5kZXggcHJvcGVydHkgc28gaXQgY2FuIGhhdmUgaXRzIG93biBlZmZlY3RzLlxuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICovXG4gICAgc2VsZWN0Rmlyc3QoKSB7XG4gICAgICBpZiAoc3VwZXIuc2VsZWN0Rmlyc3QpIHsgc3VwZXIuc2VsZWN0Rmlyc3QoKTsgfVxuICAgICAgcmV0dXJuIHNlbGVjdEluZGV4KHRoaXMsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGxpc3Qgc2hvdWxkIGFsd2F5cyBoYXZlIGEgc2VsZWN0aW9uIChpZiBpdCBoYXMgaXRlbXMpLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uUmVxdWlyZWQoKSB7XG4gICAgICByZXR1cm4gdGhpc1tzZWxlY3Rpb25SZXF1aXJlZFN5bWJvbF07XG4gICAgfVxuICAgIHNldCBzZWxlY3Rpb25SZXF1aXJlZChzZWxlY3Rpb25SZXF1aXJlZCkge1xuICAgICAgdGhpc1tzZWxlY3Rpb25SZXF1aXJlZFN5bWJvbF0gPSBzZWxlY3Rpb25SZXF1aXJlZDtcbiAgICAgIGlmICgnc2VsZWN0aW9uUmVxdWlyZWQnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGlvblJlcXVpcmVkID0gc2VsZWN0aW9uUmVxdWlyZWQ7IH1cbiAgICAgIHRyYWNrU2VsZWN0ZWRJdGVtKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgc2VsZWN0aW9uIG5hdmlnYXRpb25zIHdyYXAgZnJvbSBsYXN0IHRvIGZpcnN0LCBhbmQgdmljZSB2ZXJzYS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbldyYXBzKCkge1xuICAgICAgcmV0dXJuIHRoaXNbc2VsZWN0aW9uV3JhcHNTeW1ib2xdO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0aW9uV3JhcHModmFsdWUpIHtcbiAgICAgIHRoaXNbc2VsZWN0aW9uV3JhcHNTeW1ib2xdID0gU3RyaW5nKHZhbHVlKSA9PT0gJ3RydWUnO1xuICAgICAgaWYgKCdzZWxlY3Rpb25XcmFwcycgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0aW9uV3JhcHMgPSB2YWx1ZTsgfVxuICAgICAgdXBkYXRlUG9zc2libGVOYXZpZ2F0aW9ucyh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIGxhc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBzZWxlY3RMYXN0KCkge1xuICAgICAgaWYgKHN1cGVyLnNlbGVjdExhc3QpIHsgc3VwZXIuc2VsZWN0TGFzdCgpOyB9XG4gICAgICByZXR1cm4gc2VsZWN0SW5kZXgodGhpcywgdGhpcy5pdGVtcy5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIG5leHQgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBzZWxlY3ROZXh0KCkge1xuICAgICAgaWYgKHN1cGVyLnNlbGVjdE5leHQpIHsgc3VwZXIuc2VsZWN0TmV4dCgpOyB9XG4gICAgICByZXR1cm4gc2VsZWN0SW5kZXgodGhpcywgdGhpcy5zZWxlY3RlZEluZGV4ICsgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRoZSBwcmV2aW91cyBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogSWYgdGhlIGxpc3QgaGFzIG5vIHNlbGVjdGlvbiwgdGhlIGxhc3QgaXRlbSB3aWxsIGJlIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIHNlbGVjdFByZXZpb3VzKCkge1xuICAgICAgaWYgKHN1cGVyLnNlbGVjdFByZXZpb3VzKSB7IHN1cGVyLnNlbGVjdFByZXZpb3VzKCk7IH1cbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4IDwgMCA/XG4gICAgICAgIHRoaXMuaXRlbXMubGVuZ3RoIC0gMSA6ICAgICAvLyBObyBzZWxlY3Rpb24geWV0OyBzZWxlY3QgbGFzdCBpdGVtLlxuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggLSAxO1xuICAgICAgcmV0dXJuIHNlbGVjdEluZGV4KHRoaXMsIG5ld0luZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBzZWxlY3RlZEl0ZW0gcHJvcGVydHkgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBTaW5nbGVTZWxlY3Rpb25cbiAgICAgKiBAZXZlbnQgc2VsZWN0ZWQtaXRlbS1jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGV0YWlsLnNlbGVjdGVkSXRlbSBUaGUgbmV3IHNlbGVjdGVkIGl0ZW0uXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGV0YWlsLnByZXZpb3VzSXRlbSBUaGUgcHJldmlvdXNseSBzZWxlY3RlZCBpdGVtLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFNpbmdsZVNlbGVjdGlvblxuICAgICAqIEBldmVudCBzZWxlY3RlZC1pbmRleC1jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRldGFpbC5zZWxlY3RlZEluZGV4IFRoZSBuZXcgc2VsZWN0ZWQgaW5kZXguXG4gICAgICovXG5cbiAgfVxuXG4gIHJldHVybiBTaW5nbGVTZWxlY3Rpb247XG59O1xuXG5cbi8vIEVuc3VyZSB0aGUgZ2l2ZW4gaW5kZXggaXMgd2l0aGluIGJvdW5kcywgYW5kIHNlbGVjdCBpdCBpZiBpdCdzIG5vdCBhbHJlYWR5XG4vLyBzZWxlY3RlZC5cbmZ1bmN0aW9uIHNlbGVjdEluZGV4KGVsZW1lbnQsIGluZGV4KSB7XG4gIGNvbnN0IGNvdW50ID0gZWxlbWVudC5pdGVtcy5sZW5ndGg7XG5cbiAgY29uc3QgYm91bmRlZEluZGV4ID0gKGVsZW1lbnQuc2VsZWN0aW9uV3JhcHMpID9cbiAgICAvLyBKYXZhU2NyaXB0IG1vZCBkb2Vzbid0IGhhbmRsZSBuZWdhdGl2ZSBudW1iZXJzIHRoZSB3YXkgd2Ugd2FudCB0byB3cmFwLlxuICAgIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xODYxODI1MC83NjQ3MlxuICAgICgoaW5kZXggJSBjb3VudCkgKyBjb3VudCkgJSBjb3VudCA6XG5cbiAgICAvLyBLZWVwIGluZGV4IHdpdGhpbiBib3VuZHMgb2YgYXJyYXkuXG4gICAgTWF0aC5tYXgoTWF0aC5taW4oaW5kZXgsIGNvdW50IC0gMSksIDApO1xuXG4gIGNvbnN0IHByZXZpb3VzSW5kZXggPSBlbGVtZW50LnNlbGVjdGVkSW5kZXg7XG4gIGlmIChwcmV2aW91c0luZGV4ICE9PSBib3VuZGVkSW5kZXgpIHtcbiAgICBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSBib3VuZGVkSW5kZXg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEZvbGxvd2luZyBhIGNoYW5nZSBpbiB0aGUgc2V0IG9mIGl0ZW1zLCBvciBpbiB0aGUgdmFsdWUgb2YgdGhlXG4vLyBgc2VsZWN0aW9uUmVxdWlyZWRgIHByb3BlcnR5LCByZWFjcXVpcmUgdGhlIHNlbGVjdGVkIGl0ZW0uIElmIGl0J3MgbW92ZWQsXG4vLyB1cGRhdGUgYHNlbGVjdGVkSW5kZXhgLiBJZiBpdCdzIGJlZW4gcmVtb3ZlZCwgYW5kIGEgc2VsZWN0aW9uIGlzIHJlcXVpcmVkLFxuLy8gdHJ5IHRvIHNlbGVjdCBhbm90aGVyIGl0ZW0uXG5mdW5jdGlvbiB0cmFja1NlbGVjdGVkSXRlbShlbGVtZW50KSB7XG5cbiAgY29uc3QgaXRlbXMgPSBlbGVtZW50Lml0ZW1zO1xuICBjb25zdCBpdGVtQ291bnQgPSBpdGVtcyA/IGl0ZW1zLmxlbmd0aCA6IDA7XG5cbiAgY29uc3QgcHJldmlvdXNTZWxlY3RlZEl0ZW0gPSBlbGVtZW50LnNlbGVjdGVkSXRlbTtcbiAgaWYgKCFwcmV2aW91c1NlbGVjdGVkSXRlbSkge1xuICAgIC8vIE5vIGl0ZW0gd2FzIHByZXZpb3VzbHkgc2VsZWN0ZWQuXG4gICAgaWYgKGVsZW1lbnQuc2VsZWN0aW9uUmVxdWlyZWQpIHtcbiAgICAgIC8vIFNlbGVjdCB0aGUgZmlyc3QgaXRlbSBieSBkZWZhdWx0LlxuICAgICAgZWxlbWVudC5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlbUNvdW50ID09PSAwKSB7XG4gICAgLy8gV2UndmUgbG9zdCB0aGUgc2VsZWN0aW9uLCBhbmQgdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gc2VsZWN0LlxuICAgIGVsZW1lbnQuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUcnkgdG8gZmluZCB0aGUgcHJldmlvdXNseS1zZWxlY3RlZCBpdGVtIGluIHRoZSBjdXJyZW50IHNldCBvZiBpdGVtcy5cbiAgICBjb25zdCBpbmRleEluQ3VycmVudEl0ZW1zID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChpdGVtcywgcHJldmlvdXNTZWxlY3RlZEl0ZW0pO1xuICAgIGNvbnN0IHByZXZpb3VzU2VsZWN0ZWRJbmRleCA9IGVsZW1lbnQuc2VsZWN0ZWRJbmRleDtcbiAgICBpZiAoaW5kZXhJbkN1cnJlbnRJdGVtcyA8IDApIHtcbiAgICAgIC8vIFByZXZpb3VzbHktc2VsZWN0ZWQgaXRlbSB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBpdGVtcy5cbiAgICAgIC8vIFNlbGVjdCB0aGUgaXRlbSBhdCB0aGUgc2FtZSBpbmRleCAoaWYgaXQgZXhpc3RzKSBvciBhcyBjbG9zZSBhcyBwb3NzaWJsZS5cbiAgICAgIGNvbnN0IG5ld1NlbGVjdGVkSW5kZXggPSBNYXRoLm1pbihwcmV2aW91c1NlbGVjdGVkSW5kZXgsIGl0ZW1Db3VudCAtIDEpO1xuICAgICAgLy8gU2VsZWN0IGJ5IGl0ZW0sIHNpbmNlIGluZGV4IG1heSBiZSB0aGUgc2FtZSwgYW5kIHdlIHdhbnQgdG8gcmFpc2UgdGhlXG4gICAgICAvLyBzZWxlY3RlZC1pdGVtLWNoYW5nZWQgZXZlbnQuXG4gICAgICBlbGVtZW50LnNlbGVjdGVkSXRlbSA9IGl0ZW1zW25ld1NlbGVjdGVkSW5kZXhdO1xuICAgIH0gZWxzZSBpZiAoaW5kZXhJbkN1cnJlbnRJdGVtcyAhPT0gcHJldmlvdXNTZWxlY3RlZEluZGV4KSB7XG4gICAgICAvLyBQcmV2aW91c2x5LXNlbGVjdGVkIGl0ZW0gc3RpbGwgdGhlcmUsIGJ1dCBjaGFuZ2VkIHBvc2l0aW9uLlxuICAgICAgZWxlbWVudC5zZWxlY3RlZEluZGV4ID0gaW5kZXhJbkN1cnJlbnRJdGVtcztcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9sbG93aW5nIGEgY2hhbmdlIGluIHNlbGVjdGlvbiwgcmVwb3J0IHdoZXRoZXIgaXQncyBub3cgcG9zc2libGUgdG9cbi8vIGdvIG5leHQvcHJldmlvdXMgZnJvbSB0aGUgZ2l2ZW4gaW5kZXguXG5mdW5jdGlvbiB1cGRhdGVQb3NzaWJsZU5hdmlnYXRpb25zKGVsZW1lbnQpIHtcbiAgbGV0IGNhblNlbGVjdE5leHQ7XG4gIGxldCBjYW5TZWxlY3RQcmV2aW91cztcbiAgY29uc3QgaXRlbXMgPSBlbGVtZW50Lml0ZW1zO1xuICBpZiAoaXRlbXMgPT0gbnVsbCB8fCBpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBObyBpdGVtcyB0byBzZWxlY3QuXG4gICAgY2FuU2VsZWN0TmV4dCA9IGZhbHNlO1xuICAgIGNhblNlbGVjdFByZXZpb3VzID0gZmFsc2U7XG4gIH0gaWYgKGVsZW1lbnQuc2VsZWN0aW9uV3JhcHMpIHtcbiAgICAvLyBTaW5jZSB0aGVyZSBhcmUgaXRlbXMsIGNhbiBhbHdheXMgZ28gbmV4dC9wcmV2aW91cy5cbiAgICBjYW5TZWxlY3ROZXh0ID0gdHJ1ZTtcbiAgICBjYW5TZWxlY3RQcmV2aW91cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaW5kZXggPSBlbGVtZW50LnNlbGVjdGVkSW5kZXg7XG4gICAgaWYgKGluZGV4IDwgMCAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UuIElmIHRoZXJlIGFyZSBpdGVtcyBidXQgbm8gc2VsZWN0aW9uLCBkZWNsYXJlIHRoYXQgaXQnc1xuICAgICAgLy8gYWx3YXlzIHBvc3NpYmxlIHRvIGdvIG5leHQvcHJldmlvdXMgdG8gY3JlYXRlIGEgc2VsZWN0aW9uLlxuICAgICAgY2FuU2VsZWN0TmV4dCA9IHRydWU7XG4gICAgICBjYW5TZWxlY3RQcmV2aW91cyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vcm1hbCBjYXNlOiB3ZSBoYXZlIGFuIGluZGV4IGluIGEgbGlzdCB0aGF0IGhhcyBpdGVtcy5cbiAgICAgIGNhblNlbGVjdFByZXZpb3VzID0gKGluZGV4ID4gMCk7XG4gICAgICBjYW5TZWxlY3ROZXh0ID0gKGluZGV4IDwgaXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICB9XG4gIGlmIChlbGVtZW50LmNhblNlbGVjdE5leHQgIT09IGNhblNlbGVjdE5leHQpIHtcbiAgICBlbGVtZW50LmNhblNlbGVjdE5leHQgPSBjYW5TZWxlY3ROZXh0O1xuICB9XG4gIGlmIChlbGVtZW50LmNhblNlbGVjdFByZXZpb3VzICE9PSBjYW5TZWxlY3RQcmV2aW91cykge1xuICAgIGVsZW1lbnQuY2FuU2VsZWN0UHJldmlvdXMgPSBjYW5TZWxlY3RQcmV2aW91cztcbiAgfVxufVxuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuL2NyZWF0ZVN5bWJvbCc7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuL3N5bWJvbHMnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBkZWx0YVhTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2RlbHRhWCcpO1xuY29uc3QgZGVsdGFZU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdkZWx0YVknKTtcbmNvbnN0IG11bHRpVG91Y2hTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ211bHRpVG91Y2gnKTtcbmNvbnN0IHByZXZpb3VzWFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncHJldmlvdXNYJyk7XG5jb25zdCBwcmV2aW91c1lTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3ByZXZpb3VzWScpO1xuY29uc3Qgc3RhcnRYU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdzdGFydFgnKTtcbmNvbnN0IHRyYXZlbEZyYWN0aW9uU3ltYm9sID0gY3JlYXRlU3ltYm9sKCd0cmF2ZWxGcmFjdGlvbicpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggU3dpcGVEaXJlY3Rpb24uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYXBzIHRvdWNoIGdlc3R1cmVzIChzd2lwZSBsZWZ0LCBzd2lwZSByaWdodCkgdG8gZGlyZWN0aW9uXG4gICAqIHNlbWFudGljcyAoZ28gcmlnaHQsIGdvIGxlZnQpLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIG1peGluIHByZXNlbnRzIG5vIHVzZXItdmlzaWJsZSBlZmZlY3RzOyBpdCBqdXN0IGluZGljYXRlc1xuICAgKiBhIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgdXNlciBpcyBjdXJyZW50bHkgc3dpcGluZyBvciBoYXMgZmluaXNoZWQgc3dpcGluZy5cbiAgICogVG8gbWFwIHRoZSBkaXJlY3Rpb24gdG8gYSBjaGFuZ2UgaW4gc2VsZWN0aW9uLCB1c2VcbiAgICogW0RpcmVjdGlvblNlbGVjdGlvbk1peGluXShEaXJlY3Rpb25TZWxlY3Rpb25NaXhpbi5tZCkuXG4gICAqL1xuICBjbGFzcyBTd2lwZURpcmVjdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICB0aGlzLnRyYXZlbEZyYWN0aW9uID0gMDtcblxuICAgICAgLy8gSW4gYWxsIHRvdWNoIGV2ZW50cywgb25seSBoYW5kbGUgc2luZ2xlIHRvdWNoZXMuIFdlIGRvbid0IHdhbnQgdG9cbiAgICAgIC8vIGluYWR2ZXJ0ZW50bHkgZG8gd29yayB3aGVuIHRoZSB1c2VyJ3MgdHJ5aW5nIHRvIHBpbmNoLXpvb20gZm9yIGV4YW1wbGUuXG4gICAgICAvLyBUT0RPOiBFdmVuIGJldHRlciBhcHByb2FjaCB0aGFuIGJlbG93IHdvdWxkIGJlIHRvIGlnbm9yZSB0b3VjaGVzIGFmdGVyXG4gICAgICAvLyB0aGUgZmlyc3QgaWYgdGhlIHVzZXIgaGFzIGFscmVhZHkgYmVndW4gYSBzd2lwZS5cbiAgICAgIC8vIFRPRE86IFRvdWNoIGV2ZW50cyBzaG91bGQgcHJvYmFibHkgYmUgZmFjdG9yZWQgb3V0IGludG8gaXRzIG93biBtaXhpbi5cbiAgICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIC8vIFByZWZlciBsaXN0ZW5pbmcgdG8gc3RhbmRhcmQgcG9pbnRlciBldmVudHMuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKGlzRXZlbnRGb3JQZW5PclByaW1hcnlUb3VjaChldmVudCkpIHtcbiAgICAgICAgICAgIHRvdWNoU3RhcnQodGhpcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoaXNFdmVudEZvclBlbk9yUHJpbWFyeVRvdWNoKGV2ZW50KSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlZCA9IHRvdWNoTW92ZSh0aGlzLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKGlzRXZlbnRGb3JQZW5PclByaW1hcnlUb3VjaChldmVudCkpIHtcbiAgICAgICAgICAgIHRvdWNoRW5kKHRoaXMsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQb2ludGVyIGV2ZW50cyBub3Qgc3VwcG9ydGVkIC0tIGxpc3RlbiB0byBvbGRlciB0b3VjaCBldmVudHMuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAodGhpc1ttdWx0aVRvdWNoU3ltYm9sXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudFggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50WSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgICAgICB0b3VjaFN0YXJ0KHRoaXMsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW211bHRpVG91Y2hTeW1ib2xdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXNbbXVsdGlUb3VjaFN5bWJvbF0gJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudFggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50WSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVkID0gdG91Y2hNb3ZlKHRoaXMsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQWxsIHRvdWNoZXMgcmVtb3ZlZDsgZ2VzdHVyZSBpcyBjb21wbGV0ZS5cbiAgICAgICAgICAgIGlmICghdGhpc1ttdWx0aVRvdWNoU3ltYm9sXSkge1xuICAgICAgICAgICAgICAvLyBTaW5nbGUtdG91Y2ggc3dpcGUgaGFzIGZpbmlzaGVkLlxuICAgICAgICAgICAgICBjb25zdCBjbGllbnRYID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgICAgICAgY29uc3QgY2xpZW50WSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgICAgICAgIHRvdWNoRW5kKHRoaXMsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1ttdWx0aVRvdWNoU3ltYm9sXSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBpZiAoc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2spIHsgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTsgfVxuXG4gICAgICAvLyBGb3IgdGhlIGNvbXBvbmVudCB0byByZWNlaXZlIFBvaW50ZXJFdmVudHMgaW4gSUUvRWRnZSwgd2UgbmVlZCB0byBzZXRcbiAgICAgIC8vIHRvdWNoLWFjdGlvbjogbm9uZS4gT25seSBtYWtlIHRoaXMgY2hhbmdlIGlmIHRvdWNoLWFjdGlvbiBpcyBjdXJyZW50bHlcbiAgICAgIC8vIHRoZSBkZWZhdWx0IHZhbHVlIChcImF1dG9cIiksIGluIGNhc2UgdGhlIGRldmVsb3BlciBrbm93cyBiZXR0ZXIgdGhhbiB3ZVxuICAgICAgLy8gZG8gd2hhdCB0aGV5IHdhbnQgaW4gdGhlaXIgcGFydGljdWxhciBjb250ZXh0LlxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUodGhpcykudG91Y2hBY3Rpb24gPT09ICdhdXRvJykge1xuICAgICAgICB0aGlzLnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24uXG4gICAgZ2V0IFtzeW1ib2xzLmRyYWdnaW5nXSgpIHtcbiAgICAgIHJldHVybiBzdXBlcltzeW1ib2xzLmRyYWdnaW5nXTtcbiAgICB9XG4gICAgc2V0IFtzeW1ib2xzLmRyYWdnaW5nXSh2YWx1ZSkge1xuICAgICAgaWYgKHN5bWJvbHMuZHJhZ2dpbmcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXJbc3ltYm9scy5kcmFnZ2luZ10gPSB2YWx1ZTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSBsZWZ0LlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBbc3ltYm9scy5nb0xlZnRdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuZ29MZWZ0XSkgeyByZXR1cm4gc3VwZXJbc3ltYm9scy5nb0xlZnRdKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgcmlnaHQuXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgICAqL1xuICAgIFtzeW1ib2xzLmdvUmlnaHRdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuZ29SaWdodF0pIHsgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZ29SaWdodF0oKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXN0YW5jZSB0aGUgZmlyc3QgdG91Y2hwb2ludCBoYXMgdHJhdmVsZWQgc2luY2UgdGhlIGJlZ2lubmluZyBvZiBhXG4gICAgICogZHJhZywgZXhwcmVzc2VkIGFzIGEgZnJhY3Rpb24gb2YgdGhlIGVsZW1lbnQncyB3aWR0aC5cbiAgICAgKlxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuICAgIGdldCB0cmF2ZWxGcmFjdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzW3RyYXZlbEZyYWN0aW9uU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IHRyYXZlbEZyYWN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzW3RyYXZlbEZyYWN0aW9uU3ltYm9sXSA9IHZhbHVlO1xuICAgICAgaWYgKCd0cmF2ZWxGcmFjdGlvbicgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIudHJhdmVsRnJhY3Rpb24gPSB2YWx1ZTsgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFN3aXBlRGlyZWN0aW9uO1xufTtcblxuXG4vLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgcG9pbnRlciBldmVudCBpcyBmb3IgdGhlIHBlbiwgb3IgdGhlIHByaW1hcnkgdG91Y2ggcG9pbnQuXG5mdW5jdGlvbiBpc0V2ZW50Rm9yUGVuT3JQcmltYXJ5VG91Y2goZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnBvaW50ZXJUeXBlID09PSAncGVuJyB8fFxuICAgICAgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnICYmIGV2ZW50LmlzUHJpbWFyeSk7XG59XG5cbi8qXG4gKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgaGFzIGZpbmlzaGVkIGEgdG91Y2ggb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiB0b3VjaEVuZChlbGVtZW50LCBjbGllbnRYLCBjbGllbnRZKSB7XG4gIGVsZW1lbnRbc3ltYm9scy5kcmFnZ2luZ10gPSBmYWxzZTtcbiAgaWYgKGVsZW1lbnRbZGVsdGFYU3ltYm9sXSA+PSAyMCkge1xuICAgIC8vIEZpbmlzaGVkIGdvaW5nIHJpZ2h0IGF0IGhpZ2ggc3BlZWQuXG4gICAgZWxlbWVudFtzeW1ib2xzLmdvTGVmdF0oKTtcbiAgfSBlbHNlIGlmIChlbGVtZW50W2RlbHRhWFN5bWJvbF0gPD0gLTIwKSB7XG4gICAgLy8gRmluaXNoZWQgZ29pbmcgbGVmdCBhdCBoaWdoIHNwZWVkLlxuICAgIGVsZW1lbnRbc3ltYm9scy5nb1JpZ2h0XSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZpbmlzaGVkIGF0IGxvdyBzcGVlZC5cbiAgICB0cmFja1RvKGVsZW1lbnQsIGNsaWVudFgpO1xuICAgIGNvbnN0IHRyYXZlbEZyYWN0aW9uID0gZWxlbWVudC50cmF2ZWxGcmFjdGlvbjtcbiAgICBpZiAodHJhdmVsRnJhY3Rpb24gPj0gMC41KSB7XG4gICAgICBlbGVtZW50W3N5bWJvbHMuZ29SaWdodF0oKTtcbiAgICB9IGVsc2UgaWYgKHRyYXZlbEZyYWN0aW9uIDw9IC0wLjUpIHtcbiAgICAgIGVsZW1lbnRbc3ltYm9scy5nb0xlZnRdKCk7XG4gICAgfVxuICB9XG4gIGVsZW1lbnQudHJhdmVsRnJhY3Rpb24gPSAwO1xuICBlbGVtZW50W2RlbHRhWFN5bWJvbF0gPSBudWxsO1xuICBlbGVtZW50W2RlbHRhWVN5bWJvbF0gPSBudWxsO1xufVxuXG4vKlxuICogSW52b2tlZCB3aGVuIHRoZSB1c2VyIGhhcyBtb3ZlZCBkdXJpbmcgYSB0b3VjaCBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHRvdWNoTW92ZShlbGVtZW50LCBjbGllbnRYLCBjbGllbnRZKSB7XG5cbiAgZWxlbWVudFtkZWx0YVhTeW1ib2xdID0gY2xpZW50WCAtIGVsZW1lbnRbcHJldmlvdXNYU3ltYm9sXTtcbiAgZWxlbWVudFtkZWx0YVlTeW1ib2xdID0gY2xpZW50WSAtIGVsZW1lbnRbcHJldmlvdXNZU3ltYm9sXTtcbiAgZWxlbWVudFtwcmV2aW91c1hTeW1ib2xdID0gY2xpZW50WDtcbiAgZWxlbWVudFtwcmV2aW91c1lTeW1ib2xdID0gY2xpZW50WTtcbiAgaWYgKE1hdGguYWJzKGVsZW1lbnRbZGVsdGFYU3ltYm9sXSkgPiBNYXRoLmFicyhlbGVtZW50W2RlbHRhWVN5bWJvbF0pKSB7XG4gICAgLy8gTW92ZSB3YXMgbW9zdGx5IGhvcml6b250YWwuXG4gICAgdHJhY2tUbyhlbGVtZW50LCBjbGllbnRYKTtcbiAgICAvLyBJbmRpY2F0ZSB0aGF0IHRoZSBldmVudCB3YXMgaGFuZGxlZC4gSXQnZCBiZSBuaWNlciBpZiB3ZSBkaWRuJ3QgaGF2ZVxuICAgIC8vIHRvIGRvIHRoaXMgc28gdGhhdCwgZS5nLiwgYSB1c2VyIGNvdWxkIGJlIHN3aXBpbmcgbGVmdCBhbmQgcmlnaHRcbiAgICAvLyB3aGlsZSBzaW11bHRhbmVvdXNseSBzY3JvbGxpbmcgdXAgYW5kIGRvd24uIChOYXRpdmUgdG91Y2ggYXBwcyBjYW4gZG9cbiAgICAvLyB0aGF0LikgSG93ZXZlciwgTW9iaWxlIFNhZmFyaSB3YW50cyB0byBoYW5kbGUgc3dpcGUgZXZlbnRzIG5lYXIgdGhlXG4gICAgLy8gcGFnZSBhbmQgaW50ZXJwcmV0IHRoZW0gYXMgbmF2aWdhdGlvbnMuIFRvIGF2b2lkIGhhdmluZyBhIGhvcml6aW9udGFsXG4gICAgLy8gc3dpcGUgbWlzaW50ZXByZXRlZCBhcyBhIG5hdmlnYXRpb24sIHdlIGluZGljYXRlIHRoYXQgd2UndmUgaGFuZGxlZFxuICAgIC8vIHRoZSBldmVudCwgYW5kIHByZXZlbnQgZGVmYXVsdCBiZWhhdmlvci5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBNb3ZlIHdhcyBtb3N0bHkgdmVydGljYWwuXG4gICAgcmV0dXJuIGZhbHNlOyAvLyBOb3QgaGFuZGxlZFxuICB9XG59XG5cbi8qXG4gKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgaGFzIGJlZ3VuIGEgdG91Y2ggb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiB0b3VjaFN0YXJ0KGVsZW1lbnQsIGNsaWVudFgsIGNsaWVudFkpIHtcbiAgZWxlbWVudFtzeW1ib2xzLmRyYWdnaW5nXSA9IHRydWU7XG4gIGVsZW1lbnRbc3RhcnRYU3ltYm9sXSA9IGNsaWVudFg7XG4gIGVsZW1lbnRbcHJldmlvdXNYU3ltYm9sXSA9IGNsaWVudFg7XG4gIGVsZW1lbnRbcHJldmlvdXNZU3ltYm9sXSA9IGNsaWVudFk7XG4gIGVsZW1lbnRbZGVsdGFYU3ltYm9sXSA9IDA7XG4gIGVsZW1lbnRbZGVsdGFZU3ltYm9sXSA9IDA7XG59XG5cbmZ1bmN0aW9uIHRyYWNrVG8oZWxlbWVudCwgeCkge1xuICBjb25zdCB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIGNvbnN0IGRyYWdEaXN0YW5jZSA9IGVsZW1lbnRbc3RhcnRYU3ltYm9sXSAtIHg7XG4gIGNvbnN0IGZyYWN0aW9uID0gd2lkdGggPiAwID9cbiAgICBkcmFnRGlzdGFuY2UgLyB3aWR0aCA6XG4gICAgMDtcbiAgZWxlbWVudC50cmF2ZWxGcmFjdGlvbiA9IGZyYWN0aW9uO1xufVxuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi9zeW1ib2xzJztcblxuXG4vLyBTeW1ib2xzIGZvciBwcml2YXRlIGRhdGEgbWVtYmVycyBvbiBhbiBlbGVtZW50LlxuY29uc3QgYWJzb3JiRGVjZWxlcmF0aW9uU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdhYnNvcmJEZWNlbGVyYXRpb24nKTtcbmNvbnN0IGxhc3REZWx0YVhTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2xhc3REZWx0YVgnKTtcbmNvbnN0IGxhc3RXaGVlbFRpbWVvdXRTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2xhc3RXaGVlbFRpbWVvdXQnKTtcbmNvbnN0IHBvc3ROYXZpZ2F0ZURlbGF5Q29tcGxldGVTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3Bvc3ROYXZpZ2F0ZURlbGF5Q29tcGxldGUnKTtcbmNvbnN0IHdoZWVsRGlzdGFuY2VTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3doZWVsRGlzdGFuY2UnKTtcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIFRyYWNrcGFkRGlyZWN0aW9uLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gd2hpY2ggbWFwcyBhIGhvcml6b250YWwgdHJhY2twYWQgc3dpcGUgZ2VzdHVyZXMgKG9yIGhvcml6b250YWwgbW91c2VcbiAgICogd2hlZWwgYWN0aW9ucykgdG8gZGlyZWN0aW9uIHNlbWFudGljcy5cbiAgICpcbiAgICogWW91IGNhbiB1c2UgdGhpcyBtaXhpbiB3aXRoIGEgbWl4aW4gbGlrZVxuICAgKiBbRGlyZWN0aW9uU2VsZWN0aW9uTWl4aW5dKERpcmVjdGlvblNlbGVjdGlvbk1peGluLm1kKSB0byBsZXQgdGhlIHVzZXJcbiAgICogY2hhbmdlIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgdHJhY2twYWQgb3IgbW91c2Ugd2hlZWwuXG4gICAqXG4gICAqIFRvIHJlc3BvbmQgdG8gdGhlIHRyYWNrcGFkLCB3ZSBjYW4gbGlzdGVuIHRvIHRoZSBET00ncyBcIndoZWVsXCIgZXZlbnRzLlxuICAgKiBUaGVzZSBldmVudHMgYXJlIGZpcmVkIGFzIHRoZSB1c2VyIGRyYWdzIHRoZWlyIGZpbmdlcnMgYWNyb3NzIGEgdHJhY2twYWQuXG4gICAqIFVuZm9ydHVuYXRlbHksIGJyb3dzZXJzIGFyZSBtaXNzaW5nIGEgY3JpdGljYWwgZXZlbnQg4oCUwqB0aGVyZSBpcyBubyBldmVudFxuICAgKiB3aGVuIHRoZSB1c2VyICpzdG9wcyogYSBnZXN0dXJlZCBvbiB0aGUgdHJhY2twYWQgb3IgbW91c2Ugd2hlZWwuXG4gICAqXG4gICAqIFRvIG1ha2UgdGhpbmdzIHdvcnNlLCB0aGUgbWFpbnN0cmVhbSBicm93c2VycyBjb250aW51ZSB0byBnZW5lcmF0ZSBmYWtlXG4gICAqIHdoZWVsIGV2ZW50cyBldmVuIGFmdGVyIHRoZSB1c2VyIGhhcyBzdG9wcGVkIGRyYWdnaW5nIHRoZWlyIGZpbmdlcnMuIFRoZXNlXG4gICAqIGZha2UgZXZlbnRzIHNpbXVsYXRlIHRoZSB1c2VyIGdyYWR1YWxseSBzbG93aW5nIGRvd24gdGhlIGRyYWcgdW50aWwgdGhleVxuICAgKiBjb21lIHRvIGEgc21vb3RoIHN0b3AuIEluIHNvbWUgY29udGV4dHMsIHRoZXNlIGZha2Ugd2hlZWwgZXZlbnRzIG1pZ2h0IGJlXG4gICAqIGhlbHBmdWwsIGJ1dCBpbiB0cnlpbmcgdG8gc3VwcGx5IHR5cGljYWwgdHJhY2twYWQgc3dpcGUgbmF2aWdhdGlvbiwgdGhlc2VcbiAgICogZmFrZSBldmVudHMgZ2V0IGluIHRoZSB3YXkuXG4gICAqXG4gICAqIFRoaXMgY29tcG9uZW50IHVzZXMgaGV1cmlzdGljcyB0byB3b3JrIGFyb3VuZCB0aGVzZSBwcm9ibGVtcywgYnV0IHRoZVxuICAgKiBjb21wbGV4IG5hdHVyZSBvZiB0aGUgcHJvYmxlbSBtYWtlIGl0IGV4dHJlbWVseSBkaWZmaWN1bHQgdG8gYWNoaWV2ZSB0aGVcbiAgICogc2FtZSBkZWdyZWUgb2YgdHJhY2twYWQgcmVzcG9uc2l2ZW5lc3MgcG9zc2libGUgd2l0aCBuYXRpdmUgYXBwbGljYXRpb25zLlxuICAgKi9cbiAgY2xhc3MgVHJhY2twYWREaXJlY3Rpb24gZXh0ZW5kcyBiYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZWQgPSB3aGVlbCh0aGlzLCBldmVudCk7XG4gICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXNldFdoZWVsVHJhY2tpbmcodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbi5cbiAgICBnZXQgW3N5bWJvbHMuZHJhZ2dpbmddKCkge1xuICAgICAgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZHJhZ2dpbmddO1xuICAgIH1cbiAgICBzZXQgW3N5bWJvbHMuZHJhZ2dpbmddKHZhbHVlKSB7XG4gICAgICBpZiAoc3ltYm9scy5kcmFnZ2luZyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlcltzeW1ib2xzLmRyYWdnaW5nXSA9IHZhbHVlOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIGxlZnQuXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgICAqL1xuICAgIFtzeW1ib2xzLmdvTGVmdF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0xlZnRdKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvTGVmdF0oKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSByaWdodC5cbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICovXG4gICAgW3N5bWJvbHMuZ29SaWdodF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb1JpZ2h0XSkgeyByZXR1cm4gc3VwZXJbc3ltYm9scy5nb1JpZ2h0XSgpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIHRoZSB1c2VyIGhhcyBtb3ZlZCB0aGUgZmlyc3QgdG91Y2hwb2ludCBzaW5jZSB0aGUgYmVnaW5uaW5nXG4gICAgICogb2YgYSB0cmFja3BhZC93aGVlbCBvcGVyYXRpb24sIGV4cHJlc3NlZCBhcyBhIGZyYWN0aW9uIG9mIHRoZSBlbGVtZW50J3NcbiAgICAgKiB3aWR0aC5cbiAgICAgKlxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuICAgIGdldCB0cmF2ZWxGcmFjdGlvbigpIHtcbiAgICAgIHJldHVybiBzdXBlci50cmF2ZWxGcmFjdGlvbjtcbiAgICB9XG4gICAgc2V0IHRyYXZlbEZyYWN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoJ3RyYXZlbEZyYWN0aW9uJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci50cmF2ZWxGcmFjdGlvbiA9IHZhbHVlOyB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gVHJhY2twYWREaXJlY3Rpb247XG59O1xuXG5cbi8vIFRpbWUgd2Ugd2FpdCBmb2xsb3dpbmcgYSBuYXZpZ2F0aW9uIGJlZm9yZSBwYXlpbmcgYXR0ZW50aW9uIHRvIHdoZWVsXG4vLyBldmVudHMgYWdhaW4uXG5jb25zdCBQT1NUX05BVklHQVRFX1RJTUUgPSAyNTA7XG5cbi8vIFRpbWUgd2Ugd2FpdCBhZnRlciB0aGUgbGFzdCB3aGVlbCBldmVudCBiZWZvcmUgd2UgcmVzZXQgdGhpbmdzLlxuY29uc3QgV0hFRUxfVElNRSA9IDEwMDtcblxuXG4vLyBGb2xsb3dpbmcgYSBuYXZpZ2F0aW9uLCBwYXJ0aWFsbHkgcmVzZXQgb3VyIHdoZWVsIHRyYWNraW5nLlxuZnVuY3Rpb24gcG9zdE5hdmlnYXRlKGVsZW1lbnQpIHtcbiAgZWxlbWVudC50cmF2ZWxGcmFjdGlvbiA9IDA7XG4gIGVsZW1lbnRbd2hlZWxEaXN0YW5jZVN5bWJvbF0gPSAwO1xuICBlbGVtZW50W3Bvc3ROYXZpZ2F0ZURlbGF5Q29tcGxldGVTeW1ib2xdID0gdHJ1ZTtcbiAgZWxlbWVudFthYnNvcmJEZWNlbGVyYXRpb25TeW1ib2xdID0gdHJ1ZTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgZWxlbWVudFtwb3N0TmF2aWdhdGVEZWxheUNvbXBsZXRlU3ltYm9sXSA9IGZhbHNlO1xuICB9LCBQT1NUX05BVklHQVRFX1RJTUUpO1xufVxuXG4vLyBSZXNldCBhbGwgc3RhdGUgcmVsYXRlZCB0byB0aGUgdHJhY2tpbmcgb2YgdGhlIHdoZWVsLlxuZnVuY3Rpb24gcmVzZXRXaGVlbFRyYWNraW5nKGVsZW1lbnQpIHtcbiAgZWxlbWVudC50cmF2ZWxGcmFjdGlvbiA9IDA7XG4gIGVsZW1lbnRbd2hlZWxEaXN0YW5jZVN5bWJvbF0gPSAwO1xuICBlbGVtZW50W2xhc3REZWx0YVhTeW1ib2xdID0gMDtcbiAgZWxlbWVudFthYnNvcmJEZWNlbGVyYXRpb25TeW1ib2xdID0gZmFsc2U7XG4gIGVsZW1lbnRbcG9zdE5hdmlnYXRlRGVsYXlDb21wbGV0ZVN5bWJvbF0gPSBmYWxzZTtcbiAgaWYgKGVsZW1lbnRbbGFzdFdoZWVsVGltZW91dFN5bWJvbF0pIHtcbiAgICBjbGVhclRpbWVvdXQoZWxlbWVudFtsYXN0V2hlZWxUaW1lb3V0U3ltYm9sXSk7XG4gICAgZWxlbWVudFtsYXN0V2hlZWxUaW1lb3V0U3ltYm9sXSA9IG51bGw7XG4gIH1cbn1cblxuLy8gRGVmaW5lIG91ciBvd24gc2lnbiBmdW5jdGlvbiwgc2luY2UgKGFzIG9mIE1heSAyMDE1KSwgU2FmYXJpIGFuZCBJRSBkb24ndFxuLy8gc3VwcGx5IE1hdGguc2lnbigpLlxuZnVuY3Rpb24gc2lnbih4KSB7XG4gIHJldHVybiAoeCA9PT0gMCkgP1xuICAgIDAgOlxuICAgICh4ID4gMCkgP1xuICAgICAgMSA6XG4gICAgICAtMTtcbn1cblxuLy8gVE9ETzogRGFtcGluZywgb3Igc29tZSBvdGhlciB0cmVhdG1lbnQgZm9yIGdvaW5nIHBhc3QgdGhlIGVuZHMuXG5cbi8qXG4gKiBBIHdoZWVsIGV2ZW50IGhhcyBiZWVuIGdlbmVyYXRlZC4gVGhpcyBjb3VsZCBiZSBhIHJlYWwgd2hlZWwgZXZlbnQsIG9yIGl0XG4gKiBjb3VsZCBiZSBmYWtlIChzZWUgbm90ZXMgaW4gdGhlIGhlYWRlcikuXG4gKlxuICogVGhpcyBoYW5kbGVyIHVzZXMgc2V2ZXJhbCBzdHJhdGVnaWVzIHRvIHRyeSB0byBhcHByb3hpbWF0ZSBuYXRpdmUgdHJhY2twYWRcbiAqIHN3aXBlIG5hdmlnYXRpb24uXG4gKlxuICogSWYgdGhlIHVzZXIgaGFzIGRyYWdnZWQgZW5vdWdoIHRvIGNhdXNlIGEgbmF2aWdhdGlvbiwgdGhlbiBmb3IgYSBzaG9ydFxuICogZGVsYXkgZm9sbG93aW5nIHRoYXQgbmF2aWdhdGlvbiwgc3Vic2VxdWVudCB3aGVlbCBldmVudHMgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEZ1cnRoZXJtb3JlLCBmb2xsd293aW5nIGEgbmF2aWdhdGlvbiwgd2UgaWdub3JlIGFsbCB3aGVlbCBldmVudHMgdW50aWwgd2VcbiAqIHJlY2VpdmUgYXQgbGVhc3Qgb25lIGV2ZW50IHdoZXJlIHRoZSBldmVudCdzIGRlbHRhWCAoZGlzdGFuY2UgdHJhdmVsZWQpIGlzXG4gKiAqZ3JlYXRlciogdGhhbiB0aGUgcHJldmlvdXMgZXZlbnQncyBkZWx0YVguIFRoaXMgaGVscHMgdXMgZmlsdGVyIG91dCB0aGVcbiAqIGZha2Ugd2hlZWwgZXZlbnRzIGdlbmVyYXRlZCBieSB0aGUgYnJvd3NlciB0byBzaW11bGF0ZSBkZWNlbGVyYXRpb24uXG4gKlxuICovXG5mdW5jdGlvbiB3aGVlbChlbGVtZW50LCBldmVudCkge1xuXG4gIC8vIFNpbmNlIHdlIGhhdmUgYSBuZXcgd2hlZWwgZXZlbnQsIHJlc2V0IG91ciB0aW1lciB3YWl0aW5nIGZvciB0aGUgbGFzdFxuICAvLyB3aGVlbCBldmVudCB0byBwYXNzLlxuICBpZiAoZWxlbWVudFtsYXN0V2hlZWxUaW1lb3V0U3ltYm9sXSkge1xuICAgIGNsZWFyVGltZW91dChlbGVtZW50W2xhc3RXaGVlbFRpbWVvdXRTeW1ib2xdKTtcbiAgfVxuICBlbGVtZW50W2xhc3RXaGVlbFRpbWVvdXRTeW1ib2xdID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgd2hlZWxUaW1lZE91dChlbGVtZW50KTtcbiAgfSwgV0hFRUxfVElNRSk7XG5cbiAgY29uc3QgZGVsdGFYID0gZXZlbnQuZGVsdGFYO1xuICBjb25zdCBkZWx0YVkgPSBldmVudC5kZWx0YVk7XG5cbiAgLy8gU2VlIGlmIGVsZW1lbnQgZXZlbnQgcmVwcmVzZW50cyBhY2NlbGVyYXRpb24gb3IgZGVjZWxlcmF0aW9uLlxuICBjb25zdCBhY2NlbGVyYXRpb24gPSBzaWduKGRlbHRhWCkgKiAoZGVsdGFYIC0gZWxlbWVudFtsYXN0RGVsdGFYU3ltYm9sXSk7XG4gIGVsZW1lbnRbbGFzdERlbHRhWFN5bWJvbF0gPSBkZWx0YVg7XG5cbiAgaWYgKE1hdGguYWJzKGRlbHRhWCkgPCBNYXRoLmFicyhkZWx0YVkpKSB7XG4gICAgLy8gTW92ZSB3YXMgbW9zdGx5IHZlcnRpY2FsLiBUaGUgdXNlciBtYXkgYmUgdHJ5aW5nIHNjcm9sbCB3aXRoIHRoZVxuICAgIC8vIHRyYWNrcGFkL3doZWVsLiBUbyBiZSBvbiB0aGUgc2FmZSwgd2UgaWdub3JlIHN1Y2ggZXZlbnRzLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChlbGVtZW50W3Bvc3ROYXZpZ2F0ZURlbGF5Q29tcGxldGVTeW1ib2xdKSB7XG4gICAgLy8gSXQncyB0b28gc29vbiBhZnRlciBhIG5hdmlnYXRpb247IGlnbm9yZSB0aGUgZXZlbnQuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYWNjZWxlcmF0aW9uID4gMCkge1xuICAgIC8vIFRoZSBldmVudHMgYXJlIG5vdCAob3IgYXJlIG5vIGxvbmdlcikgZGVjZWxlcmF0aW5nLCBzbyB3ZSBjYW4gc3RhcnRcbiAgICAvLyBwYXlpbmcgYXR0ZW50aW9uIHRvIHRoZW0gYWdhaW4uXG4gICAgZWxlbWVudFthYnNvcmJEZWNlbGVyYXRpb25TeW1ib2xdID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoZWxlbWVudFthYnNvcmJEZWNlbGVyYXRpb25TeW1ib2xdKSB7XG4gICAgLy8gVGhlIHdoZWVsIGV2ZW50IHdhcyBsaWtlbHkgZmFrZWQgdG8gc2ltdWxhdGUgZGVjZWxlcmF0aW9uOyBpZ25vcmUgaXQuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBlbGVtZW50W3doZWVsRGlzdGFuY2VTeW1ib2xdICs9IGRlbHRhWDtcblxuICAvLyBVcGRhdGUgdGhlIHRyYXZlbCBmcmFjdGlvbiBvZiB0aGUgZWxlbWVudCBiZWluZyBuYXZpZ2F0ZWQuXG4gIGNvbnN0IHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgbGV0IHRyYXZlbEZyYWN0aW9uID0gd2lkdGggPiAwID9cbiAgICBlbGVtZW50W3doZWVsRGlzdGFuY2VTeW1ib2xdIC8gd2lkdGggOlxuICAgIDA7XG4gIGVsZW1lbnRbc3ltYm9scy5kcmFnZ2luZ10gPSB0cnVlO1xuICB0cmF2ZWxGcmFjdGlvbiA9IHNpZ24odHJhdmVsRnJhY3Rpb24pICogTWF0aC5taW4oTWF0aC5hYnModHJhdmVsRnJhY3Rpb24pLCAxKTtcbiAgZWxlbWVudC50cmF2ZWxGcmFjdGlvbiA9IHRyYXZlbEZyYWN0aW9uO1xuXG4gIC8vIElmIHRoZSB1c2VyIGhhcyBkcmFnZ2VkIGVub3VnaCB0byByZWFjaCB0aGUgcHJldmlvdXMvbmV4dCBpdGVtLCB0aGVuXG4gIC8vIGNvbXBsZXRlIGEgbmF2aWdhdGlvbiB0byB0aGF0IGl0ZW0uXG4gIGlmICh0cmF2ZWxGcmFjdGlvbiA9PT0gMSkge1xuICAgIGVsZW1lbnRbc3ltYm9scy5kcmFnZ2luZ10gPSBmYWxzZTtcbiAgICBlbGVtZW50W3N5bWJvbHMuZ29SaWdodF0oKTtcbiAgICBwb3N0TmF2aWdhdGUoZWxlbWVudCk7XG4gIH0gZWxzZSBpZiAodHJhdmVsRnJhY3Rpb24gPT09IC0xKSB7XG4gICAgZWxlbWVudFtzeW1ib2xzLmRyYWdnaW5nXSA9IGZhbHNlO1xuICAgIGVsZW1lbnRbc3ltYm9scy5nb0xlZnRdKCk7XG4gICAgcG9zdE5hdmlnYXRlKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEEgc3VmZmljaWVudGx5IGxvbmcgcGVyaW9kIG9mIHRpbWUgaGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCB3aGVlbCBldmVudC5cbi8vIFdlIHNuYXAgdGhlIHNlbGVjdGlvbiB0byB0aGUgY2xvc2VzdCBpdGVtLCB0aGVuIHJlc2V0IG91ciBzdGF0ZS5cbmZ1bmN0aW9uIHdoZWVsVGltZWRPdXQoZWxlbWVudCkge1xuXG4gIC8vIFNuYXAgdG8gdGhlIGNsb3Nlc3QgaXRlbS5cbiAgZWxlbWVudFtzeW1ib2xzLmRyYWdnaW5nXSA9IGZhbHNlO1xuICBjb25zdCB0cmF2ZWxGcmFjdGlvbiA9IGVsZW1lbnQudHJhdmVsRnJhY3Rpb247XG4gIGlmICh0cmF2ZWxGcmFjdGlvbiA+PSAwLjUpIHtcbiAgICBlbGVtZW50W3N5bWJvbHMuZ29SaWdodF0oKTtcbiAgfSBlbHNlIGlmICh0cmF2ZWxGcmFjdGlvbiA8PSAtMC41KSB7XG4gICAgZWxlbWVudFtzeW1ib2xzLmdvTGVmdF0oKTtcbiAgfVxuXG4gIC8vIFRPRE86IExpc3RlbiBmb3IgdGhlIHRyYW5zaXRpb24gdG8gY29tcGxldGUsIGFuZCB0aGVuIHJlc3RvcmVcbiAgLy8gZHJhZ2dpbmcgdG8gZmFsc2UgKG9yIHRoZSBwcmV2aW91cyB2YWx1ZSkuXG5cbiAgcmVzZXRXaGVlbFRyYWNraW5nKGVsZW1lbnQpO1xufVxuIiwiLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc3ltYm9sIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGFzc29jaWF0aW5nIHByaXZhdGVcbiAqIGRhdGEgd2l0aCBhbiBlbGVtZW50LlxuICpcbiAqIE1peGlucyBhbmQgY29tcG9uZW50IGNsYXNzZXMgb2Z0ZW4gd2FudCB0byBhc3NvY2lhdGUgcHJpdmF0ZSBkYXRhIHdpdGggYW5cbiAqIGVsZW1lbnQgaW5zdGFuY2UsIGJ1dCBKYXZhU2NyaXB0IGRvZXMgbm90IGhhdmUgZGlyZWN0IHN1cHBvcnQgZm9yIHRydWVcbiAqIHByaXZhdGUgcHJvcGVydGllcy4gT25lIGFwcHJvYWNoIGlzIHRvIHVzZSB0aGVcbiAqIFtTeW1ib2xdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N5bWJvbClcbiAqIGRhdGEgdHlwZSB0byBzZXQgYW5kIHJldHJpZXZlIGRhdGEgb24gYW4gZWxlbWVudC5cbiAqXG4gKiBVbmZvcnR1bmF0ZWx5LCB0aGUgU3ltYm9sIHR5cGUgaXMgbm90IGF2YWlsYWJsZSBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMS4gVGhlXG4gKiBgY3JlYXRlU3ltYm9sYCBoZWxwZXIgZnVuY3Rpb24gZXhpc3RzIGFzIGEgd29ya2Fyb3VuZCBmb3IgSUUgMTEuIFJhdGhlciB0aGFuXG4gKiByZXR1cm5pbmcgYSB0cnVlIFN5bWJvbCwgaXQgc2ltcGx5IHJldHVybnMgYW4gdW5kZXJzY29yZS1wcmVmaXhlZCBzdHJpbmcuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogICAgIGNvbnN0IGZvb1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnZm9vJyk7XG4gKlxuICogICAgIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAqICAgICAgIGdldCBmb28oKSB7XG4gKiAgICAgICAgIHJldHVybiB0aGlzW2Zvb1N5bWJvbF07XG4gKiAgICAgICB9XG4gKiAgICAgICBzZXQgZm9vKHZhbHVlKSB7XG4gKiAgICAgICAgIHRoaXNbZm9vU3ltYm9sXSA9IHZhbHVlO1xuICogICAgICAgfVxuICogICAgIH1cbiAqXG4gKiBJbiBJRSAxMSwgdGhpcyBzYW1wbGUgd2lsbCBcImhpZGVcIiBkYXRhIGJlaGluZCBhbiBpbnN0YW5jZSBwcm9wZXJ0eSB0aGlzLl9mb28uXG4gKiBUaGUgdXNlIG9mIHRoZSB1bmRlcnNjb3JlIGlzIG1lYW50IHRvIHJlZHVjZSAobm90IGVsaW1pbmF0ZSkgdGhlIHBvdGVudGlhbFxuICogZm9yIG5hbWUgY29uZmxpY3RzLCBhbmQgZGlzY291cmFnZSAobm90IHByZXZlbnQpIGV4dGVybmFsIGFjY2VzcyB0byB0aGlzXG4gKiBkYXRhLiBJbiBtb2Rlcm4gYnJvd3NlcnMsIHRoZSBhYm92ZSBjb2RlIHdpbGwgZWxpbWluYXRlIHRoZSBwb3RlbnRpYWwgb2ZcbiAqIG5hbWluZyBjb25mbGljdHMsIGFuZCBiZXR0ZXIgaGlkZSB0aGUgZGF0YSBiZWhpbmQgYSByZWFsIFN5bWJvbC5cbiAqXG4gKiBAZnVuY3Rpb24gY3JlYXRlU3ltYm9sXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzY3JpcHRpb24gLSBBIHN0cmluZyB0byBpZGVudGlmeSB0aGUgc3ltYm9sIHdoZW4gZGVidWdnaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVN5bWJvbChkZXNjcmlwdGlvbikge1xuICByZXR1cm4gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgU3ltYm9sKGRlc2NyaXB0aW9uKSA6XG4gICAgYF8ke2Rlc2NyaXB0aW9ufWA7XG59XG4iLCIvKlxuICogTWljcm90YXNrIGhlbHBlciBmb3IgSUUgMTEuXG4gKlxuICogRXhlY3V0aW5nIGEgZnVuY3Rpb24gYXMgYSBtaWNyb3Rhc2sgaXMgdHJpdmlhbCBpbiBicm93c2VycyB0aGF0IHN1cHBvcnRcbiAqIHByb21pc2VzLCB3aG9zZSB0aGVuKCkgY2xhdXNlcyB1c2UgbWljcm90YXNrIHRpbWluZy4gSUUgMTEgZG9lc24ndCBzdXBwb3J0XG4gKiBwcm9taXNlcywgYnV0IGRvZXMgc3VwcG9ydCBNdXRhdGlvbk9ic2VydmVycywgd2hpY2ggYXJlIGFsc28gZXhlY3V0ZWQgYXNcbiAqIG1pY3JvdGFza3MuIFNvIHRoaXMgaGVscGVyIHVzZXMgYW4gTXV0YXRpb25PYnNlcnZlciB0byBhY2hpZXZlIG1pY3JvdGFza1xuICogdGltaW5nLlxuICpcbiAqIFNlZSBodHRwczovL2pha2VhcmNoaWJhbGQuY29tLzIwMTUvdGFza3MtbWljcm90YXNrcy1xdWV1ZXMtYW5kLXNjaGVkdWxlcy9cbiAqXG4gKiBJbnNwaXJlZCBieSBQb2x5bWVyJ3MgYXN5bmMoKSBmdW5jdGlvbi5cbiAqL1xuXG5cbi8vIFRoZSBxdWV1ZSBvZiBwZW5kaW5nIGNhbGxiYWNrcyB0byBiZSBleGVjdXRlZCBhcyBtaWNyb3Rhc2tzLlxuY29uc3QgY2FsbGJhY2tzID0gW107XG5cbi8vIENyZWF0ZSBhbiBlbGVtZW50IHRoYXQgd2Ugd2lsbCBtb2RpZnkgdG8gZm9yY2Ugb2JzZXJ2YWJsZSBtdXRhdGlvbnMuXG5jb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuXG4vLyBBIG1vbm90b25pY2FsbHktaW5jcmVhc2luZyB2YWx1ZS5cbmxldCBjb3VudGVyID0gMDtcblxuXG4vKipcbiAqIEFkZCBhIGNhbGxiYWNrIHRvIHRoZSBtaWNyb3Rhc2sgcXVldWUuXG4gKlxuICogVGhpcyB1c2VzIGEgTXV0YXRpb25PYnNlcnZlciBzbyB0aGF0IGl0IHdvcmtzIG9uIElFIDExLlxuICpcbiAqIE5PVEU6IElFIDExIG1heSBhY3R1YWxseSB1c2UgdGltZW91dCB0aW1pbmcgd2l0aCBNdXRhdGlvbk9ic2VydmVycy4gVGhpc1xuICogbmVlZHMgbW9yZSBpbnZlc3RpZ2F0aW9uLlxuICpcbiAqIEBmdW5jdGlvbiBtaWNyb3Rhc2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pY3JvdGFzayhjYWxsYmFjaykge1xuICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIC8vIEZvcmNlIGEgbXV0YXRpb24uXG4gIGVsZW1lbnQudGV4dENvbnRlbnQgPSArK2NvdW50ZXI7XG59XG5cblxuLy8gRXhlY3V0ZSBhbnkgcGVuZGluZyBjYWxsYmFja3MuXG5mdW5jdGlvbiBleGVjdXRlQ2FsbGJhY2tzKCkge1xuICB3aGlsZSAoY2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrcy5zaGlmdCgpO1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuXG4vLyBDcmVhdGUgdGhlIG9ic2VydmVyLlxuY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihleGVjdXRlQ2FsbGJhY2tzKTtcbm9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge1xuICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG59KTtcbiIsIi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciByZW5kZXJpbmcgYW4gYXJyYXkgb2YgaXRlbXMgYXMgZWxlbWVudHMuXG4gKlxuICogVGhpcyBpcyBub3QgYSBtaXhpbiwgYnV0IGEgZnVuY3Rpb24gY29tcG9uZW50cyBjYW4gdXNlIGlmIHRoZXkgbmVlZCB0b1xuICogZ2VuZXJhdGUgYSBzZXQgb2YgZWxlbWVudHMgZm9yIHRoZSBpdGVtcyBpbiBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV1c2UgZXhpc3RpbmcgZWxlbWVudHMgaWYgcG9zc2libGUuIEUuZy4sIGlmIGl0IGlzIGNhbGxlZFxuICogdG8gcmVuZGVyIGFuIGFycmF5IG9mIDQgaXRlbXMsIGFuZCBsYXRlciBjYWxsZWQgdG8gcmVuZGVyIGFuIGFycmF5IG9mIDVcbiAqIGl0ZW1zLCBpdCBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIDQgaXRlbXMsIGNyZWF0aW5nIGp1c3Qgb25lIG5ldyBlbGVtZW50LlxuICogTm90ZSwgaG93ZXZlciwgdGhhdCB0aGlzIHJlLXJlbmRlcmluZyBpcyBub3QgYXV0b21hdGljLiBJZiwgYWZ0ZXIgY2FsbGluZ1xuICogdGhpcyBmdW5jdGlvbiwgeW91IG1hbmlwdWxhdGUgdGhlIGFycmF5IHlvdSB1c2VkLCB5b3UgbXVzdCBzdGlsbCBjYWxsIHRoaXNcbiAqIGZ1bmN0aW9uIGFnYWluIHRvIHJlLXJlbmRlciB0aGUgYXJyYXkuXG4gKlxuICogVGhlIGByZW5kZXJJdGVtYCBwYXJhbWV0ZXIgdGFrZXMgYSBmdW5jdGlvbiBvZiB0d28gYXJndW1lbnRzOiBhbiBpdGVtIHRvXG4gKiB0byByZW5kZXIsIGFuZCBhbiBleGlzdGluZyBlbGVtZW50IChpZiBvbmUgZXhpc3RzKSB3aGljaCBjYW4gYmUgcmVwdXJwb3NlZCB0b1xuICogcmVuZGVyIHRoYXQgaXRlbS4gSWYgdGhlIGxhdHRlciBhcmd1bWVudCBpcyBudWxsLCB0aGUgYHJlbmRlckl0ZW0oKWAgZnVuY3Rpb25cbiAqIHNob3VsZCBjcmVhdGUgYSBuZXcgZWxlbWVudCBhbmQgcmV0dXJuIGl0LiBUaGUgZnVuY3Rpb24gc2hvdWxkIGRvIHRoZSBzYW1lXG4gKiBpZiB0aGUgc3VwcGxpZWQgZXhpc3RpbmcgZWxlbWVudCBpcyBub3Qgc3VpdGFibGUgZm9yIHJlbmRlcmluZyB0aGUgZ2l2ZW5cbiAqIGl0ZW07IHRoZSByZXR1cm5lZCBlbGVtZW50IHdpbGwgYmUgdXNlZCB0byByZXBsYWNlIHRoZSBleGlzdGluZyBvbmUuIElmIHRoZVxuICogZXhpc3RpbmcgZWxlbWVudCAqaXMqIHN1aXRhYmxlLCB0aGUgZnVuY3Rpb24gY2FuIHNpbXBseSB1cGRhdGUgaXQgYW5kIHJldHVyblxuICogaXQgYXMgaXMuXG4gKlxuICogRXhhbXBsZTogVGhlIGZvbGxvd2luZyB3aWxsIHJlbmRlciBhbiBhcnJheSBvZiBzdHJpbmdzIGluIGRpdnMgYXMgY2hpbGRyZW5cbiAqIG9mIHRoZSBgY29udGFpbmVyYCBlbGVtZW50OlxuICpcbiAqICAgICBsZXQgc3RyaW5ncyA9IFsnYScsICdiJywgJ2MnLCAuLi5dO1xuICogICAgIGxldCBjb250YWluZXIgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoLi4uKTtcbiAqICAgICByZW5kZXJBcnJheUFzRWxlbWVudHMoc3RyaW5ncywgY29udGFpbmVyLCAoc3RyaW5nLCBlbGVtZW50KSA9PiB7XG4gKiAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAqICAgICAgICAgLy8gTm8gZWxlbWVudCBleGlzdHMgeWV0LCBzbyBjcmVhdGUgYSBuZXcgb25lLlxuICogICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gKiAgICAgICB9XG4gKiAgICAgICAvLyBTZXQvdXBkYXRlIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGVsZW1lbnQuXG4gKiAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gc3RyaW5nO1xuICogICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtBcnJheX0gaXRlbXMgLSB0aGUgaXRlbXMgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSB0aGUgcGFyZW50IHRoYXQgd2lsbCBob2xkIHRoZSBlbGVtZW50c1xuICogQHBhcmFtIHtmdW5jdGlvbn0gcmVuZGVySXRlbSAtIHJldHVybnMgYSBuZXcgZWxlbWVudCBmb3IgYW4gaXRlbSwgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXB1cnBvc2VzIGFuIGV4aXN0aW5nIGVsZW1lbnQgZm9yIGFuIGl0ZW1cbiAqL1xuZnVuY3Rpb24gcmVuZGVyQXJyYXlBc0VsZW1lbnRzKGl0ZW1zLCBjb250YWluZXIsIHJlbmRlckl0ZW0pIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IHNldCBvZiBlbGVtZW50cyBmb3IgdGhlIGN1cnJlbnQgaXRlbXMuXG4gIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgY29uc3Qgb2xkRWxlbWVudCA9IGNvbnRhaW5lci5jaGlsZE5vZGVzW2luZGV4XTtcbiAgICBjb25zdCBuZXdFbGVtZW50ID0gcmVuZGVySXRlbShpdGVtLCBvbGRFbGVtZW50KTtcbiAgICBpZiAobmV3RWxlbWVudCkge1xuICAgICAgaWYgKCFvbGRFbGVtZW50KSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChuZXdFbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAobmV3RWxlbWVudCAhPT0gb2xkRWxlbWVudCkge1xuICAgICAgICBjb250YWluZXIucmVwbGFjZUNoaWxkKG5ld0VsZW1lbnQsIG9sZEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gSWYgdGhlIGFycmF5IHNocmFuaywgcmVtb3ZlIHRoZSBleHRyYSBlbGVtZW50cyB3aGljaCBhcmUgbm8gbG9uZ2VyIG5lZWRlZC5cbiAgd2hpbGUgKGNvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aCA+IGl0ZW1zLmxlbmd0aCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIuY2hpbGROb2Rlc1tpdGVtcy5sZW5ndGhdKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJBcnJheUFzRWxlbWVudHM7XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCB0b2dnbGVDbGFzcyBmcm9tICcuL3RvZ2dsZUNsYXNzJztcblxuXG4vLyBTeW1ib2xzIGZvciBwcml2YXRlIGRhdGEgbWVtYmVycyBvbiBhbiBlbGVtZW50LlxuY29uc3Qgc2FmZVRvU2V0QXR0cmlidXRlc1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnc2FmZVRvU2V0QXR0cmlidXRlcycpO1xuY29uc3QgcGVuZGluZ0F0dHJpYnV0ZXNTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3BlbmRpbmdBdHRyaWJ1dGVzJyk7XG5jb25zdCBwZW5kaW5nQ2xhc3Nlc1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncGVuZGluZ0NsYXNzZXMnKTtcblxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIHVwZGF0aW5nIGF0dHJpYnV0ZXMsIGluY2x1ZGluZyB0aGUgYGNsYXNzYCBhdHRyaWJ1dGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcbiAgICogUGVyZm9ybSBhbnkgcGVuZGluZyB1cGRhdGVzIHRvIGF0dHJpYnV0ZXMgYW5kIGNsYXNzZXMuXG4gICAqXG4gICAqIFRoaXMgd3JpdGVzIGFueSBgc2V0QXR0cmlidXRlYCBvciBgdG9nZ2xlQ2xhc3NgIHZhbHVlcyB0aGF0IHdlcmUgcGVyZm9ybWVkXG4gICAqIGJlZm9yZSBhbiBlbGVtZW50IHdhcyBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGJ5IG1peGlucy9jb21wb25lbnRzIGluIHRoZWlyXG4gICAqIGBjb25uZWN0ZWRDYWxsYmFja2AuIElmIG11bGl0cGxlIG1peGlucy9jb21wb25lbnRzIGludm9rZSB0aGlzIGR1cmluZyB0aGVcbiAgICogc2FtZSBgY29ubmVjdGVkQ2FsbGJhY2tgLCBvbmx5IHRoZSBmaXJzdCBjYWxsIHdpbGwgaGF2ZSBhbnkgZWZmZWN0LiBUaGVcbiAgICogc3Vic2VxdWVudCBjYWxscyB3aWxsIGJlIGhhcm1sZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgYmVpbmcgYWRkZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgKi9cbiAgY29ubmVjdGVkKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50W3NhZmVUb1NldEF0dHJpYnV0ZXNTeW1ib2xdID0gdHJ1ZTtcblxuICAgIC8vIFNldCBhbnkgcGVuZGluZyBhdHRyaWJ1dGVzLlxuICAgIGlmIChlbGVtZW50W3BlbmRpbmdBdHRyaWJ1dGVzU3ltYm9sXSkge1xuICAgICAgZm9yIChsZXQgYXR0cmlidXRlIGluIGVsZW1lbnRbcGVuZGluZ0F0dHJpYnV0ZXNTeW1ib2xdKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZWxlbWVudFtwZW5kaW5nQXR0cmlidXRlc1N5bWJvbF1bYXR0cmlidXRlXTtcbiAgICAgICAgc2V0QXR0cmlidXRlVG9FbGVtZW50KGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxlbWVudFtwZW5kaW5nQXR0cmlidXRlc1N5bWJvbF0gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNldCBhbnkgcGVuZGluZyBjbGFzc2VzLlxuICAgIGlmIChlbGVtZW50W3BlbmRpbmdDbGFzc2VzU3ltYm9sXSkge1xuICAgICAgZm9yIChsZXQgY2xhc3NOYW1lIGluIGVsZW1lbnRbcGVuZGluZ0NsYXNzZXNTeW1ib2xdKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZWxlbWVudFtwZW5kaW5nQ2xhc3Nlc1N5bWJvbF1bY2xhc3NOYW1lXTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbGVtZW50W3BlbmRpbmdDbGFzc2VzU3ltYm9sXSA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQvdW5zZXQgdGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBpbmRpY2F0ZWQgbmFtZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZXhpc3RzIHByaW1hcmlseSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYW4gZWxlbWVudCB3YW50cyB0b1xuICAgKiBzZXQgYSBkZWZhdWx0IHByb3BlcnR5IHZhbHVlIHRoYXQgc2hvdWxkIGJlIHJlZmxlY3RlZCBhcyBhbiBhdHRyaWJ1dGUuIEFuXG4gICAqIGltcG9ydGFudCBsaW1pdGF0aW9uIG9mIGN1c3RvbSBlbGVtZW50IGNvbnN0dXJjdG9ycyBpcyB0aGF0IHRoZXkgY2Fubm90XG4gICAqIHNldCBhdHRyaWJ1dGVzLiBBIGNhbGwgdG8gYHNldEF0dHJpYnV0ZWAgZHVyaW5nIHRoZSBjb25zdHJ1Y3RvciB3aWxsXG4gICAqIGJlIGRlZmVycmVkIHVudGlsIHRoZSBlbGVtZW50IGlzIGNvbm5lY3RlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgLSBUaGUgbmFtZSBvZiB0aGUgKmF0dHJpYnV0ZSogKG5vdCBwcm9wZXJ0eSkgdG8gc2V0LlxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0LiBJZiBudWxsLCB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICovXG4gIHNldEF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgaWYgKGVsZW1lbnRbc2FmZVRvU2V0QXR0cmlidXRlc1N5bWJvbF0pIHtcbiAgICAgIC8vIFNhZmUgdG8gc2V0IGF0dHJpYnV0ZXMgaW1tZWRpYXRlbHkuXG4gICAgICBzZXRBdHRyaWJ1dGVUb0VsZW1lbnQoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZmVyIHNldHRpbmcgYXR0cmlidXRlcyB1bnRpbCB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0ZWQuXG4gICAgICBpZiAoIWVsZW1lbnRbcGVuZGluZ0F0dHJpYnV0ZXNTeW1ib2xdKSB7XG4gICAgICAgIGVsZW1lbnRbcGVuZGluZ0F0dHJpYnV0ZXNTeW1ib2xdID0ge307XG4gICAgICB9XG4gICAgICBlbGVtZW50W3BlbmRpbmdBdHRyaWJ1dGVzU3ltYm9sXVthdHRyaWJ1dGVdID0gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQvdW5zZXQgdGhlIGNsYXNzIHdpdGggdGhlIGluZGljYXRlZCBuYW1lLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBleGlzdHMgcHJpbWFyaWx5IHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbiBlbGVtZW50IHdhbnRzIHRvXG4gICAqIHNldCBhIGRlZmF1bHQgcHJvcGVydHkgdmFsdWUgdGhhdCBzaG91bGQgYmUgcmVmbGVjdGVkIGFzIGFzIGNsYXNzLiBBblxuICAgKiBpbXBvcnRhbnQgbGltaXRhdGlvbiBvZiBjdXN0b20gZWxlbWVudCBjb25zdHVyY3RvcnMgaXMgdGhhdCB0aGV5IGNhbm5vdFxuICAgKiBzZXQgYXR0cmlidXRlcywgaW5jbHVkaW5nIHRoZSBgY2xhc3NgIGF0dHJpYnV0ZS4gQSBjYWxsIHRvXG4gICAqIGB0b2dnbGVDbGFzc2AgZHVyaW5nIHRoZSBjb25zdHJ1Y3RvciB3aWxsIGJlIGRlZmVycmVkIHVudGlsIHRoZSBlbGVtZW50XG4gICAqIGlzIGNvbm5lY3RlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY2xhc3MgdG8gc2V0LlxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgLSBUcnVlIHRvIHNldCB0aGUgY2xhc3MsIGZhbHNlIHRvIHJlbW92ZSBpdC5cbiAgICovXG4gIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoZWxlbWVudFtzYWZlVG9TZXRBdHRyaWJ1dGVzU3ltYm9sXSkge1xuICAgICAgLy8gU2FmZSB0byBzZXQgY2xhc3MgaW1tZWRpYXRlbHkuXG4gICAgICB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVmZXIgc2V0dGluZyBjbGFzcyB1bnRpbCB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0ZWQuXG4gICAgICBpZiAoIWVsZW1lbnRbcGVuZGluZ0NsYXNzZXNTeW1ib2xdKSB7XG4gICAgICAgIGVsZW1lbnRbcGVuZGluZ0NsYXNzZXNTeW1ib2xdID0ge307XG4gICAgICB9XG4gICAgICBlbGVtZW50W3BlbmRpbmdDbGFzc2VzU3ltYm9sXVtjbGFzc05hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbn07XG5cblxuLy8gUmVmbGVjdCB0aGUgYXR0cmlidXRlIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuLy8gSWYgdGhlIHZhbHVlIGlzIG51bGwsIHJlbW92ZSB0aGUgYXR0cmlidXRlLlxuZnVuY3Rpb24gc2V0QXR0cmlidXRlVG9FbGVtZW50KGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGV4dCA9IFN0cmluZyh2YWx1ZSk7XG4gICAgLy8gQXZvaWQgcmVjdXJzaXZlIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayBjYWxscy5cbiAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkgIT09IHRleHQpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi9jcmVhdGVTeW1ib2wnO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBTeW1ib2wgb2JqZWN0cyBmb3Igc3RhbmRhcmQgY29tcG9uZW50IHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gKlxuICogVGhlc2UgU3ltYm9sIG9iamVjdHMgYXJlIHVzZWQgdG8gYWxsb3cgbWl4aW5zIGFuZCBhIGNvbXBvbmVudCB0byBpbnRlcm5hbGx5XG4gKiBjb21tdW5pY2F0ZSwgd2l0aG91dCBleHBvc2luZyB0aGVzZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZSBjb21wb25lbnQnc1xuICogcHVibGljIEFQSS5cbiAqXG4gKiBUbyB1c2UgdGhlc2UgU3ltYm9sIG9iamVjdHMgaW4geW91ciBvd24gY29tcG9uZW50LCBpbmNsdWRlIHRoaXMgbW9kdWxlIGFuZFxuICogdGhlbiBjcmVhdGUgYSBwcm9wZXJ0eSBvciBtZXRob2Qgd2hvc2Uga2V5IGlzIHRoZSBkZXNpcmVkIFN5bWJvbC5cbiAqXG4gKiAgICAgaW1wb3J0ICdTaW5nbGVTZWxlY3Rpb25NaXhpbicgZnJvbSAnYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2luZ2xlU2VsZWN0aW9uTWl4aW4nO1xuICogICAgIGltcG9ydCAnc3ltYm9scycgZnJvbSAnYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc3ltYm9scyc7XG4gKlxuICogICAgIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIFNpbmdsZVNlbGVjdGlvbk1peGluKEhUTUxFbGVtZW50KSB7XG4gKiAgICAgICBbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIHNlbGVjdGVkKSB7XG4gKiAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSBpbnZva2VkIHdoZW5ldmVyIGFuIGl0ZW0gaXMgc2VsZWN0ZWQvZGVzZWxlY3RlZC5cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogQG1vZHVsZSBzeW1ib2xzXG4gKi9cbmNvbnN0IHN5bWJvbHMgPSB7XG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBkZWZhdWx0c2AgcHJvcGVydHkuXG4gICAqXG4gICAqIFRoaXMgcHJvcGVydHkgY2FuIGJlIHVzZWQgdG8gc2V0IG9yIG92ZXJyaWRlIGRlZmF1bHRzIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gICAqIHRvIGEgbmV3IGNvbXBvbmVudCBpbnN0YW5jZS4gV2hlbiBpbXBsZW1lbnRpbmcgdGhpcyBwcm9wZXJ0eSwgdGFrZSBjYXJlIHRvXG4gICAqIGZpcnN0IGFjcXVpcmUgYW55IGRlZmF1bHRzIGRlZmluZWQgYnkgdGhlIHN1cGVyY2xhc3MuIFRoZSBzdGFuZGFyZCBpZGlvbSBpc1xuICAgKiBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiAgICAgZ2V0IFtzeW1ib2xzLmRlZmF1bHRzXSgpIHtcbiAgICogICAgICAgY29uc3QgZGVmYXVsdHMgPSBzdXBlcltzeW1ib2xzLmRlZmF1bHRzXSB8fCB7fTtcbiAgICogICAgICAgLy8gU2V0IG9yIG92ZXJyaWRlIGRlZmF1bHQgdmFsdWVzIGhlcmVcbiAgICogICAgICAgZGVmYXVsdHMuY3VzdG9tUHJvcGVydHkgPSBmYWxzZTtcbiAgICogICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgKiAgICAgfVxuICAgKlxuICAgKiBAdmFyIHtvYmplY3R9IGRlZmF1bHRzXG4gICAqL1xuICBkZWZhdWx0czogY3JlYXRlU3ltYm9sKCdkZWZhdWx0cycpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgZHJhZ2dpbmdgIHByb3BlcnR5LlxuICAgKlxuICAgKiBDb21wb25lbnRzIGxpa2UgY2Fyb3VzZWxzIG9mdGVuIGRlZmluZSBhbmltYXRlZCBDU1MgdHJhbnNpdGlvbnMgZm9yXG4gICAqIHNsaWRpbmcgZWZmZWN0cy4gU3VjaCBhIHRyYW5zaXRpb24gc2hvdWxkIHVzdWFsbHkgKm5vdCogYmUgYXBwbGllZCB3aGlsZVxuICAgKiB0aGUgdXNlciBpcyBkcmFnZ2luZywgYmVjYXVzZSBhIENTUyBhbmltYXRpb24gd2lsbCBpbnRyb2R1Y2UgYSBsYWcgdGhhdFxuICAgKiBtYWtlcyB0aGUgc3dpcGUgZmVlbCBzbHVnZ2lzaC4gSW5zdGVhZCwgYXMgbG9uZyBhcyB0aGUgdXNlciBpcyBkcmFnZ2luZ1xuICAgKiB3aXRoIHRoZWlyIGZpbmdlciBkb3duLCB0aGUgdHJhbnNpdGlvbiBzaG91bGQgYmUgc3VwcHJlc3NlZC4gV2hlbiB0aGVcbiAgICogdXNlciByZWxlYXNlcyB0aGVpciBmaW5nZXIsIHRoZSB0cmFuc2l0aW9uIGNhbiBiZSByZXN0b3JlZCwgYWxsb3dpbmcgdGhlXG4gICAqIGFuaW1hdGlvbiB0byBzaG93IHRoZSBjYXJvdXNlbCBzbGlkaW5nIGludG8gaXRzIGZpbmFsIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIGRyYWcgaXMgaW4gcHJvZ3Jlc3MsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGRyYWdnaW5nOiBjcmVhdGVTeW1ib2woJ2RyYWdnaW5nJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBnb0Rvd25gIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIGRvd24uXG4gICAqXG4gICAqIEBmdW5jdGlvbiBnb0Rvd25cbiAgICovXG4gIGdvRG93bjogY3JlYXRlU3ltYm9sKCdnb0Rvd24nKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGdvRW5kYCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSB0byB0aGUgZW5kIChlLmcuLFxuICAgKiBvZiBhIGxpc3QpLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gZ29FbmRcbiAgICovXG4gIGdvRW5kOiBjcmVhdGVTeW1ib2woJ2dvRW5kJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBnb0xlZnRgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIGxlZnQuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBnb0xlZnRcbiAgICovXG4gIGdvTGVmdDogY3JlYXRlU3ltYm9sKCdnb0xlZnQnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGdvUmlnaHRgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIHJpZ2h0LlxuICAgKlxuICAgKiBAZnVuY3Rpb24gZ29SaWdodFxuICAgKi9cbiAgZ29SaWdodDogY3JlYXRlU3ltYm9sKCdnb1JpZ2h0JyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBnb1N0YXJ0YCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSB0byB0aGUgc3RhcnRcbiAgICogKGUuZy4sIG9mIGEgbGlzdCkuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBnb1N0YXJ0XG4gICAqL1xuICBnb1N0YXJ0OiBjcmVhdGVTeW1ib2woJ2dvU3RhcnQnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGdvVXBgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIHVwLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gZ29VcFxuICAgKi9cbiAgZ29VcDogY3JlYXRlU3ltYm9sKCdnb1VwJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBpdGVtQWRkZWRgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIGEgbmV3IGl0ZW0gaXMgYWRkZWQgdG8gYSBsaXN0LlxuICAgKlxuICAgKiBAZnVuY3Rpb24gaXRlbUFkZGVkXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGl0ZW0gLSB0aGUgaXRlbSBiZWluZyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gICAqL1xuICBpdGVtQWRkZWQ6IGNyZWF0ZVN5bWJvbCgnaXRlbUFkZGVkJyksXG5cblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGl0ZW1zQ2hhbmdlZGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gdGhlIHVuZGVybHlpbmcgY29udGVudHMgY2hhbmdlLiBJdCBpcyBhbHNvXG4gICAqIGludm9rZWQgb24gY29tcG9uZW50IGluaXRpYWxpemF0aW9uIOKAkyBzaW5jZSB0aGUgaXRlbXMgaGF2ZSBcImNoYW5nZWRcIiBmcm9tXG4gICAqIGJlaW5nIG5vdGhpbmcuXG4gICAqL1xuICBpdGVtc0NoYW5nZWQ6IGNyZWF0ZVN5bWJvbCgnaXRlbXNDaGFuZ2VkJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBpdGVtU2VsZWN0ZWRgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIGFuIGl0ZW0gYmVjb21lcyBzZWxlY3RlZCBvciBkZXNlbGVjdGVkLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gaXRlbVNlbGVjdGVkXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGl0ZW0gLSB0aGUgaXRlbSBiZWluZyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgLSB0cnVlIGlmIHRoZSBpdGVtIGlzIHNlbGVjdGVkLCBmYWxzZSBpZiBub3RcbiAgICovXG4gIGl0ZW1TZWxlY3RlZDogY3JlYXRlU3ltYm9sKCdpdGVtU2VsZWN0ZWQnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGtleWRvd25gIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIGFuIGVsZW1lbnQgcmVjZWl2ZXMgYSBga2V5ZG93bmAgZXZlbnQuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBrZXlkb3duXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgYmVpbmcgcHJvY2Vzc2VkXG4gICAqL1xuICBrZXlkb3duOiBjcmVhdGVTeW1ib2woJ2tleWRvd24nKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYHRlbXBsYXRlYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogVGhpcyBwcm9wZXJ0eSByZXR1cm5zIGEgY29tcG9uZW50J3MgdGVtcGxhdGUuXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd8SFRNTEVsZW1lbnR9XG4gICAqL1xuICB0ZW1wbGF0ZTogY3JlYXRlU3ltYm9sKCd0ZW1wbGF0ZScpXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzeW1ib2xzO1xuIiwiLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHN0YW5kYXJkIGNsYXNzTGlzdC50b2dnbGUoKSBiZWhhdmlvciBvbiBvbGQgYnJvd3NlcnMsXG4gKiBuYW1lbHkgSUUgMTEuXG4gKlxuICogVGhlIHN0YW5kYXJkXG4gKiBbY2xhc3NsaXN0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbGFzc0xpc3QpXG4gKiBvYmplY3QgaGFzIGEgYHRvZ2dsZSgpYCBmdW5jdGlvbiB0aGF0IHN1cHBvcnRzIGEgc2Vjb25kIEJvb2xlYW4gcGFyYW1ldGVyXG4gKiB0aGF0IGNhbiBiZSB1c2VkIHRvIHN1Y2NpbmN0bHkgdHVybiBhIGNsYXNzIG9uIG9yIG9mZi4gVGhpcyBmZWF0dXJlIGlzIG9mdGVuXG4gKiB1c2VmdWwgaW4gZGVzaWduaW5nIGN1c3RvbSBlbGVtZW50cywgd2hpY2ggbWF5IHdhbnQgdG8gZXh0ZXJuYWxseSByZWZsZWN0XG4gKiBjb21wb25lbnQgc3RhdGUgaW4gYSBDU1MgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCBmb3Igc3R5bGluZyBwdXJwb3Nlcy5cbiAqXG4gKiBVbmZvcnR1bmF0ZWx5LCBJRSAxMSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBCb29sZWFuIHBhcmFtZXRlciB0b1xuICogYGNsYXNzTGlzdC50b2dnbGUoKWAuIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGJlaGF2ZXMgbGlrZSB0aGUgc3RhbmRhcmRcbiAqIGB0b2dnbGUoKWAsIGluY2x1ZGluZyBzdXBwb3J0IGZvciB0aGUgQm9vbGVhbiBwYXJhbWV0ZXIsIHNvIHRoYXQgaXQgY2FuIGJlXG4gKiB1c2VkIGV2ZW4gb24gSUUgMTEuXG4gKlxuICogQGZ1bmN0aW9uIHRvZ2dsZUNsYXNzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIC0gVGhlIGNsYXNzIHRvIGFkZC9yZW1vdmVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlXSAtIEZvcmNlIHRoZSBjbGFzcyB0byBiZSBhZGRlZCAoaWYgdHJ1ZSkgb3IgcmVtb3ZlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIGZhbHNlKVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUsIGZvcmNlKSB7XG4gIGNvbnN0IGNsYXNzTGlzdCA9IGVsZW1lbnQuY2xhc3NMaXN0O1xuICBjb25zdCBhZGRDbGFzcyA9ICh0eXBlb2YgZm9yY2UgPT09ICd1bmRlZmluZWQnKSA/XG4gICAgIWNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpIDpcbiAgICBmb3JjZTtcbiAgaWYgKGFkZENsYXNzKSB7XG4gICAgY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIGNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgfVxuICByZXR1cm4gYWRkQ2xhc3M7XG59XG4iLCJpbXBvcnQgQXR0cmlidXRlTWFyc2hhbGxpbmdNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9BdHRyaWJ1dGVNYXJzaGFsbGluZ01peGluJztcbmltcG9ydCBDb21wb3NhYmxlTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQ29tcG9zYWJsZU1peGluJztcbmltcG9ydCBEaXN0cmlidXRlZENoaWxkcmVuTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvRGlzdHJpYnV0ZWRDaGlsZHJlbk1peGluJztcbmltcG9ydCBTaGFkb3dFbGVtZW50UmVmZXJlbmNlc01peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NoYWRvd0VsZW1lbnRSZWZlcmVuY2VzTWl4aW4nO1xuaW1wb3J0IFNoYWRvd1RlbXBsYXRlTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2hhZG93VGVtcGxhdGVNaXhpbic7XG5cblxuLyoqXG4gKiBBIHNhbXBsZSBnZW5lcmFsLXB1cnBvc2UgYmFzZSBjbGFzcyBmb3IgZGVmaW5pbmcgY3VzdG9tIGVsZW1lbnRzIHRoYXQgbWl4ZXNcbiAqIGluIHNvbWUgY29tbW9uIGZlYXR1cmVzOiB0ZW1wbGF0ZSBzdGFtcGluZyBpbnRvIGEgc2hhZG93IHJvb3QsIHNoYWRvdyBlbGVtZW50XG4gKiByZWZlcmVuY2VzLCBtYXJzaGFsbGluZyBhdHRyaWJ1dGVzIHRvIHByb3BlcnRpZXMsIGFuZCByZXRyaWV2aW5nIHRoZSBjaGlsZHJlblxuICogZGlzdHJpYnV0ZWQgdG8gYSBjb21wb25lbnQuXG4gKlxuICogVGhpcyBiYXNlIGNsYXNzIGlzIG5vdCBzcGVjaWFsIGluIGFueSB3YXksIGFuZCBpcyBkZWZpbmVkIG9ubHkgYXMgYVxuICogY29udmVuaWVudCBzaG9ydGhhbmQgZm9yIGFwcGx5aW5nIHRoZSBtaXhpbnMgbGlzdGVkIGFib3ZlLiBZb3UgY2FuIHVzZSB0aGlzXG4gKiBjbGFzcyBhcyBhIGJhc2UgY2xhc3MgZm9yIHlvdXIgb3duIGVsZW1lbnRzLCBvciBlYXNpbHkgY3JlYXRlIHlvdXIgb3duIGJhc2VcbiAqIGNsYXNzIGJ5IGFwcGx5aW5nIHRoZSBzYW1lIHNldCBvZiBtaXhpbnMuXG4gKlxuICogVGhlIEVsZW1lbnRCYXNlIGJhc2UgY2xhc3MgZG9lcyBub3QgcmVnaXN0ZXIgaXRzZWxmIGFzIGEgY3VzdG9tIGVsZW1lbnQgd2l0aFxuICogdGhlIGJyb3dzZXIsIGFuZCBoZW5jZSBjYW5ub3QgYmUgaW5kZXBlbmRlbnRseSBpbnN0YW50aWF0ZWQuXG4gKlxuICogQG1peGVzIEF0dHJpYnV0ZU1hcnNoYWxsaW5nTWl4aW5cbiAqIEBtaXhlcyBDb21wb3NhYmxlTWl4aW5cbiAqIEBtaXhlcyBEaXN0cmlidXRlZENoaWxkcmVuTWl4aW5cbiAqIEBtaXhlcyBTaGFkb3dFbGVtZW50UmVmZXJlbmNlc01peGluXG4gKiBAbWl4ZXMgU2hhZG93VGVtcGxhdGVNaXhpblxuICovXG5jbGFzcyBFbGVtZW50QmFzZSBleHRlbmRzIENvbXBvc2FibGVNaXhpbihIVE1MRWxlbWVudCkuY29tcG9zZShcbiAgU2hhZG93VGVtcGxhdGVNaXhpbiwgICAgICAgICAgLy8gYmVmb3JlIG5vZGUgZmluZGluZywgc28gc2hhZG93IHJvb3QgaXMgcG9wdWxhdGVkXG4gIFNoYWRvd0VsZW1lbnRSZWZlcmVuY2VzTWl4aW4sIC8vIGJlZm9yZSBtYXJzaGFsbGluZywgc28gcHJvcGVydGllcyBjYW4gdXNlIHJlZnNcbiAgQXR0cmlidXRlTWFyc2hhbGxpbmdNaXhpbixcbiAgRGlzdHJpYnV0ZWRDaGlsZHJlbk1peGluXG4pIHt9XG5cbmV4cG9ydCBkZWZhdWx0IEVsZW1lbnRCYXNlO1xuIiwiaW1wb3J0IEhvcml6b250YWxOYXZpZ2F0aW9uTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvSG9yaXpvbnRhbE5hdmlnYXRpb25NaXhpbic7XG5pbXBvcnQgU2xpZGluZ1ZpZXdwb3J0IGZyb20gJy4uLy4uL2Jhc2ljLXNsaWRpbmctdmlld3BvcnQvc3JjL1NsaWRpbmdWaWV3cG9ydCc7XG5cblxuLyoqXG4gKiBMZXRzIHRoZSB1c2VyIG5hdmlnYXRlIGxhdGVyYWxseSB0aHJvdWdoIGEgc2VxdWVuY2Ugb2YgY2hpbGQgZWxlbWVudHNcbiAqIHVzaW5nIGEgc2ltcGxlIENTUyB0cmFuc2l0aW9uIGVmZmVjdCB0byBzaG93IGhvcml6b250YWwgbW92ZW1lbnQuXG4gKlxuICogW0xpdmUgZGVtb10oaHR0cDovL2Jhc2ljd2ViY29tcG9uZW50cy5vcmcvYmFzaWMtd2ViLWNvbXBvbmVudHMvcGFja2FnZXMvYmFzaWMtc2xpZGluZy1jYXJvdXNlbC8pXG4gKlxuICogYmFzaWMtc2xpZGluZy1jYXJvdXNlbCBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgY2Fyb3VzZWwgdXNlciBpbnRlcmZhY2VcbiAqIHBhdHRlcm4sIGNvbW1vbmx5IHVzZWQgZm9yIG5hdmlnYXRpbmcgYmV0d2VlbiBpbWFnZXMsIHBhZ2VzLCBhbmQgb3RoZXJcbiAqIGVsZW1lbnRzLiBUaGlzIHBhdHRlcm4gcHJlc2VudHMgdGhlIHVzZXIgd2l0aCBhIGxpbmVhciBzZXF1ZW5jZSBvZiBlbGVtZW50cyxcbiAqIG9ubHkgb25lIG9mIHdoaWNoIGlzIHNob3duIGF0IGEgdGltZS4gVGhlIHVzZXIgY2FuIG5hdmlnYXRlIHRvIHRoZVxuICogbmV4dC9wcmV2aW91cyBlbGVtZW50IHdpdGggYSB2YXJpZXR5IG9mIGlucHV0IG1ldGhvZHMuXG4gKlxuICogYmFzaWMtc2xpZGluZy1jYXJvdXNlbCBpcyBhIHNpbXBsZXIgdmFyaWF0aW9uIG9mIHRoZSBtb3JlIHNvcGhpc3RpY2F0ZWRcbiAqIFtiYXNpYy1jYXJvdXNlbF0oLi4vYmFzaWMtY2Fyb3VzZWwpIGNvbXBvbmVudC4gVGhlIGxhdHRlciBpbmNsdWRlcyBzdXBwb3J0XG4gKiBmb3Igd3JhcHBpbmcgKGdvaW5nIGZvcndhcmQgZnJvbSB0aGUgbGFzdCBpdGVtIHRvIHRoZSBmaXJzdCwgYW5kIHZpY2UgdmVyc2EpLFxuICogYW5kIG1vcmUgY29tcGxleCB2aXN1YWwgdHJhbnNpdGlvbnMuIFRob3NlIHRyYW5zaXRpb25zIGVudGFpbCB1c2Ugb2YgdGhlIFdlYlxuICogQW5pbWF0aW9uIEFQSSwgd2hpY2ggcmVxdWlyZXMgYSBwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gSGVuY2UsIHRoZVxuICogc2ltcGxlciBiYXNpYy1zbGlkaW5nLWNhcm91c2VsIG1heSBiZSBhIG1vcmUgYXBwcm9wcmlhdGUgY2hvaWNlIGlmIGZhY3RvcnNcbiAqIHN1Y2ggYXMgZG93bmxvYWQgc2l6ZSBhcmUgY3JpdGljYWwuXG4gKlxuICogQmV5b25kIHRob3NlIGRpZmZlcmVuY2VzLCBiYXNpYy1zbGlkaW5nLWNhcm91c2VsIG9mZmVycyB0aGUgc2FtZSBBUEksIHVzYWdlXG4gKiByZWNvbW1lbmRhdGlvbnMsIGFuZCBzdXBwb3J0IGZvciBrZXlib2FyZC90b3VjaC9tb3VzZSBhbmQgYXNzaXN0aXZlIGRldmljZXMuXG4gKiBTZWUgdGhhdCBjb21wb25lbnQgZm9yIG1vcmUgZGV0YWlscyBvbiB1c2UuXG4gKlxuICogQGV4dGVuZHMgU2xpZGluZ1ZpZXdwb3J0XG4gKiBAbWl4ZXMgSG9yaXpvbnRhbE5hdmlnYXRpb25NaXhpblxuICovXG5jbGFzcyBTbGlkaW5nQ2Fyb3VzZWwgZXh0ZW5kcyBTbGlkaW5nVmlld3BvcnQuY29tcG9zZShcbiAgSG9yaXpvbnRhbE5hdmlnYXRpb25NaXhpblxuKSB7fVxuXG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnYmFzaWMtc2xpZGluZy1jYXJvdXNlbCcsIFNsaWRpbmdDYXJvdXNlbCk7XG5leHBvcnQgZGVmYXVsdCBTbGlkaW5nQ2Fyb3VzZWw7XG4iLCJpbXBvcnQgQ29udGVudEl0ZW1zTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQ29udGVudEl0ZW1zTWl4aW4nO1xuaW1wb3J0IERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbic7XG5pbXBvcnQgRWxlbWVudEJhc2UgZnJvbSAnLi4vLi4vYmFzaWMtZWxlbWVudC1iYXNlL3NyYy9FbGVtZW50QmFzZSc7XG5pbXBvcnQgRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0ZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NlbGVjdGlvbkFyaWFBY3RpdmVNaXhpbic7XG5pbXBvcnQgU2luZ2xlU2VsZWN0aW9uTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2luZ2xlU2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IFNwcmVhZEl0ZW1zIGZyb20gJy4uLy4uL2Jhc2ljLXNwcmVhZC1pdGVtcy9zcmMvU3ByZWFkSXRlbXMnOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3N5bWJvbHMnO1xuXG5cbmNvbnN0IGJhc2UgPSBFbGVtZW50QmFzZS5jb21wb3NlKFxuICBDb250ZW50SXRlbXNNaXhpbixcbiAgRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbixcbiAgRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluLFxuICBTZWxlY3Rpb25BcmlhQWN0aXZlTWl4aW4sXG4gIFNpbmdsZVNlbGVjdGlvbk1peGluXG4pO1xuXG5cbi8qKlxuICogUHJlc2VudHMgbGlzdCBpdGVtcyBpbiBhIHZpZXdwb3J0IHN1Y2ggdGhhdCBvbmx5IGEgc2luZ2xlIGl0ZW0gaXMgdmlzaWJsZSBhdFxuICogYSB0aW1lLlxuICpcbiAqIE5hdmlnYXRpbmcgYmV0d2VlbiBpdGVtcyB3aWxsIGJlIHJlcHJlc2VudGVkIHdpdGggYSBob3Jpem9udGFsIHZpc3VhbFxuICogc2xpZGluZyBlZmZlY3QuIEZvciBtb3JlIGNvbXBsZXggdmlzdWFsIGVmZmVjdHMsIHNlZVxuICogW2Jhc2ljLWFuaW1hdGlvbi1zdGFnZV0oLi4vYmFzaWMtYW5pbWF0aW9uLXN0YWdlKSwgd2hpY2ggdGFrZXMgYWR2YW50YWdlIG9mXG4gKiB0aGUgV2ViIEFuaW1hdGlvbnMgQVBJLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGhhbmRsZXMgdGhlIHJlbmRlcmluZyByZXNwb25zaWJpbGl0aWVzIGZvciB0aGUgYmFzaWMtY2Fyb3VzZWxcbiAqIGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBjdXJyZW50bHkgcmVxdWlyZXMgdGhhdCB5b3UgZXhwbGljaXRseSBhcHBseSBhIHNpemUgdG8gaXQuXG4gKlxuICogQGV4dGVuZHMgRWxlbWVudEJhc2VcbiAqIEBtaXhlcyBDb250ZW50SXRlbXNNaXhpblxuICogQG1peGVzIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW5cbiAqIEBtaXhlcyBGcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW5cbiAqIEBtaXhlcyBTZWxlY3Rpb25BcmlhQWN0aXZlTWl4aW5cbiAqIEBtaXhlcyBTaW5nbGVTZWxlY3Rpb25NaXhpblxuICovXG5jbGFzcyBTbGlkaW5nVmlld3BvcnQgZXh0ZW5kcyBiYXNlIHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXNbc3ltYm9scy5kcmFnZ2luZ10gPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgY29uc3QgZGVmYXVsdHMgPSBzdXBlcltzeW1ib2xzLmRlZmF1bHRzXSB8fCB7fTtcbiAgICBkZWZhdWx0cy5zZWxlY3Rpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9XG5cbiAgLypcbiAgICogRHVyaW5nIGRyYWdzLCBkb24ndCBzaG93IENTUyB0cmFuc2l0aW9ucy5cbiAgICovXG4gIGdldCBbc3ltYm9scy5kcmFnZ2luZ10oKSB7XG4gICAgcmV0dXJuICF0aGlzLnNob3dUcmFuc2l0aW9uO1xuICB9XG4gIHNldCBbc3ltYm9scy5kcmFnZ2luZ10odmFsdWUpIHtcbiAgICBpZiAoc3ltYm9scy5kcmFnZ2luZyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlcltzeW1ib2xzLmRyYWdnaW5nXSA9IHZhbHVlOyB9XG4gICAgdGhpcy5yZWZsZWN0Q2xhc3MoJ3Nob3dUcmFuc2l0aW9uJywgIXZhbHVlKTtcbiAgfVxuXG4gIGdldCBzZWxlY3RlZEZyYWN0aW9uKCkge1xuICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEZyYWN0aW9uO1xuICB9XG4gIHNldCBzZWxlY3RlZEZyYWN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCdzZWxlY3RlZEZyYWN0aW9uJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3RlZEZyYWN0aW9uID0gdmFsdWU7IH1cbiAgICByZW5kZXIodGhpcyk7XG4gIH1cblxuICBnZXQgc2VsZWN0ZWRJdGVtKCkge1xuICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEl0ZW07XG4gIH1cbiAgc2V0IHNlbGVjdGVkSXRlbShpdGVtKSB7XG4gICAgaWYgKCdzZWxlY3RlZEl0ZW0nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGVkSXRlbSA9IGl0ZW07IH1cbiAgICByZW5kZXIodGhpcyk7XG4gIH1cblxuICBnZXQgW3N5bWJvbHMudGVtcGxhdGVdKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgICNzbGlkaW5nQ29udGFpbmVyIHtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIC8qXG4gICAgICAgICBTZXQgd2lkdGggZm9yIElFL0VkZ2UuIEl0J3Mgbm90IGNsZWFyIHdoeSB0aGV5IG5lZWQgdGhpcywgYW5kIHRoZSBvdGhlclxuICAgICAgICAgYnJvd3NlcnMgZG9uJ3QuXG4gICAgICAgICAqL1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoLnNob3dUcmFuc2l0aW9uKSAjc2xpZGluZ0NvbnRhaW5lciB7XG4gICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gMC4ycyBlYXNlLW91dDtcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQ7XG4gICAgICB9XG4gICAgICA8L3N0eWxlPlxuXG4gICAgICA8YmFzaWMtc3ByZWFkLWl0ZW1zIGlkPVwic2xpZGluZ0NvbnRhaW5lclwiIHJvbGU9XCJub25lXCI+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICAgIDwvYmFzaWMtc3ByZWFkLWl0ZW1zPlxuICAgIGA7XG4gIH1cblxufVxuXG5cblxuZnVuY3Rpb24gcmVuZGVyKGVsZW1lbnQpIHtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlclNlbGVjdGlvbi5iaW5kKGVsZW1lbnQpKTtcbn1cblxuLy8gTm90ZTogSW4gdGhpcyByb3V0aW5lLCBcInRoaXNcIiBpcyBib3VuZCB0byBhbiBlbGVtZW50IGluc3RhbmNlLlxuZnVuY3Rpb24gcmVuZGVyU2VsZWN0aW9uKCkge1xuICBpZiAoIXRoaXMuc2VsZWN0ZWRJdGVtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHNlbGVjdGlvbiA9IEZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbi5oZWxwZXJzLmVsZW1lbnRTZWxlY3Rpb24odGhpcyk7XG4gIGNvbnN0IGl0ZW1Db3VudCA9IHRoaXMuaXRlbXMgPyB0aGlzLml0ZW1zLmxlbmd0aCA6IDA7XG4gIGNvbnN0IGRhbXBlZCA9IEZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbi5oZWxwZXJzLmRhbXBlZFNlbGVjdGlvbihzZWxlY3Rpb24sIGl0ZW1Db3VudCk7XG4gIC8vIFVzZSBhIHBlcmNlbnRhZ2Ugc28gdGhlIHRyYW5zZm9ybSB3aWxsIHN0aWxsIHdvcmsgaWYgc2NyZWVuIHNpemUgY2hhbmdlc1xuICAvLyAoZS5nLiwgaWYgZGV2aWNlIG9yaWVudGF0aW9uIGNoYW5nZXMpLlxuICBjb25zdCBsZWZ0ID0gLWRhbXBlZCAqIDEwMDtcbiAgY29uc3QgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoJyArIGxlZnQgKyAnJSknO1xuICB0aGlzLiQuc2xpZGluZ0NvbnRhaW5lci5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIHRoaXMuJC5zbGlkaW5nQ29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbn1cblxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2Jhc2ljLXNsaWRpbmctdmlld3BvcnQnLCBTbGlkaW5nVmlld3BvcnQpO1xuZXhwb3J0IGRlZmF1bHQgU2xpZGluZ1ZpZXdwb3J0O1xuIiwiaW1wb3J0IEVsZW1lbnRCYXNlIGZyb20gJy4uLy4uL2Jhc2ljLWVsZW1lbnQtYmFzZS9zcmMvRWxlbWVudEJhc2UnO1xuaW1wb3J0IERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbic7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zeW1ib2xzJztcblxuXG4vKipcbiAqIFNwcmVhZHMgb3V0IGEgc2V0IG9mIGl0ZW1zIGhvcml6b250YWxseSBzbyB0aGV5IHRha2UgZXF1YWwgc3BhY2UuXG4gKlxuICogW0xpdmUgZGVtb10oaHR0cDovL2Jhc2ljd2ViY29tcG9uZW50cy5vcmcvYmFzaWMtd2ViLWNvbXBvbmVudHMvcGFja2FnZXMvYmFzaWMtc3ByZWFkLWl0ZW1zLylcbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkLCBmb3IgZXhhbXBsZSwgYnkgdGhlIGJhc2ljLXNsaWRpbmctdmlld3BvcnQgY29tcG9uZW50XG4gKiB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBvZiBkaWZmZXJlbnQgc2l6ZSB3aWxsIHRha2UgdXAgdGhlIHNhbWUgYW1vdW50IG9mXG4gKiBob3Jpem9udGFsIHNwYWNlLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGN1cnJlbnRseSByZXF1aXJlcyBhbiBleHBsaWNpdCBzaXplIGJ5IGFwcGxpZWQgdG8gaXQuXG4gKlxuICogQGV4dGVuZHMgRWxlbWVudEJhc2VcbiAqIEBtaXhlcyBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluXG4gKi9cbmNsYXNzIFNwcmVhZEl0ZW1zIGV4dGVuZHMgRWxlbWVudEJhc2UuY29tcG9zZShcbiAgRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpblxuKSB7XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKSB7IHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7IH1cbiAgICAvLyBIQUNLXG4gICAgdGhpc1tzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKTtcbiAgfVxuXG4gIGdldCBpdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICB9XG5cbiAgLy8gVE9ETzogU2hvdWxkIGFsc28gaGFuZGxlIGNvbnRlbnRDaGFuZ2VkKCksIGJ1dCBuZWVkIHRvIHJhdGlvbmFsaXplIHdpdGhcbiAgLy8gaW52b2NhdGlvbiBvZiBbc3ltYm9scy5pdGVtc0NoYW5nZWRdIGluIGNvbm5lY3RlZENhbGxiYWNrLlxuICBbc3ltYm9scy5pdGVtc0NoYW5nZWRdKCkge1xuICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1zQ2hhbmdlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtc0NoYW5nZWRdKCk7IH1cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgY291bnQgPSBpdGVtcy5sZW5ndGg7XG4gICAgdGhpcy4kLnNwcmVhZENvbnRhaW5lci5zdHlsZS53aWR0aCA9IChjb3VudCAqIDEwMCkgKyAnJSc7XG4gICAgY29uc3QgaXRlbVdpZHRoID0gKDEwMCAvIGNvdW50KSArIFwiJVwiO1xuICAgIFtdLmZvckVhY2guY2FsbChpdGVtcywgaXRlbSA9PiB7XG4gICAgICBpdGVtLnN0eWxlLndpZHRoID0gaXRlbVdpZHRoO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IFtzeW1ib2xzLnRlbXBsYXRlXSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cblxuICAgICAgI3NwcmVhZENvbnRhaW5lciB7XG4gICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgICNzcHJlYWRDb250YWluZXIgOjpzbG90dGVkKCopIHtcbiAgICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICAgICAgb2JqZWN0LWZpdDogdmFyKC0tYmFzaWMtaXRlbS1vYmplY3QtZml0LCBjb250YWluKTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICAtd2Via2l0LXVzZXItZHJhZzogbm9uZTtcbiAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG5cbiAgICAgIDxkaXYgaWQ9XCJzcHJlYWRDb250YWluZXJcIiByb2xlPVwibm9uZVwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICB9XG5cbn1cblxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2Jhc2ljLXNwcmVhZC1pdGVtcycsIFNwcmVhZEl0ZW1zKTtcbmV4cG9ydCBkZWZhdWx0IFNwcmVhZEl0ZW1zO1xuIiwiaW1wb3J0IEFuaW1hdGlvblN0YWdlIGZyb20gJy4uLy4uL2Jhc2ljLWFuaW1hdGlvbi1zdGFnZS9zcmMvQW5pbWF0aW9uU3RhZ2UnO1xuaW1wb3J0IFBhZ2VEb3RzTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvUGFnZURvdHNNaXhpbic7XG5cbmNsYXNzIEFuaW1hdGlvblN0YWdlV2l0aERvdHMgZXh0ZW5kcyBQYWdlRG90c01peGluKEFuaW1hdGlvblN0YWdlKSB7fVxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdhbmltYXRpb24tc3RhZ2Utd2l0aC1kb3RzJywgQW5pbWF0aW9uU3RhZ2VXaXRoRG90cyk7XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGlvblN0YWdlV2l0aERvdHM7XG4iLCJpbXBvcnQgQXJyb3dTZWxlY3Rpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9BcnJvd1NlbGVjdGlvbk1peGluJztcbmltcG9ydCBDYXJvdXNlbCBmcm9tICcuLi8uLi9iYXNpYy1jYXJvdXNlbC9zcmMvQ2Fyb3VzZWwnO1xuXG5jbGFzcyBDYXJvdXNlbFdpdGhBcnJvd3MgZXh0ZW5kcyBBcnJvd1NlbGVjdGlvbk1peGluKENhcm91c2VsKSB7fVxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdjYXJvdXNlbC13aXRoLWFycm93cycsIENhcm91c2VsV2l0aEFycm93cyk7XG5cbmV4cG9ydCBkZWZhdWx0IENhcm91c2VsV2l0aEFycm93cztcbiIsImltcG9ydCBBcnJvd1NlbGVjdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0Fycm93U2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IENhcm91c2VsIGZyb20gJy4uLy4uL2Jhc2ljLWNhcm91c2VsL3NyYy9DYXJvdXNlbCc7XG5pbXBvcnQgUGFnZURvdHNNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9QYWdlRG90c01peGluJztcblxuY2xhc3MgQ2Fyb3VzZWxXaXRoQXJyb3dzIGV4dGVuZHMgQ2Fyb3VzZWwuY29tcG9zZShcbiAgQXJyb3dTZWxlY3Rpb25NaXhpbixcbiAgUGFnZURvdHNNaXhpblxuKSB7fVxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdjYXJvdXNlbC13aXRoLWFycm93cy1hbmQtZG90cycsIENhcm91c2VsV2l0aEFycm93cyk7XG5cbmV4cG9ydCBkZWZhdWx0IENhcm91c2VsV2l0aEFycm93cztcbiIsImltcG9ydCBDYXJvdXNlbCBmcm9tICcuLi8uLi9iYXNpYy1jYXJvdXNlbC9zcmMvQ2Fyb3VzZWwnO1xuaW1wb3J0IFBhZ2VEb3RzTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvUGFnZURvdHNNaXhpbic7XG5cbmNsYXNzIENhcm91c2VsV2l0aERvdHMgZXh0ZW5kcyBQYWdlRG90c01peGluKENhcm91c2VsKSB7fVxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdjYXJvdXNlbC13aXRoLWRvdHMnLCBDYXJvdXNlbFdpdGhEb3RzKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2Fyb3VzZWxXaXRoRG90cztcbiIsImltcG9ydCBBcnJvd1NlbGVjdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0Fycm93U2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IFNsaWRpbmdDYXJvdXNlbCBmcm9tICcuLi8uLi9iYXNpYy1zbGlkaW5nLWNhcm91c2VsL3NyYy9TbGlkaW5nQ2Fyb3VzZWwnO1xuaW1wb3J0IFBhZ2VEb3RzTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvUGFnZURvdHNNaXhpbic7XG5cbmNsYXNzIFNsaWRpbmdDYXJvdXNlbFdpdGhBcnJvd3NBbmREb3RzIGV4dGVuZHMgU2xpZGluZ0Nhcm91c2VsLmNvbXBvc2UoXG4gIEFycm93U2VsZWN0aW9uTWl4aW4sXG4gIFBhZ2VEb3RzTWl4aW5cbikge31cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzbGlkaW5nLWNhcm91c2VsLXdpdGgtYXJyb3dzLWFuZC1kb3RzJywgU2xpZGluZ0Nhcm91c2VsV2l0aEFycm93c0FuZERvdHMpO1xuZXhwb3J0IGRlZmF1bHQgU2xpZGluZ0Nhcm91c2VsV2l0aEFycm93c0FuZERvdHM7XG4iXX0="}