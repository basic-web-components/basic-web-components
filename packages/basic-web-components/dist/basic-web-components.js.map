{"version":3,"sources":["node_modules/browser-pack/_prelude.js","packages/basic-animation-stage/globals.js","packages/basic-animation-stage/src/AnimationStage.js","packages/basic-autosize-textarea/globals.js","packages/basic-autosize-textarea/src/AutosizeTextarea.js","packages/basic-carousel/globals.js","packages/basic-carousel/src/Carousel.js","packages/basic-collapsible-panel/globals.js","packages/basic-collapsible-panel/src/CollapsiblePanel.js","packages/basic-component-mixins/globals.js","packages/basic-component-mixins/src/ArrowSelectionMixin.js","packages/basic-component-mixins/src/AttributeMarshallingMixin.js","packages/basic-component-mixins/src/ClickSelectionMixin.js","packages/basic-component-mixins/src/ComposableMixin.js","packages/basic-component-mixins/src/ContentItemsMixin.js","packages/basic-component-mixins/src/DirectionSelectionMixin.js","packages/basic-component-mixins/src/DistributedChildrenContentMixin.js","packages/basic-component-mixins/src/DistributedChildrenMixin.js","packages/basic-component-mixins/src/FractionalSelectionMixin.js","packages/basic-component-mixins/src/GenericMixin.js","packages/basic-component-mixins/src/HorizontalNavigationMixin.js","packages/basic-component-mixins/src/KeyboardDirectionMixin.js","packages/basic-component-mixins/src/KeyboardMixin.js","packages/basic-component-mixins/src/KeyboardPagedSelectionMixin.js","packages/basic-component-mixins/src/KeyboardPrefixSelectionMixin.js","packages/basic-component-mixins/src/OpenCloseMixin.js","packages/basic-component-mixins/src/PageDotsMixin.js","packages/basic-component-mixins/src/PlayControlsMixin.js","packages/basic-component-mixins/src/SelectedItemTextValueMixin.js","packages/basic-component-mixins/src/SelectionAnimationMixin.js","packages/basic-component-mixins/src/SelectionAriaActiveMixin.js","packages/basic-component-mixins/src/SelectionHighlightMixin.js","packages/basic-component-mixins/src/SelectionInViewMixin.js","packages/basic-component-mixins/src/ShadowElementReferencesMixin.js","packages/basic-component-mixins/src/ShadowTemplateMixin.js","packages/basic-component-mixins/src/SingleSelectionMixin.js","packages/basic-component-mixins/src/SwipeDirectionMixin.js","packages/basic-component-mixins/src/TimerSelectionMixin.js","packages/basic-component-mixins/src/TrackpadDirectionMixin.js","packages/basic-component-mixins/src/createSymbol.js","packages/basic-component-mixins/src/microtask.js","packages/basic-component-mixins/src/renderArrayAsElements.js","packages/basic-component-mixins/src/safeAttributes.js","packages/basic-component-mixins/src/symbols.js","packages/basic-component-mixins/src/toggleClass.js","packages/basic-current-anchor/globals.js","packages/basic-current-anchor/src/CurrentAnchor.js","packages/basic-element-base/globals.js","packages/basic-element-base/src/ElementBase.js","packages/basic-fade-overflow/globals.js","packages/basic-fade-overflow/src/FadeOverflow.js","packages/basic-list-box/globals.js","packages/basic-list-box/src/ListBox.js","packages/basic-modes/globals.js","packages/basic-modes/src/Modes.js","packages/basic-slideshow-with-controls/globals.js","packages/basic-slideshow-with-controls/src/SlideshowWithControls.js","packages/basic-slideshow/globals.js","packages/basic-slideshow/src/Slideshow.js","packages/basic-sliding-carousel/globals.js","packages/basic-sliding-carousel/src/SlidingCarousel.js","packages/basic-sliding-viewport/globals.js","packages/basic-sliding-viewport/src/SlidingViewport.js","packages/basic-spread-items/globals.js","packages/basic-spread-items/src/SpreadItems.js","packages/basic-tab-strip/globals.js","packages/basic-tab-strip/src/TabStrip.js","packages/basic-tab-strip/src/TabStripMixin.js","packages/basic-tabs/globals.js","packages/basic-tabs/src/Tabs.js","packages/basic-web-components/globals.js","packages/basic-wrapped-standard-element/globals.js","packages/basic-wrapped-standard-element/src/WrappedStandardElement.js"],"names":[],"mappings":"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","file":"basic-web-components.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport AnimationStage from './src/AnimationStage';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.AnimationStage = AnimationStage;\n","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport ContentItemsMixin from '../../basic-component-mixins/src/ContentItemsMixin';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport FractionalSelectionMixin from '../../basic-component-mixins/src/FractionalSelectionMixin';\nimport SelectionAnimationMixin from '../../basic-component-mixins/src/SelectionAnimationMixin';\nimport SelectionAriaActiveMixin from '../../basic-component-mixins/src/SelectionAriaActiveMixin';\nimport SingleSelectionMixin from '../../basic-component-mixins/src/SingleSelectionMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\nconst base = ElementBase.compose(\n  ContentItemsMixin,\n  DistributedChildrenContentMixin,\n  FractionalSelectionMixin,\n  SelectionAnimationMixin,\n  SelectionAriaActiveMixin,\n  SingleSelectionMixin\n);\n\n/**\n * Presents a single item as selected, providing animated transitions when the\n * selection changes. The same animation can be shown at an arbitrary point,\n * generally used to reflect a user-controlled touch or trackpad drag operation\n * in progress.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-animation-stage/)\n *\n * This component is intended to be used as a programmatic rendering surface for\n * components which want to show transitional effects.\n *\n * The component uses [SelectionAnimationMixin](../basic-component-mixins/docs/SelectionAnimationMixin.md)\n * mixin, which in turn uses the Web Animations API. For use on browsers which\n * do not support that API natively, you will need to load the\n * [Web Animations polyfill](https://github.com/web-animations/web-animations-js).\n *\n * For a simpler component that exhibits only a sliding effect, but does not\n * require the Web Animations API, see [basic-sliding-viewport](../basic-sliding-viewport).\n *\n * @extends ElementBase\n * @mixes ContentItemsMixin\n * @mixes DistributedChildrenContentMixin\n * @mixes SelectionAnimationMixin\n * @mixes SelectionAriaActiveMixin\n * @mixes SingleSelectionMixin\n */\nclass AnimationStage extends base {\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.selectionRequired = true;\n    return defaults;\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        overflow: hidden;\n        position: relative;\n      }\n\n      #container ::slotted(*) {\n        height: 100%;\n        object-fit: contain;\n        position: absolute;\n        width: 100%;\n        will-change: transform;\n      }\n      </style>\n\n      <div id=\"container\" role=\"none\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n}\n\n\ncustomElements.define('basic-animation-stage', AnimationStage);\nexport default AnimationStage;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport AutosizeTextarea from './src/AutosizeTextarea';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.AutosizeTextarea = AutosizeTextarea;\n","import createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport WrappedStandardElement from '../../basic-wrapped-standard-element/src/WrappedStandardElement';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport GenericMixin from '../../basic-component-mixins/src/GenericMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n// Symbols for private data members on an element.\nconst lineHeightSymbol = createSymbol('lineHeight');\nconst minimumRowsSymbol = createSymbol('minimumRows');\nconst valueTracksContentSymbol = createSymbol('valueTracksContent');\n\nconst base = WrappedStandardElement.wrap('textarea').compose(\n  DistributedChildrenContentMixin,\n  GenericMixin\n);\n\n/**\n * A text area that makes itself big enough to show its content.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-autosize-textarea/)\n *\n * This text input component is useful in situations where you want to ask the\n * user to enter as much text as they want, but don't want to take up a lot of\n * room on the page.\n *\n * The component works by copying the text to an invisible element which will\n * automatically grow in size; the expanding copy will expand the container,\n * which in turn will vertically stretch the text area to match.\n *\n * This component generally exposes all the same attributes/properties as a\n * standard HTML `<textarea>`.\n *\n * @extends WrappedStandardElement\n * @mixes GenericMixin\n * @mixes DistributedChildrenContentMixin\n */\nclass AutosizeTextarea extends base {\n\n  constructor() {\n    super();\n\n    this.inner.addEventListener('input', event => {\n      valueChanged(this);\n    });\n    this.inner.addEventListener('keypress', event => {\n      keypress(this, event);\n    });\n\n    // Set defaults.\n    if (typeof this.minimumRows === 'undefined') {\n      this.minimumRows = this[symbols.defaults].minimumRows;\n    }\n\n    // A standard textarea has its value track its textContent by default.\n    // That is, changes to textContent update the value. However, if an attempt\n    // is made to change the value directly, this breaks the automatic tracking.\n    // From that point on, changes to textContent do *not* update the value.\n    this[valueTracksContentSymbol] = true;\n  }\n\n  /**\n   * Resize the element such that the textarea can exactly contain its content.\n   * By default, this method is invoked whenever the text content changes.\n   */\n  autoSize() {\n    // If we had speculatively added an extra line because of an Enter keypress,\n    // we can now hide the extra line.\n    this.$.extraLine.style.display = 'none';\n\n    // We resize by copying the textarea contents to the element itself; the\n    // text will then appear (via <slot>) inside the invisible div. If\n    // we've set things up correctly, this new content should take up the same\n    // amount of room as the same text in the textarea. Updating the element's\n    // content adjusts the element's size, which in turn will make the textarea\n    // the correct height.\n    this.$.textCopy.textContent = this.value;\n  }\n\n  // Normally the value of the element is set and read through its value\n  // attribute. As a convenience, and to mirror standard textarea behavior, it\n  // is possible to set the content of the textarea by including text between\n  // the opening and closing tag. This works only in one direction: setting the\n  // tag content updates the textarea, but user edits in the textarea are not\n  // reflected in the tag content. We capture the value of the initial text\n  // content in order to set the value property during the create event.\n  // TODO: Normalize indentation in the text content. Users will often want to\n  // indent the markup so that it looks pretty. We should detect the indentation\n  // level and remove any indentation whitespace\n  // TODO: Consider using content innerHTML rather than plain text. The native\n  // textarea element will include HTML, not just the stripped text, as initial\n  // value property text.\n  connectedCallback() {\n    if (super.connectedCallback) { super.connectedCallback(); }\n    initializeWhenRendered(this);\n  }\n\n  contentChanged() {\n    if (super.contentChanged) { super.contentChanged(); }\n    if (this[valueTracksContentSymbol]) {\n      const text = getTextContent(this);\n      this.inner.value = unescapeHtml(text);\n      valueChanged(this);\n    }\n  }\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.minimumRows = 1;\n    return defaults;\n  }\n\n  /**\n   * Determines the minimum number of rows shown. This is similar to the rows\n   * attribute on a standard textarea, but because this element can grow, is\n   * expressed as a minimum rather than a fixed number.\n   *\n   * By default, this property is 1, so when empty, the text area will be a\n   * single line tall. That's efficient in terms of the space it consumes, but\n   * until the user interacts with the element, they may not realize they can\n   * enter multiple lines of text. Setting the property to a value higher than 1\n   * will signal to the user that they can enter multiple lines of a text.\n   *\n   * By setting this property, you can also communicate to the user some sense\n   * of how much text you're expecting them to provide. For example, on a\n   * feedback form, asking the user to enter their feedback in a single-line\n   * text box implies you don't really want them to enter much text  even if\n   * the text box will grow when they type. By setting this to a value like,\n   * say, 10 rows, you can signal that you're fully expecting them to enter more\n   * text.\n   *\n   * @type {number}\n   * @default 1\n   */\n  get minimumRows() {\n    return this[minimumRowsSymbol];\n  }\n  set minimumRows(value) {\n    this[minimumRowsSymbol] = parseInt(value);\n    if (this[lineHeightSymbol]) {\n      setMinimumHeight(this);\n    }\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        display: block;\n      }\n\n      #autoSizeContainer {\n        position: relative;\n      }\n\n      /*\n       * Ensure both the text area and copy end up with the element's own font\n       * metrics, so that text will lay out the same in both of them.\n       */\n      #inner,\n      #copyContainer {\n        -moz-box-sizing: border-box;\n        box-sizing: border-box;\n        font-family: inherit;\n        font-size: inherit;\n        font-style: inherit;\n        font-weight: inherit;\n        line-height: inherit;\n        margin: 0;\n      }\n\n      #inner {\n        height: 100%;\n        overflow: hidden;\n        position: absolute;\n        resize: none;\n        top: 0;\n        width: 100%;\n        @apply(--textarea);\n      }\n\n      #copyContainer {\n        visibility: hidden;\n        white-space: pre-wrap; /* So lines wrap */\n        word-wrap: break-word; /* So we break at word boundaries when possible */\n      }\n\n      #contentContainer {\n        display: none;\n      }\n      </style>\n\n      <!--\n      The invisible copyContainer contains an extraSpace element that ensures that,\n      even if the last line of the textarea is blank, there will be something in the\n      line that forces the text copy to grow by a line. This extra space is a thin\n      space, to reduce the amount by which the text copy will prematurely grow.\n\n      The copyContainer also contains an extraLine element exists to deal with the\n      fact that, if the user presses the Enter key down, the textarea's content will\n      move before the complete text is available. See notes at _keypress.\n\n      Lastly, we put the HTML content element into a separate container so we can\n      hide it. We need to have a content element somewhere in the template to\n      convince Polymer that we care about the content in the Shady DOM case --\n      without that content element, Shady DOM will conclude the element doesn't\n      need its light DOM content, and will throw it away.\n      -->\n      <div id=\"autoSizeContainer\">\n        <textarea id=\"inner\"></textarea>\n        <div id=\"copyContainer\"><span id=\"textCopy\"></span><span id=\"extraSpace\">&thinsp;</span><div id=\"extraLine\">&nbsp;</div></div>\n      </div>\n      <div id=\"contentContainer\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n  /**\n   * The text currently shown in the textarea.\n   *\n   * Note that the text shown in the textarea can also be updated by changing\n   * the element's innerHTML/textContent. However, if the value property is\n   * explicitly set, that will override the innerHTML/textContent.\n   *\n   * @type {string}\n   */\n  get value() {\n    return this.inner.value;\n  }\n  set value(text) {\n    // Explicitly setting value breaks automatic update of value from content.\n    this[valueTracksContentSymbol] = false;\n    this.inner.value = text;\n    valueChanged(this);\n  }\n\n  /**\n   * Fires when the user types in the textarea.\n   *\n   * @memberof AutosizeTextarea\n   * @event change\n   */\n}\n\n\nfunction getTextContent(element) {\n  let text = element.distributedTextContent;\n\n  // Trim the text.\n  // This is non-standard textarea behavior. A standard textarea will trim the\n  // first character if it's a newline, but that's it. However, authors will\n  // want to be able to place the opening and closing tags on their own lines.\n  // So it seems more helpful to trim whitespace on either side.\n  text = text.trim();\n\n  return text;\n}\n\n\n// Set up once this component has been rendered.\n//\n// On Chrome (as of 10/23/14) at least, if an instance if this component is\n// added dynamically, its attached handler may trigger before its been\n// rendered. That would cause our layout calculations to be incorrect.\n//\nfunction initializeWhenRendered(element) {\n\n  // If the component has been rendered, our height should be nonzero.\n  if (element.clientHeight === 0) {\n    // Not rendered yet: wait a bit before trying again.\n    setTimeout(() => initializeWhenRendered(element), 10);\n    return;\n  }\n\n  // If we reach this point, the component's elements should by styled.\n\n  // For auto-sizing to work, we need the text copy to have the same border,\n  // padding, and other relevant characteristics as the original text area.\n  // Since those aspects are affected by CSS, we have to wait until the\n  // element is in the document before we can update the text copy.\n  const textBoxStyle = getComputedStyle(element.inner);\n  const copyContainerStyle = element.$.copyContainer.style;\n  copyContainerStyle.borderBottomStyle  = textBoxStyle.borderBottomStyle;\n  copyContainerStyle.borderBottomWidth  = textBoxStyle.borderBottomWidth;\n  copyContainerStyle.borderLeftStyle    = textBoxStyle.borderLeftStyle;\n  copyContainerStyle.borderLeftWidth    = textBoxStyle.borderLeftWidth;\n  copyContainerStyle.borderRightStyle   = textBoxStyle.borderRightStyle;\n  copyContainerStyle.borderRightWidth   = textBoxStyle.borderRightWidth;\n  copyContainerStyle.borderTopStyle     = textBoxStyle.borderTopStyle;\n  copyContainerStyle.borderTopWidth     = textBoxStyle.borderTopWidth;\n  copyContainerStyle.paddingBottom      = textBoxStyle.paddingBottom;\n  copyContainerStyle.paddingLeft        = textBoxStyle.paddingLeft;\n  copyContainerStyle.paddingRight       = textBoxStyle.paddingRight;\n  copyContainerStyle.paddingTop         = textBoxStyle.paddingTop;\n\n  // Use the extraLine member to gauge the expected height of a single line of\n  // text. We can't use lineHeight, because that can be reported as \"normal\",\n  // and we want to know the actual pixel height.\n  element.$.extraLine.style.display = 'inherit';\n  element[lineHeightSymbol] = element.$.extraLine.clientHeight;\n\n  // Now that we know the line height, we can hide the extra line.\n  element.$.extraLine.style.display = 'none';\n\n  // Use the line height in conjunction with minimumRows to establish the\n  // overall minimum height of the component.\n  setMinimumHeight(element);\n}\n\n\n// Speculatively add a line to our copy of the text. We're not sure what the\n// exact effect of typing this character will be, and at this point it's not\n// reflected yet in the textarea's content. We speculate that it will add a\n// line to the text and size accordingly. (One other possibility is that the\n// user's replacing a selected chunk of text with a newline.) In any event,\n// once we get the keyup or change event, we'll make any final adjustments.\n//\n// TODO: If the user holds down the Enter key, we can get a bunch of keypress\n// events before we get keyup. This causes flicker. Instead of supporting only\n// a single extra speculative line, we should grow the speculative element to\n// contain the number of Enter keypresses we've received.\nfunction keypress(element, event) {\n  if (event.keyCode === 13 /* Enter */) {\n    element.$.extraLine.style.display = 'inherit';\n  }\n}\n\n\n// Setting the minimumRows attribute translates into setting the minimum\n// height on the text copy container.\nfunction setMinimumHeight(element) {\n  const copyContainer = element.$.copyContainer;\n  const outerHeight = copyContainer.getBoundingClientRect().height;\n  const style = getComputedStyle(copyContainer);\n  const paddingTop = parseFloat(style.paddingTop);\n  const paddingBottom = parseFloat(style.paddingBottom);\n  const innerHeight = copyContainer.clientHeight - paddingTop - paddingBottom;\n  const bordersPlusPadding = outerHeight - innerHeight;\n  let minHeight = (element.minimumRows * element[lineHeightSymbol]) + bordersPlusPadding;\n  minHeight = Math.ceil(minHeight);\n  copyContainer.style.minHeight = minHeight + 'px';\n}\n\n\nfunction unescapeHtml(html) {\n  return html\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, \">\")\n    .replace(/&quot;/g, '\\\"')\n    .replace(/&#039;/g, '\\'');\n}\n\n\n/*\n * Handle a change in the element's value property.\n */\nfunction valueChanged(element) {\n  element.autoSize();\n  element.dispatchEvent(new CustomEvent('value-changed'));\n}\n\n\ncustomElements.define('basic-autosize-textarea', AutosizeTextarea);\nexport default AutosizeTextarea;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport Carousel from './src/Carousel';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.Carousel = Carousel;\n","import AnimationStage from '../../basic-animation-stage/src/AnimationStage';\nimport HorizontalNavigationMixin from '../../basic-component-mixins/src/HorizontalNavigationMixin';\n\n\n/**\n * Lets the user navigate laterally through a sequence of child elements.\n *\n * basic-carousel is an implementation of the carousel user interface pattern,\n * commonly used for navigating between images, pages, and other elements. This\n * pattern presents the user with a linear sequence of elements, only one of\n * which is shown at a time. The user can navigate to the next/previous element\n * with a variety of input methods.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-carousel/)\n *\n * The above demo is a plain carousel. It's often combined, however, with\n * mixins like\n * [ArrowSelectionMixin](../basic-component-mixins/docs/ArrowSelectionMixin.md),\n * [PageDotsMixin](../basic-component-mixins/docs/PageDotsMixin.md),\n * [TimerSelectionMixin](../basic-component-mixins/docs/TimerSelectionMixin.md).\n * For example, you can view a\n * [demo with arrows and page dots](http://basicwebcomponents.org/basic-web-components/packages/demos/carousel-with-arrows-and-dots.html).\n * See the specific mixins for other carousel demos.\n *\n * basic-carousel uses its children as the elements the user will navigate\n * through. In a typical use, a basic-carousel can be used to navigate between a\n * sequence of images:\n *\n *     <basic-carousel>\n *       <img src=\"image1.jpg\">\n *       <img src=\"image2.jpg\">\n *       <img src=\"image3.jpg\">\n *     </basic-carousel>\n *\n * The child elements can be of any type they are not restricted to images.\n *\n * This component attempts to meet the [Gold Standard for web components]\n * (https://github.com/webcomponents/gold-standard/wiki) so that it is generally\n * as flexible and robust as standard HTML elements. For example, it meets the\n * \"Content Changes\" criteria: the carousel will adapt to new child elements\n * added or removed at runtime.\n *\n * Currently, this component does not meet the Gold Standard criteria \"Size to\n * Content\". As a result, for the time being, **you must manually set a size on\n * this component**. Two approaches are to: 1) stretch the component across\n * whatever surface it is contained within, or 2) set it to be larger than the\n * largest child element you want to display. The former approach is more\n * common, and can be achieved with CSS styling such as:\n *\n *     html {\n *       height: 100%;\n *     }\n *\n *     body {\n *       display: -webkit-flex;\n *       display: flex;\n *       height: 100%;\n *       margin: 0;\n *     }\n *\n *     basic-carousel {\n *       -webkit-flex: 1;\n *       flex: 1;\n *     }\n *\n * The standard basic-carousel component supports navigation via the following\n * input methods:\n *\n * * Keyboard. When the carousel has focus, the user can press Left, Right,\n *   Home, or End. These navigate to the expected element.\n * * Touch. On mobile and other touch-enabled devices, the user can drag left or\n *   right.\n * * Trackpad. The user can swipe left or right on a trackpad to navigate.\n *\n * Because carousels are used in a wide variety of circumstances, by default\n * basic-carousel provides a minimal appearance and no separately interactive\n * elements such as arrow buttons on the side or dots along the bottom. Those\n * elements can be added by wrapping a Carousel in optional mixins:\n *\n * * [ArrowSelectionMixin](../basic-component-mixins/docs/ArrowSelectionMixin.md).\n *   Adds prominent left and right arrow buttons on the side of the carousel.\n * * [PageDotsMixin](../basic-component-mixins/docs/PageDotsMixin.md).\n *   Adds a series of small dots below the carousel to indicate the user's\n *   current position in the sequence.\n * * [TimerSelectionMixin](../basic-component-mixins/docs/TimerSelectionMixin.md).\n *   Advances to the next item on a timer.\n * * [TabStripMixin](../basic-tab-strip).\n *   Adds a strip of traditional tab buttons.\n *\n * See those components for more details, but in general you can construct a\n * common carousel with both arrow buttons and dots like so:\n *\n *     class MyCarousel extends\n *         ArrowSelectionMixin(PageDotsMixin(Carousel)) {}\n *     customElements.define('my-carousel', MyCarousel);\n *\n * For universal access, basic-carousel automatically adds a variety of\n * [ARIA](http://www.w3.org/WAI/intro/aria) properties to itself and to child\n * elements. This helps users navigate the sequence of elements in the carousel\n * using assistive technologies.\n *\n * @extends AnimationStage\n * @mixes HorizontalNavigationMixin\n */\nclass Carousel extends AnimationStage.compose(\n  HorizontalNavigationMixin\n) {}\n\ncustomElements.define('basic-carousel', Carousel);\nexport default Carousel;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport CollapsiblePanel from './src/CollapsiblePanel';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.CollapsiblePanel = CollapsiblePanel;\n","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport OpenCloseMixin from '../../basic-component-mixins/src/OpenCloseMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/**\n * A panel which can be expanded/collapsed with an animated transition.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-collapsible-panel/)\n *\n * This component combines the OpenCloseMixin mixin and a simple CSS height\n * animation.\n *\n * This component handles only the duties of collapsing and expanding. It does\n * not provide a user interface for the user to trigger the change in state;\n * you must provide that user interface yourself.\n *\n * @extends ElementBase\n * @mixes OpenCloseMixin\n */\nclass CollapsiblePanel extends OpenCloseMixin(ElementBase) {\n\n  constructor() {\n    super();\n    this.$.overflow.addEventListener('transitionend', () => {\n      if (!this.closed) {\n        // Remove the hard-coded height we applied for the transition so that\n        // the element will reflow correctly, e.g., on window resize.\n        this.$.overflow.style.height = '';\n      }\n      // Ensure the animation only plays once. For some reason, Safari will show\n      // the animation twice without this line, even though the render function\n      // explicitly removes this class when it sets the old height. Neither\n      // Chrome nor Firefox seem to need this line.\n      this.classList.remove('showTransition');\n    });\n  }\n\n  render(closing) {\n    super.render(closing);\n\n    const naturalHeight = this.$.container.getBoundingClientRect().height;\n    if (naturalHeight === 0) {\n      // Most likely haven't had a chance to render yet.\n      this.$.overflow.style.height = closing ? 0 : '';\n      return;\n    }\n\n    // Without animating, set starting height of transition.\n    this.classList.remove('showTransition');\n    const oldHeight = closing ? naturalHeight : 0;\n    this.$.overflow.style.height = oldHeight + 'px';\n\n    // Force a relayout so that the starting height is applied.\n    // This can be achieved by reading a property like offsetHeight.\n    this.$.overflow.offsetHeight; // jshint ignore:line\n\n    // Turn animation on, and ending height of transition.\n    this.classList.add('showTransition');\n    const newHeight = closing ? 0 : naturalHeight;\n    this.$.overflow.style.height = newHeight + 'px';\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        display: block;\n        overflow: hidden;\n      }\n\n      :host(.showTransition) #overflow {\n        transition: height 0.2s;\n      }\n      </style>\n\n      <div id=\"overflow\" role=\"none\">\n        <div id=\"container\" role=\"none\">\n          <slot></slot>\n        </div>\n      </div>\n    `;\n  }\n\n}\n\n\ncustomElements.define('basic-collapsible-panel', CollapsiblePanel);\nexport default CollapsiblePanel;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport ArrowSelectionMixin from './src/ArrowSelectionMixin';\nimport AttributeMarshallingMixin from './src/AttributeMarshallingMixin';\nimport ClickSelectionMixin from './src/ClickSelectionMixin';\nimport ComposableMixin from './src/ComposableMixin';\nimport ContentItemsMixin from './src/ContentItemsMixin';\nimport createSymbol from './src/createSymbol';\nimport DirectionSelectionMixin from './src/DirectionSelectionMixin';\nimport DistributedChildrenMixin from './src/DistributedChildrenMixin';\nimport DistributedChildrenContentMixin from './src/DistributedChildrenContentMixin';\nimport GenericMixin from './src/GenericMixin';\nimport KeyboardMixin from './src/KeyboardMixin';\nimport KeyboardDirectionMixin from './src/KeyboardDirectionMixin';\nimport KeyboardPagedSelectionMixin from './src/KeyboardPagedSelectionMixin';\nimport KeyboardPrefixSelectionMixin from './src/KeyboardPrefixSelectionMixin';\nimport microtask from './src/microtask';\nimport PageDotsMixin from './src/PageDotsMixin';\nimport PlayControlsMixin from './src/PlayControlsMixin';\nimport safeAttributes from './src/safeAttributes';\nimport SelectionAnimationMixin from './src/SelectionAnimationMixin';\nimport SelectionAriaActiveMixin from './src/SelectionAriaActiveMixin';\nimport SelectionHighlightMixin from './src/SelectionHighlightMixin';\nimport SelectionInViewMixin from './src/SelectionInViewMixin';\nimport ShadowElementReferencesMixin from './src/ShadowElementReferencesMixin';\nimport ShadowTemplateMixin from './src/ShadowTemplateMixin';\nimport SingleSelectionMixin from './src/SingleSelectionMixin';\nimport SwipeDirectionMixin from './src/SwipeDirectionMixin';\nimport symbols from './src/symbols';\nimport TimerSelectionMixin from './src/TimerSelectionMixin';\nimport TrackpadDirectionMixin from './src/TrackpadDirectionMixin';\n\nwindow.Basic = window.Basic || {};\n\nwindow.Basic.ArrowSelectionMixin = ArrowSelectionMixin;\nwindow.Basic.AttributeMarshallingMixin = AttributeMarshallingMixin;\nwindow.Basic.ClickSelectionMixin = ClickSelectionMixin;\nwindow.Basic.ComposableMixin = ComposableMixin;\nwindow.Basic.ContentItemsMixin = ContentItemsMixin;\nwindow.Basic.createSymbol = createSymbol;\nwindow.Basic.DirectionSelectionMixin = DirectionSelectionMixin;\nwindow.Basic.DistributedChildrenMixin = DistributedChildrenMixin;\nwindow.Basic.DistributedChildrenContentMixin = DistributedChildrenContentMixin;\nwindow.Basic.generic = GenericMixin;\nwindow.Basic.KeyboardMixin = KeyboardMixin;\nwindow.Basic.KeyboardDirectionMixin = KeyboardDirectionMixin;\nwindow.Basic.KeyboardPagedSelectionMixin = KeyboardPagedSelectionMixin;\nwindow.Basic.KeyboardPrefixSelectionMixin = KeyboardPrefixSelectionMixin;\nwindow.Basic.microtask = microtask;\nwindow.Basic.PageDotsMixin = PageDotsMixin;\nwindow.Basic.PlayControlsMixin = PlayControlsMixin;\nwindow.Basic.safeAttributes = safeAttributes;\nwindow.Basic.SelectionAnimationMixin = SelectionAnimationMixin;\nwindow.Basic.SelectionAriaActiveMixin = SelectionAriaActiveMixin;\nwindow.Basic.SelectionHighlightMixin = SelectionHighlightMixin;\nwindow.Basic.SelectionInViewMixin = SelectionInViewMixin;\nwindow.Basic.ShadowElementReferencesMixin = ShadowElementReferencesMixin;\nwindow.Basic.ShadowTemplateMixin = ShadowTemplateMixin;\nwindow.Basic.SingleSelectionMixin = SingleSelectionMixin;\nwindow.Basic.SwipeDirectionMixin = SwipeDirectionMixin;\nwindow.Basic.symbols = symbols;\nwindow.Basic.TimerSelectionMixin = TimerSelectionMixin;\nwindow.Basic.TrackpadDirectionMixin = TrackpadDirectionMixin;\n","import createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n// Symbols for private data members on an element.\nconst mousedownListenerSymbol = createSymbol('mousedownListener');\nconst mousemoveListenerSymbol = createSymbol('mousemoveListener');\nconst lastMouseXSymbol = createSymbol('lastMouseX');\nconst lastMouseYSymbol = createSymbol('lastMouseY');\nconst mouseTimeoutSymbol = createSymbol('mouseTimeout');\n\n\n/* Exported function extends a base class with ArrowSelection. */\nexport default (base) => {\n\n  /**\n   * Template mixin which adds prominent left and right arrow buttons to a\n   * wrapped child such as a carousel.\n   *\n   * You can see a\n   * [live demo](http://basicwebcomponents.org/basic-web-components/packages/demos/carousel-with-arrows.html)\n   * of this mixin applied to a carousel.\n   *\n   * Clicking the left/right buttons selects the previous/next item.\n   *\n   * Typical usage:\n   *\n   *     class CarouselWithArrows extends ArrowSelectionMixin(Carousel) {}\n   *     customElements.define('carousel-with-arrows', CarouselWithArrows);\n   *\n   * By default, the arrow buttons are shown on devices with a mouse or mouse-like\n   * pointing device. They are not shown on a touch-capable device unless mouse\n   * movement is detected. To cause the buttons to always appear, apply the\n   * 'showArrows' CSS class.\n   */\n  class ArrowSelection extends base {\n\n    constructor() {\n      super();\n\n      this.$.buttonLeft.addEventListener('click', event => {\n        this.selectPrevious();\n        event.stopPropagation();\n      });\n      this.$.buttonRight.addEventListener('click', event => {\n        this.selectNext();\n        event.stopPropagation();\n      });\n      assumeButtonFocus(this, this.$.buttonLeft);\n      assumeButtonFocus(this, this.$.buttonRight);\n    }\n\n    get canSelectNext() {\n      return super.canSelectNext;\n    }\n    set canSelectNext(canSelectNext) {\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      this.$.buttonRight.disabled = !canSelectNext;\n    }\n\n    get canSelectPrevious() {\n      return super.canSelectPrevious;\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      this.$.buttonLeft.disabled = !canSelectPrevious;\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      if (!this.classList.contains('showArrows')) {\n        // Determine whether we should show arrow buttons or not.\n        if (deviceSupportsTouch()) {\n          // A touch device might also support a mouse, but we can't know whether\n          // there's actually a mouse until we hear from it.\n          listenForMouse(this);\n        } else {\n          // The device doesn't support touch, so assume it has a mouse.\n          showArrows(this);\n        }\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.navigationAxis = 'horizontal';\n      return defaults;\n    }\n\n    /*\n     * The template uses the chevron-left and chevron-right SVG icons from\n     * https://github.com/PolymerElements/iron-icons/blob/master/iron-icons.html.\n     */\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n        :host {\n          -webkit-align-items: stretch;\n          align-items: stretch;\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          -webkit-justify-content: center;\n          justify-content: center;\n        }\n\n        #arrowNavigationContainer {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          position: relative;\n        }\n\n        .navigationButton {\n          background: transparent;\n          border: 1px solid transparent;\n          box-sizing: border-box;\n          color: rgba(0, 0, 0, 0.7);\n          fill: currentColor;\n          margin: 0;\n          opacity: 1;\n          outline: none; /* REVIEW: Accessibility should be provided by other elements. */\n          padding: 0;\n          transition: opacity 1s;\n          z-index: 1;\n        }\n\n        .navigationButton:hover:not(:disabled) {\n          background: rgba(0, 0, 0, 0.5);\n          color: rgba(0, 0, 0, 0.8);\n          cursor: pointer;\n        }\n        .navigationButton:active:not(:disabled) {\n          background: rgba(0, 0, 0, 0.7);\n          color: rgba(0, 0, 0, 0.9);\n        }\n        .navigationButton:disabled {\n          color: rgba(0, 0, 0, 0.2);\n        }\n\n        :host(:not(.showArrows)) .navigationButton {\n          opacity: 0;\n          visibility: hidden;\n        }\n\n        .navigationButton .icon {\n          height: 48px;\n          width: 48px;\n        }\n\n        /* Overlay variant */\n        :host(.overlayArrows) {\n          position: relative;\n        }\n        :host(.overlayArrows) .navigationButton {\n          bottom: 0;\n          color: rgba(255, 255, 255, 0.7);\n          position: absolute;\n          top: 0;\n        }\n        :host(.overlayArrows) #buttonLeft {\n          left: 0;\n        }\n        :host(.overlayArrows) #buttonRight {\n          right: 0;\n        }\n        :host(.overlayArrows) .navigationButton:hover:not(:disabled) {\n          background: rgba(255, 255, 255, 0.2);\n          color: rgba(255, 255, 255, 0.8);\n        }\n        :host(.overlayArrows) .navigationButton:active:not(:disabled) {\n          background: rgba(255, 255, 255, 0.4);\n          color: rgba(255, 255, 255, 0.9);\n        }\n        :host(.overlayArrows) .navigationButton:disabled {\n          color: rgba(255, 255, 255, 0.3);\n        }\n        </style>\n\n        <!--\n        Accessibility note: since the navigation offered by the arrow buttons should\n        be redundant (that is, there should be other ways of navigating the list),\n        we mark the button as aria-hidden so that assistive devices ignore them.\n        -->\n        <button id=\"buttonLeft\" class=\"navigationButton\" disabled tabindex=\"-1\" aria-hidden=\"true\">\n          <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n            <g id=\"chevron-left\">\n              <path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"/>\n            </g>\n          </svg>\n        </button>\n        <div id=\"arrowNavigationContainer\" role=\"none\">\n          ${baseTemplate}\n        </div>\n        <button id=\"buttonRight\" class=\"navigationButton\" disabled tabindex=\"-1\" aria-hidden=\"true\">\n          <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n            <g id=\"chevron-right\">\n              <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"/>\n            </g>\n          </svg>\n        </button>\n      `;\n    }\n\n  }\n\n  return ArrowSelection;\n};\n\n\n/*\n * By default, a button will always take focus on mousedown. For this component,\n * we want to override that behavior, such that a mousedown on a button keeps\n * the focus on the outer component.\n */\nfunction assumeButtonFocus(element, button) {\n  button.addEventListener('mousedown', event => {\n    // Given the main element the focus if it doesn't already have it.\n    element.focus();\n    // Prevent the default focus-on-mousedown behavior.\n    event.preventDefault();\n  });\n}\n\nfunction deviceSupportsTouch() {\n  return 'ontouchstart' in window ||\n      (window.DocumentTouch && document instanceof window.DocumentTouch);\n}\n\n// We try to detect the presence of a mouse by listening for mousemove events\n// which are *not* the result of a mousedown. On a touch device, a tap on the\n// page will generate a fake mousemove, followed by a mousedown. We don't want\n// to respond to those fake mousemove events. To discriminate between fake and\n// real mousemove events, when we get a mousemove event, we wait for a bit to\n// see if the same location is reported as the location of a subsequent\n// mousedown.\nfunction listenForMouse(element) {\n\n  element[mousedownListenerSymbol] = event => {\n    if (element[mouseTimeoutSymbol]) {\n      clearTimeout(element[mouseTimeoutSymbol]);\n    }\n    element[lastMouseXSymbol] = event.pageX;\n    element[lastMouseYSymbol] = event.pageY;\n  };\n  window.addEventListener('mousedown', element[mousedownListenerSymbol]);\n\n  element[mousemoveListenerSymbol] = event => {\n    // Postpone checking the mousemove location to give the mousedown event a\n    // chance to fire. The 250 ms delay is just guesswork; a shorter delay\n    // doesn't seem to work.\n    element[mouseTimeoutSymbol] = setTimeout(() => {\n      if (element[lastMouseXSymbol] != null && event.pageX !== element[lastMouseXSymbol] ||\n          element[lastMouseYSymbol] != null && event.pageY !== element[lastMouseYSymbol]) {\n        // mousemove event was at a location other than the last mousedown,\n        // and hence most likely a real mousemove event.\n        mouseDetected(element);\n      } else {\n        element[lastMouseXSymbol] = event.pageX;\n        element[lastMouseYSymbol] = event.pageY;\n      }\n    }, 250);\n  };\n  window.addEventListener('mousemove', element[mousemoveListenerSymbol]);\n}\n\nfunction mouseDetected(element) {\n  showArrows(element);\n\n  // We can stop listening for mouse events now.\n  if (element[mouseTimeoutSymbol]) {\n    clearTimeout(element[mouseTimeoutSymbol]);\n  }\n  window.removeEventListener('mousedown', element[mousedownListenerSymbol]);\n  window.removeEventListener('mousemove', element[mousemoveListenerSymbol]);\n  element[mousedownListenerSymbol] = null;\n  element[mousemoveListenerSymbol] = null;\n}\n\nfunction showArrows(element) {\n  element.classList.add('showArrows');\n}\n","import safeAttributes from './safeAttributes';\n\n\n// Memoized maps of attribute to property names and vice versa.\nconst attributeToPropertyNames = {};\nconst propertyNamesToAttributes = {};\n\n\n/* Exported function extends a base class with AttributeMarshalling. */\nexport default (base) => {\n\n  /**\n   * Mixin which marshalls attributes to properties and vice versa.\n   *\n   * If your component exposes a setter for a property, it's generally a good\n   * idea to let devs using your component be able to set that property in HTML\n   * via an element attribute. You can code that yourself by writing an\n   * `attributeChangedCallback`, or you can use this mixin to get a degree of\n   * automatic support.\n   *\n   * This mixin implements an `attributeChangedCallback` that will attempt to\n   * convert a change in an element attribute into a call to the corresponding\n   * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n   * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n   * respects that convention, automatically mapping the hyphenated attribute\n   * name to the corresponding camelCase property name.\n   *\n   * Example: You define a component using this mixin:\n   *\n   *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n   *       get fooBar() { return this._fooBar; }\n   *       set fooBar(value) { this._fooBar = value; }\n   *     }\n   *     customElements.define('my-element', MyElement);\n   *\n   * If someone then instantiates your component in HTML:\n   *\n   *     <my-element foo-bar=\"Hello\"></my-element>\n   *\n   * Then, after the element has been upgraded, the `fooBar` setter will\n   * automatically be invoked with the initial value \"Hello\".\n   *\n   * For the time being, this mixin only supports string-valued properties.\n   * If you'd like to convert string attributes to other types (numbers,\n   * booleans), you need to implement `attributeChangedCallback` yourself.\n   */\n  class AttributeMarshalling extends base {\n\n    /*\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n      const propertyName = attributeToPropertyName(attributeName);\n      // If the attribute name corresponds to a property name, set the property.\n      // Ignore standard HTMLElement properties handled by the DOM.\n      if (propertyName in this && !(propertyName in HTMLElement.prototype)) {\n        this[propertyName] = newValue;\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    static get observedAttributes() {\n      return attributesForClass(this);\n    }\n\n    /**\n     * Set/unset the attribute with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as an attribute. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes. A call to `reflectAttribute` during the constructor will\n     * be deferred until the element is connected to the document.\n     *\n     * @param {string} attribute - The name of the *attribute* (not property) to set.\n     * @param {object} value - The value to set. If null, the attribute will be removed.\n     */\n    reflectAttribute(attribute, value) {\n      return safeAttributes.setAttribute(this, attribute, value);\n    }\n\n    /**\n     * Set/unset the class with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as as class. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes, including the `class` attribute. A call to\n     * `reflectClass` during the constructor will be deferred until the element\n     * is connected to the document.\n     *\n     * @param {string} className - The name of the class to set.\n     * @param {object} value - True to set the class, false to remove it.\n     */\n    reflectClass(className, value) {\n      return safeAttributes.toggleClass(this, className, value);\n    }\n\n  }\n\n  return AttributeMarshalling;\n};\n\n\n// Convert hyphenated foo-bar attribute name to camel case fooBar property name.\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hypenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hypenRegEx,\n        match => match[1].toUpperCase());\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\nfunction attributesForClass(classFn) {\n\n  // We treat the element base classes as if they have no attributes, since we\n  // don't want to receive attributeChangedCallback for them.\n  if (classFn === HTMLElement || classFn === Object) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n  const baseAttributes = attributesForClass(baseClass);\n\n  // Get attributes for this class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter(propertyName =>\n    typeof Object.getOwnPropertyDescriptor(\n        classFn.prototype, propertyName).set === 'function');\n  const attributes = setterNames.map(setterName =>\n      propertyNameToAttribute(setterName));\n\n  // Merge.\n  const diff = attributes.filter(attribute =>\n      baseAttributes.indexOf(attribute) < 0);\n  return baseAttributes.concat(diff);\n}\n\n// Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, '-$1').toLowerCase();\n  }\n  return attribute;\n}\n","/* Exported function extends a base class with ClickSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps a click (actually, a mousedown) to a selection.\n   *\n   * This simple mixin is useful in list box-like elements, where a click on a\n   * list item implicitly selects it.\n   *\n   * This mixin expects the component to provide an `items` property. You can\n   * provide that property yourself, or use\n   * [ContentItemsMixin](ContentItemsMixin.md). This mixin also expects the\n   * component to define a `selectedIndex` property. You can provide that\n   * yourself, or use [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class ClickSelection extends base {\n\n    constructor() {\n      super();\n      /*\n       * REVIEW: Which event should we listen to here?\n       *\n       * The standard use for this mixin is in list boxes. List boxes don't\n       * appear to be consistent with regard to whether they select on mousedown\n       * or click/mouseup.\n       */\n      this.addEventListener('mousedown', event => {\n        // HACK: If the item is a button, the event seems to be raised in\n        // phase 2 (AT_TARGET), but the target is the component, not item.\n        // Need to invesigate.\n        const target = event.target === this ?\n          event.path[0] :\n          event.target;\n        const index = indexOfContainingItem(this, target);\n        if (index >= 0) {\n          this.selectedIndex = index;\n          // Note: We don't call preventDefault here. The default behavior for\n          // mousedown includes setting keyboard focus if the element doesn't\n          // already have the focus, and we want to preserve that behavior.\n          event.stopPropagation();\n        }\n      });\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n    }\n\n  }\n\n  return ClickSelection;\n};\n\n\n/*\n * Return index of the element items that either is or contains the indicated\n * target. Return -1 if not found.\n */\nfunction indexOfContainingItem(element, target) {\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n  for (let i = 0; i < itemCount; i++) {\n    let item = items[i];\n    if (item === target || item.contains(target)) {\n      return i;\n    }\n  }\n  return -1;\n}\n","/* Exported function extends a base class with Composable. */\nexport default (base) => {\n\n  /**\n   * Mixin to make a class more easily composable with other mixins.\n   *\n   * This mixin contributes a `compose` method that applies a set of mixin\n   * functions and returns the resulting new class. This sugar can make the\n   * application of many mixins at once easier to read.\n   */\n  class Composable extends base {\n\n    /**\n     * Apply a set of mixin functions or mixin objects to the present class and\n     * return the new class.\n     *\n     * Instead of writing:\n     *\n     *     let MyClass = Mixin1(Mixin2(Mixin3(Mixin4(Mixin5(BaseClass)))));\n     *\n     * You can write:\n     *\n     *     let MyClass = ComposableMixin(BaseClass).compose(\n     *       Mixin1,\n     *       Mixin2,\n     *       Mixin3,\n     *       Mixin4,\n     *       Mixin5\n     *     );\n     *\n     * This function can also take mixin objects. A mixin object is just a\n     * shorthand for a mixin function that creates a new subclass with the given\n     * members. The mixin object's members are *not* copied directly onto the\n     * prototype of the base class, as with traditional mixins.\n     *\n     * In addition to providing syntactic sugar, this mixin can be used to\n     * define a class in ES5, which lacks ES6's `class` keyword.\n     *\n     * @param {...mixins} mixins - A set of mixin functions or objects to apply.\n     */\n    static compose(...mixins) {\n      // We create a new subclass for each mixin in turn. The result becomes\n      // the base class extended by any subsequent mixins. It turns out that\n      // we can use Array.reduce() to concisely express this, using the current\n      // object as the seed for reduce().\n      return mixins.reduce(composeClass, this);\n    }\n\n  }\n\n  return Composable;\n};\n\n\n// Properties defined by Object that we don't want to mixin.\nconst NON_MIXABLE_OBJECT_PROPERTIES = [\n  'constructor'\n];\n\n/*\n * Apply the mixin to the given base class to return a new class.\n * The mixin can either be a function that returns the modified class, or a\n * plain object whose members will be copied to the new class' prototype.\n */\nfunction composeClass(base, mixin) {\n  if (typeof mixin === 'function') {\n    // Mixin function\n    return mixin(base);\n  } else {\n    // Mixin object\n    class Subclass extends base {}\n    copyOwnProperties(mixin, Subclass.prototype, NON_MIXABLE_OBJECT_PROPERTIES);\n    return Subclass;\n  }\n}\n\n\n/*\n * Copy the given properties/methods to the target.\n * Return the updated target.\n */\nfunction copyOwnProperties(source, target, ignorePropertyNames = []) {\n  Object.getOwnPropertyNames(source).forEach(name => {\n    if (ignorePropertyNames.indexOf(name) < 0) {\n      const descriptor = Object.getOwnPropertyDescriptor(source, name);\n      Object.defineProperty(target, name, descriptor);\n    }\n  });\n  return target;\n}\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemsSymbol = createSymbol('items');\nconst itemInitializedSymbol = createSymbol('itemInitialized');\n\n\n/* Exported function extends a base class with ContentItems. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps content semantics (elements) to list item semantics.\n   *\n   * Items differ from element contents in several ways:\n   *\n   * * They are often referenced via index.\n   * * They may have a selection state.\n   * * It's common to do work to initialize the appearance or state of a new\n   *   item.\n   * * Auxiliary invisible child elements are filtered out and not counted as\n   *   items. Auxiliary elements include link, script, style, and template\n   *   elements. This filtering ensures that those auxiliary elements can be\n   *   used in markup inside of a list without being treated as list items.\n   *\n   * This mixin expects a component to provide a `content` property returning a\n   * raw set of elements. You can provide that yourself, or use\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md).\n   *\n   * The most commonly referenced property defined by this mixin is the `items`\n   * property. To avoid having to do work each time that property is requested,\n   * this mixin supports an optimized mode. If you invoke the `contentChanged`\n   * method when the set of items changes, the mixin concludes that you'll take\n   * care of notifying it of future changes, and turns on the optimization. With\n   * that on, the mixin saves a reference to the computed set of items, and will\n   * return that immediately on subsequent calls to the `items` property. If you\n   * use this mixin in conjunction with\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md), the\n   * `contentChanged` method will be invoked for you when the element's children\n   * change, turning on the optimization automatically.\n   */\n  class ContentItems extends base {\n\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n\n      // Since we got the contentChanged call, we'll assume we'll be notified if\n      // the set of items changes later. We turn on memoization of the items\n      // property by setting our internal property to null (instead of\n      // undefined).\n      this[itemsSymbol] = null;\n\n      this[symbols.itemsChanged]();\n    }\n\n    /**\n     * This method is invoked whenever a new item is added to the list.\n     *\n     * The default implementation of this method does nothing. You can override\n     * this to perform per-item initialization.\n     *\n     * @param {HTMLElement} item - The item that was added.\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n    }\n\n    /**\n     * The selection state for a single item has changed.\n     *\n     * Invoke this method to signal that the selected state of the indicated item\n     * has changed. By default, this applies a `selected` CSS class if the item\n     * is selected, and removed it if not selected.\n     *\n     * @param {HTMLElement} item - The item whose selection state has changed.\n     * @param {boolean} selected - True if the item is selected, false if not.\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      toggleClass(item, 'selected', selected);\n    }\n\n    /**\n     * The current set of items in the list. See the top-level documentation for\n     * mixin for a description of how items differ from plain content.\n     *\n     * @type {HTMLElement[]}\n     */\n    get items() {\n      let items;\n      if (this[itemsSymbol] == null) {\n        items = filterAuxiliaryElements(this.content);\n        // Note: test for *equality* with null; don't treat undefined as a match.\n        if (this[itemsSymbol] === null) {\n          // Memoize the set of items.\n          this[itemsSymbol] = items;\n        }\n      } else {\n        // Return the memoized items.\n        items = this[itemsSymbol];\n      }\n      return items;\n    }\n\n    /**\n     * This method is invoked when the underlying contents change. It is also\n     * invoked on component initialization  since the items have \"changed\" from\n     * being nothing.\n     */\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // Perform per-item initialization.\n      Array.prototype.forEach.call(this.items, item => {\n        if (!item[itemInitializedSymbol]) {\n          this[symbols.itemAdded](item);\n          item[itemInitializedSymbol] = true;\n        }\n      });\n\n      this.dispatchEvent(new CustomEvent('items-changed'));\n    }\n\n    /**\n     * Fires when the items in the list change.\n     *\n     * @memberof ContentItems\n     * @event items-changed\n     */\n  }\n\n  return ContentItems;\n};\n\n\n// Return the given elements, filtering out auxiliary elements that aren't\n// typically visible. Items which are not elements are returned as is.\nfunction filterAuxiliaryElements(items) {\n  const auxiliaryTags = [\n    'link',\n    'script',\n    'style',\n    'template'\n  ];\n  return [].filter.call(items, function(item) {\n    return !item.localName || auxiliaryTags.indexOf(item.localName) < 0;\n  });\n}\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with DirectionSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps direction semantics (goLeft, goRight, etc.) to selection\n   * semantics (selectPrevious, selectNext, etc.).\n   *\n   * This mixin can be used in conjunction with\n   * [KeyboardDirectionMixin](KeyboardDirectionMixin.md) (which maps keyboard\n   * events to directions) and a mixin that handles selection like\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class DirectionSelection extends base {\n\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { super[symbols.goDown](); }\n      return this.selectNext();\n    }\n\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { super[symbols.goEnd](); }\n      return this.selectLast();\n    }\n\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { super[symbols.goLeft](); }\n      return this.selectPrevious();\n    }\n\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { super[symbols.goRight](); }\n      return this.selectNext();\n    }\n\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { super[symbols.goStart](); }\n      return this.selectFirst();\n    }\n\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { super[symbols.goUp](); }\n      return this.selectPrevious();\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    get selectedFraction() {\n      return super.selectedFraction;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectFirst() {\n      if (super.selectFirst) { return super.selectFirst(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectLast() {\n      if (super.selectLast) { return super.selectLast(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectNext() {\n      if (super.selectNext) { return super.selectNext(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectPrevious() {\n      if (super.selectPrevious) { return super.selectPrevious(); }\n    }\n\n    // Map drag travel fraction to selection fraction.\n    get travelFraction() {\n      return super.travelFraction;\n    }\n    set travelFraction(value) {\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n      this.selectedFraction = value;\n    }\n\n  }\n\n  return DirectionSelection;\n};\n","import microtask from './microtask';\n\n\n/* Exported function extends a base class with DistributedChildrenContent. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines a component's content as its children, expanding any\n   * nodes distributed to the component's slots.\n   *\n   * This also provides notification of changes to a component's content. It\n   * will invoke a `contentChanged` method when the component is first\n   * instantiated, and whenever its distributed children change. This is an\n   * easy way to satisfy the Gold Standard checklist item for monitoring\n   * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n   *\n   * Example:\n   *\n   * ```\n   * let base = DistributedChildrenContentMixin(DistributedChildrenMixin(HTMLElement));\n   * class CountingElement extends base {\n   *\n   *   constructor() {\n   *     super();\n   *     let root = this.attachShadow({ mode: 'open' });\n   *     root.innerHTML = `<slot></slot>`;\n   *   }\n   *\n   *   contentChanged() {\n   *     // Count the component's children, both initially and when changed.\n   *     this.count = this.distributedChildren.length;\n   *   }\n   *\n   * }\n   * ```\n   *\n   * Note that content change detection depends upon the element having at least\n   * one `slot` element in its shadow subtree.\n   *\n   * This mixin is intended for use with the\n   * [DistributedChildrenMixin](DistributedChildrenMixin.md). See that mixin for\n   * a discussion of how that works. This DistributedChildrenContentMixin\n   * provides an easy way of defining the \"content\" of a component as the\n   * component's distributed children. That in turn lets mixins like\n   * [ContentItemsMixin](ContentItemsMixin.md) manipulate the children as list\n   * items.\n   */\n  class DistributedChildrenContent extends base {\n\n    constructor() {\n      super();\n\n      if (this.shadowRoot) {\n        // Listen to changes on all slots.\n        const slots = this.shadowRoot.querySelectorAll('slot');\n        slots.forEach(slot => slot.addEventListener('slotchange', event => {\n          this.contentChanged();\n        }));\n      }\n\n      // Make an initial call to contentChanged() so that the component can do\n      // initialization that it normally does when content changes.\n      //\n      // This will invoke contentChanged() handlers in other mixins. In order\n      // that those mixins have a chance to complete their own initialization,\n      // we add the contentChanged() call to the microtask queue.\n      microtask(() => this.contentChanged());\n    }\n\n    /**\n     * Invoked when the contents of the component (including distributed\n     * children) have changed.\n     *\n     * This method is also invoked when a component is first instantiated; the\n     * contents have essentially \"changed\" from being nothing. This allows the\n     * component to perform initial processing of its children.\n     */\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n      const event = new CustomEvent('content-changed');\n      this.dispatchEvent(event);\n    }\n\n    /**\n     * The content of this component, defined to be the flattened array of\n     * children distributed to the component.\n     *\n     * @type {HTMLElement[]}\n     */\n    get content() {\n      const distributedChildren = this.distributedChildren;\n      if (typeof distributedChildren === 'undefined') {\n        console.warn(`DistributedChildrenContentMixin expects the component to define a \"distributedChildren\" property.`);\n      }\n      return distributedChildren;\n    }\n    set content(value) {\n      if ('content' in base.prototype) { super.content = value; }\n      // TODO: Set the children to the given value (which should be an array of\n      // elements)?\n    }\n\n    /**\n     * This event is raised when the component's contents (including distributed\n     * children) have changed.\n     *\n     * @memberof DistributedChildrenContent\n     * @event content-changed\n     */\n  }\n\n  return DistributedChildrenContent;\n};\n","/* Exported function extends a base class with DistributedChildren. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines helpers for accessing a component's distributed\n   * children as a flattened array or string.\n   *\n   * The standard DOM API provides several ways of accessing child content:\n   * `children`, `childNodes`, and `textContent`. None of these functions are\n   * Shadow DOM aware. This mixin defines variations of those functions that\n   * *are* Shadow DOM aware.\n   *\n   * Example: you create a component `<count-children>` that displays a number\n   * equal to the number of children placed inside that component. If someone\n   * instantiates your component like:\n   *\n   *     <count-children>\n   *       <div></div>\n   *       <div></div>\n   *       <div></div>\n   *     </count-children>\n   *\n   * Then the component should show \"3\", because there are three children. To\n   * calculate the number of children, the component can just calculate\n   * `this.children.length`. However, suppose someone instantiates your\n   * component inside one of their own components, and puts a `<slot>` element\n   * inside your component:\n   *\n   *     <count-children>\n   *       <slot></slot>\n   *     </count-children>\n   *\n   * If your component only looks at `this.children`, it will always see exactly\n   * one child the `<slot>` element. But the user looking at the page will\n   * *see* any nodes distributed to that slot. To match what the user sees, your\n   * component should expand any `<slot>` elements it contains.\n   *\n   * That is the problem this mixin solves. After applying this mixin, your\n   * component code has access to `this.distributedChildren`, whose `length`\n   * will return the total number of all children distributed to your component\n   * in the composed tree.\n   *\n   * Note: The latest Custom Elements API design calls for a new function,\n   * `getAssignedNodes` that takes an optional `deep` parameter, that will solve\n   * this problem at the API level.\n   */\n  class DistributedChildren extends base {\n\n    /**\n     * An in-order collection of distributed children, expanding any slot\n     * elements. Like the standard children property, this skips text nodes.\n     *\n     * @type {HTMLElement[]}\n     */\n    get distributedChildren() {\n      return expandContentElements(this.children, false);\n    }\n\n    /**\n     * An in-order collection of distributed child nodes, expanding any slot\n     * elements. Like the standard childNodes property, this includes text\n     * nodes.\n     *\n     * @type {Node[]}\n     */\n    get distributedChildNodes() {\n      return expandContentElements(this.childNodes, true);\n    }\n\n    /**\n     * The concatenated text content of all distributed child nodes, expanding\n     * any slot elements.\n     *\n     * @type {string}\n     */\n    get distributedTextContent() {\n      const strings = this.distributedChildNodes.map(function(child) {\n        return child.textContent;\n      });\n      return strings.join('');\n    }\n\n  }\n\n  return DistributedChildren;\n};\n\n\n/*\n * Given a array of nodes, return a new array with any content elements expanded\n * to the nodes distributed to that content element. This rule is applied\n * recursively.\n *\n * If includeTextNodes is true, text nodes will be included, as in the\n * standard childNodes property; by default, this skips text nodes, like the\n * standard children property.\n */\nfunction expandContentElements(nodes, includeTextNodes) {\n  const expanded = Array.prototype.map.call(nodes, node => {\n    // We want to see if the node is an instanceof HTMLSlotELement, but\n    // that class won't exist if the browser that doesn't support native\n    // Shadow DOM and if the Shadow DOM polyfill hasn't been loaded. Instead,\n    // we do a simplistic check to see if the tag name is \"slot\".\n    const isSlot = typeof HTMLSlotElement !== 'undefined' ?\n      node instanceof HTMLSlotElement :\n      node.localName === 'slot';\n    if (isSlot) {\n      // Use the nodes assigned to this node instead.\n      const assignedNodes = node.assignedNodes({ flatten: true });\n      return assignedNodes ?\n        expandContentElements(assignedNodes, includeTextNodes) :\n        [];\n    } else if (node instanceof HTMLElement) {\n      // Plain element; use as is.\n      return [node];\n    } else if (node instanceof Text && includeTextNodes) {\n      // Text node.\n      return [node];\n    } else {\n      // Comment, processing instruction, etc.; skip.\n      return [];\n    }\n  });\n  const flattened = [].concat(...expanded);\n  return flattened;\n}\n","import createSymbol from './createSymbol';\n\n\n// Symbols for private data members on an element.\nconst selectedFractionSymbol = createSymbol('selectedFraction');\n\n\n/* Exported function extends a base class with FractionalSelection. */\nexport default function mixin(base) {\n\n  /**\n   * Adds support for fractional selection: treating a selection as a real\n   * number that combines an integer portion (an index into a list), and a\n   * fraction (indicating how far of the way we are to the next or previous\n   * item).\n   *\n   * This is useful in components that support incremental operations during\n   * dragging and swiping. Example: a carousel component has several items, and the\n   * currently selected item is item 3. The user begins swiping to the left,\n   * moving towards selecting item 4. Halfway through this operation, the\n   * fractional selection value is 3.5.\n   *\n   * This value permits communication between mixins like\n   * [SwipeDirectionMixin](./SwipeDirectionMixin.md) and\n   * [TrackpadDirectionMixin](./TrackpadDirectionMixin.md), which generate\n   * fractional selection values, and mixins like\n   * [SelectionAnimationMixin](./SelectionAnimationMixin.md), which can render\n   * selection at a fractional value.\n   */\n  class FractionalSelection extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      this.selectedFraction = 0;\n    }\n\n    /**\n     * A fractional value indicating how far the user has currently advanced to\n     * the next/previous item. E.g., a `selectedFraction` of 3.5 indicates the\n     * user is halfway between items 3 and 4.\n     *\n     * @type {number}\n     */\n    get selectedFraction() {\n      return this[selectedFractionSymbol];\n    }\n    set selectedFraction(value) {\n      this[selectedFractionSymbol] = value;\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      const event = new CustomEvent('selected-fraction-changed');\n      this.dispatchEvent(event);\n    }\n\n  }\n\n  return FractionalSelection;\n}\n\n\nmixin.helpers = {\n\n  /*\n   * Dampen a selection that goes past the beginning or end of a list. This is\n   * generally used to produce a visual effect of tension as the user tries to\n   * go further in a direction that has no more items.\n   *\n   * Example: suppose `itemCount` is 5, indicating a list of 5 items. The index of\n   * the last item is 4. If the `selection` parameter is 4.5, the user is trying\n   * to go past this last item. When a damping function is applied, the resulting\n   * value will be less than 4.5 (the actual value will be 4.25). When this\n   * selection state is rendered, the user will see that, each unit distance the\n   * drag travels has less and less visible effect. This is perceived as tension.\n   *\n   * @param {number} selection - A real number indicating a selection position\n   * @param {number} itemCount - An integer for the number of items in the list\n   * @returns {number} A real number representing the damped selection value.\n   */\n  dampedSelection(selection, itemCount) {\n    const bound = itemCount - 1;\n    let damped;\n    if (selection < 0) {\n      // Trying to go past beginning of list. Apply tension from the left edge.\n      damped = -mixin.helpers.damping(-selection);\n    } else if (selection >= bound) {\n      // Trying to go past end of list. Apply tension from the right edge.\n      damped = bound + mixin.helpers.damping(selection - bound);\n    } else {\n      // No damping required.\n      damped = selection;\n    }\n    return damped;\n  },\n\n  /*\n   * Calculate damping as a function of the distance past the minimum/maximum\n   * values.\n   *\n   * We want to asymptotically approach an absolute minimum of 1 unit\n   * below/above the actual minimum/maximum. This requires calculating a\n   * hyperbolic function.\n   *\n   * See http://www.wolframalpha.com/input/?i=y+%3D+-1%2F%28x%2B1%29+%2B+1\n   * for the one we use. The only portion of that function we care about is when\n   * x is zero or greater. An important consideration is that the curve be\n   * tangent to the diagonal line x=y at (0, 0). This ensures smooth continuity\n   * with the normal drag behavior, in which the visible sliding is linear with\n   * the distance the touchpoint has been dragged.\n   */\n  damping(x) {\n    const y = (-1 / (x + 1)) + 1;\n    return y;\n  },\n\n  /*\n   * Return the current fractional selection value for the given element.\n   *\n   * This simply adds the element's `selectedIndex` and `selectedFraction`\n   * properties.\n   *\n   * @param {HTMLElement} element - An element that supports selection\n   */\n  elementSelection(element) {\n    const selectedIndex = element.selectedIndex;\n    if (selectedIndex < 0) {\n      // No selection\n      return;\n    }\n    const selectedFraction = element.selectedFraction || 0;\n    return selectedIndex + selectedFraction;\n  },\n\n  /*\n   * Breaks a fractional selection into its integer and fractional parts.\n   *\n   * Example: if passed 3.5, this returns { index: 3, fraction: 5 }.\n   *\n   * @param {number} selection A real number representing a selection point\n   * @returns {object} - An object with an `index` property holding the\n   * selection's integer component, and a `fraction` property holding the\n   * selection's fractional component.\n   */\n  selectionParts(selection) {\n    // Stupid IE doesn't have Math.trunc.\n    // const index = Math.trunc(selection);\n    const index = selection < 0 ? Math.ceil(selection) : Math.floor(selection);\n    const fraction = selection - index;\n    return { index, fraction };\n  },\n\n  /*\n   * Returns a fractional selection point after accounting for wrapping, ensuring\n   * that the integer portion of the selection stays between 0 and `itemCount`-1.\n   * That is, the integer portion will always be a valid index into the list.\n   *\n   * Example of wrapping past the end of the list: if `selection` is 5.5 and\n   * `itemCount` is 5, this returns 0.5. Example of wrapping past the beginning of\n   * the list: if `selection` is 0.5 and `itemCount` is 5, this returns 4.5.\n   *\n   * @param {number} selection - A real number representing a selection point\n   * @param {number} itemCount - The number of items in the list\n   * @returns {number} - The result of wrapping the selection point\n   */\n  wrappedSelection(selection, itemCount) {\n    // Handles possibility of negative mod.\n    // See http://stackoverflow.com/a/18618250/76472\n    return ((selection % itemCount) + itemCount) % itemCount;\n  },\n\n  /*\n   * Return the parts of a selection, first wrapping if necessary.\n   *\n   * @param {number} selection  A real number representing a selection point\n   * @param {number} itemCount - The number of items in the list\n   * @param {boolean} wrap  True if the selection should wrap to stay within the\n   * list\n   * @returns {object}  The parts of the selection, using the same format as\n   * `selectionParts`.\n   */\n  wrappedSelectionParts(selection, itemCount, wrap) {\n    if (wrap) {\n      selection = mixin.helpers.wrappedSelection(selection, itemCount);\n    }\n    return mixin.helpers.selectionParts(selection);\n  }\n\n};\n","import createSymbol from './createSymbol';\nimport safeAttributes from './safeAttributes';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst genericSymbol = createSymbol('generic');\n\n\n/* Exported function extends a base class with Generic. */\nexport default (base) => {\n\n  /**\n   * Mixin which allows a component to support a \"generic\" style: a minimalist\n   * style that can easily be removed to reset its visual appearance to a\n   * baseline state.\n   *\n   * By default, a component should provide a minimal visual presentation that\n   * allows the component to function. However, the more styling the component\n   * provides by default, the harder it becomes to get the component to fit in\n   * in other settings. Each CSS rule has to be overridden. Worse, new CSS rules\n   * added to the default style won't be overridden by default, making it hard\n   * to know whether a new version of a component will still look okay.\n   *\n   * As a compromise, the mixin defines a `generic` attribute. This attribute is\n   * normally set by default, and styles can be written that apply only when the\n   * generic attribute is set. This allows the construction of CSS rules that\n   * will only apply to generic components like:\n   *\n   *     :host([generic=\"\"]) {\n   *       ... generic appearance defined here ...\n   *     }\n   *\n   * This makes it easy to remove all default styling  set the `GenericMixin`\n   * attribute to false, and all default styling will be removed.\n   */\n  class Generic extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.generic === 'undefined') {\n        this.generic = this[symbols.defaults].generic;\n      }\n    }\n\n    // This mixin doesn't actually respond to attribute changes, but relies\n    // on separately-defined behavior (e.g., in AttributeMarshallingMixin) for that.\n    // Still, we need define a baseline attributeChangedCallback that does\n    // nothing, in case this mixin gets used on its own.\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(name, oldValue, newValue); }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.generic = true;\n      return defaults;\n    }\n\n    /**\n     * True if the component would like to receive generic styling.\n     *\n     * This property is true by default set it to false to turn off all\n     * generic styles. This makes it easier to apply custom styling; you won't\n     * have to explicitly override styling you don't want.\n     *\n     * @type Boolean\n     * @default true\n     */\n    get generic() {\n      return this[genericSymbol];\n    }\n    set generic(value) {\n      const parsed = typeof value === 'string' ?\n        String(value) !== 'false' :\n        value;\n      this[genericSymbol] = parsed;\n\n      if ('generic' in base.prototype) { super.generic = value; }\n\n      // We roll our own attribute setting so that an explicitly false value\n      // shows up as GenericMixin=\"false\".\n      if (parsed === false) {\n        // Explicitly use false string.\n        safeAttributes.setAttribute(this, 'generic', 'false');\n      } else if (parsed == null) {\n        // Explicitly remove attribute. (Always safe to do this.)\n        this.removeAttribute('generic');\n      } else {\n        // Use the empty string to get attribute to appear with no value.\n        safeAttributes.setAttribute(this, 'generic', '');\n      }\n    }\n\n  }\n\n  return Generic;\n};\n\n\n","import DirectionSelectionMixin from '../../basic-component-mixins/src/DirectionSelectionMixin';\nimport KeyboardDirectionMixin from '../../basic-component-mixins/src/KeyboardDirectionMixin';\nimport KeyboardMixin from '../../basic-component-mixins/src/KeyboardMixin';\nimport SwipeDirectionMixin from '../../basic-component-mixins/src/SwipeDirectionMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\nimport TrackpadDirectionMixin from '../../basic-component-mixins/src/TrackpadDirectionMixin';\n\n\nexport default (base) => {\n\n  const mixins = [\n    DirectionSelectionMixin,\n    KeyboardMixin,\n    KeyboardDirectionMixin,\n    SwipeDirectionMixin,\n    TrackpadDirectionMixin\n  ];\n\n  // Don't assume base class uses ComposableMixin. Do composition by hand.\n  const baseWithMixins = mixins.reduce((c, mixin) => mixin(c), base);\n\n  /**\n   * @mixes KeyboardMixin\n   * @mixes KeyboardDirectionMixin\n   * @mixes SwipeDirectionMixin\n   * @mixes TrackpadDirectionMixin\n   */\n  class HorizontalNavigation extends baseWithMixins {\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.navigationAxis = 'horizontal';\n      defaults.selectionAnimationEffect = 'slideWithGap';\n      // defaults.selectionRequired = true;\n      return defaults;\n    }\n\n  }\n\n  return HorizontalNavigation;\n\n};\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst navigationAxisSymbol = createSymbol('navigationAxis');\n\n\n/* Exported function extends a base class with KeyboardDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps direction keys (Left, Right, etc.) to direction semantics\n   * (go left, go right, etc.).\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   *\n   * This mixin calls methods such as `goLeft` and `goRight`. You can define\n   * what that means by implementing those methods yourself. If you want to use\n   * direction keys to navigate a selection, use this mixin with\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n   */\n  class KeyboardDirection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.navigationAxis === 'undefined') {\n        this.navigationAxis = this[symbols.defaults].navigationAxis;\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.navigationAxis = 'both';\n      return defaults;\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate down.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { return super[symbols.goDown](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the end (e.g., of a list).\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { return super[symbols.goEnd](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the start (e.g., of a\n     * list). The default implementation of this method does nothing.\n     */\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { return super[symbols.goStart](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate up.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { return super[symbols.goUp](); }\n    }\n\n    /**\n     * Indicates the direction of permitted navigation with the keyboard.\n     *\n     * Accepted values are \"horizontal\", \"vertical\", or \"both\" (the default).\n     * If this property is \"horizontal\", the Up Arrow and Down Arrow keys will\n     * be ignored. Conversely, if this is \"vertical\", the Left Arrow and Right\n     * Arrow keys will be ignored.\n     *\n     * @type {string}\n     */\n    get navigationAxis() {\n      return this[navigationAxisSymbol];\n    }\n    set navigationAxis(value) {\n      this[navigationAxisSymbol] = value;\n      if ('navigationAxis' in base.prototype) { super.navigationAxis = value; }\n    }\n\n    [symbols.keydown](event) {\n      let handled;\n\n      const axis = this.navigationAxis;\n      const horizontal = (axis === 'horizontal' || axis === 'both');\n      const vertical = (axis === 'vertical' || axis === 'both');\n\n      // Ignore Left/Right keys when metaKey or altKey modifier is also pressed,\n      // as the user may be trying to navigate back or forward in the browser.\n      switch (event.keyCode) {\n        case 35: // End\n          handled = this[symbols.goEnd]();\n          break;\n        case 36: // Home\n          handled = this[symbols.goStart]();\n          break;\n        case 37: // Left\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goLeft]();\n          }\n          break;\n        case 38: // Up\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goStart]() : this[symbols.goUp]();\n          }\n          break;\n        case 39: // Right\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goRight]();\n          }\n          break;\n        case 40: // Down\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goEnd]() : this[symbols.goDown]();\n          }\n          break;\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n  }\n\n  return KeyboardDirection;\n};\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with Keyboard. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages the keydown handling for a component.\n   *\n   * This mixin handles several keyboard-related features.\n   *\n   * First, it wires up a single keydown event handler that can be shared by\n   * multiple mixins on a component. The event handler will invoke a `keydown`\n   * method with the event object, and any mixin along the prototype chain that\n   * wants to handle that method can do so.\n   *\n   * If a mixin wants to indicate that keyboard event has been handled, and that\n   * other mixins should *not* handle it, the mixin's `keydown` handler should\n   * return a value of true. The convention that seems to work well is that a\n   * mixin should see if it wants to handle the event and, if not, then ask the\n   * superclass to see if it wants to handle the event. This has the effect of\n   * giving the mixin that was applied last the first chance at handling a\n   * keyboard event.\n   *\n   * Example:\n   *\n   *     [symbols.keydown](event) {\n   *       let handled;\n   *       switch (event.keyCode) {\n   *         // Handle the keys you want, setting handled = true if appropriate.\n   *       }\n   *       // Prefer mixin result if it's defined, otherwise use base result.\n   *       return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n   *     }\n   *\n   * A second feature provided by this mixin is that it implicitly makes the\n   * component a tab stop if it isn't already, by setting `tabIndex` to 0. This\n   * has the effect of adding the component to the tab order in document order.\n   */\n  class Keyboard extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('keydown', event => {\n        const handled = this[symbols.keydown](event);\n        if (handled) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      });\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (this.getAttribute('tabindex') == null && this[symbols.defaults].tabindex !== null) {\n        this.setAttribute('tabindex', this[symbols.defaults].tabindex);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      // The default tab index is 0 (document order).\n      defaults.tabindex = 0;\n      return defaults;\n    }\n\n    /**\n     * Handle the indicated keyboard event.\n     *\n     * The default implementation of this method does nothing. This will\n     * typically be handled by other mixins.\n     *\n     * @param {KeyboardEvent} event - the keyboard event\n     * @return {boolean} true if the event was handled\n     */\n    [symbols.keydown](event) {\n      if (super[symbols.keydown]) { return super[symbols.keydown](event); }\n    }\n\n  }\n\n  return Keyboard;\n};\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with KeyboardPagedSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps page keys (Page Up, Page Down) into operations that move\n   * the selection by one page.\n   *\n   * The keyboard interaction model generally follows that of Microsoft Windows'\n   * list boxes instead of those in OS X:\n   *\n   * * The Page Up/Down and Home/End keys actually change the selection, rather\n   *   than just scrolling. The former behavior seems more generally useful for\n   *   keyboard users.\n   *\n   * * Pressing Page Up/Down will change the selection to the topmost/bottommost\n   *   visible item if the selection is not already there. Thereafter, the key\n   *   will move the selection up/down by a page, and (per the above point) make\n   *   the selected item visible.\n   *\n   * To ensure the selected item is in view following use of Page Up/Down, use\n   * the related [SelectionInViewMixin](SelectionInViewMixin.md).\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   */\n  class KeyboardPagedSelection extends base {\n\n    [symbols.keydown](event) {\n      let handled;\n      switch (event.keyCode) {\n        case 33: // Page Up\n          handled = this.pageUp();\n          break;\n        case 34: // Page Down\n          handled = this.pageDown();\n          break;\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    /**\n     * Scroll down one page.\n     */\n    pageDown() {\n      if (super.pageDown) { super.pageDown(); }\n      return scrollOnePage(this, true);\n    }\n\n    /**\n     * Scroll up one page.\n     */\n    pageUp() {\n      if (super.pageUp) { super.pageUp(); }\n      return scrollOnePage(this, false);\n    }\n\n    /**\n     * The element that should be scrolled with the Page Up/Down keys.\n     * Default is the current element.\n     *\n     * @type {HTMLElement}\n     */\n    get scrollTarget() {\n      // Prefer base result.\n      return 'scrollTarget' in base.prototype ? super.scrollTarget : this;\n    }\n    set scrollTarget(element) {\n      if ('scrollTarget' in base.prototype) { super.scrollTarget = element; }\n    }\n  }\n\n  return KeyboardPagedSelection;\n};\n\n\n// Return the item whose content spans the given y position (relative to the\n// top of the list's scrolling client area), or null if not found.\n//\n// If downward is true, move down the list of items to find the first item\n// found at the given y position; if downward is false, move up the list of\n// items to find the last item at that position.\nfunction getIndexOfItemAtY(element, y, downward) {\n  const items = element.items;\n  const start = downward ? 0 : items.length - 1;\n  const end = downward ? items.length : 0;\n  const step = downward ? 1 : -1;\n  const scrollTarget = element.scrollTarget;\n  const topOfClientArea = scrollTarget.offsetTop + scrollTarget.clientTop;\n\n  // Find the item spanning the indicated y coordinate.\n  let item;\n  let itemIndex = start;\n  let itemTop;\n  let found = false;\n  while (itemIndex !== end) {\n    item = items[itemIndex];\n    itemTop = item.offsetTop - topOfClientArea;\n    const itemBottom = itemTop + item.offsetHeight;\n    if (itemTop <= y && itemBottom >= y) {\n      // Item spans the indicated y coordinate.\n      found = true;\n      break;\n    }\n    itemIndex += step;\n  }\n\n  if (!found) {\n    return null;\n  }\n\n  // We may have found an item whose padding spans the given y coordinate,\n  // but whose content is actually above/below that point.\n  // TODO: If the item has a border, then padding should be included in\n  // considering a hit.\n  const itemStyle = getComputedStyle(item);\n  const itemPaddingTop = parseFloat(itemStyle.paddingTop);\n  const itemPaddingBottom = parseFloat(itemStyle.paddingBottom);\n  const contentTop = itemTop + item.clientTop + itemPaddingTop;\n  const contentBottom = contentTop + item.clientHeight - itemPaddingTop - itemPaddingBottom;\n  if (downward && contentTop <= y || !downward && contentBottom >= y) {\n    // The indicated coordinate hits the actual item content.\n    return itemIndex;\n  }\n  else {\n    // The indicated coordinate falls within the item's padding. Back up to\n    // the item below/above the item we found and return that.\n    return itemIndex - step;\n  }\n}\n\n// Move by one page downward (if downward is true), or upward (if false).\n// Return true if we ended up changing the selection, false if not.\n// TODO: Better support for horizontal lists.\nfunction scrollOnePage(element, downward) {\n\n  // Determine the item visible just at the edge of direction we're heading.\n  // We'll select that item if it's not already selected.\n  const scrollTarget = element.scrollTarget;\n  const edge = scrollTarget.scrollTop + (downward ? scrollTarget.clientHeight : 0);\n  const indexOfItemAtEdge = getIndexOfItemAtY(element, edge, downward);\n\n  const selectedIndex = element.selectedIndex;\n  let newIndex;\n  if (indexOfItemAtEdge && selectedIndex === indexOfItemAtEdge) {\n    // The item at the edge was already selected, so scroll in the indicated\n    // direction by one page. Leave the new item at that edge selected.\n    const delta = (downward ? 1 : -1) * scrollTarget.clientHeight;\n    newIndex = getIndexOfItemAtY(element, edge + delta, downward);\n  }\n  else {\n    // The item at the edge wasn't selected yet. Instead of scrolling, we'll\n    // just select that item. That is, the first attempt to page up/down\n    // usually just moves the selection to the edge in that direction.\n    newIndex = indexOfItemAtEdge;\n  }\n\n  if (!newIndex) {\n    // We can't find an item in the direction we want to travel. Select the\n    // last item (if moving downward) or first item (if moving upward).\n    newIndex = (downward ? element.items.length - 1 : 0);\n  }\n\n  if (newIndex !== selectedIndex) {\n    element.selectedIndex = newIndex;\n    return true; // We handled the page up/down ourselves.\n  }\n  else {\n    return false; // We didn't do anything.\n  }\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemTextContentsSymbol = createSymbol('itemTextContents');\nconst typedPrefixSymbol = createSymbol('typedPrefix');\nconst prefixTimeoutSymbol = createSymbol('prefixTimeout');\n\n\n/* Exported function extends a base class with KeyboardPrefixSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin that handles list box-style prefix typing, in which the user can type\n   * a string to select the first item that begins with that string.\n   *\n   * Example: suppose a component using this mixin has the following items:\n   *\n   *     <sample-list-component>\n   *       <div>Apple</div>\n   *       <div>Apricot</div>\n   *       <div>Banana</div>\n   *       <div>Blackberry</div>\n   *       <div>Blueberry</div>\n   *       <div>Cantaloupe</div>\n   *       <div>Cherry</div>\n   *       <div>Lemon</div>\n   *       <div>Lime</div>\n   *     </sample-list-component>\n   *\n   * If this component receives the focus, and the user presses the \"b\" or \"B\"\n   * key, the \"Banana\" item will be selected, because it's the first item that\n   * matches the prefix \"b\". (Matching is case-insensitive.) If the user now\n   * presses the \"l\" or \"L\" key quickly, the prefix to match becomes \"bl\", so\n   * \"Blackberry\" will be selected.\n   *\n   * The prefix typing feature has a one second timeout the prefix to match\n   * will be reset after a second has passed since the user last typed a key.\n   * If, in the above example, the user waits a second between typing \"b\" and\n   * \"l\", the prefix will become \"l\", so \"Lemon\" would be selected.\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   *\n   * This mixin also expects the component to provide an `items` property. The\n   * `textContent` of those items will be used for purposes of prefix matching.\n   */\n  class KeyboardPrefixSelection extends base {\n\n    // TODO: If the set of items is changed, reset the prefix.\n    // [symbols.itemsChanged]() {\n    //   this[itemTextContentsSymbol] = null;\n    //   resetTypedPrefix(this);\n    // }\n\n    // TODO: If the selection is changed by some other means (e.g., arrow keys)\n    // other than prefix typing, then that act should reset the prefix.\n\n    [symbols.keydown](event) {\n      let handled;\n      let resetPrefix = true;\n\n      switch (event.keyCode) {\n        case 8: // Backspace\n          handleBackspace(this);\n          handled = true;\n          resetPrefix = false;\n          break;\n        case 27: // Escape\n          handled = true;\n          break;\n        default:\n          if (!event.ctrlKey && !event.metaKey && !event.altKey &&\n              event.which !== 32 /* Space */) {\n            handlePlainCharacter(this, String.fromCharCode(event.which));\n          }\n          resetPrefix = false;\n      }\n\n      if (resetPrefix) {\n        resetTypedPrefix(this);\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    /**\n     * Select the first item whose text content begins with the given prefix.\n     *\n     * @param prefix [String] The prefix string to search for\n     */\n    selectItemWithTextPrefix(prefix) {\n      if (super.selectItemWithTextPrefix) { super.selectItemWithTextPrefix(prefix); }\n      if (prefix == null || prefix.length === 0) {\n        return;\n      }\n      const index = getIndexOfItemWithTextPrefix(this, prefix);\n      if (index >= 0) {\n        this.selectedIndex = index;\n      }\n    }\n\n  }\n\n  return KeyboardPrefixSelection;\n};\n\n\n// Time in milliseconds after which the user is considered to have stopped\n// typing.\nconst PREFIX_TIMEOUT_DURATION = 1000;\n\n\n// Return the index of the first item with the given prefix, else -1.\nfunction getIndexOfItemWithTextPrefix(element, prefix) {\n  const itemTextContents = getItemTextContents(element);\n  const prefixLength = prefix.length;\n  for (let i = 0; i < itemTextContents.length; i++) {\n    const itemTextContent = itemTextContents[i];\n    if (itemTextContent.substr(0, prefixLength) === prefix) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n// Return an array of the text content (in lowercase) of all items.\n// Cache these results.\nfunction getItemTextContents(element) {\n  if (!element[itemTextContentsSymbol]) {\n    const items = element.items;\n    element[itemTextContentsSymbol] = items.map(child => {\n      const text = child.textContent || child.alt;\n      return text.toLowerCase();\n    });\n  }\n  return element[itemTextContentsSymbol];\n}\n\nfunction handleBackspace(element) {\n  const length = element[typedPrefixSymbol] ? element[typedPrefixSymbol].length : 0;\n  if (length > 0) {\n    element[typedPrefixSymbol] = element[typedPrefixSymbol].substr(0, length - 1);\n  }\n  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n  setPrefixTimeout(element);\n}\n\nfunction handlePlainCharacter(element, char) {\n  const prefix = element[typedPrefixSymbol] || '';\n  element[typedPrefixSymbol] = prefix + char.toLowerCase();\n  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n  setPrefixTimeout(element);\n}\n\nfunction resetPrefixTimeout(element) {\n  if (element[prefixTimeoutSymbol]) {\n    clearTimeout(element[prefixTimeoutSymbol]);\n    element[prefixTimeoutSymbol] = false;\n  }\n}\n\nfunction resetTypedPrefix(element) {\n  element[typedPrefixSymbol] = '';\n  resetPrefixTimeout(element);\n}\n\nfunction setPrefixTimeout(element) {\n  resetPrefixTimeout(element);\n  element[prefixTimeoutSymbol] = setTimeout(() => {\n    resetTypedPrefix(element);\n  }, PREFIX_TIMEOUT_DURATION);\n}\n","import createSymbol from './createSymbol';\nimport safeAttributes from './safeAttributes';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst closedSymbol = createSymbol('closed');\n\n\n/* Exported function extends a base class with OpenClose. */\nexport default (base) => {\n\n  /**\n   * Mixin which adds close/open semantics.\n   *\n   * This mixin does not produce any user-visible effects. Instead it applies\n   * a `basic-closed` CSS class to the component host if the host is\n   * closed, and a `basic-opened` class if opened. It also invokes a `render`\n   * function that can be overridden to apply custom effects.\n   */\n  class OpenClose extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.closed === 'undefined') {\n        this.closed = this[symbols.defaults].closed;\n      }\n    }\n\n    /**\n     * Close the component.\n     *\n     * This is equivalent to setting the `closed` property to true.\n     */\n    close() {\n      this.closed = true;\n    }\n\n    /**\n     * True if the component is curently closed.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get closed() {\n      return this[closedSymbol];\n    }\n    set closed(value) {\n      const previousClosed = this[closedSymbol];\n      this[closedSymbol] = value;\n      if ('closed' in base.prototype) { super.closed = value; }\n      if (value !== previousClosed) {\n        this.render(value);\n\n        const event = new CustomEvent('closed-changed');\n        this.dispatchEvent(event);\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n      this.render(this.closed);\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.closed = false;\n      return defaults;\n    }\n\n    /**\n     * Open the component.\n     *\n     * This is equivalent to setting the `closed` property to false.\n     */\n    open() {\n      this.closed = false;\n    }\n\n    /**\n     * Perform custom rendering of the close/open transition.\n     *\n     * You can override this method to perform custom effects. If you do so,\n     * be sure to invoke `super()` in your implementation to get the baseline\n     * behavior.\n     *\n     * @param {boolean} closing - True if the component is being closed,\n     *        false if it's being opened.\n     */\n    render(closing) {\n      if (super.render) { super.render(); }\n      safeAttributes.toggleClass(this, 'basic-closed', closing);\n      safeAttributes.toggleClass(this, 'basic-opened', !closing);\n      safeAttributes.setAttribute(this, 'aria-expanded', !closing);\n    }\n\n    /**\n     * Toggle the component's open/closed state.\n     */\n    toggle() {\n      this.closed = !this.closed;\n    }\n\n  }\n\n  return OpenClose;\n};\n","import renderArrayAsElements from '../../basic-component-mixins/src/renderArrayAsElements';\nimport symbols from '../../basic-component-mixins/src/symbols';\nimport toggleClass from '../../basic-component-mixins/src/toggleClass';\n\n\n/* Exported function extends a base class with PageDots. */\nexport default (base) => {\n\n  /**\n   * Template mixin which adds small dots to show the number of items and let\n   * the user select a specific item.\n   *\n   * You can see a\n   * [live demo](http://basicwebcomponents.org/basic-web-components/packages/demos/carousel-with-dots.html)\n   * of this mixin applied to a carousel.\n   *\n   * There will be one dot for each item, and the dot for the currently selected\n   * item will be shown selected.\n   *\n   * Typical usage:\n   *\n   *     class CarouselWithDots extends PageDotsMixin(Carousel) {}\n   *     customElements.define('carousel-with-dots', CarouselWithDots);\n   *\n   * Although the dots are quite small by default, clicking/tapping a dot will\n   * will select the corresponding list item.\n   */\n  class PageDots extends base {\n\n    constructor() {\n      super();\n\n      this.$.dots.addEventListener('click', event => {\n        const dot = event.target;\n        const dotIndex = this.dots.indexOf(dot);\n        if (dotIndex >= 0) {\n          this.selectedIndex = dotIndex;\n        }\n      });\n    }\n\n    get dots() {\n      return [].slice.call(this.$.dots.querySelectorAll('.dot'));\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n      renderArrayAsElements(this.items, this.$.dots, (item, element) => {\n        // We don't use the item parameter, because any item will produce an\n        // identical corresponding dot.\n        if (!element) {\n          element = document.createElement('div');\n          element.classList.add('dot');\n          element.classList.add('style-scope');\n          element.classList.add('basic-page-dots');\n          element.setAttribute('role', 'none');\n          return element;\n        }\n      });\n      refreshDots(this);\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      const index = this.items.indexOf(item);\n      // See if the corresponding dot has already been created.\n      // If not, the correct dot will be selected when it gets created.\n      const dots = this.dots;\n      if (dots && dots.length > index) {\n        const dot = this.dots[index];\n        if (dot) {\n          toggleClass(dot, 'selected', selected);\n        }\n      }\n    }\n\n    /**\n     * The distance the user has moved the first touchpoint since the beginning\n     * of a drag, expressed as a fraction of the element's width.\n     *\n     * @type number\n     */\n    get selectedFraction() {\n      return super.selectedFraction;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      renderTransition(this, this.selectedIndex, value);\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n      refreshDots(this);\n    }\n\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n        :host {\n          display: -webkit-flex;\n          display: flex;\n          position: relative;\n        }\n\n        #dots {\n          bottom: 0;\n          display: -webkit-flex;\n          display: flex;\n          -webkit-justify-content: center;\n          justify-content: center;\n          position: absolute;\n          width: 100%;\n          z-index: 1;\n        }\n\n        #dotNavigationContainer {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          position: relative;\n          z-index: 0;\n        }\n\n        #container ::slotted(*) {\n          -webkit-flex: 1;\n          flex: 1;\n        }\n\n        .dot {\n          background: rgb(255, 255, 255);\n          border-radius: 7px;\n          box-shadow: 0 0 1px 1px rgba(0, 0, 0, 0.5);\n          box-sizing: border-box;\n          cursor: pointer;\n          height: 8px;\n          margin: 7px 5px;\n          opacity: 0.4;\n          padding: 0;\n          transition: background 0.2s box-shadow 0.2s;\n          width: 8px;\n        }\n\n        .dot:hover {\n          background: rgba(0, 0, 0, 0.75);\n          box-shadow: 0 0 1px 3px rgba(255, 255, 255, 0.5);\n        }\n\n        .dot.selected {\n          opacity: 0.95;\n        }\n\n        @media (min-width: 768px) {\n          .dot {\n            height: 12px;\n            width: 12px;\n          }\n        }\n        </style>\n\n        <div id=\"dots\" role=\"none\"></div>\n        <div id=\"dotNavigationContainer\" role=\"none\">\n          ${baseTemplate}\n        </div>\n      `;\n    }\n\n  }\n\n  return PageDots;\n};\n\n\n// Return the index, ensuring it stays between 0 and the given length.\nfunction keepIndexWithinBounds(length, index) {\n  // Handle possibility of negative mod.\n  // See http://stackoverflow.com/a/18618250/76472\n  return ((index % length) + length) % length;\n}\n\nfunction renderTransition(element, selectedIndex, selectedFraction) {\n  const dots = element.dots;\n  if (!dots || dots.length === 0) {\n    return;\n  }\n  const dotCount = dots.length;\n  const opacityMinimum = 0.4;\n  const opacityMaximum = 0.95;\n  const opacityRange = opacityMaximum - opacityMinimum;\n  const fractionalIndex = selectedIndex + selectedFraction;\n  const leftIndex = Math.floor(fractionalIndex);\n  const rightIndex = Math.ceil(fractionalIndex);\n  const selectionWraps = element.selectionWraps;\n  let awayIndex = selectedFraction >= 0 ? leftIndex : rightIndex;\n  let towardIndex = selectedFraction >= 0 ? rightIndex : leftIndex;\n  if (selectionWraps) {\n    awayIndex = keepIndexWithinBounds(dotCount, awayIndex);\n    towardIndex = keepIndexWithinBounds(dotCount, towardIndex);\n  }\n  // Stupid IE doesn't have Math.trunc.\n  // const truncatedSelectedFraction = Math.trunc(selectedFraction);\n  const truncatedSelectedFraction = selectedFraction < 0 ? Math.ceil(selectedFraction) : Math.floor(selectedFraction);\n  const progress = selectedFraction - truncatedSelectedFraction;\n  const opacityProgressThroughRange = Math.abs(progress) * opacityRange;\n  dots.forEach((dot, index) => {\n    let dotOpacity;\n    if (selectedFraction === 0) {\n      // Remove explicit opacity and rely on styling.\n      dotOpacity = '';\n    } else if (index === awayIndex) {\n      dotOpacity = opacityMaximum - opacityProgressThroughRange;\n    } else if (index === towardIndex) {\n      dotOpacity = opacityMinimum + opacityProgressThroughRange;\n    } else {\n      dotOpacity = opacityMinimum;\n    }\n    dot.style.opacity = dotOpacity;\n  });\n}\n\nfunction refreshDots(element) {\n  const selectedIndex = element.selectedIndex;\n  element.dots.forEach((dot, i) => {\n    toggleClass(dot, 'selected', i === selectedIndex);\n  });\n}\n","import safeAttributes from '../../basic-component-mixins/src/safeAttributes';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/* Exported function extends a base class with PlayControls. */\nexport default (base) => {\n\n  /**\n   * Template mixin which adds buttons for managing playback of a slideshow,\n   * audio playlist, etc.\n   *\n   * Typical usage:\n   *\n   *     class SlideshowWithControls extends PlayControlsMixin(Slideshow) {}\n   *     customElements.define('slideshow-with-controls', SlideshowWithControls);\n   *\n   */\n  class PlayControls extends base {\n\n    constructor() {\n      super();\n      this.$.previousButton.addEventListener('click', event => {\n        this.selectPrevious();\n      });\n      this.$.playButton.addEventListener('click', event => {\n        this.playing = !this.playing;\n      });\n      this.$.nextButton.addEventListener('click', event => {\n        this.selectNext();\n      });\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    [symbols.keydown](event) {\n      let handled;\n\n      switch (event.keyCode) {\n        case 32: /* Space */\n          this.playing = !this.playing;\n          handled = true;\n          break;\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    get playing() {\n      return super.playing;\n    }\n    set playing(value) {\n      if ('playing' in base.prototype) { super.playing = value; }\n      safeAttributes.toggleClass(this, 'playing', value);\n    }\n\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n        :host {\n          display: -webkit-flex;\n          display: flex;\n          position: relative;\n        }\n\n        #buttons {\n          bottom: 0;\n          box-sizing: border-box;\n          padding: 0.5em;\n          position: absolute;\n          text-align: center;\n          width: 100%;\n          z-index: 1;\n        }\n\n        button {\n          background: transparent;\n          border: none;\n          fill: rgba(255, 255, 255, 0.5);\n          padding: 0;\n          transition: fill 0.5s;\n          vertical-align: middle;\n        }\n        :host(:hover) button {\n          fill: rgba(255, 255, 255, 0.7);\n        }\n        button:hover {\n          fill: rgba(255, 255, 255, 0.85);\n        }\n        button:active {\n          fill: white;\n        }\n\n        .icon {\n          height: 30px;\n          width: 30px;\n        }\n        #playButton .icon {\n          height: 40px;\n          width: 40px;\n        }\n\n        :host(.playing) .pausedControl {\n          display: none;\n        }\n        :host(:not(.playing)) .playingControl {\n          display: none;\n        }\n\n        #container {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n        }\n\n        #container ::slotted(*) {\n          -webkit-flex: 1;\n          flex: 1;\n        }\n        </style>\n\n        <div id=\"buttons\">\n          <button id=\"previousButton\">\n            <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n              <g id=\"skip-previous\">\n                <path d=\"M6 6h2v12H6zm3.5 6l8.5 6V6z\"/>\n              </g>\n            </svg>\n          </button>\n          <button id=\"playButton\">\n            <svg class=\"icon playingControl\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n              <g id=\"pause-circle-outline\">\n                <path d=\"M9 16h2V8H9v8zm3-14C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm1-4h2V8h-2v8z\"></path>\n              </g>\n            </svg>\n            <svg class=\"icon pausedControl\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n              <g id=\"play-circle-outline\">\n                <path d=\"M10 16.5l6-4.5-6-4.5v9zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"></path>\n              </g>\n            </svg>\n          </button>\n          <button id=\"nextButton\">\n            <svg class=\"icon\" viewBox=\"0 0 24 24\" preserveAspectRatio=\"xMidYMid meet\">\n              <g id=\"skip-next\">\n                <path d=\"M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z\"/>\n              </g>\n            </svg>\n          </button>\n        </div>\n\n        <div id=\"container\" role=\"none\">\n          ${baseTemplate}\n        </div>\n      `;\n    }\n\n  }\n\n  return PlayControls;\n};\n","/* Exported function extends a base class with SelectedItemTextValue. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines a `value` property that reflects the text content of a\n   * selected item.\n   *\n   * This mixin exists for list-like components that want to provide a more\n   * convenient way to get/set the selected item using text.\n   *\n   * This mixin expects a component to provide an `items` array of all elements\n   * in the list. A standard way to do that with is\n   * [ContentItemsMixin](ContentItemsMixin.md). This also expects the definition\n   * of `selectedIndex` and `selectedItem` properties, which can be obtained\n   * from [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class SelectedItemTextValue extends base {\n\n    /**\n     * The text content of the selected item.\n     *\n     * Setting this value to a string will attempt to select the first list item\n     * whose text content match that string. Setting this to a string not matching\n     * any list item will result in no selection.\n     *\n     * @type {string}\n     */\n    get value() {\n      return this.selectedItem == null || this.selectedItem.textContent == null ?\n        '' :\n        this.selectedItem.textContent;\n    }\n    set value(text) {\n\n      const currentIndex = this.selectedIndex;\n      let newIndex = -1; // Assume we won't find the text.\n\n      // Find the item with the indicated text.\n      const items = this.items;\n      for (let i = 0, length = items.length; i < length; i++) {\n        if (items[i].textContent === text) {\n          newIndex = i;\n          break;\n        }\n      }\n\n      if (newIndex !== currentIndex) {\n        this.selectedIndex = newIndex;\n        const event = new CustomEvent('value-changed');\n        this.dispatchEvent(event);\n      }\n    }\n  }\n\n  return SelectedItemTextValue;\n};\n","import createSymbol from './createSymbol';\nimport FractionalSelectionMixin from './FractionalSelectionMixin';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst animationSymbol = createSymbol('animation');\nconst draggingSymbol = createSymbol('dragging');\nconst lastAnimationSymbol = createSymbol('lastAnimation');\nconst playingAnimationSymbol = createSymbol('animatingSelection');\nconst previousSelectionSymbol = createSymbol('previousSelection');\nconst selectionAnimationDurationSymbol = createSymbol('selectionAnimationDuration');\nconst selectionAnimationEffectSymbol = createSymbol('selectionAnimationEffect');\nconst selectionAnimationKeyframesSymbol = createSymbol('selectionAnimationKeyframes');\nconst resetAnimationsOnNextRenderSymbol = createSymbol('resetAnimationsOnNextRender');\n\n\n/* Exported function extends a base class with SelectionAnimation. */\nexport default function mixin(base) {\n\n  /**\n   * Mixin which uses animation to show transitions between selection states.\n   *\n   * This mixin can be used by components that want to provide visible\n   * animations when changing the selection. For example, a carousel component\n   * may want to define a sliding animation effect shown when moving between\n   * items.\n   *\n   * The animation is defined by a `selectionAnimationKeyframes` property; see\n   * that property for details on how to define these keyframes. This animation\n   * will be used in two ways. First, when moving strictly between items, the\n   * animation will play smoothly to show the selection changing. Second, the\n   * animation can be used to render the selection at a fixed point in the\n   * transition between states. E.g., if the user pauses halfway through\n   * dragging an element using [SwipeDirectionMixin](SwipeDirectionMixin.md)\n   * or [TrackpadDirectionMixin](TrackpadDirectionMixin.md)s, then the selection\n   * animation will be shown at the point exactly halfway through.\n   *\n   * This mixin expects a component to provide an `items` array of all elements\n   * in the list, which can be provided via\n   * [ContentItemsMixin](ContentItemsMixin.md). This mixin also expects\n   * `selectedIndex` and `selectedItem` properties, which can be provided via\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   *\n   * This mixin supports a `selectionWraps` property. When true, the user can\n   * navigate forward from the last item in the list and wrap around to the\n   * first item, or navigate backward from the first item and wrap around to the\n   * last item.\n   *\n   * This mixin uses the Web Animations API. For use on browsers which\n   * do not support that API natively, you will need to load the\n   * [Web Animations polyfill](https://github.com/web-animations/web-animations-js).\n   */\n  class SelectionAnimation extends base {\n\n    constructor() {\n      super();\n\n      // Set defaults.\n      if (typeof this.selectionAnimationDuration === 'undefined') {\n        this.selectionAnimationDuration = this[symbols.defaults].selectionAnimationDuration;\n      }\n      if (typeof this.selectionAnimationEffect === 'undefined' && this.selectionAnimationKeyframes == null) {\n        this.selectionAnimationEffect = this[symbols.defaults].selectionAnimationEffect;\n      }\n\n      this[symbols.dragging] = false;\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionAnimationDuration = 250;\n      defaults.selectionAnimationEffect = 'slide';\n      return defaults;\n    }\n\n    /*\n     * Provide backing for the dragging property.\n     * Also, when a drag begins, reset the animations.\n     */\n    get [symbols.dragging]() {\n      return this[draggingSymbol];\n    }\n    set [symbols.dragging](value) {\n      const previousValue = this[symbols.dragging];\n      this[draggingSymbol] = value;\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n      if (value && !previousValue) {\n        // Have begun a drag.\n        this[resetAnimationsOnNextRenderSymbol] = true;\n      }\n    }\n\n    [symbols.itemAdded](item) {\n      // We mark new items in the list as explicitly visible to ARIA. Otherwise,\n      // when an item isn't visible on the screen, ARIA will assume the item is\n      // of no interest to the user, and leave it out of the accessibility tree.\n      // If the list contains 10 items, but only 3 are visible, a screen reader\n      // might then announce the list only has 3 items. To ensure that screen\n      // readers and other assistive technologies announce the correct total\n      // number of items, we explicitly mark all items as not hidden. This will\n      // expose them all in the accessibility tree, even the items which are\n      // currently not rendered.\n      //\n      // TODO: Generally speaking, this entire mixin assumes that the user can\n      // navigate through all items in a list. But an app could style an item as\n      // display:none or visibility:hidden because the user is not allowed to\n      // interact with that item at the moment. Support for this scenario should\n      // be added. This would entail changing all locations where a mixin\n      // function is counting items, iterating over the (visible) items, and\n      // showing or hiding items. Among other things, the code below to make\n      // items visible to ARIA would need to discriminate between items which\n      // are invisible because of animation state, or invisible because the user\n      // shouldn't interact with them.\n      item.setAttribute('aria-hidden', false);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      resetAnimations(this);\n\n      // TODO: Also reset our notion of the last rendered selection? This comes\n      // up when a DOM removal causes the selected item to change position.\n      // this[previousSelectionSymbol] = null;\n\n      renderSelection(this);\n    }\n\n    resetAnimations() {\n      resetAnimations(this);\n    }\n\n    /**\n     * A fractional value indicating how far the user has currently advanced to\n     * the next/previous item. E.g., a `selectedFraction` of 3.5 indicates the\n     * user is halfway between items 3 and 4.\n     *\n     * For more details, see [FractionalSelectionMixin](FractionalSelectionMixin.md)\n     * mixin.\n     *\n     * @type {number}\n     */\n    get selectedFraction() {\n      return super.selectedFraction || 0;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n      renderSelection(this, this.selectedIndex, value);\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n      renderSelection(this, index, 0);\n    }\n\n    /**\n     * The duration of a selection animation in milliseconds.\n     *\n     * This measures the amount of time required for a selection animation to\n     * complete. This number remains constant, even if the number of items being\n     * animated increases.\n     *\n     * The default value is 250 milliseconds (a quarter a second).\n     *\n     * @type {number}\n     * @default 250\n     */\n    get selectionAnimationDuration() {\n      return this[selectionAnimationDurationSymbol];\n    }\n    set selectionAnimationDuration(value) {\n      this[selectionAnimationDurationSymbol] = value;\n      if ('selectionAnimationDuration' in base.prototype) { super.selectionAnimationDuration = value; }\n    }\n\n    /**\n     * The name of a standard selection animation effect.\n     *\n     * This is a shorthand for setting the `selectionAnimationKeyframes`\n     * property to standard keyframes. Supported string values:\n     *\n     * * \"crossfade\"\n     * * \"reveal\"\n     * * \"revealWithFade\"\n     * * \"showAdjacent\"\n     * * \"slide\"\n     * * \"slideWithGap\"\n     *\n     * @type {string}\n     * @default \"slide\"\n     */\n    get selectionAnimationEffect() {\n      return this[selectionAnimationEffectSymbol];\n    }\n    set selectionAnimationEffect(value) {\n      this[selectionAnimationEffectSymbol] = value;\n      if ('selectionAnimationEffect' in base.prototype) { super.selectionAnimationEffect = value; }\n      this.selectionAnimationKeyframes = mixin.standardEffectKeyframes[value];\n    }\n\n    /**\n     * The keyframes that define an animation that plays for an item when moving\n     * forward in the sequence.\n     *\n     * This is an array of CSS rules that will be applied. These are used as\n     * [keyframes](http://w3c.github.io/web-animations/#keyframes-section)\n     * to animate the item with the\n     * [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/animation).\n     *\n     * The animation represents the state of the next item as it moves from\n     * completely unselected (offstage, usually right), to selected (center\n     * stage), to completely unselected (offstage, usually left). The center time\n     * of the animation should correspond to the item's quiscent selected state,\n     * typically in the center of the stage and at the item's largest size.\n     *\n     * The default forward animation is a smooth slide at full size from right to\n     * left.\n     *\n     * When moving the selection backward, this animation is played in reverse.\n     *\n     * @type {cssRules[]}\n     */\n    get selectionAnimationKeyframes() {\n      // Standard animation slides left/right, keeps adjacent items out of view.\n      return this[selectionAnimationKeyframesSymbol];\n    }\n    set selectionAnimationKeyframes(value) {\n      this[selectionAnimationKeyframesSymbol] = value;\n      if ('selectionAnimationKeyframes' in base.prototype) { super.selectionAnimationKeyframes = value; }\n      resetAnimations(this);\n      renderSelection(this);\n    }\n\n    get selectionWraps() {\n      return super.selectionWraps;\n    }\n    set selectionWraps(value) {\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      resetAnimations(this);\n      renderSelection(this);\n    }\n  }\n\n  return SelectionAnimation;\n}\n\n\n// We expose helpers on the mixin function that we want to be able to unit test.\n// Since these are on the function, not on the class emitted by the function,\n// they don't end up getting exposed on actual element instances.\nmixin.helpers = {\n\n  /*\n   * Calculate the animation fractions for an element's items at the given\n   * selection point. This is used when rendering the element's selection state\n   * instantaneously.\n   *\n   * This function considers the selectedIndex parameter, which can be a whole\n   * or fractional number, and determines which items will be visible at that\n   * index. This function then calculates a corresponding animation fraction: a\n   * number between 0 and 1 indicating how far through the selection animation\n   * an item should be shown, or null if the item should not be visible at that\n   * selection index. These fractions are returned as an array, where the\n   * animation fraction at position N corresponds to how item N should be shown.\n   */\n  animationFractionsForSelection(element, selection) {\n\n    const items = element.items;\n    if (!items) {\n      return;\n    }\n\n    const itemCount = items.length;\n    const selectionWraps = element.selectionWraps;\n\n    return items.map((item, itemIndex) => {\n      // How many steps from the selection point to this item?\n      const steps = stepsToIndex(itemCount, selectionWraps, selection, itemIndex);\n      // To convert steps to animation fraction:\n      // steps      animation fraction\n      //  1         0     (stage right)\n      //  0         0.5   (center stage)\n      // -1         1     (stage left)\n      const animationFraction = (1 - steps) / 2;\n      return (animationFraction >= 0 && animationFraction <= 1) ?\n        animationFraction :\n        null; // Outside animation range\n    });\n  },\n\n  /*\n   * Calculate the animation timings that should be used to smoothly animate the\n   * element's items from one selection state to another.\n   *\n   * This returns an array of timings, where the timing at position N should be\n   * used to animate item N. If an item's timing is null, then that item should\n   * not take place in the animation, and should be hidden instead.\n   */\n  effectTimingsForSelectionAnimation(element, fromSelection, toSelection) {\n\n    const items = element.items;\n    if (!items) {\n      return;\n    }\n    const itemCount = items.length;\n    const selectionWraps = element.selectionWraps;\n    const toIndex = FractionalSelectionMixin.helpers.wrappedSelectionParts(toSelection, itemCount, selectionWraps).index;\n    const totalSteps = stepsToIndex(itemCount, selectionWraps, fromSelection, toSelection);\n    const direction = totalSteps >= 0 ? 'normal': 'reverse';\n    const fill = 'both';\n    const totalDuration = element.selectionAnimationDuration;\n    const stepDuration = totalSteps !== 0 ?\n      totalDuration * 2 / Math.ceil(Math.abs(totalSteps)) :\n      0;  // No steps required, animation will be instantenous.\n\n    const timings = items.map((item, itemIndex) => {\n      const steps = stepsToIndex(itemCount, selectionWraps, itemIndex, toSelection);\n      // If we include this item in the staggered sequence of animations we're\n      // creating, where would the item appear in the sequence?\n      let positionInSequence = totalSteps - steps;\n      if (totalSteps < 0) {\n        positionInSequence = -positionInSequence;\n      }\n      // So, is this item really included in the sequence?\n      if (Math.ceil(positionInSequence) >= 0 && positionInSequence <= Math.abs(totalSteps)) {\n        // Note that delay for first item will be negative. That will cause\n        // the animation to start halfway through, which is what we want.\n        const delay = stepDuration * (positionInSequence - 1)/2;\n        const endDelay = itemIndex === toIndex ?\n          -stepDuration/2 :   // Stop halfway through.\n          0;              // Play animation until end.\n        return { duration: stepDuration, direction, fill, delay, endDelay };\n      } else {\n        return null;\n      }\n    });\n\n    return timings;\n  }\n\n};\n\n\n// Keyframes for standard selection animation effects.\nmixin.standardEffectKeyframes = {\n\n  // Simple crossfade\n  crossfade: [\n    { opacity: 0 },\n    { opacity: 1 },\n    { opacity: 0 }\n  ],\n\n  // Reveal, as if sliding the top card off a deck of cards\n  reveal: [\n    { transform: 'translateX(0%)', zIndex: 0 },\n    { transform: 'translateX(0%)', zIndex: 1 },\n    { transform: 'translateX(-100%)', zIndex: 2 }\n  ],\n\n  // Google Photos-style reveal-with-fade animation\n  revealWithFade: [\n    { transform: 'translateX(0%) scale(0.75)', opacity: 0, zIndex: 0 },\n    { transform: 'translateX(0%) scale(1.0)', opacity: 1, zIndex: 1 },\n    { transform: 'translateX(-100%) scale(1.0)', opacity: 1, zIndex: 2 }\n  ],\n\n  // Carousel variant with a bit of off-stage elements showing\n  showAdjacent: [\n    { transform: 'translateX(78%) scale(0.7)', zIndex: 0 },\n    { transform: 'translateX(0%) scale(0.82)', zIndex: 1 },\n    { transform: 'translateX(-78%) scale(0.7)', zIndex: 0 }\n  ],\n\n  // Simple slide\n  slide: [\n    { transform: 'translateX(100%)' },\n    { transform: 'translateX(-100%)' }\n  ],\n\n  // Slide, with a gap between\n  slideWithGap: [\n    { transform: 'translateX(110%)' },\n    { transform: 'translateX(-110%)' }\n  ]\n\n};\n\n\n/*\n * Smoothly animate the selection between the indicated \"from\" and \"to\"\n * indices. The former can be a fraction, e.g., when the user releases a finger\n * to complete a touch drag, and the selection will snap to the closest whole\n * index.\n */\nfunction animateSelection(element, fromSelection, toSelection) {\n\n  resetAnimations(element);\n\n  // Calculate the animation timings.\n  const items = element.items;\n  const keyframes = element.selectionAnimationKeyframes;\n  element[playingAnimationSymbol] = true;\n  const timings = mixin.helpers.effectTimingsForSelectionAnimation(element, fromSelection, toSelection);\n\n  // Figure out which item will be the one *after* the one we're selecting.\n  const itemCount = items.length;\n  const selectionWraps = element.selectionWraps;\n  const selectionIndex = FractionalSelectionMixin.helpers.selectionParts(toSelection, itemCount, selectionWraps).index;\n  const totalSteps = stepsToIndex(itemCount, selectionWraps, fromSelection, toSelection);\n  const forward = totalSteps >= 0;\n  let nextUpIndex = selectionIndex + (forward ? 1 : - 1);\n  if (selectionWraps) {\n    nextUpIndex = FractionalSelectionMixin.helpers.wrappedSelection(nextUpIndex, itemCount);\n  } else if (!isItemIndexInBounds(element, nextUpIndex)) {\n    nextUpIndex = null; // At start/end of list; don't have a next item to show.\n  }\n\n  // Play the animations using those timings.\n  let lastAnimationDetails;\n  timings.forEach((timing, index) => {\n    const item = items[index];\n    if (timing) {\n      showItem(item, true);\n      const animation = item.animate(keyframes, timing);\n      element[animationSymbol][index] = animation;\n      if (index === nextUpIndex) {\n        // This item will be animated, so will already be in the desired state\n        // after the animation completes.\n        nextUpIndex = null;\n      }\n      if (timing.endDelay !== 0) {\n        // This is the animation for the item that will be left selected.\n        // We want to clean up when this animation completes.\n        lastAnimationDetails = { animation, index, timing, forward };\n      }\n    } else {\n      // This item doesn't participate in the animation.\n      showItem(item, false);\n    }\n  });\n\n  if (lastAnimationDetails != null) {\n    // Arrange for clean-up work to be performed.\n    lastAnimationDetails.nextUpIndex = nextUpIndex;\n    lastAnimationDetails.animation.onfinish = event => selectionAnimationFinished(element, lastAnimationDetails);\n    element[lastAnimationSymbol] = lastAnimationDetails.animation;\n  } else {\n    // Shouldn't happen -- we should always have at least one animation.\n    element[playingAnimationSymbol] = false;\n  }\n}\n\n\nfunction getAnimationForItemIndex(element, index) {\n  if (element[animationSymbol] == null) {\n    // Not ready yet;\n    return null;\n  }\n  let animation = element[animationSymbol][index];\n  if (!animation) {\n    const item = element.items[index];\n    animation = item.animate(element.selectionAnimationKeyframes, {\n      duration: element.selectionAnimationDuration,\n      fill: 'both'\n    });\n    animation.pause();\n    element[animationSymbol][index] = animation;\n  }\n  return animation;\n}\n\nfunction isItemIndexInBounds(element, index) {\n  return index >= 0 && element.items && index < element.items.length;\n}\n\n/*\n * Render the selection state of the element.\n *\n * This can be used to re-render a previous selection state (if the\n * selectedIndex param is omitted), render the selection instantly at a given\n * whole or fractional selection index, or animate to a given selection index.\n *\n * There are several distinct scenarios we need to cover:\n *\n * 1. Initial positioning, or repositioning after changing a property like\n *    selectionAnimationKeyframes that affects rendering.\n * 2. Animate on selectedIndex change. This should override any animation/swipe\n *    already in progress.\n * 3. Instantly render the current position of a drag operation in progress.\n * 4. Complete a drag operation. If the drag wasn't far enough to affect\n *    selection, we'll just be restoring the selectedFraction to 0.\n *\n * If the list does not wrap, any selection position outside the list's bounds\n * will be damped to produce a visual effect of tension.\n */\nfunction renderSelection(element, selectedIndex=element.selectedIndex, selectedFraction=element.selectedFraction) {\n  const itemCount = element.items ? element.items.length : 0;\n  if (itemCount === 0) {\n    // Nothing to render.\n    return;\n  }\n  if (selectedIndex < 0) {\n    // TODO: Handle no selection.\n    return;\n  }\n  let selection = selectedIndex + selectedFraction;\n  if (element.selectionWraps) {\n    // Apply wrapping to ensure consistent representation of selection.\n    selection = FractionalSelectionMixin.helpers.wrappedSelection(selection, itemCount);\n  } else {\n    // Apply damping if necessary.\n    selection = FractionalSelectionMixin.helpers.dampedSelection(selection, itemCount);\n  }\n  const previousSelection = element[previousSelectionSymbol];\n  // TODO: If an item changes position in the DOM, we end up animating from\n  // its old index to its new index, but we really don't want to animate at all.\n  if (!element[symbols.dragging] && previousSelection != null &&\n      previousSelection !== selection) {\n    // Animate selection from previous state to new state.\n    animateSelection(element, previousSelection, selection);\n  } else if (selectedFraction === 0 && element[playingAnimationSymbol]) {\n    // Already in process of animating to fraction 0. During that process,\n    // ignore subsequent attempts to renderSelection to fraction 0.\n    return;\n  } else {\n    // Render current selection state instantly.\n    renderSelectionInstantly(element, selection);\n  }\n  element[previousSelectionSymbol] = selection;\n}\n\n/*\n * Instantly render (don't animate) the element's items at the given whole or\n * fractional selection index.\n */\nfunction renderSelectionInstantly(element, toSelection) {\n  if (element[resetAnimationsOnNextRenderSymbol]) {\n    resetAnimations(element);\n    element[resetAnimationsOnNextRenderSymbol] = false;\n  }\n  const animationFractions = mixin.helpers.animationFractionsForSelection(element, toSelection);\n  animationFractions.map((animationFraction, index) => {\n    const item = element.items[index];\n    if (animationFraction != null) {\n      showItem(item, true);\n      setAnimationFraction(element, index, animationFraction);\n    } else {\n      showItem(item, false);\n    }\n  });\n}\n\n/*\n * We maintain an array containing an animation per item. This is used for two\n * reasons:\n *\n * * During a drag operation, we want to be able to reuse animations between\n *   drag updates.\n * * When a selection animation completes, we need to be able to leave the\n *   visibile items in a paused state. Later, we'll want to be able to clean up\n *   those animations.\n *\n * Note that this array is sparse: it will only hold up from 03 animations at\n * any given point.\n */\nfunction resetAnimations(element) {\n  const animations = element[animationSymbol];\n  if (animations) {\n    // Cancel existing animations to remove the effects they're applying.\n    animations.forEach((animation, index) => {\n      if (animation) {\n        animation.cancel();\n        animations[index] = null;\n      }\n    });\n  }\n  const itemCount = element.items ? element.items.length : 0;\n  if (!animations || animations.length !== itemCount) {\n    // Haven't animated before with this number of items; (re)create array.\n    element[animationSymbol] = new Array(itemCount);\n  }\n}\n\n/*\n * The last animation in our selection animation has completed. Clean up.\n */\nfunction selectionAnimationFinished(element, details) {\n\n  // When the last animation completes, show the next item in the direction\n  // we're going. Waiting to that until this point is a bit of a hack to avoid\n  // having a next item that's higher in the natural z-order obscure other items\n  // during animation.\n  const nextUpIndex = details.nextUpIndex;\n  if (nextUpIndex != null) {\n    if (element[animationSymbol][nextUpIndex]) {\n      // Cancel existing selection animation so we can construct a new one.\n      element[animationSymbol][nextUpIndex].cancel();\n      element[animationSymbol][nextUpIndex] = null;\n    }\n    const animationFraction = details.forward ? 0 : 1;\n    setAnimationFraction(element, nextUpIndex, animationFraction);\n    showItem(element.items[nextUpIndex], true);\n  }\n\n  element[lastAnimationSymbol].onfinish = null;\n  element[playingAnimationSymbol] = false;\n}\n\n/*\n * Pause the indicated animation and have it show the animation at the given\n * fraction (between 0 and 1) of the way through the animation.\n */\nfunction setAnimationFraction(element, itemIndex, fraction) {\n  const animation = getAnimationForItemIndex(element, itemIndex);\n  if (animation) {\n    const duration = element.selectionAnimationDuration;\n    if (duration) {\n      animation.currentTime = fraction * duration;\n    }\n  }\n}\n\nfunction showItem(item, flag) {\n  item.style.visibility = flag ? 'visible' : 'hidden';\n}\n\n/*\n * Figure out how many steps it will take to go from fromSelection to\n * toSelection. To go from item 3 to item 4 is one step.\n *\n * If wrapping is allowed, then going from the last item to the first will take\n * one step (forward), and going from the first item to the last will take one\n * step (backward).\n */\nfunction stepsToIndex(length, allowWrap, fromSelection, toSelection) {\n  let steps = toSelection - fromSelection;\n  // Wrapping only kicks in when list has more than 1 item.\n  if (allowWrap && length > 1) {\n    const wrapSteps = length - Math.abs(steps);\n    if (wrapSteps <= 1) {\n      // Special case\n      steps = steps < 0 ?\n        wrapSteps :   // Wrap forward from last item to first.\n        -wrapSteps;   // Wrap backward from first item to last.\n    }\n  }\n  return steps;\n}\n","import symbols from './symbols';\n\n\n// Used to assign unique IDs to item elements without IDs.\nlet idCount = 0;\n\n\n/* Exported function extends a base class with SelectionAriaActive. */\nexport default (base) => {\n\n  /**\n   * Mixin which treats the selected item in a list as the active item in ARIA\n   * accessibility terms.\n   *\n   * Handling ARIA selection state properly is actually quite complex:\n   *\n   * * The items in the list need to be indicated as possible items via an ARIA\n   *   `role` attribute value such as \"option\".\n   * * The selected item need to be marked as selected by setting the item's\n   *   `aria-selected` attribute to true *and* the other items need be marked as\n   *   *not* selected by setting `aria-selected` to false.\n   * * The outermost element with the keyboard focus needs to have attributes\n   *   set on it so that the selection is knowable at the list level via the\n   *   `aria-activedescendant` attribute.\n   * * Use of `aria-activedescendant` in turn requires that all items in the\n   *   list have ID attributes assigned to them.\n   *\n   * This mixin tries to address all of the above requirements. To that end,\n   * this mixin will assign generated IDs to any item that doesn't already have\n   * an ID.\n   *\n   * ARIA relies on elements to provide `role` attributes. This mixin will apply\n   * a default role of \"listbox\" on the outer list if it doesn't already have an\n   * explicit role. Similarly, this mixin will apply a default role of \"option\"\n   * to any list item that does not already have a role specified.\n   *\n   * This mixin expects a set of members that manage the state of the selection:\n   * `[symbols.itemSelected]`, `itemAdded`, and `selectedIndex`. You can\n   * supply these yourself, or do so via\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class SelectionAriaActive extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      // Set default ARIA role.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'listbox';\n      return defaults;\n    }\n\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n\n      if (!item.getAttribute('role')) {\n        // Assign a default ARIA role.\n        item.setAttribute('role', 'option');\n      }\n\n      // Ensure each item has an ID so we can set aria-activedescendant on the\n      // overall list whenever the selection changes.\n      //\n      // The ID will take the form of a base ID plus a unique integer. The base\n      // ID will be incorporate the component's own ID. E.g., if a component has\n      // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n      // the compnent has no ID itself, its items will get IDs that look like\n      // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n      // them from manually-assigned IDs, and to minimize the potential for ID\n      // conflicts.\n      if (!item.id) {\n        const baseId = this.id ?\n            \"_\" + this.id + \"Option\" :\n            \"_option\";\n        item.id = baseId + idCount++;\n      }\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      item.setAttribute('aria-selected', selected);\n      const itemId = item.id;\n      if (itemId && selected) {\n        this.setAttribute('aria-activedescendant', itemId);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item == null) {\n        // Selection was removed.\n        this.removeAttribute('aria-activedescendant');\n      }\n    }\n\n  }\n\n  return SelectionAriaActive;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with SelectionHighlight. */\nexport default (base) => {\n\n  /**\n   * Template mixin which applies standard highlight colors to a selected item.\n   *\n   * This mixin highlights textual items (e.g., in a list) in a standard way by\n   * using the CSS `highlight` and `highlighttext` color values. These values\n   * respect operating system defaults and user preferences, and hence are good\n   * default values for highlight colors.\n   *\n   * This mixin expects a `selected` class to be applied to selected items. You\n   * can use [ContentItemsMixin](ContentItemsMixin.md) for that purpose.\n   */\n  class SelectionHighlight extends base {\n\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n          :host([generic=\"\"]) ::slotted(.selected) {\n            background-color: highlight;\n            color: highlighttext;\n          }\n        </style>\n        ${baseTemplate}\n      `;\n    }\n\n  }\n\n  return SelectionHighlight;\n};\n","/* Exported function extends a base class with SelectionInView. */\nexport default (base) => {\n\n  /**\n   * Mixin which scrolls a container to ensure that a newly-selected item is\n   * visible to the user.\n   *\n   * When the selected item in a list-like component changes, it's easier for\n   * the to confirm that the selection has changed to an appropriate item if the\n   * user can actually see that item.\n   *\n   * This mixin expects a `selectedItem` property to be set when the selection\n   * changes. You can supply that yourself, or use\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class SelectionInView extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      const selectedItem = this.selectedItem;\n      if (selectedItem) {\n        this.scrollItemIntoView(selectedItem);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item) {\n        // Keep the selected item in view.\n        this.scrollItemIntoView(item);\n      }\n    }\n\n    /**\n     * Scroll the given element completely into view, minimizing the degree of\n     * scrolling performed.\n     *\n     * Blink has a `scrollIntoViewIfNeeded()` function that does something\n     * similar, but unfortunately it's non-standard, and in any event often ends\n     * up scrolling more than is absolutely necessary.\n     *\n     * @param {HTMLElement} item - the item to scroll into view.\n     */\n    scrollItemIntoView(item) {\n      if (super.scrollItemIntoView) { super.scrollItemIntoView(); }\n      // Get the relative position of the item with respect to the top of the\n      // list's scrollable canvas. An item at the top of the list will have a\n      // elementTop of 0.\n\n      const scrollTarget = this.scrollTarget;\n      const elementTop = item.offsetTop - scrollTarget.offsetTop - scrollTarget.clientTop;\n      const elementBottom = elementTop + item.offsetHeight;\n      // Determine the bottom of the scrollable canvas.\n      const scrollBottom = scrollTarget.scrollTop + scrollTarget.clientHeight;\n      if (elementBottom > scrollBottom) {\n        // Scroll up until item is entirely visible.\n        scrollTarget.scrollTop += elementBottom - scrollBottom;\n      }\n      else if (elementTop < scrollTarget.scrollTop) {\n        // Scroll down until item is entirely visible.\n        scrollTarget.scrollTop = elementTop;\n      }\n    }\n\n    /**\n     * The element that should be scrolled to bring an item into view.\n     *\n     * The default value of this property is the element itself.\n     *\n     * @type {HTMLElement}\n     */\n    get scrollTarget() {\n      // Prefer base result.\n      return 'scrollTarget' in base.prototype ? super.scrollTarget : this;\n    }\n    set scrollTarget(element) {\n      if ('scrollTarget' in base.prototype) { super.scrollTarget = element; }\n    }\n\n  }\n\n  return SelectionInView;\n};\n","/* Exported function extends a base class with ShadowElementReferences. */\nexport default (base) => {\n\n  /**\n   * Mixin to create references to elements in a component's Shadow DOM subtree.\n   *\n   * This adds a member on the component called `this.$` that can be used to\n   * reference shadow elements with IDs. E.g., if component's shadow contains an\n   * element `<button id=\"foo\">`, then this mixin will create a member\n   * `this.$.foo` that points to that button.\n   *\n   * Such references simplify a component's access to its own elements. In\n   * exchange, this mixin trades off a one-time cost of querying all elements in\n   * the shadow tree instead of paying an ongoing cost to query for an element\n   * each time the component wants to inspect or manipulate it.\n   *\n   * This mixin expects the component to define a Shadow DOM subtree. You can\n   * create that tree yourself, or make use of\n   * [ShadowTemplateMixin](ShadowTemplateMixin.md).\n   *\n   * This mixin is inspired by Polymer's [automatic\n   * node finding](https://www.polymer-project.org/1.0/docs/devguide/local-dom.html#node-finding)\n   * feature.\n   */\n  class ShadowElementReferences extends base {\n\n    constructor() {\n      super();\n      if (this.shadowRoot) {\n        // Look for elements in the shadow subtree that have id attributes.\n        // An alternatively implementation of this mixin would be to just define\n        // a this.$ getter that lazily does this search the first time someone\n        // tries to access this.$. That might introduce some complexity  if the\n        // the tree changed after it was first populated, the result of\n        // searching for a node might be somewhat unpredictable.\n        this.$ = {};\n        const nodesWithIds = this.shadowRoot.querySelectorAll('[id]');\n        [].forEach.call(nodesWithIds, node => {\n          const id = node.getAttribute('id');\n          this.$[id] = node;\n        });\n      }\n    }\n\n    /**\n     * The collection of references to the elements with IDs in a component's\n     * Shadow DOM subtree.\n     *\n     * @type {object}\n     * @member $\n     */\n  }\n\n  return ShadowElementReferences;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with ShadowTemplate. */\nexport default (base) => {\n\n  /**\n   * Mixin for stamping a template into a Shadow DOM subtree upon component\n   * instantiation.\n   *\n   * To use this mixin, define a `template` property as a string or HTML\n   * `<template>` element:\n   *\n   *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n   *       get [symbols.template]() {\n   *         return `Hello, <em>world</em>.`;\n   *       }\n   *     }\n   *\n   * When your component class is instantiated, a shadow root will be created on\n   * the instance, and the contents of the template will be cloned into the\n   * shadow root. If your component does not define a `template` property, this\n   * mixin has no effect.\n   *\n   * For the time being, this extension retains support for Shadow DOM v0. That\n   * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n   * implement Shadow DOM v1.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n      let template = this[symbols.template];\n      // TODO: Save the processed template with the component's class prototype\n      // so it doesn't need to be processed with every instantiation.\n      if (template) {\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          template = createTemplateWithInnerHTML(template);\n        }\n\n        if (window.ShadowDOMPolyfill) {\n          shimTemplateStyles(template, this.localName);\n        }\n\n        const root = this.attachShadow({ mode: 'open' });\n        const clone = document.importNode(template.content, true);\n        root.appendChild(clone);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n};\n\n\n// Convert a plain string of HTML into a real template element.\nfunction createTemplateWithInnerHTML(innerHTML) {\n  const template = document.createElement('template');\n  // REVIEW: Is there an easier way to do this?\n  // We'd like to just set innerHTML on the template content, but since it's\n  // a DocumentFragment, that doesn't work.\n  const div = document.createElement('div');\n  div.innerHTML = innerHTML;\n  while (div.childNodes.length > 0) {\n    template.content.appendChild(div.childNodes[0]);\n  }\n  return template;\n}\n\n// Invoke basic style shimming with ShadowCSS.\nfunction shimTemplateStyles(template, tag) {\n  window.WebComponents.ShadowCSS.shimStyling(template.content, tag);\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = createSymbol('canSelectNext');\nconst canSelectPreviousSymbol = createSymbol('canSelectPrevious');\nconst selectionRequiredSymbol = createSymbol('selectionRequired');\nconst selectionWrapsSymbol = createSymbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = createSymbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = createSymbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = createSymbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = createSymbol('internalSelectedItem');\n\n\n/* Exported function extends a base class with SingleSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages single-selection semantics for items in a list.\n   *\n   * This mixin expects a component to provide an `items` Array or NodeList of\n   * all elements in the list. A standard way to do that with is the\n   * [ContentItemsMixin](ContentItemsMixin.md), which takes a component's\n   * content (typically its distributed children) as the set of list items; see\n   * that mixin for details.\n   *\n   * This mixin tracks a single selected item in the list, and provides means to\n   * get and set that state by item position (`selectedIndex`) or item identity\n   * (`selectedItem`). The selection can be moved in the list via the methods\n   * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n   *\n   * This mixin does not produce any user-visible effects to represent\n   * selection. Other mixins, such as\n   * [SelectionAriaActiveMixin](SelectionAriaActiveMixin.md),\n   * [SelectionHighlightMixin](SelectionHighlightMixin.md) and\n   * [SelectionInViewMixin](SelectionInViewMixin.md), modify the selected item\n   * in common ways to let the user know a given item is selected or not\n   * selected.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const previousCanSelectNext = this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (canSelectNext !== previousCanSelectNext) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const previousCanSelectPrevious = this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (canSelectPrevious !== previousCanSelectPrevious) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedIndex = this[internalSelectedIndexSymbol];\n      let item;\n      if (index !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && index >= 0 && index < items.length)) {\n          index = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = index;\n        item = hasItems && index >= 0 ? items[index] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (index !== previousSelectedIndex) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = index;\n\n        const event = new CustomEvent('selected-index-changed', {\n          detail: {\n            selectedIndex: index,\n            value: index // for Polymer binding. TODO: Verify still necessary\n          }\n        });\n        this.dispatchEvent(event);\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (item !== previousSelectedItem) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        const event = new CustomEvent('selected-item-changed', {\n          detail: {\n            selectedItem: item,\n            value: item // for Polymer binding\n          }\n        });\n        this.dispatchEvent(event);\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      this[selectionRequiredSymbol] = selectionRequired;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      trackSelectedItem(this);\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(value) {\n      this[selectionWrapsSymbol] = String(value) === 'true';\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Select the last item in the list.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the selectedItem property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     * @param {HTMLElement} detail.previousItem The previously selected item.\n     */\n\n    /**\n     * Fires when the selectedIndex property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n  }\n\n  return SingleSelection;\n};\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n  const count = element.items.length;\n\n  const boundedIndex = (element.selectionWraps) ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst deltaXSymbol = createSymbol('deltaX');\nconst deltaYSymbol = createSymbol('deltaY');\nconst multiTouchSymbol = createSymbol('multiTouch');\nconst previousXSymbol = createSymbol('previousX');\nconst previousYSymbol = createSymbol('previousY');\nconst startXSymbol = createSymbol('startX');\nconst travelFractionSymbol = createSymbol('travelFraction');\n\n\n/* Exported function extends a base class with SwipeDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps touch gestures (swipe left, swipe right) to direction\n   * semantics (go right, go left).\n   *\n   * By default, this mixin presents no user-visible effects; it just indicates\n   * a direction in which the user is currently swiping or has finished swiping.\n   * To map the direction to a change in selection, use\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n   */\n  class SwipeDirection extends base {\n\n    constructor() {\n      super();\n\n      this.travelFraction = 0;\n\n      // In all touch events, only handle single touches. We don't want to\n      // inadvertently do work when the user's trying to pinch-zoom for example.\n      // TODO: Even better approach than below would be to ignore touches after\n      // the first if the user has already begun a swipe.\n      // TODO: Touch events should probably be factored out into its own mixin.\n      if (window.PointerEvent) {\n        // Prefer listening to standard pointer events.\n        this.addEventListener('pointerdown', event => {\n          if (isEventForPenOrPrimaryTouch(event)) {\n            touchStart(this, event.clientX, event.clientY);\n          }\n        });\n        this.addEventListener('pointermove', event => {\n          if (isEventForPenOrPrimaryTouch(event)) {\n            const handled = touchMove(this, event.clientX, event.clientY);\n            if (handled) {\n              event.preventDefault();\n            }\n          }\n        });\n        this.addEventListener('pointerup', event => {\n          if (isEventForPenOrPrimaryTouch(event)) {\n            touchEnd(this, event.clientX, event.clientY);\n          }\n        });\n      } else {\n        // Pointer events not supported -- listen to older touch events.\n        this.addEventListener('touchstart', event => {\n          if (this[multiTouchSymbol]) {\n            return;\n          } else if (event.touches.length === 1) {\n            const clientX = event.changedTouches[0].clientX;\n            const clientY = event.changedTouches[0].clientY;\n            touchStart(this, clientX, clientY);\n          } else {\n            this[multiTouchSymbol] = true;\n          }\n        });\n        this.addEventListener('touchmove', event => {\n          if (!this[multiTouchSymbol] && event.touches.length === 1) {\n            const clientX = event.changedTouches[0].clientX;\n            const clientY = event.changedTouches[0].clientY;\n            const handled = touchMove(this, clientX, clientY);\n            if (handled) {\n              event.preventDefault();\n            }\n          }\n        });\n        this.addEventListener('touchend', event => {\n          if (event.touches.length === 0) {\n            // All touches removed; gesture is complete.\n            if (!this[multiTouchSymbol]) {\n              // Single-touch swipe has finished.\n              const clientX = event.changedTouches[0].clientX;\n              const clientY = event.changedTouches[0].clientY;\n              touchEnd(this, clientX, clientY);\n            }\n            this[multiTouchSymbol] = false;\n          }\n        });\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // For the component to receive PointerEvents in IE/Edge, we need to set\n      // touch-action: none. Only make this change if touch-action is currently\n      // the default value (\"auto\"), in case the developer knows better than we\n      // do what they want in their particular context.\n      if (getComputedStyle(this).touchAction === 'auto') {\n        this.style.touchAction = 'none';\n      }\n    }\n\n    // Default implementation.\n    get [symbols.dragging]() {\n      return super[symbols.dragging];\n    }\n    set [symbols.dragging](value) {\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * The distance the first touchpoint has traveled since the beginning of a\n     * drag, expressed as a fraction of the element's width.\n     *\n     * @type number\n     */\n    get travelFraction() {\n      return this[travelFractionSymbol];\n    }\n    set travelFraction(value) {\n      this[travelFractionSymbol] = value;\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n    }\n\n  }\n\n  return SwipeDirection;\n};\n\n\n// Return true if the pointer event is for the pen, or the primary touch point.\nfunction isEventForPenOrPrimaryTouch(event) {\n  return event.pointerType === 'pen' ||\n      (event.pointerType === 'touch' && event.isPrimary);\n}\n\n/*\n * Invoked when the user has finished a touch operation.\n */\nfunction touchEnd(element, clientX, clientY) {\n  element[symbols.dragging] = false;\n  if (element[deltaXSymbol] >= 20) {\n    // Finished going right at high speed.\n    element[symbols.goLeft]();\n  } else if (element[deltaXSymbol] <= -20) {\n    // Finished going left at high speed.\n    element[symbols.goRight]();\n  } else {\n    // Finished at low speed.\n    trackTo(element, clientX);\n    const travelFraction = element.travelFraction;\n    if (travelFraction >= 0.5) {\n      element[symbols.goRight]();\n    } else if (travelFraction <= -0.5) {\n      element[symbols.goLeft]();\n    }\n  }\n  element.travelFraction = 0;\n  element[deltaXSymbol] = null;\n  element[deltaYSymbol] = null;\n}\n\n/*\n * Invoked when the user has moved during a touch operation.\n */\nfunction touchMove(element, clientX, clientY) {\n\n  element[deltaXSymbol] = clientX - element[previousXSymbol];\n  element[deltaYSymbol] = clientY - element[previousYSymbol];\n  element[previousXSymbol] = clientX;\n  element[previousYSymbol] = clientY;\n  if (Math.abs(element[deltaXSymbol]) > Math.abs(element[deltaYSymbol])) {\n    // Move was mostly horizontal.\n    trackTo(element, clientX);\n    // Indicate that the event was handled. It'd be nicer if we didn't have\n    // to do this so that, e.g., a user could be swiping left and right\n    // while simultaneously scrolling up and down. (Native touch apps can do\n    // that.) However, Mobile Safari wants to handle swipe events near the\n    // page and interpret them as navigations. To avoid having a horiziontal\n    // swipe misintepreted as a navigation, we indicate that we've handled\n    // the event, and prevent default behavior.\n    return true;\n  } else {\n    // Move was mostly vertical.\n    return false; // Not handled\n  }\n}\n\n/*\n * Invoked when the user has begun a touch operation.\n */\nfunction touchStart(element, clientX, clientY) {\n  element[symbols.dragging] = true;\n  element[startXSymbol] = clientX;\n  element[previousXSymbol] = clientX;\n  element[previousYSymbol] = clientY;\n  element[deltaXSymbol] = 0;\n  element[deltaYSymbol] = 0;\n}\n\nfunction trackTo(element, x) {\n  const width = element.offsetWidth;\n  const dragDistance = element[startXSymbol] - x;\n  const fraction = width > 0 ?\n    dragDistance / width :\n    0;\n  element.travelFraction = fraction;\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\nconst playingSymbol = createSymbol('playing');\nconst selectionTimerDurationSymbol = createSymbol('selectionTimerDuration');\nconst timerTimeoutSymbol = createSymbol('timerTimeout');\n\n\n/* Exported function extends a base class with TimerSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which provides for automatic timed changes in selection.\n   *\n   * This mixin is useful for creating slideshow-like elements such as\n   * [basic-slideshow](../../basic-slideshow) and\n   * [basic-slideshow-with-controls](../../basic-slideshow-with-controls).\n   *\n   * Typical usage:\n   *\n   *     class CarouselWithTimer extends TimerSelectionMixin(Carousel) {}\n   *     customElements.define('carousel-with-arrows', CarouselWithTimer);\n   *\n   * This mixin expects the component to define an `items` property, as well as\n   * `selectFirst` and `selectNext` methods. You can implement those yourself,\n   * or use [ContentItemsMixin](ContentItemsMixin.md) and\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class TimerSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.playing === 'undefined') {\n        this.playing = this[symbols.defaults].playing;\n      }\n      if (typeof this.selectionTimerDuration === 'undefined') {\n        this.selectionTimerDuration = this[symbols.defaults].selectionTimerDuration;\n      }\n    }\n\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n      restartTimer(this);\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.playing = false;\n      defaults.selectionTimerDuration = 1000;\n      return defaults;\n    }\n\n    /**\n     * Begin automatic progression of the selection.\n     */\n    play() {\n      if (super.play) { super.play(); }\n      startTimer(this);\n      this[playingSymbol] = true;\n    }\n\n    /**\n     * Pause automatic progression of the selection.\n     */\n    pause() {\n      if (super.pause) { super.pause(); }\n      clearTimer(this);\n      this[playingSymbol] = false;\n    }\n\n    /**\n     * True if the selection is being automatically advanced.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get playing() {\n      return this[playingSymbol];\n    }\n    set playing(playing) {\n      const previousPlaying = this[playingSymbol];\n      const parsed = String(playing) === 'true'; // Cast to boolean\n      if ('playing' in base.prototype) { super.playing = playing; }\n      if (parsed !== previousPlaying) {\n        if (playing) {\n          this.play();\n        } else {\n          this.pause();\n        }\n      }\n    }\n\n    /*\n     * When the selected item changes (because of something this mixin did, or\n     * was changed by an outside agent like the user), we wait before advancing\n     * to the next item. By triggering the next item this way, we implicitly get\n     * a desirable behavior: if the user changes the selection (e.g., in a\n     * carousel), we let them see that selection state for a while before\n     * advancing the selection ourselves.\n     */\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      restartTimer(this);\n    }\n\n    /**\n     * The time in milliseconds that will elapse after the selection changes\n     * before the selection will be advanced to the next item in the list.\n     *\n     * @type {number} - Time in milliseconds\n     * @default 1000 (1 second)\n     */\n    get selectionTimerDuration() {\n      return this[selectionTimerDurationSymbol];\n    }\n    set selectionTimerDuration(value) {\n      this[selectionTimerDurationSymbol] = parseInt(value);\n      if ('selectionTimerDuration' in base.prototype) { super.selectionTimerDuration = value; }\n    }\n\n  }\n\n  return TimerSelection;\n};\n\n\nfunction clearTimer(element) {\n  if (element[timerTimeoutSymbol]) {\n    clearTimeout(element[timerTimeoutSymbol]);\n    element[timerTimeoutSymbol] = null;\n  }\n}\n\nfunction restartTimer(element) {\n  clearTimer(element);\n  if (element.playing && element.items && element.items.length > 0) {\n    startTimer(element);\n  }\n}\n\nfunction startTimer(element) {\n  // If play() is called more than once, cancel any existing timer.\n  clearTimer(element);\n  element[timerTimeoutSymbol] = setTimeout(() => {\n    selectNextWithWrap(element);\n  }, element.selectionTimerDuration);\n}\n\n// Select the next item, wrapping to first item if necessary.\nfunction selectNextWithWrap(element) {\n  const items = element.items;\n  if (items && items.length > 0) {\n    if (element.selectedIndex == null || element.selectedIndex === items.length - 1) {\n      element.selectFirst();\n    } else {\n      element.selectNext();\n    }\n  }\n}\n","import createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst absorbDecelerationSymbol = createSymbol('absorbDeceleration');\nconst lastDeltaXSymbol = createSymbol('lastDeltaX');\nconst lastWheelTimeoutSymbol = createSymbol('lastWheelTimeout');\nconst postNavigateDelayCompleteSymbol = createSymbol('postNavigateDelayComplete');\nconst wheelDistanceSymbol = createSymbol('wheelDistance');\n\n\n/* Exported function extends a base class with TrackpadDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps a horizontal trackpad swipe gestures (or horizontal mouse\n   * wheel actions) to direction semantics.\n   *\n   * You can use this mixin with a mixin like\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md) to let the user\n   * change the selection with the trackpad or mouse wheel.\n   *\n   * To respond to the trackpad, we can listen to the DOM's \"wheel\" events.\n   * These events are fired as the user drags their fingers across a trackpad.\n   * Unfortunately, browsers are missing a critical event there is no event\n   * when the user *stops* a gestured on the trackpad or mouse wheel.\n   *\n   * To make things worse, the mainstream browsers continue to generate fake\n   * wheel events even after the user has stopped dragging their fingers. These\n   * fake events simulate the user gradually slowing down the drag until they\n   * come to a smooth stop. In some contexts, these fake wheel events might be\n   * helpful, but in trying to supply typical trackpad swipe navigation, these\n   * fake events get in the way.\n   *\n   * This component uses heuristics to work around these problems, but the\n   * complex nature of the problem make it extremely difficult to achieve the\n   * same degree of trackpad responsiveness possible with native applications.\n   */\n  class TrackpadDirection extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('wheel', event => {\n        const handled = wheel(this, event);\n        if (handled) {\n          event.preventDefault();\n        }\n      });\n      resetWheelTracking(this);\n    }\n\n    // Default implementation.\n    get [symbols.dragging]() {\n      return super[symbols.dragging];\n    }\n    set [symbols.dragging](value) {\n      if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * The distance the user has moved the first touchpoint since the beginning\n     * of a trackpad/wheel operation, expressed as a fraction of the element's\n     * width.\n     *\n     * @type number\n     */\n    get travelFraction() {\n      return super.travelFraction;\n    }\n    set travelFraction(value) {\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n    }\n\n  }\n\n  return TrackpadDirection;\n};\n\n\n// Time we wait following a navigation before paying attention to wheel\n// events again.\nconst POST_NAVIGATE_TIME = 250;\n\n// Time we wait after the last wheel event before we reset things.\nconst WHEEL_TIME = 100;\n\n\n// Following a navigation, partially reset our wheel tracking.\nfunction postNavigate(element) {\n  element.travelFraction = 0;\n  element[wheelDistanceSymbol] = 0;\n  element[postNavigateDelayCompleteSymbol] = true;\n  element[absorbDecelerationSymbol] = true;\n  setTimeout(() => {\n    element[postNavigateDelayCompleteSymbol] = false;\n  }, POST_NAVIGATE_TIME);\n}\n\n// Reset all state related to the tracking of the wheel.\nfunction resetWheelTracking(element) {\n  element.travelFraction = 0;\n  element[wheelDistanceSymbol] = 0;\n  element[lastDeltaXSymbol] = 0;\n  element[absorbDecelerationSymbol] = false;\n  element[postNavigateDelayCompleteSymbol] = false;\n  if (element[lastWheelTimeoutSymbol]) {\n    clearTimeout(element[lastWheelTimeoutSymbol]);\n    element[lastWheelTimeoutSymbol] = null;\n  }\n}\n\n// Define our own sign function, since (as of May 2015), Safari and IE don't\n// supply Math.sign().\nfunction sign(x) {\n  return (x === 0) ?\n    0 :\n    (x > 0) ?\n      1 :\n      -1;\n}\n\n// TODO: Damping, or some other treatment for going past the ends.\n\n/*\n * A wheel event has been generated. This could be a real wheel event, or it\n * could be fake (see notes in the header).\n *\n * This handler uses several strategies to try to approximate native trackpad\n * swipe navigation.\n *\n * If the user has dragged enough to cause a navigation, then for a short\n * delay following that navigation, subsequent wheel events will be ignored.\n *\n * Furthermore, follwowing a navigation, we ignore all wheel events until we\n * receive at least one event where the event's deltaX (distance traveled) is\n * *greater* than the previous event's deltaX. This helps us filter out the\n * fake wheel events generated by the browser to simulate deceleration.\n *\n */\nfunction wheel(element, event) {\n\n  // Since we have a new wheel event, reset our timer waiting for the last\n  // wheel event to pass.\n  if (element[lastWheelTimeoutSymbol]) {\n    clearTimeout(element[lastWheelTimeoutSymbol]);\n  }\n  element[lastWheelTimeoutSymbol] = setTimeout(() => {\n    wheelTimedOut(element);\n  }, WHEEL_TIME);\n\n  const deltaX = event.deltaX;\n  const deltaY = event.deltaY;\n\n  // See if element event represents acceleration or deceleration.\n  const acceleration = sign(deltaX) * (deltaX - element[lastDeltaXSymbol]);\n  element[lastDeltaXSymbol] = deltaX;\n\n  if (Math.abs(deltaX) < Math.abs(deltaY)) {\n    // Move was mostly vertical. The user may be trying scroll with the\n    // trackpad/wheel. To be on the safe, we ignore such events.\n    return false;\n  }\n\n  if (element[postNavigateDelayCompleteSymbol]) {\n    // It's too soon after a navigation; ignore the event.\n    return true;\n  }\n\n  if (acceleration > 0) {\n    // The events are not (or are no longer) decelerating, so we can start\n    // paying attention to them again.\n    element[absorbDecelerationSymbol] = false;\n  } else if (element[absorbDecelerationSymbol]) {\n    // The wheel event was likely faked to simulate deceleration; ignore it.\n    return true;\n  }\n\n  element[wheelDistanceSymbol] += deltaX;\n\n  // Update the travel fraction of the element being navigated.\n  const width = element.offsetWidth;\n  let travelFraction = width > 0 ?\n    element[wheelDistanceSymbol] / width :\n    0;\n  element[symbols.dragging] = true;\n  travelFraction = sign(travelFraction) * Math.min(Math.abs(travelFraction), 1);\n  element.travelFraction = travelFraction;\n\n  // If the user has dragged enough to reach the previous/next item, then\n  // complete a navigation to that item.\n  if (travelFraction === 1) {\n    element[symbols.dragging] = false;\n    element[symbols.goRight]();\n    postNavigate(element);\n  } else if (travelFraction === -1) {\n    element[symbols.dragging] = false;\n    element[symbols.goLeft]();\n    postNavigate(element);\n  }\n\n  return true;\n}\n\n// A sufficiently long period of time has passed since the last wheel event.\n// We snap the selection to the closest item, then reset our state.\nfunction wheelTimedOut(element) {\n\n  // Snap to the closest item.\n  element[symbols.dragging] = false;\n  const travelFraction = element.travelFraction;\n  if (travelFraction >= 0.5) {\n    element[symbols.goRight]();\n  } else if (travelFraction <= -0.5) {\n    element[symbols.goLeft]();\n  }\n\n  // TODO: Listen for the transition to complete, and then restore\n  // dragging to false (or the previous value).\n\n  resetWheelTracking(element);\n}\n","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n","/*\n * Microtask helper for IE 11.\n *\n * Executing a function as a microtask is trivial in browsers that support\n * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n * promises, but does support MutationObservers, which are also executed as\n * microtasks. So this helper uses an MutationObserver to achieve microtask\n * timing.\n *\n * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * Inspired by Polymer's async() function.\n */\n\n\n// The queue of pending callbacks to be executed as microtasks.\nconst callbacks = [];\n\n// Create an element that we will modify to force observable mutations.\nconst element = document.createTextNode('');\n\n// A monotonically-increasing value.\nlet counter = 0;\n\n\n/**\n * Add a callback to the microtask queue.\n *\n * This uses a MutationObserver so that it works on IE 11.\n *\n * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n * needs more investigation.\n *\n * @function microtask\n * @param {function} callback\n */\nexport default function microtask(callback) {\n  callbacks.push(callback);\n  // Force a mutation.\n  element.textContent = ++counter;\n}\n\n\n// Execute any pending callbacks.\nfunction executeCallbacks() {\n  while (callbacks.length > 0) {\n    const callback = callbacks.shift();\n    callback();\n  }\n}\n\n\n// Create the observer.\nconst observer = new MutationObserver(executeCallbacks);\nobserver.observe(element, {\n  characterData: true\n});\n","/**\n * Helper function for rendering an array of items as elements.\n *\n * This is not a mixin, but a function components can use if they need to\n * generate a set of elements for the items in an array.\n *\n * This function will reuse existing elements if possible. E.g., if it is called\n * to render an array of 4 items, and later called to render an array of 5\n * items, it can reuse the existing 4 items, creating just one new element.\n * Note, however, that this re-rendering is not automatic. If, after calling\n * this function, you manipulate the array you used, you must still call this\n * function again to re-render the array.\n *\n * The `renderItem` parameter takes a function of two arguments: an item to\n * to render, and an existing element (if one exists) which can be repurposed to\n * render that item. If the latter argument is null, the `renderItem()` function\n * should create a new element and return it. The function should do the same\n * if the supplied existing element is not suitable for rendering the given\n * item; the returned element will be used to replace the existing one. If the\n * existing element *is* suitable, the function can simply update it and return\n * it as is.\n *\n * Example: The following will render an array of strings in divs as children\n * of the `container` element:\n *\n *     let strings = ['a', 'b', 'c', ...];\n *     let container = this.querySelector(...);\n *     renderArrayAsElements(strings, container, (string, element) => {\n *       if (!element) {\n *         // No element exists yet, so create a new one.\n *         element = document.createElement('div');\n *       }\n *       // Set/update the text content of the element.\n *       element.textContent = string;\n *       return element;\n *     });\n *\n * @param {Array} items - the items to render\n * @param {HTMLElement} container - the parent that will hold the elements\n * @param {function} renderItem - returns a new element for an item, or\n *                                repurposes an existing element for an item\n */\nfunction renderArrayAsElements(items, container, renderItem) {\n  // Create a new set of elements for the current items.\n  items.forEach((item, index) => {\n    const oldElement = container.childNodes[index];\n    const newElement = renderItem(item, oldElement);\n    if (newElement) {\n      if (!oldElement) {\n        container.appendChild(newElement);\n      } else if (newElement !== oldElement) {\n        container.replaceChild(newElement, oldElement);\n      }\n    }\n  });\n\n  // If the array shrank, remove the extra elements which are no longer needed.\n  while (container.childNodes.length > items.length) {\n    container.removeChild(container.childNodes[items.length]);\n  }\n}\n\nexport default renderArrayAsElements;\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\n\n\n// Symbols for private data members on an element.\nconst safeToSetAttributesSymbol = createSymbol('safeToSetAttributes');\nconst pendingAttributesSymbol = createSymbol('pendingAttributes');\nconst pendingClassesSymbol = createSymbol('pendingClasses');\n\n\n/**\n * Helper functions for updating attributes, including the `class` attribute.\n */\nexport default {\n\n  /**\n   * Perform any pending updates to attributes and classes.\n   *\n   * This writes any `setAttribute` or `toggleClass` values that were performed\n   * before an element was attached to the document for the first time.\n   *\n   * This method should be called by mixins/components in their\n   * `connectedCallback`. If mulitple mixins/components invoke this during the\n   * same `connectedCallback`, only the first call will have any effect. The\n   * subsequent calls will be harmless.\n   *\n   * @param {HTMLElement} element - The element being added to the document.\n   */\n  connected(element) {\n    element[safeToSetAttributesSymbol] = true;\n\n    // Set any pending attributes.\n    if (element[pendingAttributesSymbol]) {\n      for (let attribute in element[pendingAttributesSymbol]) {\n        const value = element[pendingAttributesSymbol][attribute];\n        setAttributeToElement(element, attribute, value);\n      }\n      element[pendingAttributesSymbol] = null;\n    }\n\n    // Set any pending classes.\n    if (element[pendingClassesSymbol]) {\n      for (let className in element[pendingClassesSymbol]) {\n        const value = element[pendingClassesSymbol][className];\n        toggleClass(element, className, value);\n      }\n      element[pendingClassesSymbol] = null;\n    }\n  },\n\n  /**\n   * Set/unset the attribute with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as an attribute. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes. A call to `setAttribute` during the constructor will\n   * be deferred until the element is connected to the document.\n   *\n   * @param {string} attribute - The name of the *attribute* (not property) to set.\n   * @param {object} value - The value to set. If null, the attribute will be removed.\n   */\n  setAttribute(element, attribute, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set attributes immediately.\n      setAttributeToElement(element, attribute, value);\n    } else {\n      // Defer setting attributes until the first time we're connected.\n      if (!element[pendingAttributesSymbol]) {\n        element[pendingAttributesSymbol] = {};\n      }\n      element[pendingAttributesSymbol][attribute] = value;\n    }\n  },\n\n  /**\n   * Set/unset the class with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as as class. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes, including the `class` attribute. A call to\n   * `toggleClass` during the constructor will be deferred until the element\n   * is connected to the document.\n   *\n   * @param {string} className - The name of the class to set.\n   * @param {object} value - True to set the class, false to remove it.\n   */\n  toggleClass(element, className, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set class immediately.\n      toggleClass(element, className, value);\n    } else {\n      // Defer setting class until the first time we're connected.\n      if (!element[pendingClassesSymbol]) {\n        element[pendingClassesSymbol] = {};\n      }\n      element[pendingClassesSymbol][className] = value;\n    }\n  }\n\n};\n\n\n// Reflect the attribute to the given element.\n// If the value is null, remove the attribute.\nfunction setAttributeToElement(element, attributeName, value) {\n  if (value === null || typeof value === 'undefined') {\n    element.removeAttribute(attributeName);\n  } else {\n    const text = String(value);\n    // Avoid recursive attributeChangedCallback calls.\n    if (element.getAttribute(attributeName) !== text) {\n      element.setAttribute(attributeName, value);\n    }\n  }\n}\n","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'basic-component-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'basic-component-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `dragging` property.\n   *\n   * Components like carousels often define animated CSS transitions for\n   * sliding effects. Such a transition should usually *not* be applied while\n   * the user is dragging, because a CSS animation will introduce a lag that\n   * makes the swipe feel sluggish. Instead, as long as the user is dragging\n   * with their finger down, the transition should be suppressed. When the\n   * user releases their finger, the transition can be restored, allowing the\n   * animation to show the carousel sliding into its final position.\n   *\n   * @type {boolean} true if a drag is in progress, false if not.\n   */\n  dragging: createSymbol('dragging'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: createSymbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: createSymbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: createSymbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: createSymbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: createSymbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: createSymbol('goUp'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization  since the items have \"changed\" from\n   * being nothing.\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: createSymbol('keydown'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLElement}\n   */\n  template: createSymbol('template')\n};\n\nexport default symbols;\n","/**\n * Helper function for standard classList.toggle() behavior on old browsers,\n * namely IE 11.\n *\n * The standard\n * [classlist](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)\n * object has a `toggle()` function that supports a second Boolean parameter\n * that can be used to succinctly turn a class on or off. This feature is often\n * useful in designing custom elements, which may want to externally reflect\n * component state in a CSS class that can be used for styling purposes.\n *\n * Unfortunately, IE 11 does not support the Boolean parameter to\n * `classList.toggle()`. This helper function behaves like the standard\n * `toggle()`, including support for the Boolean parameter, so that it can be\n * used even on IE 11.\n *\n * @function toggleClass\n * @param {HTMLElement} element - The element to modify\n * @param {string} className - The class to add/remove\n * @param {boolean} [force] - Force the class to be added (if true) or removed\n *                            (if false)\n */\nexport default function toggleClass(element, className, force) {\n  const classList = element.classList;\n  const addClass = (typeof force === 'undefined') ?\n    !classList.contains(className) :\n    force;\n  if (addClass) {\n    classList.add(className);\n  } else {\n    classList.remove(className);\n  }\n  return addClass;\n}\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport CurrentAnchor from './src/CurrentAnchor';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.CurrentAnchor = CurrentAnchor;\n","import createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport safeAttributes from '../../basic-component-mixins/src/safeAttributes';\nimport symbols from '../../basic-component-mixins/src/symbols';\nimport WrappedStandardElement from '../../basic-wrapped-standard-element/src/WrappedStandardElement';\n\n\n// Symbols for private data members on an element.\nconst areaLinkSymbol = createSymbol('areaLink');\n\n\n/**\n * An anchor (link) that highlights itself when its destination matches the\n * current location.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-current-anchor/)\n *\n * Such a link commonly appears in toolbars, side bars, and other navigation\n * elements. In these situations, you generally want the user to understand what\n * page or area the user is already on.\n *\n * When the link is current  when it points to the current location  the\n * link will have the CSS `current` class applied to it, and its `current`\n * property will be true.\n *\n * Note: one limitation of this component is that, by default, the link does\n * *not* show the standard link color (usually blue) and text decoration\n * (underline). However, in navigation elements like toolbars, you often will\n * want to explicitly specific link colors anyway, e.g., to reflect your\n * application's visual style and brand.\n *\n * @extends WrappedStandardElement\n */\nclass CurrentAnchor extends WrappedStandardElement.wrap('a') {\n\n  constructor() {\n    super();\n\n    window.addEventListener('popstate', event => {\n      refresh(this);\n    });\n\n    // Stupid Edge/IE \"support\" popstate, but don't fire it on hashchange.\n    // So we have to listen for hashchange as well, with the result that a\n    // standards-compliant browser may end up refreshing the link twice.\n    window.addEventListener('hashchange', event => {\n      refresh(this);\n    });\n\n    // Set defaults.\n    if (typeof this.areaLink === 'undefined') {\n      this.areaLink = this[symbols.defaults].areaLink;\n    }\n  }\n\n  /**\n   * True if the link points to an area within a site, not just a single page.\n   *\n   * If true, the matching rule to determine whether the link is current changes:\n   * an area link is considered to be current if the link's destination forms a\n   * prefix of the current location (instead of matching the complete URL).\n   *\n   * @type {boolean}\n   */\n  get areaLink() {\n    return this[areaLinkSymbol];\n  }\n  set areaLink(value) {\n    // Cast boolean or string values to boolean.\n    this[areaLinkSymbol] = (String(value) === 'true');\n    refresh(this);\n  }\n\n  connectedCallback() {\n    if (super.connectedCallback) { super.connectedCallback(); }\n    safeAttributes.connected(this);\n    refresh(this);\n  }\n\n  /**\n   * True if the link's destination matches the current page location.\n   *\n   * If this is true, the element will have an `current` CSS class applied to it.\n   *\n   * @type {boolean}\n   */\n  get current() {\n    return this.classList.contains('current');\n  }\n  set current(value) {\n    safeAttributes.toggleClass(this, 'current', value);\n    this.dispatchEvent(new CustomEvent('current-changed'));\n  }\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.areaLink = false;\n    return defaults;\n  }\n\n  // Augment href implementation so that changing href checks the active status.\n  get href() {\n    return super.href;\n  }\n  set href(value) {\n    super.href = value;\n    refresh(this);\n  }\n\n  get [symbols.template]() {\n    // Reset styles so that color can be specified from the outside without\n    // having to define a CSS variable.\n    return `\n      <style>\n      :host {\n        display: inline-block;\n      }\n\n      #inner {\n        color: inherit;\n        display: inline-block;\n        text-decoration: inherit;\n      }\n      </style>\n      <a id=\"inner\"><slot></slot></a>`;\n  }\n\n}\n\n\n// Update the current status of the element based on the current location.\nfunction refresh(element) {\n  const url = window.location.href;\n  let match;\n  if (element.areaLink) {\n    // Match prefix\n    let prefix = element.href;\n    // If prefix doesn't end in slash, add a slash.\n    // We want to avoid matching in the middle of a folder name.\n    if (prefix.length < url.length && prefix.substr(-1) !== '/') {\n      prefix += '/';\n    }\n    match = (url.substr(0, prefix.length) === prefix);\n  } else {\n    // Match whole path\n    match = (url === element.href);\n  }\n  element.current = match;\n}\n\n\ncustomElements.define('basic-current-anchor', CurrentAnchor);\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport ElementBase from './src/ElementBase';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.ElementBase = ElementBase;\n","import AttributeMarshallingMixin from '../../basic-component-mixins/src/AttributeMarshallingMixin';\nimport ComposableMixin from '../../basic-component-mixins/src/ComposableMixin';\nimport DistributedChildrenMixin from '../../basic-component-mixins/src/DistributedChildrenMixin';\nimport ShadowElementReferencesMixin from '../../basic-component-mixins/src/ShadowElementReferencesMixin';\nimport ShadowTemplateMixin from '../../basic-component-mixins/src/ShadowTemplateMixin';\n\n\n/**\n * A sample general-purpose base class for defining custom elements that mixes\n * in some common features: template stamping into a shadow root, shadow element\n * references, marshalling attributes to properties, and retrieving the children\n * distributed to a component.\n *\n * This base class is not special in any way, and is defined only as a\n * convenient shorthand for applying the mixins listed above. You can use this\n * class as a base class for your own elements, or easily create your own base\n * class by applying the same set of mixins.\n *\n * The ElementBase base class does not register itself as a custom element with\n * the browser, and hence cannot be independently instantiated.\n *\n * @mixes AttributeMarshallingMixin\n * @mixes ComposableMixin\n * @mixes DistributedChildrenMixin\n * @mixes ShadowElementReferencesMixin\n * @mixes ShadowTemplateMixin\n */\nclass ElementBase extends ComposableMixin(HTMLElement).compose(\n  ShadowTemplateMixin,          // before node finding, so shadow root is populated\n  ShadowElementReferencesMixin, // before marshalling, so properties can use refs\n  AttributeMarshallingMixin,\n  DistributedChildrenMixin\n) {}\n\nexport default ElementBase;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport FadeOverflow from './src/FadeOverflow';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.FadeOverflow = FadeOverflow;\n","import createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport ElementBase from '../../basic-element-base/src/ElementBase';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n// Symbols for private data members on an element.\nconst fadeColorSymbol = createSymbol('fadeColor');\n\n\n/**\n * Fades out content that overflows so the user knows there's more.\n *\n * This component doesn't handle interactivity.\n *\n * The component needs to know the color it should fade to, which it tries to\n * infer from the background color. In some situations, this may not work, in\n * which case you can explicitly set the fadeColor attribute.\n *\n * The component currently always displays the fade, even if the component's\n * content is short enough to fit completely in view.\n *\n * @extends ElementBase\n */\nclass FadeOverflow extends ElementBase {\n\n  connectedCallback() {\n    if (super.connectedCallback) { super.connectedCallback(); }\n    if (this.fadeColor == null) {\n      this.refresh();\n    }\n  }\n\n  /**\n   * The color of the fade.\n   *\n   * The fade color should match the background color. The component does its\n   * best to infer the background color, but in some situations, that may not\n   * work. In those cases, you can manually identify the background color.\n   * This should be a solid color.\n   *\n   * @attribute fadeColor\n   * @default white\n   */\n  get fadeColor() {\n    return this[fadeColorSymbol];\n  }\n  set fadeColor(value) {\n    this[fadeColorSymbol] = value;\n    if (value) {\n      const rgb = extractRgbValues(value);\n      if (rgb) {\n        const fadeColorTransparent = `rgba(${rgb.r},${rgb.g},${rgb.b},0)`;\n        const gradient = `linear-gradient(${fadeColorTransparent} 0%, ${value} 100%)`;\n        this.$.fade.style.backgroundImage = gradient;\n      }\n    }\n  }\n\n  /**\n   * Infer the fade color from background color. If you have programmatically\n   * changed the color behind the component, you can invoke this method to have\n   * the component try to pick up the new background color.\n   */\n  refresh() {\n    // TODO: Automatically hide the fade if all the content can be seen.\n    this.fadeColor = findBackgroundColor(this);\n  }\n\n  /**\n   * True if the component should show the fade to the background color.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  get showFade() {\n    return this.$.fade.style.display !== 'none';\n  }\n  set showFade(value) {\n    this.$.fade.style.display = value ? '' : 'none';\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        display: block;\n        position: relative;\n        overflow: hidden;\n      }\n\n      #fade {\n        bottom: 0;\n        height: 3em;\n        max-height: 50%;\n        pointer-events: none; /* Lets user interact with content through the fade. */\n        position: absolute;\n        width: 100%;\n      }\n      </style>\n\n      <div id=\"fade\"></div>\n      <slot></slot>\n    `;\n  }\n\n}\n\n\n// Return the background color of the given element. If the color is\n// \"transparent\" (the default in Mozilla and IE) or \"rgba(0, 0, 0, 0)\" (the\n// default transparent value in Blink and Webkit), walk up the parent chain\n// until a non-transparent color is found.\nfunction findBackgroundColor(element) {\n  if (element == null || typeof element.style === 'undefined') {\n    // This element has no background, assume white.\n    return 'rgb(255,255,255)';\n  }\n  const backgroundColor = getComputedStyle(element).backgroundColor;\n  if (backgroundColor === 'transparent' || backgroundColor === 'rgba(0, 0, 0, 0)') {\n    return findBackgroundColor(element.parentNode);\n  } else {\n    return backgroundColor;\n  }\n}\n\n\n// Return the individual RGB values from a CSS color string.\nfunction extractRgbValues(rgbString) {\n  const rgbRegex = /rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*[\\d\\.]+\\s*)?\\)/;\n  const match = rgbRegex.exec(rgbString);\n  if (match) {\n    return {\n      r: parseInt(match[1]),\n      g: parseInt(match[2]),\n      b: parseInt(match[3])\n    };\n  } else {\n    return null;\n  }\n}\n\n\ncustomElements.define('basic-fade-overflow', FadeOverflow);\nexport default FadeOverflow;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport ListBox from './src/ListBox';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.ListBox = ListBox;\n","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport ClickSelectionMixin from '../../basic-component-mixins/src/ClickSelectionMixin';\nimport ContentItemsMixin from '../../basic-component-mixins/src/ContentItemsMixin';\nimport DirectionSelectionMixin from '../../basic-component-mixins/src/DirectionSelectionMixin';\nimport GenericMixin from '../../basic-component-mixins/src/GenericMixin';\nimport KeyboardMixin from '../../basic-component-mixins/src/KeyboardMixin';\nimport KeyboardDirectionMixin from '../../basic-component-mixins/src/KeyboardDirectionMixin';\nimport KeyboardPagedSelectionMixin from '../../basic-component-mixins/src/KeyboardPagedSelectionMixin';\nimport KeyboardPrefixSelectionMixin from '../../basic-component-mixins/src/KeyboardPrefixSelectionMixin';\nimport SelectedItemTextValueMixin from '../../basic-component-mixins/src/SelectedItemTextValueMixin';\nimport SelectionAriaActiveMixin from '../../basic-component-mixins/src/SelectionAriaActiveMixin';\nimport SelectionHighlightMixin from '../../basic-component-mixins/src/SelectionHighlightMixin';\nimport SelectionInViewMixin from '../../basic-component-mixins/src/SelectionInViewMixin';\nimport SingleSelectionMixin from '../../basic-component-mixins/src/SingleSelectionMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/**\n * A single-selection list box that supports selection highlighting (using the\n * system highlight color) and keyboard navigation.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-list-box/)\n *\n * The user can select an item with the mouse/touch or keyboard: Up/Down, Page\n * Up/Down, Home/End.\n *\n * Like other Basic Web Components, this can handle distributed content: you can\n * include a content element inside a basic-list-box, and the list will navigate\n * through the distributed content.\n *\n * This component includes basic ARIA support to provide a reasonable default\n * experience, e.g., for screen readers. The list component itself will be\n * assigned an appropriate ARIA role (default is \"listbox\"). The ID of the\n * selected item will be reflected in an \"aria-activedescendant\" attribute\n * applied to the list. To support this feature, all items in the list need\n * unique IDs. If an item does not have an ID, basic-list-box will automatically\n * assign a default ID.\n *\n * The keyboard interaction model generally follows that of Microsoft Windows'\n * list boxes instead of those in OS X:\n *\n * * The Page Up/Down and Home/End keys actually move the selection, rather than\n *   just scrolling the list. The former behavior seems more generally useful\n *   for keyboard users.\n *\n * * Pressing Page Up/Down will move the selection to the topmost/bottommost\n *   visible item if the selection is not already there. Thereafter, the key\n *   will move the selection up/down by a page, and (per the above point) make\n *   the selected item visible.\n *\n * Programmatically selecting an item (by setting the selected property) scrolls\n * the item into view.\n *\n * The user can also select an item by typing the beginning of an item's text.\n *\n * @extends ElementBase\n * @mixes ClickSelectionMixin\n * @mixes ContentItemsMixin\n * @mixes DirectionSelectionMixin\n * @mixes DistributedChildrenContentMixin\n * @mixes GenericMixin\n * @mixes KeyboardMixin\n * @mixes KeyboardDirectionMixin\n * @mixes KeyboardPagedSelectionMixin\n * @mixes KeyboardPrefixSelectionMixin\n * @mixis SelectedItemTextValueMixin\n * @mixes SelectionAriaActiveMixin\n * @mixes SelectionHighlightMixin\n * @mixes SelectionInViewMixin\n * @mixes SingleSelectionMixin\n */\nclass ListBox extends ElementBase.compose(\n  ClickSelectionMixin,\n  ContentItemsMixin,\n  DirectionSelectionMixin,\n  DistributedChildrenContentMixin,\n  GenericMixin,\n  KeyboardMixin,\n  KeyboardDirectionMixin,\n  KeyboardPagedSelectionMixin,\n  KeyboardPrefixSelectionMixin,\n  SelectedItemTextValueMixin,\n  SelectionAriaActiveMixin,\n  SelectionHighlightMixin,\n  SelectionInViewMixin,\n  SingleSelectionMixin\n) {\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.navigationAxis = 'vertical';\n    return defaults;\n  }\n\n  get scrollTarget() {\n    return this.$.itemsContainer;\n  }\n\n  get [symbols.template]() {\n    const baseTemplate = super[symbols.template] || '';\n    return `\n      <style>\n      :host {\n        display: -webkit-flex;\n        display: flex;\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n      }\n\n      [target=\"child\"] {\n        display: -webkit-flex;\n        display: flex;\n        -webkit-flex: 1;\n        flex: 1;\n      }\n\n      #itemsContainer {\n        -webkit-flex: 1;\n        flex: 1;\n        -webkit-overflow-scrolling: touch;\n        overflow-y: scroll; /* for momentum scrolling */\n      }\n\n      /* GenericMixin appearance */\n      :host([generic=\"\"]) {\n        border: 1px solid gray;\n        box-sizing: border-box;\n        cursor: default;\n      }\n\n      :host([generic=\"\"]) #itemsContainer ::slotted(*) {\n        cursor: default;\n        padding: 0.25em;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n      </style>\n\n      <div id=\"itemsContainer\" role=\"none\">\n        <slot></slot>\n      </div>\n      ${baseTemplate}\n    `;\n  }\n\n  /**\n   * Fires when the list's value property changes.\n   *\n   * @memberof ListBox\n   * @event value-changed\n   */\n}\n\n\ncustomElements.define('basic-list-box', ListBox);\nexport default ListBox;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport Modes from './src/Modes';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.Modes = Modes;\n","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport ContentItemsMixin from '../../basic-component-mixins/src/ContentItemsMixin';\nimport SingleSelectionMixin from '../../basic-component-mixins/src/SingleSelectionMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\nconst base = ElementBase.compose(\n  ContentItemsMixin,\n  DistributedChildrenContentMixin,\n  SingleSelectionMixin\n);\n\n\n/**\n * Shows exactly one child element at a time. This can be useful, for example,\n * if a given UI element has multiple modes that present substantially different\n * elements.\n *\n * The transition between child elements is instantenous. If you'd like the\n * transition to be accompanied by visible animated effects, see\n * [basic-animation-stage](../basic-animation-stage).\n *\n * This component doesn't provide any UI for changing which mode is shown.\n *\n * @extends ElementBase\n * @mixes ContentItemsMixin\n * @mixes DistributedChildrenContentMixin\n * @mixes SingleSelectionMixin\n */\nclass Modes extends base {\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.selectionRequired = true;\n    return defaults;\n  }\n\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.style.display = selected ? '' : 'none';\n    item.setAttribute('aria-hidden', !selected);\n  }\n\n  get [symbols.template]() {\n    return `<slot></slot>`;\n  }\n\n}\n\n\ncustomElements.define('basic-modes', Modes);\nexport default Modes;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport SlideshowWithControls from './src/SlideshowWithControls';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.SlideshowWithControls = SlideshowWithControls;\n","import Slideshow from '../../basic-slideshow/src/Slideshow';\nimport PlayControlsMixin from '../../basic-component-mixins/src/PlayControlsMixin';\n\n/**\n * An extension of\n * [basic-slideshow](../basic-slideshow) that adds play controls\n * via [PlayControlsMixin](../basic-component-mixins/docs/PlayControlsMixin.md).\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-slideshow-with-controls/)\n *\n * @extends Slideshow\n * @mixes PlayControlsMixin\n */\nclass SlideshowWithControls extends PlayControlsMixin(Slideshow) {}\ncustomElements.define('basic-slideshow-with-controls', SlideshowWithControls);\n\nexport default SlideshowWithControls;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport Slideshow from './src/Slideshow';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.Slideshow = Slideshow;\n","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport ContentItemsMixin from '../../basic-component-mixins/src/ContentItemsMixin';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport FractionalSelectionMixin from '../../basic-component-mixins/src/FractionalSelectionMixin';\nimport SelectionAnimationMixin from '../../basic-component-mixins/src/SelectionAnimationMixin';\nimport SelectionAriaActiveMixin from '../../basic-component-mixins/src/SelectionAriaActiveMixin';\nimport SingleSelectionMixin from '../../basic-component-mixins/src/SingleSelectionMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\nimport TimerSelectionMixin from '../../basic-component-mixins/src/TimerSelectionMixin';\n\n\nconst base = ElementBase.compose(\n  ContentItemsMixin,\n  DistributedChildrenContentMixin,\n  FractionalSelectionMixin,\n  SelectionAnimationMixin,\n  SelectionAriaActiveMixin,\n  SingleSelectionMixin,\n  TimerSelectionMixin\n);\n\n\n/**\n * Slideshow with animated transitions.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-slideshow/)\n *\n * By default the slideshow will immediately begin playing when it is connected\n * to the document, advance every 3000 ms (3 seconds), and use a simple\n * crossfade effect. For a variation with play controls, see\n * [basic-slideshow-with-controls](../basic-slideshow-with-controls).\n *\n * This component can be used on its own. To incorporate slideshow behavior into\n * a component of your own, apply the\n * [TimerSelectionMixin](../basic-component-mixins/docs/TimerSelectionMixin.md).\n *\n * @extends ElementBase\n * @mixes ContentItemsMixin\n * @mixes DistributedChildrenContentMixin\n * @mixes FractionalSelectionMixin\n * @mixes SelectionAnimationMixin\n * @mixes SelectionAriaActiveMixin\n * @mixes SingleSelectionMixin\n * @mixes TimerSelectionMixin\n */\nclass Slideshow extends base {\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.playing = true;\n    defaults.selectionAnimationDuration = 500;\n    defaults.selectionAnimationEffect = 'crossfade';\n    defaults.selectionRequired = true;\n    defaults.selectionTimerDuration = 3000;\n    defaults.selectionWraps = true;\n    return defaults;\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        display: -webkit-flex;\n        display: flex;\n        overflow: hidden;\n        position: relative;\n      }\n\n      #container ::slotted(*) {\n        height: 100%;\n        object-fit: contain;\n        position: absolute;\n        width: 100%;\n        will-change: transform;\n      }\n      </style>\n\n      <div id=\"container\" role=\"none\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n}\n\n\ncustomElements.define('basic-slideshow', Slideshow);\nexport default Slideshow;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport SlidingCarousel from './src/SlidingCarousel';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.SlidingCarousel = SlidingCarousel;\n","import HorizontalNavigationMixin from '../../basic-component-mixins/src/HorizontalNavigationMixin';\nimport SlidingViewport from '../../basic-sliding-viewport/src/SlidingViewport';\n\n\n/**\n * Lets the user navigate laterally through a sequence of child elements\n * using a simple CSS transition effect to show horizontal movement.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-sliding-carousel/)\n *\n * basic-sliding-carousel is an implementation of the carousel user interface\n * pattern, commonly used for navigating between images, pages, and other\n * elements. This pattern presents the user with a linear sequence of elements,\n * only one of which is shown at a time. The user can navigate to the\n * next/previous element with a variety of input methods.\n *\n * basic-sliding-carousel is a simpler variation of the more sophisticated\n * [basic-carousel](../basic-carousel) component. The latter includes support\n * for wrapping (going forward from the last item to the first, and vice versa),\n * and more complex visual transitions. Those transitions entail use of the Web\n * Animation API, which requires a polyfill in older browsers. Hence, the\n * simpler basic-sliding-carousel may be a more appropriate choice if factors\n * such as download size are critical.\n *\n * Beyond those differences, basic-sliding-carousel offers the same API, usage\n * recommendations, and support for keyboard/touch/mouse and assistive devices.\n * See that component for more details on use.\n *\n * @extends SlidingViewport\n * @mixes HorizontalNavigationMixin\n */\nclass SlidingCarousel extends SlidingViewport.compose(\n  HorizontalNavigationMixin\n) {}\n\n\ncustomElements.define('basic-sliding-carousel', SlidingCarousel);\nexport default SlidingCarousel;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport SlidingViewport from './src/SlidingViewport';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.SlidingViewport = SlidingViewport;\n","import ContentItemsMixin from '../../basic-component-mixins/src/ContentItemsMixin';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport ElementBase from '../../basic-element-base/src/ElementBase';\nimport FractionalSelectionMixin from '../../basic-component-mixins/src/FractionalSelectionMixin';\nimport SelectionAriaActiveMixin from '../../basic-component-mixins/src/SelectionAriaActiveMixin';\nimport SingleSelectionMixin from '../../basic-component-mixins/src/SingleSelectionMixin';\nimport SpreadItems from '../../basic-spread-items/src/SpreadItems'; // jshint ignore:line\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\nconst base = ElementBase.compose(\n  ContentItemsMixin,\n  DistributedChildrenContentMixin,\n  FractionalSelectionMixin,\n  SelectionAriaActiveMixin,\n  SingleSelectionMixin\n);\n\n\n/**\n * Presents list items in a viewport such that only a single item is visible at\n * a time.\n *\n * Navigating between items will be represented with a horizontal visual\n * sliding effect. For more complex visual effects, see\n * [basic-animation-stage](../basic-animation-stage), which takes advantage of\n * the Web Animations API.\n *\n * This component handles the rendering responsibilities for the basic-carousel\n * component.\n *\n * This component currently requires that you explicitly apply a size to it.\n *\n * @extends ElementBase\n * @mixes ContentItemsMixin\n * @mixes DistributedChildrenContentMixin\n * @mixes FractionalSelectionMixin\n * @mixes SelectionAriaActiveMixin\n * @mixes SingleSelectionMixin\n */\nclass SlidingViewport extends base {\n\n  constructor() {\n    super();\n    this[symbols.dragging] = false;\n  }\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.selectionRequired = true;\n    return defaults;\n  }\n\n  /*\n   * During drags, don't show CSS transitions.\n   */\n  get [symbols.dragging]() {\n    return !this.showTransition;\n  }\n  set [symbols.dragging](value) {\n    if (symbols.dragging in base.prototype) { super[symbols.dragging] = value; }\n    this.reflectClass('showTransition', !value);\n  }\n\n  get selectedFraction() {\n    return super.selectedFraction;\n  }\n  set selectedFraction(value) {\n    if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n    render(this);\n  }\n\n  get selectedItem() {\n    return super.selectedItem;\n  }\n  set selectedItem(item) {\n    if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n    render(this);\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        display: block;\n        overflow: hidden;\n        position: relative;\n      }\n\n      #slidingContainer {\n        height: 100%;\n        position: absolute;\n        /*\n         Set width for IE/Edge. It's not clear why they need this, and the other\n         browsers don't.\n         */\n        width: 100%;\n        will-change: transform;\n      }\n\n      :host(.showTransition) #slidingContainer {\n        -webkit-transition: -webkit-transform 0.2s ease-out;\n        transition: transform 0.2s ease-out;\n      }\n      </style>\n\n      <basic-spread-items id=\"slidingContainer\" role=\"none\">\n        <slot></slot>\n      </basic-spread-items>\n    `;\n  }\n\n}\n\n\n\nfunction render(element) {\n  requestAnimationFrame(renderSelection.bind(element));\n}\n\n// Note: In this routine, \"this\" is bound to an element instance.\nfunction renderSelection() {\n  if (!this.selectedItem) {\n    return;\n  }\n  const selection = FractionalSelectionMixin.helpers.elementSelection(this);\n  const itemCount = this.items ? this.items.length : 0;\n  const damped = FractionalSelectionMixin.helpers.dampedSelection(selection, itemCount);\n  // Use a percentage so the transform will still work if screen size changes\n  // (e.g., if device orientation changes).\n  const left = -damped * 100;\n  const transform = 'translateX(' + left + '%)';\n  this.$.slidingContainer.style.webkitTransform = transform;\n  this.$.slidingContainer.style.transform = transform;\n}\n\n\ncustomElements.define('basic-sliding-viewport', SlidingViewport);\nexport default SlidingViewport;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport SpreadItems from './src/SpreadItems';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.SpreadItems = SpreadItems;\n","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/**\n * Spreads out a set of items horizontally so they take equal space.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-spread-items/)\n *\n * This component is used, for example, by the basic-sliding-viewport component\n * to ensure that children of different size will take up the same amount of\n * horizontal space.\n *\n * This component currently requires an explicit size by applied to it.\n *\n * @extends ElementBase\n * @mixes DistributedChildrenContentMixin\n */\nclass SpreadItems extends ElementBase.compose(\n  DistributedChildrenContentMixin\n) {\n\n  connectedCallback() {\n    if (super.connectedCallback) { super.connectedCallback(); }\n    // HACK\n    this[symbols.itemsChanged]();\n  }\n\n  get items() {\n    return this.content;\n  }\n\n  // TODO: Should also handle contentChanged(), but need to rationalize with\n  // invocation of [symbols.itemsChanged] in connectedCallback.\n  [symbols.itemsChanged]() {\n    if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n    const items = this.items;\n    const count = items.length;\n    this.$.spreadContainer.style.width = (count * 100) + '%';\n    const itemWidth = (100 / count) + \"%\";\n    [].forEach.call(items, item => {\n      item.style.width = itemWidth;\n    });\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        display: block;\n      }\n\n      #spreadContainer {\n        display: -webkit-flex;\n        display: flex;\n        height: 100%;\n        position: relative;\n      }\n\n      #spreadContainer ::slotted(*) {\n        object-fit: contain;\n        object-fit: var(--basic-item-object-fit, contain);\n        height: 100%;\n        -webkit-user-drag: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n      </style>\n\n      <div id=\"spreadContainer\" role=\"none\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n}\n\n\ncustomElements.define('basic-spread-items', SpreadItems);\nexport default SpreadItems;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport TabStrip from './src/TabStrip';\nimport TabStripMixin from './src/TabStripMixin';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.TabStrip = TabStrip;\nwindow.Basic.TabStripMixin = TabStripMixin;\n","// import ClickSelectionMixin from '../../basic-component-mixins/src/ClickSelectionMixin';\nimport ContentItemsMixin from '../../basic-component-mixins/src/ContentItemsMixin';\nimport createSymbol from '../../basic-component-mixins/src/createSymbol';\nimport DirectionSelectionMixin from '../../basic-component-mixins/src/DirectionSelectionMixin';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport ElementBase from '../../basic-element-base/src/ElementBase';\nimport GenericMixin from '../../basic-component-mixins/src/GenericMixin';\nimport KeyboardDirectionMixin from '../../basic-component-mixins/src/KeyboardDirectionMixin';\nimport KeyboardMixin from '../../basic-component-mixins/src/KeyboardMixin';\nimport renderArrayAsElements from '../../basic-component-mixins/src/renderArrayAsElements';\nimport SingleSelectionMixin from '../../basic-component-mixins/src/SingleSelectionMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\nimport toggleClass from '../../basic-component-mixins/src/toggleClass';\n\n\n// Symbols for private data members on an element.\nconst panelsSymbol = createSymbol('panels');\nconst spreadTabsSymbol = createSymbol('spreadTabs');\nconst tabPositionSymbol = createSymbol('tabPosition');\n\n\n/**\n * A set of pages with a tab strip governing which page is shown.\n *\n * This stock combination applies the [TabStripMixin](../basic-tab-strip/) to a\n * [basic-modes](../basic-modes/) element. If you'd like to create something\n * more complex than this arrangement, you can use either of those elements on\n * its own.\n *\n * Since this component uses `TabStripMixin`, it obtains the names of the\n * individual tabs from a child's `aria-label` property. Example:\n *\n *     <basic-tabs>\n *       <div aria-label=\"One\">Page one</div>\n *       <div aria-label=\"Two\">Page two</div>\n *       <div aria-label=\"Three\">Page three</div>\n *     </basic-tabs>\n *\n * @extends ElementBase\n * @mixes ClickSelectionMixin\n * @mixes ContentItemsMixin\n * @mixes DirectionSelectionMixin\n * @mixes DistributedChildrenContentMixin\n * @mixes GenericMixin\n * @mixes KeyboardMixin\n * @mixes KeyboardDirectionMixin\n * @mixes SingleSelectionMixin\n */\nclass TabStrip extends ElementBase.compose(\n  // ClickSelectionMixin,\n  DirectionSelectionMixin,\n  GenericMixin,\n  KeyboardMixin,\n  KeyboardDirectionMixin,\n  ContentItemsMixin,\n  DistributedChildrenContentMixin,\n  SingleSelectionMixin\n) {\n\n  constructor() {\n    super();\n\n    // Handle clicks/Enter on tab buttons.\n    // TODO: Rationalize with ClickSelection?\n    this.addEventListener('click', event => {\n      const tab = event.path[0];\n      const index = Array.prototype.indexOf.call(this.items, tab);\n      if (index >= 0 && this.selectedIndex !== index) {\n        this.selectedIndex = index;\n        // Note: We don't call preventDefault here. The default behavior for\n        // mousedown includes setting keyboard focus if the element doesn't\n        // already have the focus, and we want to preserve that behavior.\n        event.stopPropagation();\n      }\n    });\n\n    // Set defaults.\n    if (typeof this.tabPosition === 'undefined') {\n      this.tabPosition = this[symbols.defaults].tabPosition;\n    }\n  }\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.tabindex = null;\n    defaults.tabPosition = 'top';\n    return defaults;\n  }\n\n  get items() {\n    return this.$.tabs.children;\n  }\n\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    applySelectionToTab(item, selected);\n  }\n\n  [symbols.keydown](event) {\n    const handled = super[symbols.keydown] && super[symbols.keydown](event);\n    if (handled && this.selectedItem) {\n      // If the event resulted in a change of selection, move the focus to the\n      // newly-selected tab.\n      this.selectedItem.focus();\n    }\n    return handled;\n  }\n\n  get panels() {\n    return this[panelsSymbol];\n  }\n  set panels(panels) {\n    this[panelsSymbol] = panels;\n\n    // Create one tab for each panel.\n    const selectedIndex = this.selectedIndex;\n    const selectedPanel = panels[selectedIndex];\n    renderArrayAsElements(panels, this.$.tabs, (panel, tab) => {\n      if (!tab) {\n        tab = document.createElement('button');\n        tab.classList.add('tab');\n        tab.classList.add('style-scope');\n        tab.classList.add('basic-tab-strip');\n        tab.setAttribute('role', 'tab');\n        tab.setAttribute('tabindex', 0);\n      }\n      tab.id = panel.id + '_tab';\n      tab.textContent = panel.getAttribute('aria-label');\n\n      // Point tab and panel at each other.\n      tab.setAttribute('aria-controls', panel.id);\n      panel.setAttribute('aria-labelledby', tab.id);\n\n      applySelectionToTab(tab, panel === selectedPanel);\n\n      return tab;\n    });\n\n    this[symbols.itemsChanged]();\n  }\n\n  get spreadTabs() {\n    return this[spreadTabsSymbol];\n  }\n  set spreadTabs(value) {\n    this[spreadTabsSymbol] = value;\n    toggleClass(this, 'spread', value);\n  }\n\n  /**\n   * The position of the tab strip relative to the element's children. Valid\n   * values are \"top\", \"left\", \"right\", and \"bottom\".\n   *\n   * @default \"top\"\n   * @type {string}\n   */\n  get tabPosition() {\n    return this[tabPositionSymbol];\n  }\n  set tabPosition(position) {\n    this[tabPositionSymbol] = position;\n    this.reflectAttribute('tab-position', position);\n    this.navigationAxis = (position === 'top' || position === 'bottom') ?\n      'horizontal' :\n      'vertical';\n  }\n\n  get [symbols.template]() {\n    return `\n      <style>\n        :host {\n          display: -webkit-flex;\n          display: flex;\n        }\n\n        /*\n         * Avoid having tab container stretch across. User won't be able to see\n         * it, but since it handles the keyboard, in Mobile Safari a tap on the\n         * container background will cause the region to flash. Aligning the\n         * region collapses it down to hold its contents.\n         */\n        #tabs {\n          /* For IE bug (clicking tab produces gap between tab and page). */\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex-direction: row;\n          flex-direction: row;\n          -webkit-flex: 1;\n          flex: 1;\n          /*\n           * Try to obtain fast-tap behavior on all tabs.\n           * See https://webkit.org/blog/5610/more-responsive-tapping-on-ios/.\n           */\n          touch-action: manipulation;\n        }\n        :host(:not(.spread)) #tabs {\n          -webkit-align-self: flex-start;\n          align-self: flex-start;\n        }\n\n        .tab {\n          cursor: pointer;\n          display: inline-block;\n          font-family: inherit;\n          font-size: inherit;\n          position: relative;\n        }\n\n        :host([generic=\"\"]) .tab {\n          background: white;\n          border: 1px solid #ccc;\n          margin: 0;\n          padding: 0.5em 0.75em;\n          transition: border-color 0.25s;\n        }\n\n        :host([generic=\"\"]) .tab.selected {\n          border-color: #ccc;\n          opacity: 1;\n        }\n\n        :host([generic=\"\"]) .tab:hover {\n          background-color: #eee;\n        }\n\n        /* Left/right positions */\n        :host([tab-position=\"left\"]) #tabs,\n        :host([tab-position=\"right\"]) #tabs {\n          -webkit-flex-direction: column;\n          flex-direction: column;\n        }\n\n        /* Spread variant */\n        :host(.spread) #tabs {\n          -webkit-align-items: stretch;\n          align-items: stretch;\n        }\n        :host(.spread) .tab {\n          -webkit-flex: 1;\n          flex: 1;\n        }\n\n        /* Generic style, top/bottom positions */\n        :host([generic=\"\"][tab-position=\"top\"]) .tab:not(:last-child),\n        :host([generic=\"\"][tab-position=\"bottom\"]) .tab:not(:last-child) {\n          margin-right: 0.2em;\n        }\n\n        /* Generic style, top position */\n        :host([generic=\"\"][tab-position=\"top\"]) .tab {\n          border-radius: 0.25em 0.25em 0 0;\n          margin-bottom: -1px;\n        }\n        :host([generic=\"\"][tab-position=\"top\"]) .tab.selected {\n          border-bottom-color: transparent;\n        }\n\n        /* Generic style, bottom position */\n        :host([generic=\"\"][tab-position=\"bottom\"]) .tab {\n          border-radius: 0 0 0.25em 0.25em;\n          margin-top: -1px;\n        }\n        :host([generic=\"\"][tab-position=\"bottom\"]) .tab.selected {\n          border-top-color: transparent;\n        }\n\n        /* Generic style, left/right positions */\n        :host([generic=\"\"][tab-position=\"left\"]) .tab:not(:last-child),\n        :host([generic=\"\"][tab-position=\"right\"]) .tab:not(:last-child) {\n          margin-bottom: 0.2em;\n        }\n\n        /* Generic style, left position */\n        :host([generic=\"\"][tab-position=\"left\"]) .tab {\n          border-radius: 0.25em 0 0 0.25em;\n          margin-right: -1px;\n        }\n        :host([generic=\"\"][tab-position=\"left\"]) .tab.selected {\n          border-right-color: transparent;\n        }\n\n        /* Generic style, right position */\n        :host([generic=\"\"][tab-position=\"right\"]) .tab {\n          border-radius: 0 0.25em 0.25em 0;\n          margin-left: -1px;\n        }\n        :host([generic=\"\"][tab-position=\"right\"]) .tab.selected {\n          border-left-color: transparent;\n        }\n      </style>\n      <div id=\"tabs\" role=\"tablist\"></div>\n    `;\n  }\n}\n\n\nfunction applySelectionToTab(tab, selected) {\n  tab.setAttribute('aria-selected', selected);\n}\n\n\ncustomElements.define('basic-tab-strip', TabStrip);\nexport default TabStrip;\n","import TabStrip from './TabStrip'; // jshint ignore:line\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n// Used to assign unique IDs to tabs for ARIA purposes.\nlet idCount = 0;\n\n\n/* Exported function extends a base class with TabStrip. */\nexport default (base) => {\n\n  /**\n   * A template mixin which adds strip of tabs for selecting one of the\n   * component's children.\n   *\n   * The component creates a tab to represent each of its light DOM children.\n   * The tab name is obtained by examining the children for an `aria-label`\n   * property.\n   *\n   * Use tabs when you want to provide a large set of options or elements than\n   * can comfortably fit inline, the options can be coherently grouped into pages,\n   * and you want to avoid making the user navigate to a separate page. Tabs work\n   * best if you only have a small handful of pages, say 27.\n   *\n   * The basic-tab-strip component does not define how a selected child is\n   * represented. If you're looking for the standard behavior of just showing only\n   * the selected child, you can use this component in combination with the\n   * separate [basic-modes](../basic-modes/) component. A typical arrangement:\n   *\n   *     <basic-tab-strip>\n   *       <basic-modes aria-label=\"Panels\">\n   *         <div aria-label=\"One\">Page one</div>\n   *         <div aria-label=\"Two\">Page two</div>\n   *         <div aria-label=\"Three\">Page three</div>\n   *       </basic-modes>\n   *     </basic-tab-strip>\n   *\n   * The above combination is so common it is provided as a single component,\n   * [basic-tabs](../basic-tabs/).\n   *\n   * The user can select a tab with the mouse or touch, as well as by through the\n   * keyboard. Each tab appears as a separate button in the tab order.\n   * Additionally, if the focus is currently on a tab, the user can quickly\n   * navigate between tabs with the left/right arrow keys (or, if the tabs are\n   * in vertical position, the up/down arrow keys).\n   *\n   * By default, the tabs are shown grouped to the left, where each tab is only\n   * as big as necessary. You can apply the `spread` CSS class to a\n   * basic-tab-strip element for a variant appearance in which the available width\n   * of the element is divided up equally among tabs.\n   *\n   * The GenericMixin default styling of the tab strip will present the classic\n   * skeumorphic look of rounded tabs attached to a surface. You can remove this\n   * styling by setting the `GenericMixin` property/attribute to false.\n   */\n  class TabStrip extends base {\n\n    constructor() {\n      super();\n      this.$.tabStrip.addEventListener('selected-item-changed', event => {\n        const selectedIndex = event.target.selectedIndex;\n        if (this.selectedIndex !== selectedIndex) {\n          this.selectedIndex = selectedIndex;\n        }\n      });\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.tabPosition = 'top';\n      return defaults;\n    }\n\n    get generic() {\n      return super.generic;\n    }\n    set generic(value) {\n      if ('generic' in base.prototype) { super.generic = value; }\n      this.$.tabStrip.generic = value;\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      const baseId = this.id ?\n        \"_\" + this.id + \"Panel\" :\n        \"_panel\";\n\n      // Confirm that items have at least a default role and ID for ARIA purposes.\n      this.items.forEach(item => {\n        // if (!item.getAttribute('role')) {\n          item.setAttribute('role', 'tabpanel');\n        // }\n        if (!item.id) {\n          item.id = baseId + idCount++;\n        }\n      });\n\n      // Point the tab strip at the panels.\n      this.$.tabStrip.panels = this.items;\n      this.$.tabStrip.selectedIndex = this.selectedIndex;\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(value) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = value; }\n      if (this.$.tabStrip.selectedIndex !== value) {\n        this.$.tabStrip.selectedIndex = value;\n      }\n    }\n\n    get spreadTabs() {\n      return this.$.tabStrip.spreadTabs;\n    }\n    set spreadTabs(value) {\n      this.$.tabStrip.spreadTabs = value;\n    }\n\n    get tabPosition() {\n      return this.$.tabStrip.tabPosition;\n    }\n    set tabPosition(position) {\n      this.$.tabStrip.tabPosition = position;\n      this.reflectAttribute('tab-position', position);\n\n      // Physically reorder the tabs and pages to reflect the desired arrangement.\n      // We could change the visual appearance by reversing the order of the flex\n      // box, but then the visual order wouldn't reflect the document order, which\n      // determines focus order. That would surprise a user trying to tab through\n      // the controls.\n      const firstElement = (position === 'top' || position === 'left') ?\n        this.$.tabStrip :\n        this.$.pages;\n      const lastElement = (position === 'top' || position === 'left') ?\n        this.$.pages :\n        this.$.tabStrip;\n      if (firstElement.nextSibling !== lastElement) {\n        this.shadowRoot.insertBefore(firstElement, lastElement);\n      }\n\n    }\n\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n        :host {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex-direction: column;\n          flex-direction: column;\n          position: relative;\n        }\n\n        #pages {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n          -webkit-flex-direction: column;\n          flex-direction: column;\n        }\n\n        #pages ::slotted(*) {\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex: 1;\n          flex: 1;\n        }\n\n        /* Left/right positions */\n        :host([tab-position=\"left\"]),\n        :host([tab-position=\"right\"]) {\n          -webkit-flex-direction: row;\n          flex-direction: row;\n        }\n\n        /* Generic style */\n        :host([generic=\"\"]) #pages {\n          background: white;\n          border: 1px solid #ccc;\n          box-sizing: border-box;\n        }\n        </style>\n\n        <basic-tab-strip id=\"tabStrip\" role=\"tablist\"></basic-tab-strip>\n        <div id=\"pages\">\n          ${baseTemplate}\n        </div>\n      `;\n    }\n\n  }\n\n  return TabStrip;\n};\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport Tabs from './src/Tabs';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.Tabs = Tabs;\n","import GenericMixin from '../../basic-component-mixins/src/GenericMixin';\nimport Modes from '../../basic-modes/src/Modes';\nimport TabStripMixin from '../../basic-tab-strip/src/TabStripMixin';\n\n\nconst base = Modes.compose(\n  GenericMixin,\n  TabStripMixin\n);\n\n\n/**\n * A set of pages with a tab strip governing which page is shown.\n *\n * This stock combination applies the [TabStripMixin](../basic-tab-strip/) to a\n * [basic-modes](../basic-modes/) element. If you'd like to create something\n * more complex than this arrangement, you can use either of those elements on\n * its own.\n *\n * Since this component uses `TabStripMixin`, it obtains the names of the\n * individual tabs from a child's `aria-label` property. Example:\n *\n *     <basic-tabs>\n *       <div aria-label=\"One\">Page one</div>\n *       <div aria-label=\"Two\">Page two</div>\n *       <div aria-label=\"Three\">Page three</div>\n *     </basic-tabs>\n *\n * @extends Modes\n * @mixes GenericMixin\n */\nclass Tabs extends base {}\n\ncustomElements.define('basic-tabs', Tabs);\nexport default Tabs;\n","/*\n * This file is transpiled to create an ES5-compatible distribution of all\n * components in the project. If you're already using ES6 yourself, ignore this\n * file, and instead import the source file(s) you want from the specific\n * package you want.\n */\n\n// Import all the globals from each package.\n// We tell jshint to ignore the fact that we're not actually using them here.\n/* jshint ignore:start */\n\nimport * as animationStage from '../basic-animation-stage/globals';\nimport * as autosizeTextarea from '../basic-autosize-textarea/globals';\nimport * as carousel from '../basic-carousel/globals';\nimport * as collapsiblePanel from '../basic-collapsible-panel/globals';\nimport * as componentMixins from '../basic-component-mixins/globals';\nimport * as currentAnchor from '../basic-current-anchor/globals';\nimport * as elementBase from '../basic-element-base/globals';\nimport * as fadeOverflow from '../basic-fade-overflow/globals';\nimport * as listBox from '../basic-list-box/globals';\nimport * as modes from '../basic-modes/globals';\nimport * as slideshow from '../basic-slideshow/globals';\nimport * as slideshowWithControls from '../basic-slideshow-with-controls/globals';\nimport * as slidingCarousel from '../basic-sliding-carousel/globals';\nimport * as slidingViewport from '../basic-sliding-viewport/globals';\nimport * as spreadItems from '../basic-spread-items/globals';\nimport * as tabs from '../basic-tabs/globals';\nimport * as tabStrip from '../basic-tab-strip/globals';\nimport * as webComponents from '../basic-web-components/globals';\nimport * as wrappedStandardElement from '../basic-wrapped-standard-element/globals';\n\n/* jshint ignore:end */\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport WrappedStandardElement from './src/WrappedStandardElement';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.WrappedStandardElement = WrappedStandardElement;\n","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/*\n * A set of events which, if fired by the inner standard element, should be\n * re-raised by the custom element. (We only need to do that under native\n * Shadow DOM, not the polyfill.)\n *\n * These are events which are spec'ed to NOT get retargetted across a Shadow DOM\n * boundary, organized by which element(s) raise the events. To properly\n * simulate these, we will need to listen for the real events, then re-raise a\n * simulation of the original event. For more information, see\n * https://www.w3.org/TR/shadow-dom/#h-events-that-are-not-leaked-into-ancestor-trees.\n *\n * It appears that we do *not* need to re-raise the non-bubbling \"focus\" and\n * \"blur\" events. These appear to be automatically re-raised as expected -- but\n * it's not clear why that happens.\n *\n * The list below is reasonably complete. It omits elements that cannot be\n * wrapped (see class notes above). Also, we haven't actually tried wrapping\n * every element in this list; some of the more obscure ones might not actually\n * work as expected, but it was easier to include them for completeness than\n * to actually verify whether or not the element can be wrapped.\n */\nconst reraiseEvents = {\n  address: ['scroll'],\n  blockquote: ['scroll'],\n  caption: ['scroll'],\n  center: ['scroll'],\n  dd: ['scroll'],\n  dir: ['scroll'],\n  div: ['scroll'],\n  dl: ['scroll'],\n  dt: ['scroll'],\n  fieldset: ['scroll'],\n  form: ['reset', 'scroll'],\n  frame: ['load'],\n  h1: ['scroll'],\n  h2: ['scroll'],\n  h3: ['scroll'],\n  h4: ['scroll'],\n  h5: ['scroll'],\n  h6: ['scroll'],\n  iframe: ['load'],\n  img: ['abort', 'error', 'load'],\n  input: ['abort', 'change', 'error', 'select', 'load'],\n  keygen: ['reset', 'select'],\n  li: ['scroll'],\n  link: ['load'],\n  menu: ['scroll'],\n  object: ['error', 'scroll'],\n  ol: ['scroll'],\n  p: ['scroll'],\n  script: ['error', 'load'],\n  select: ['change', 'scroll'],\n  tbody: ['scroll'],\n  tfoot: ['scroll'],\n  thead: ['scroll'],\n  textarea: ['change', 'select', 'scroll']\n};\n\n\n// Keep track of which re-raised events should bubble.\nconst eventBubbles = {\n  abort: true,\n  change: true,\n  reset: true\n};\n\n\n// Elements which are display: block by default.\n// Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nconst blockElements = [\n  'address',\n  'article',\n  'aside',\n  'blockquote',\n  'canvas',\n  'dd',\n  'div',\n  'dl',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'header',\n  'hgroup',\n  'hr',\n  'li',\n  'main',\n  'nav',\n  'noscript',\n  'ol',\n  'output',\n  'p',\n  'pre',\n  'section',\n  'table',\n  'tfoot',\n  'ul',\n  'video'\n];\n\n\n/**\n * Wraps a standard HTML element so that the standard behavior can then be\n * extended.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-wrapped-standard-element/)\n *\n * See also [basic-autosize-textarea](../basic-autosize-textarea) and\n * [basic-current-anchor](../basic-current-anchor). The former uses\n * WrappedStandardElement to wrap a standard `<textarea>` and `<a>`,\n * respectively.\n *\n * The Custom Elements spec does not currently (as of March 2016) allow you to\n * extend the behavior of a standard HTML element like `<a>` or `<button>`.\n * As a partial workaround, the WrappedStandardElement class can create a class\n * for you that wraps an instance of a standard HTML element. For example, the\n * code below creates a class that will wrap an instance of a standard `<a>`\n * element:\n *\n *     class WrappedA extends WrappedStandardElement.wrap('a') {\n *       customMethod() { ... }\n *     }\n *     customElements.define('wrapped-a', WrappedA);\n *\n * An instance of the resulting class will look to the user like an instance of\n * the standard element class it wraps. The resulting class will *not* be an\n * `instanceof` the standard class (here, HTMLAnchorElement). Another limitation\n * is that the resulting `<wrapped-a>` will not automatically pick up CSS styles\n * for standard `<a>` elements. However, the resulting class *can* be extended.\n * E.g., instances of the above class have a `customMethod()` available to them.\n *\n * Any properties defined by the original standard element will be exposed on\n * the resulting wrapper class, and calls to get or set those properties will be\n * delegated to the wrapped element instance. Continuing the above example:\n *\n *     let wrapped = document.createElement('wrapped-a');\n *     wrapped.href = 'http://example.com/';\n *     wrapped.textContent = 'Click here';\n *\n * Here, the created custom `<wrapped-a>` element will contain inside its\n * shadow tree an instance of a standard `<a>` element. The call to set the\n * wrapper's `href` property will ultimately set the `href` on the inner link.\n * Moreover, the text content of the `<wrapped-a>` element will appear inside\n * the inner link. The result of all this is that the user will see what *looks*\n * like a normal link, just as if you had written\n * `<a href=\"http://example.com/\">Click here</a>`. However, the actual element\n * will be an instance of your custom class, with whatever behavior you've\n * defined for it.\n *\n * Wrapped elements should raise the same events as the original standard\n * elements. E.g., if you wrap an `<img>` element, the wrapped result will raise\n * the standard `load` event as expected.\n *\n * Some elements, such as `<body>`, `<html>`, and `<style>` cannot be wrapped\n * and still achieve their standard behavior.\n *\n * @extends ElementBase\n */\nclass WrappedStandardElement extends ElementBase {\n\n  constructor() {\n    super();\n\n    // Listen for any events raised by the inner element which will not\n    // automatically be retargetted across the Shadow DOM boundary, and re-raise\n    // those events when they happen.\n    //\n    // Note: It's unclear why we need to do this in the Shadow DOM polyfill.\n    // In theory, events in the light DOM should bubble as normal. But this\n    // code appears to be required in the polyfill case as well.\n    const eventNames = reraiseEvents[this.extends] || [];\n    eventNames.forEach(eventName => {\n      this.inner.addEventListener(eventName, realEvent => {\n        const event = new Event(eventName, {\n          bubbles: eventBubbles[eventName] || false\n        });\n        this.dispatchEvent(event);\n      });\n    });\n  }\n\n  /**\n   * A description for the user of the element's purpose on the page. Setting\n   * this applies the label to the inner element, ensuring that screen readers\n   * and other assistive technologies will provide a meaningful description to\n   * the user.\n   *\n   * @type {string}\n   */\n  get ariaLabel() {\n    return this.inner.getAttribute('aria-label');\n  }\n  set ariaLabel(label) {\n    // Propagate the ARIA label to the inner textarea.\n    this.inner.setAttribute('aria-label', label);\n  }\n\n  /**\n   * Returns a reference to the inner standard HTML element.\n   *\n   * @type {HTMLElement}\n   */\n  get inner() {\n    return this.$.inner;\n  }\n\n  /**\n   * The template copied into the shadow tree of new instances of this element.\n   *\n   * The default value of this property is a template that includes an instance\n   * the standard element being wrapped, with a `<slot>` element inside that\n   * to pick up the element's light DOM content. For example, if you wrap an\n   * `<a>` element, then the default template will look like:\n   *\n   *     <template>\n   *       <style>\n   *       :host {\n   *         display: inline-block;\n   *       }\n   *       </style>\n   *       <a id=\"inner\">\n   *         <slot></slot>\n   *       </a>\n   *     </template>\n   *\n   * The `display` styling applied to the host will be `block` for elements that\n   * are block elements by default, and `inline-block` (not `inline`) for other\n   * elements.\n   *\n   * If you'd like the template to include other elements, then override this\n   * property and return a template of your own. The template should include an\n   * instance of the standard HTML element you are wrapping, and the ID of that\n   * element should be \"inner\".\n   *\n   * @type {(string|HTMLTemplateElement)}\n   */\n  get [symbols.template]() {\n    const display = blockElements.indexOf(this.extends) >= 0 ?\n      'block' :\n      'inline-block';\n    return `<style>:host { display: ${display}}</style><${this.extends} id=\"inner\"><slot></slot></${this.extends}`;\n  }\n\n  /**\n   * Creates a class that wraps a standard HTML element.\n   *\n   * Note that the resulting class is a subclass of WrappedStandardElement, not\n   * the standard class being wrapped. E.g., if you call\n   * `WrappedStandardElement.wrap('a')`, you will get a class whose shadow tree\n   * will include an anchor element, but the class will *not* inherit from\n   * HTMLAnchorElement.\n   *\n   * @param {string} extendsTag - the standard HTML element tag to extend\n   */\n  static wrap(extendsTag) {\n\n    // Create the new class.\n    class Wrapped extends WrappedStandardElement {}\n\n    // Indicate which tag it wraps.\n    Wrapped.prototype.extends = extendsTag;\n\n    // Create getter/setters that delegate to the wrapped element.\n    const element = document.createElement(extendsTag);\n    const extendsPrototype = element.constructor.prototype;\n    const names = Object.getOwnPropertyNames(extendsPrototype);\n    names.forEach(name => {\n        const descriptor = Object.getOwnPropertyDescriptor(extendsPrototype, name);\n        const delegate = createPropertyDelegate(name, descriptor);\n        Object.defineProperty(Wrapped.prototype, name, delegate);\n    });\n\n    return Wrapped;\n  }\n\n}\n\n\nfunction createPropertyDelegate(name, descriptor) {\n  const delegate = {\n    configurable: descriptor.configurable,\n    enumerable: descriptor.enumerable,\n  };\n  if (descriptor.get) {\n    delegate.get = function() {\n      return this.inner[name];\n    };\n  }\n  if (descriptor.set) {\n    delegate.set = function(value) {\n      this.inner[name] = value;\n    };\n  }\n  if (descriptor.writable) {\n    delegate.writable = descriptor.writable;\n  }\n  return delegate;\n}\n\n\nexport default WrappedStandardElement;\n"],"preExisting":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJwYWNrYWdlcy9iYXNpYy1hbmltYXRpb24tc3RhZ2UvZ2xvYmFscy5qcyIsInBhY2thZ2VzL2Jhc2ljLWFuaW1hdGlvbi1zdGFnZS9zcmMvQW5pbWF0aW9uU3RhZ2UuanMiLCJwYWNrYWdlcy9iYXNpYy1hdXRvc2l6ZS10ZXh0YXJlYS9nbG9iYWxzLmpzIiwicGFja2FnZXMvYmFzaWMtYXV0b3NpemUtdGV4dGFyZWEvc3JjL0F1dG9zaXplVGV4dGFyZWEuanMiLCJwYWNrYWdlcy9iYXNpYy1jYXJvdXNlbC9nbG9iYWxzLmpzIiwicGFja2FnZXMvYmFzaWMtY2Fyb3VzZWwvc3JjL0Nhcm91c2VsLmpzIiwicGFja2FnZXMvYmFzaWMtY29sbGFwc2libGUtcGFuZWwvZ2xvYmFscy5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbGxhcHNpYmxlLXBhbmVsL3NyYy9Db2xsYXBzaWJsZVBhbmVsLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9nbG9iYWxzLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQXJyb3dTZWxlY3Rpb25NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0F0dHJpYnV0ZU1hcnNoYWxsaW5nTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9DbGlja1NlbGVjdGlvbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQ29tcG9zYWJsZU1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQ29udGVudEl0ZW1zTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9EaXJlY3Rpb25TZWxlY3Rpb25NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0Rpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9EaXN0cmlidXRlZENoaWxkcmVuTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9GcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9HZW5lcmljTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9Ib3Jpem9udGFsTmF2aWdhdGlvbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvS2V5Ym9hcmREaXJlY3Rpb25NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0tleWJvYXJkTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9LZXlib2FyZFBhZ2VkU2VsZWN0aW9uTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9LZXlib2FyZFByZWZpeFNlbGVjdGlvbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvT3BlbkNsb3NlTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9QYWdlRG90c01peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvUGxheUNvbnRyb2xzTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TZWxlY3RlZEl0ZW1UZXh0VmFsdWVNaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NlbGVjdGlvbkFuaW1hdGlvbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2VsZWN0aW9uSGlnaGxpZ2h0TWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TZWxlY3Rpb25JblZpZXdNaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NoYWRvd0VsZW1lbnRSZWZlcmVuY2VzTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TaGFkb3dUZW1wbGF0ZU1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2luZ2xlU2VsZWN0aW9uTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9Td2lwZURpcmVjdGlvbk1peGluLmpzIiwicGFja2FnZXMvYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvVGltZXJTZWxlY3Rpb25NaXhpbi5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1RyYWNrcGFkRGlyZWN0aW9uTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9jcmVhdGVTeW1ib2wuanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9taWNyb3Rhc2suanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9yZW5kZXJBcnJheUFzRWxlbWVudHMuanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zYWZlQXR0cmlidXRlcy5qcyIsInBhY2thZ2VzL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3N5bWJvbHMuanMiLCJwYWNrYWdlcy9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy90b2dnbGVDbGFzcy5qcyIsInBhY2thZ2VzL2Jhc2ljLWN1cnJlbnQtYW5jaG9yL2dsb2JhbHMuanMiLCJwYWNrYWdlcy9iYXNpYy1jdXJyZW50LWFuY2hvci9zcmMvQ3VycmVudEFuY2hvci5qcyIsInBhY2thZ2VzL2Jhc2ljLWVsZW1lbnQtYmFzZS9nbG9iYWxzLmpzIiwicGFja2FnZXMvYmFzaWMtZWxlbWVudC1iYXNlL3NyYy9FbGVtZW50QmFzZS5qcyIsInBhY2thZ2VzL2Jhc2ljLWZhZGUtb3ZlcmZsb3cvZ2xvYmFscy5qcyIsInBhY2thZ2VzL2Jhc2ljLWZhZGUtb3ZlcmZsb3cvc3JjL0ZhZGVPdmVyZmxvdy5qcyIsInBhY2thZ2VzL2Jhc2ljLWxpc3QtYm94L2dsb2JhbHMuanMiLCJwYWNrYWdlcy9iYXNpYy1saXN0LWJveC9zcmMvTGlzdEJveC5qcyIsInBhY2thZ2VzL2Jhc2ljLW1vZGVzL2dsb2JhbHMuanMiLCJwYWNrYWdlcy9iYXNpYy1tb2Rlcy9zcmMvTW9kZXMuanMiLCJwYWNrYWdlcy9iYXNpYy1zbGlkZXNob3ctd2l0aC1jb250cm9scy9nbG9iYWxzLmpzIiwicGFja2FnZXMvYmFzaWMtc2xpZGVzaG93LXdpdGgtY29udHJvbHMvc3JjL1NsaWRlc2hvd1dpdGhDb250cm9scy5qcyIsInBhY2thZ2VzL2Jhc2ljLXNsaWRlc2hvdy9nbG9iYWxzLmpzIiwicGFja2FnZXMvYmFzaWMtc2xpZGVzaG93L3NyYy9TbGlkZXNob3cuanMiLCJwYWNrYWdlcy9iYXNpYy1zbGlkaW5nLWNhcm91c2VsL2dsb2JhbHMuanMiLCJwYWNrYWdlcy9iYXNpYy1zbGlkaW5nLWNhcm91c2VsL3NyYy9TbGlkaW5nQ2Fyb3VzZWwuanMiLCJwYWNrYWdlcy9iYXNpYy1zbGlkaW5nLXZpZXdwb3J0L2dsb2JhbHMuanMiLCJwYWNrYWdlcy9iYXNpYy1zbGlkaW5nLXZpZXdwb3J0L3NyYy9TbGlkaW5nVmlld3BvcnQuanMiLCJwYWNrYWdlcy9iYXNpYy1zcHJlYWQtaXRlbXMvZ2xvYmFscy5qcyIsInBhY2thZ2VzL2Jhc2ljLXNwcmVhZC1pdGVtcy9zcmMvU3ByZWFkSXRlbXMuanMiLCJwYWNrYWdlcy9iYXNpYy10YWItc3RyaXAvZ2xvYmFscy5qcyIsInBhY2thZ2VzL2Jhc2ljLXRhYi1zdHJpcC9zcmMvVGFiU3RyaXAuanMiLCJwYWNrYWdlcy9iYXNpYy10YWItc3RyaXAvc3JjL1RhYlN0cmlwTWl4aW4uanMiLCJwYWNrYWdlcy9iYXNpYy10YWJzL2dsb2JhbHMuanMiLCJwYWNrYWdlcy9iYXNpYy10YWJzL3NyYy9UYWJzLmpzIiwicGFja2FnZXMvYmFzaWMtd2ViLWNvbXBvbmVudHMvZ2xvYmFscy5qcyIsInBhY2thZ2VzL2Jhc2ljLXdyYXBwZWQtc3RhbmRhcmQtZWxlbWVudC9nbG9iYWxzLmpzIiwicGFja2FnZXMvYmFzaWMtd3JhcHBlZC1zdGFuZGFyZC1lbGVtZW50L3NyYy9XcmFwcGVkU3RhbmRhcmRFbGVtZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNPQTs7Ozs7O0FBRUEsT0FBTyxLQUFQLEdBQWUsT0FBTyxLQUFQLElBQWdCLEVBQS9CLEMsQ0FUQTs7Ozs7OztBQVVBLE9BQU8sS0FBUCxDQUFhLGNBQWI7Ozs7Ozs7Ozs7Ozs7QUNWQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFHQSxJQUFNLE9BQU8sc0JBQVksT0FBWixtTkFBYjs7QUFTQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMEJNLGM7Ozs7Ozs7Ozs7U0FFQyxrQkFBUSxRO3dCQUFZO0FBQ3ZCLFVBQU0sV0FBVyw0RkFBTSxrQkFBUSxRQUFkLFdBQTJCLEVBQTVDO0FBQ0EsZUFBUyxpQkFBVCxHQUE2QixJQUE3QjtBQUNBLGFBQU8sUUFBUDtBQUNEOztTQUVJLGtCQUFRLFE7d0JBQVk7QUFDdkI7QUFvQkQ7Ozs7RUE3QjBCLEk7O0FBa0M3QixlQUFlLE1BQWYsQ0FBc0IsdUJBQXRCLEVBQStDLGNBQS9DO2tCQUNlLGM7Ozs7O0FDekVmOzs7Ozs7QUFFQSxPQUFPLEtBQVAsR0FBZSxPQUFPLEtBQVAsSUFBZ0IsRUFBL0IsQyxDQVRBOzs7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Q0QsTUFBSSxXQUFXLFFBQWYsRUFBeUI7QUFDdkIsYUFBUyxRQUFULEdBQW9CLFdBQVcsUUFBL0I7QUFDRDtBQUNELFNBQU8sUUFBUDtBQUNEOztrQkFHYyxzQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKlxuICogVGhpcyBmaWxlIGlzIHRyYW5zcGlsZWQgdG8gY3JlYXRlIGFuIEVTNS1jb21wYXRpYmxlIGRpc3RyaWJ1dGlvbiBpbiB3aGljaFxuICogdGhlIHBhY2thZ2UncyBtYWluIGZlYXR1cmUocykgYXJlIGF2YWlsYWJsZSB2aWEgdGhlIHdpbmRvdy5CYXNpYyBnbG9iYWwuXG4gKiBJZiB5b3UncmUgYWxyZWFkeSB1c2luZyBFUzYgeW91cnNlbGYsIGlnbm9yZSB0aGlzIGZpbGUsIGFuZCBpbnN0ZWFkIGltcG9ydFxuICogdGhlIHNvdXJjZSBmaWxlKHMpIHlvdSB3YW50IGZyb20gdGhlIHNyYyBmb2xkZXIuXG4gKi9cblxuaW1wb3J0IEFuaW1hdGlvblN0YWdlIGZyb20gJy4vc3JjL0FuaW1hdGlvblN0YWdlJztcblxud2luZG93LkJhc2ljID0gd2luZG93LkJhc2ljIHx8IHt9O1xud2luZG93LkJhc2ljLkFuaW1hdGlvblN0YWdlID0gQW5pbWF0aW9uU3RhZ2U7XG4iLCJpbXBvcnQgRWxlbWVudEJhc2UgZnJvbSAnLi4vLi4vYmFzaWMtZWxlbWVudC1iYXNlL3NyYy9FbGVtZW50QmFzZSc7XG5pbXBvcnQgQ29udGVudEl0ZW1zTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQ29udGVudEl0ZW1zTWl4aW4nO1xuaW1wb3J0IERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbic7XG5pbXBvcnQgRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0ZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgU2VsZWN0aW9uQW5pbWF0aW9uTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2VsZWN0aW9uQW5pbWF0aW9uTWl4aW4nO1xuaW1wb3J0IFNlbGVjdGlvbkFyaWFBY3RpdmVNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TZWxlY3Rpb25BcmlhQWN0aXZlTWl4aW4nO1xuaW1wb3J0IFNpbmdsZVNlbGVjdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NpbmdsZVNlbGVjdGlvbk1peGluJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3N5bWJvbHMnO1xuXG5cbmNvbnN0IGJhc2UgPSBFbGVtZW50QmFzZS5jb21wb3NlKFxuICBDb250ZW50SXRlbXNNaXhpbixcbiAgRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbixcbiAgRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluLFxuICBTZWxlY3Rpb25BbmltYXRpb25NaXhpbixcbiAgU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluLFxuICBTaW5nbGVTZWxlY3Rpb25NaXhpblxuKTtcblxuLyoqXG4gKiBQcmVzZW50cyBhIHNpbmdsZSBpdGVtIGFzIHNlbGVjdGVkLCBwcm92aWRpbmcgYW5pbWF0ZWQgdHJhbnNpdGlvbnMgd2hlbiB0aGVcbiAqIHNlbGVjdGlvbiBjaGFuZ2VzLiBUaGUgc2FtZSBhbmltYXRpb24gY2FuIGJlIHNob3duIGF0IGFuIGFyYml0cmFyeSBwb2ludCxcbiAqIGdlbmVyYWxseSB1c2VkIHRvIHJlZmxlY3QgYSB1c2VyLWNvbnRyb2xsZWQgdG91Y2ggb3IgdHJhY2twYWQgZHJhZyBvcGVyYXRpb25cbiAqIGluIHByb2dyZXNzLlxuICpcbiAqIFtMaXZlIGRlbW9dKGh0dHA6Ly9iYXNpY3dlYmNvbXBvbmVudHMub3JnL2Jhc2ljLXdlYi1jb21wb25lbnRzL3BhY2thZ2VzL2Jhc2ljLWFuaW1hdGlvbi1zdGFnZS8pXG4gKlxuICogVGhpcyBjb21wb25lbnQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBhIHByb2dyYW1tYXRpYyByZW5kZXJpbmcgc3VyZmFjZSBmb3JcbiAqIGNvbXBvbmVudHMgd2hpY2ggd2FudCB0byBzaG93IHRyYW5zaXRpb25hbCBlZmZlY3RzLlxuICpcbiAqIFRoZSBjb21wb25lbnQgdXNlcyBbU2VsZWN0aW9uQW5pbWF0aW9uTWl4aW5dKC4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvZG9jcy9TZWxlY3Rpb25BbmltYXRpb25NaXhpbi5tZClcbiAqIG1peGluLCB3aGljaCBpbiB0dXJuIHVzZXMgdGhlIFdlYiBBbmltYXRpb25zIEFQSS4gRm9yIHVzZSBvbiBicm93c2VycyB3aGljaFxuICogZG8gbm90IHN1cHBvcnQgdGhhdCBBUEkgbmF0aXZlbHksIHlvdSB3aWxsIG5lZWQgdG8gbG9hZCB0aGVcbiAqIFtXZWIgQW5pbWF0aW9ucyBwb2x5ZmlsbF0oaHR0cHM6Ly9naXRodWIuY29tL3dlYi1hbmltYXRpb25zL3dlYi1hbmltYXRpb25zLWpzKS5cbiAqXG4gKiBGb3IgYSBzaW1wbGVyIGNvbXBvbmVudCB0aGF0IGV4aGliaXRzIG9ubHkgYSBzbGlkaW5nIGVmZmVjdCwgYnV0IGRvZXMgbm90XG4gKiByZXF1aXJlIHRoZSBXZWIgQW5pbWF0aW9ucyBBUEksIHNlZSBbYmFzaWMtc2xpZGluZy12aWV3cG9ydF0oLi4vYmFzaWMtc2xpZGluZy12aWV3cG9ydCkuXG4gKlxuICogQGV4dGVuZHMgRWxlbWVudEJhc2VcbiAqIEBtaXhlcyBDb250ZW50SXRlbXNNaXhpblxuICogQG1peGVzIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW5cbiAqIEBtaXhlcyBTZWxlY3Rpb25BbmltYXRpb25NaXhpblxuICogQG1peGVzIFNlbGVjdGlvbkFyaWFBY3RpdmVNaXhpblxuICogQG1peGVzIFNpbmdsZVNlbGVjdGlvbk1peGluXG4gKi9cbmNsYXNzIEFuaW1hdGlvblN0YWdlIGV4dGVuZHMgYmFzZSB7XG5cbiAgZ2V0IFtzeW1ib2xzLmRlZmF1bHRzXSgpIHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgIGRlZmF1bHRzLnNlbGVjdGlvblJlcXVpcmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gZGVmYXVsdHM7XG4gIH1cblxuICBnZXQgW3N5bWJvbHMudGVtcGxhdGVdKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIH1cblxuICAgICAgI2NvbnRhaW5lciA6OnNsb3R0ZWQoKikge1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XG4gICAgICB9XG4gICAgICA8L3N0eWxlPlxuXG4gICAgICA8ZGl2IGlkPVwiY29udGFpbmVyXCIgcm9sZT1cIm5vbmVcIj5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgfVxuXG59XG5cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdiYXNpYy1hbmltYXRpb24tc3RhZ2UnLCBBbmltYXRpb25TdGFnZSk7XG5leHBvcnQgZGVmYXVsdCBBbmltYXRpb25TdGFnZTtcbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgdHJhbnNwaWxlZCB0byBjcmVhdGUgYW4gRVM1LWNvbXBhdGlibGUgZGlzdHJpYnV0aW9uIGluIHdoaWNoXG4gKiB0aGUgcGFja2FnZSdzIG1haW4gZmVhdHVyZShzKSBhcmUgYXZhaWxhYmxlIHZpYSB0aGUgd2luZG93LkJhc2ljIGdsb2JhbC5cbiAqIElmIHlvdSdyZSBhbHJlYWR5IHVzaW5nIEVTNiB5b3Vyc2VsZiwgaWdub3JlIHRoaXMgZmlsZSwgYW5kIGluc3RlYWQgaW1wb3J0XG4gKiB0aGUgc291cmNlIGZpbGUocykgeW91IHdhbnQgZnJvbSB0aGUgc3JjIGZvbGRlci5cbiAqL1xuXG5pbXBvcnQgQXV0b3NpemVUZXh0YXJlYSBmcm9tICcuL3NyYy9BdXRvc2l6ZVRleHRhcmVhJztcblxud2luZG93LkJhc2ljID0gd2luZG93LkJhc2ljIHx8IHt9O1xud2luZG93LkJhc2ljLkF1dG9zaXplVGV4dGFyZWEgPSBBdXRvc2l6ZVRleHRhcmVhO1xuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IFdyYXBwZWRTdGFuZGFyZEVsZW1lbnQgZnJvbSAnLi4vLi4vYmFzaWMtd3JhcHBlZC1zdGFuZGFyZC1lbGVtZW50L3NyYy9XcmFwcGVkU3RhbmRhcmRFbGVtZW50JztcbmltcG9ydCBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0Rpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4nO1xuaW1wb3J0IEdlbmVyaWNNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9HZW5lcmljTWl4aW4nO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc3ltYm9scyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IGxpbmVIZWlnaHRTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2xpbmVIZWlnaHQnKTtcbmNvbnN0IG1pbmltdW1Sb3dzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdtaW5pbXVtUm93cycpO1xuY29uc3QgdmFsdWVUcmFja3NDb250ZW50U3ltYm9sID0gY3JlYXRlU3ltYm9sKCd2YWx1ZVRyYWNrc0NvbnRlbnQnKTtcblxuY29uc3QgYmFzZSA9IFdyYXBwZWRTdGFuZGFyZEVsZW1lbnQud3JhcCgndGV4dGFyZWEnKS5jb21wb3NlKFxuICBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluLFxuICBHZW5lcmljTWl4aW5cbik7XG5cbi8qKlxuICogQSB0ZXh0IGFyZWEgdGhhdCBtYWtlcyBpdHNlbGYgYmlnIGVub3VnaCB0byBzaG93IGl0cyBjb250ZW50LlxuICpcbiAqIFtMaXZlIGRlbW9dKGh0dHA6Ly9iYXNpY3dlYmNvbXBvbmVudHMub3JnL2Jhc2ljLXdlYi1jb21wb25lbnRzL3BhY2thZ2VzL2Jhc2ljLWF1dG9zaXplLXRleHRhcmVhLylcbiAqXG4gKiBUaGlzIHRleHQgaW5wdXQgY29tcG9uZW50IGlzIHVzZWZ1bCBpbiBzaXR1YXRpb25zIHdoZXJlIHlvdSB3YW50IHRvIGFzayB0aGVcbiAqIHVzZXIgdG8gZW50ZXIgYXMgbXVjaCB0ZXh0IGFzIHRoZXkgd2FudCwgYnV0IGRvbid0IHdhbnQgdG8gdGFrZSB1cCBhIGxvdCBvZlxuICogcm9vbSBvbiB0aGUgcGFnZS5cbiAqXG4gKiBUaGUgY29tcG9uZW50IHdvcmtzIGJ5IGNvcHlpbmcgdGhlIHRleHQgdG8gYW4gaW52aXNpYmxlIGVsZW1lbnQgd2hpY2ggd2lsbFxuICogYXV0b21hdGljYWxseSBncm93IGluIHNpemU7IHRoZSBleHBhbmRpbmcgY29weSB3aWxsIGV4cGFuZCB0aGUgY29udGFpbmVyLFxuICogd2hpY2ggaW4gdHVybiB3aWxsIHZlcnRpY2FsbHkgc3RyZXRjaCB0aGUgdGV4dCBhcmVhIHRvIG1hdGNoLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGdlbmVyYWxseSBleHBvc2VzIGFsbCB0aGUgc2FtZSBhdHRyaWJ1dGVzL3Byb3BlcnRpZXMgYXMgYVxuICogc3RhbmRhcmQgSFRNTCBgPHRleHRhcmVhPmAuXG4gKlxuICogQGV4dGVuZHMgV3JhcHBlZFN0YW5kYXJkRWxlbWVudFxuICogQG1peGVzIEdlbmVyaWNNaXhpblxuICogQG1peGVzIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW5cbiAqL1xuY2xhc3MgQXV0b3NpemVUZXh0YXJlYSBleHRlbmRzIGJhc2Uge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmlubmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZXZlbnQgPT4ge1xuICAgICAgdmFsdWVDaGFuZ2VkKHRoaXMpO1xuICAgIH0pO1xuICAgIHRoaXMuaW5uZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBldmVudCA9PiB7XG4gICAgICBrZXlwcmVzcyh0aGlzLCBldmVudCk7XG4gICAgfSk7XG5cbiAgICAvLyBTZXQgZGVmYXVsdHMuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm1pbmltdW1Sb3dzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5taW5pbXVtUm93cyA9IHRoaXNbc3ltYm9scy5kZWZhdWx0c10ubWluaW11bVJvd3M7XG4gICAgfVxuXG4gICAgLy8gQSBzdGFuZGFyZCB0ZXh0YXJlYSBoYXMgaXRzIHZhbHVlIHRyYWNrIGl0cyB0ZXh0Q29udGVudCBieSBkZWZhdWx0LlxuICAgIC8vIFRoYXQgaXMsIGNoYW5nZXMgdG8gdGV4dENvbnRlbnQgdXBkYXRlIHRoZSB2YWx1ZS4gSG93ZXZlciwgaWYgYW4gYXR0ZW1wdFxuICAgIC8vIGlzIG1hZGUgdG8gY2hhbmdlIHRoZSB2YWx1ZSBkaXJlY3RseSwgdGhpcyBicmVha3MgdGhlIGF1dG9tYXRpYyB0cmFja2luZy5cbiAgICAvLyBGcm9tIHRoYXQgcG9pbnQgb24sIGNoYW5nZXMgdG8gdGV4dENvbnRlbnQgZG8gKm5vdCogdXBkYXRlIHRoZSB2YWx1ZS5cbiAgICB0aGlzW3ZhbHVlVHJhY2tzQ29udGVudFN5bWJvbF0gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgZWxlbWVudCBzdWNoIHRoYXQgdGhlIHRleHRhcmVhIGNhbiBleGFjdGx5IGNvbnRhaW4gaXRzIGNvbnRlbnQuXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbmV2ZXIgdGhlIHRleHQgY29udGVudCBjaGFuZ2VzLlxuICAgKi9cbiAgYXV0b1NpemUoKSB7XG4gICAgLy8gSWYgd2UgaGFkIHNwZWN1bGF0aXZlbHkgYWRkZWQgYW4gZXh0cmEgbGluZSBiZWNhdXNlIG9mIGFuIEVudGVyIGtleXByZXNzLFxuICAgIC8vIHdlIGNhbiBub3cgaGlkZSB0aGUgZXh0cmEgbGluZS5cbiAgICB0aGlzLiQuZXh0cmFMaW5lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAvLyBXZSByZXNpemUgYnkgY29weWluZyB0aGUgdGV4dGFyZWEgY29udGVudHMgdG8gdGhlIGVsZW1lbnQgaXRzZWxmOyB0aGVcbiAgICAvLyB0ZXh0IHdpbGwgdGhlbiBhcHBlYXIgKHZpYSA8c2xvdD4pIGluc2lkZSB0aGUgaW52aXNpYmxlIGRpdi4gSWZcbiAgICAvLyB3ZSd2ZSBzZXQgdGhpbmdzIHVwIGNvcnJlY3RseSwgdGhpcyBuZXcgY29udGVudCBzaG91bGQgdGFrZSB1cCB0aGUgc2FtZVxuICAgIC8vIGFtb3VudCBvZiByb29tIGFzIHRoZSBzYW1lIHRleHQgaW4gdGhlIHRleHRhcmVhLiBVcGRhdGluZyB0aGUgZWxlbWVudCdzXG4gICAgLy8gY29udGVudCBhZGp1c3RzIHRoZSBlbGVtZW50J3Mgc2l6ZSwgd2hpY2ggaW4gdHVybiB3aWxsIG1ha2UgdGhlIHRleHRhcmVhXG4gICAgLy8gdGhlIGNvcnJlY3QgaGVpZ2h0LlxuICAgIHRoaXMuJC50ZXh0Q29weS50ZXh0Q29udGVudCA9IHRoaXMudmFsdWU7XG4gIH1cblxuICAvLyBOb3JtYWxseSB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgaXMgc2V0IGFuZCByZWFkIHRocm91Z2ggaXRzIHZhbHVlXG4gIC8vIGF0dHJpYnV0ZS4gQXMgYSBjb252ZW5pZW5jZSwgYW5kIHRvIG1pcnJvciBzdGFuZGFyZCB0ZXh0YXJlYSBiZWhhdmlvciwgaXRcbiAgLy8gaXMgcG9zc2libGUgdG8gc2V0IHRoZSBjb250ZW50IG9mIHRoZSB0ZXh0YXJlYSBieSBpbmNsdWRpbmcgdGV4dCBiZXR3ZWVuXG4gIC8vIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZy4gVGhpcyB3b3JrcyBvbmx5IGluIG9uZSBkaXJlY3Rpb246IHNldHRpbmcgdGhlXG4gIC8vIHRhZyBjb250ZW50IHVwZGF0ZXMgdGhlIHRleHRhcmVhLCBidXQgdXNlciBlZGl0cyBpbiB0aGUgdGV4dGFyZWEgYXJlIG5vdFxuICAvLyByZWZsZWN0ZWQgaW4gdGhlIHRhZyBjb250ZW50LiBXZSBjYXB0dXJlIHRoZSB2YWx1ZSBvZiB0aGUgaW5pdGlhbCB0ZXh0XG4gIC8vIGNvbnRlbnQgaW4gb3JkZXIgdG8gc2V0IHRoZSB2YWx1ZSBwcm9wZXJ0eSBkdXJpbmcgdGhlIGNyZWF0ZSBldmVudC5cbiAgLy8gVE9ETzogTm9ybWFsaXplIGluZGVudGF0aW9uIGluIHRoZSB0ZXh0IGNvbnRlbnQuIFVzZXJzIHdpbGwgb2Z0ZW4gd2FudCB0b1xuICAvLyBpbmRlbnQgdGhlIG1hcmt1cCBzbyB0aGF0IGl0IGxvb2tzIHByZXR0eS4gV2Ugc2hvdWxkIGRldGVjdCB0aGUgaW5kZW50YXRpb25cbiAgLy8gbGV2ZWwgYW5kIHJlbW92ZSBhbnkgaW5kZW50YXRpb24gd2hpdGVzcGFjZVxuICAvLyBUT0RPOiBDb25zaWRlciB1c2luZyBjb250ZW50IGlubmVySFRNTCByYXRoZXIgdGhhbiBwbGFpbiB0ZXh0LiBUaGUgbmF0aXZlXG4gIC8vIHRleHRhcmVhIGVsZW1lbnQgd2lsbCBpbmNsdWRlIEhUTUwsIG5vdCBqdXN0IHRoZSBzdHJpcHBlZCB0ZXh0LCBhcyBpbml0aWFsXG4gIC8vIHZhbHVlIHByb3BlcnR5IHRleHQuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgaW5pdGlhbGl6ZVdoZW5SZW5kZXJlZCh0aGlzKTtcbiAgfVxuXG4gIGNvbnRlbnRDaGFuZ2VkKCkge1xuICAgIGlmIChzdXBlci5jb250ZW50Q2hhbmdlZCkgeyBzdXBlci5jb250ZW50Q2hhbmdlZCgpOyB9XG4gICAgaWYgKHRoaXNbdmFsdWVUcmFja3NDb250ZW50U3ltYm9sXSkge1xuICAgICAgY29uc3QgdGV4dCA9IGdldFRleHRDb250ZW50KHRoaXMpO1xuICAgICAgdGhpcy5pbm5lci52YWx1ZSA9IHVuZXNjYXBlSHRtbCh0ZXh0KTtcbiAgICAgIHZhbHVlQ2hhbmdlZCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBnZXQgW3N5bWJvbHMuZGVmYXVsdHNdKCkge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gc3VwZXJbc3ltYm9scy5kZWZhdWx0c10gfHwge307XG4gICAgZGVmYXVsdHMubWluaW11bVJvd3MgPSAxO1xuICAgIHJldHVybiBkZWZhdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBtaW5pbXVtIG51bWJlciBvZiByb3dzIHNob3duLiBUaGlzIGlzIHNpbWlsYXIgdG8gdGhlIHJvd3NcbiAgICogYXR0cmlidXRlIG9uIGEgc3RhbmRhcmQgdGV4dGFyZWEsIGJ1dCBiZWNhdXNlIHRoaXMgZWxlbWVudCBjYW4gZ3JvdywgaXNcbiAgICogZXhwcmVzc2VkIGFzIGEgbWluaW11bSByYXRoZXIgdGhhbiBhIGZpeGVkIG51bWJlci5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBwcm9wZXJ0eSBpcyAxLCBzbyB3aGVuIGVtcHR5LCB0aGUgdGV4dCBhcmVhIHdpbGwgYmUgYVxuICAgKiBzaW5nbGUgbGluZSB0YWxsLiBUaGF0J3MgZWZmaWNpZW50IGluIHRlcm1zIG9mIHRoZSBzcGFjZSBpdCBjb25zdW1lcywgYnV0XG4gICAqIHVudGlsIHRoZSB1c2VyIGludGVyYWN0cyB3aXRoIHRoZSBlbGVtZW50LCB0aGV5IG1heSBub3QgcmVhbGl6ZSB0aGV5IGNhblxuICAgKiBlbnRlciBtdWx0aXBsZSBsaW5lcyBvZiB0ZXh0LiBTZXR0aW5nIHRoZSBwcm9wZXJ0eSB0byBhIHZhbHVlIGhpZ2hlciB0aGFuIDFcbiAgICogd2lsbCBzaWduYWwgdG8gdGhlIHVzZXIgdGhhdCB0aGV5IGNhbiBlbnRlciBtdWx0aXBsZSBsaW5lcyBvZiBhIHRleHQuXG4gICAqXG4gICAqIEJ5IHNldHRpbmcgdGhpcyBwcm9wZXJ0eSwgeW91IGNhbiBhbHNvIGNvbW11bmljYXRlIHRvIHRoZSB1c2VyIHNvbWUgc2Vuc2VcbiAgICogb2YgaG93IG11Y2ggdGV4dCB5b3UncmUgZXhwZWN0aW5nIHRoZW0gdG8gcHJvdmlkZS4gRm9yIGV4YW1wbGUsIG9uIGFcbiAgICogZmVlZGJhY2sgZm9ybSwgYXNraW5nIHRoZSB1c2VyIHRvIGVudGVyIHRoZWlyIGZlZWRiYWNrIGluIGEgc2luZ2xlLWxpbmVcbiAgICogdGV4dCBib3ggaW1wbGllcyB5b3UgZG9uJ3QgcmVhbGx5IHdhbnQgdGhlbSB0byBlbnRlciBtdWNoIHRleHQg4oCUIGV2ZW4gaWZcbiAgICogdGhlIHRleHQgYm94IHdpbGwgZ3JvdyB3aGVuIHRoZXkgdHlwZS4gQnkgc2V0dGluZyB0aGlzIHRvIGEgdmFsdWUgbGlrZSxcbiAgICogc2F5LCAxMCByb3dzLCB5b3UgY2FuIHNpZ25hbCB0aGF0IHlvdSdyZSBmdWxseSBleHBlY3RpbmcgdGhlbSB0byBlbnRlciBtb3JlXG4gICAqIHRleHQuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldCBtaW5pbXVtUm93cygpIHtcbiAgICByZXR1cm4gdGhpc1ttaW5pbXVtUm93c1N5bWJvbF07XG4gIH1cbiAgc2V0IG1pbmltdW1Sb3dzKHZhbHVlKSB7XG4gICAgdGhpc1ttaW5pbXVtUm93c1N5bWJvbF0gPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgaWYgKHRoaXNbbGluZUhlaWdodFN5bWJvbF0pIHtcbiAgICAgIHNldE1pbmltdW1IZWlnaHQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IFtzeW1ib2xzLnRlbXBsYXRlXSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cblxuICAgICAgI2F1dG9TaXplQ29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICogRW5zdXJlIGJvdGggdGhlIHRleHQgYXJlYSBhbmQgY29weSBlbmQgdXAgd2l0aCB0aGUgZWxlbWVudCdzIG93biBmb250XG4gICAgICAgKiBtZXRyaWNzLCBzbyB0aGF0IHRleHQgd2lsbCBsYXkgb3V0IHRoZSBzYW1lIGluIGJvdGggb2YgdGhlbS5cbiAgICAgICAqL1xuICAgICAgI2lubmVyLFxuICAgICAgI2NvcHlDb250YWluZXIge1xuICAgICAgICAtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xuICAgICAgICBmb250LXNpemU6IGluaGVyaXQ7XG4gICAgICAgIGZvbnQtc3R5bGU6IGluaGVyaXQ7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBpbmhlcml0O1xuICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgfVxuXG4gICAgICAjaW5uZXIge1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgcmVzaXplOiBub25lO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBAYXBwbHkoLS10ZXh0YXJlYSk7XG4gICAgICB9XG5cbiAgICAgICNjb3B5Q29udGFpbmVyIHtcbiAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgICAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7IC8qIFNvIGxpbmVzIHdyYXAgKi9cbiAgICAgICAgd29yZC13cmFwOiBicmVhay13b3JkOyAvKiBTbyB3ZSBicmVhayBhdCB3b3JkIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAqL1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lciB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICB9XG4gICAgICA8L3N0eWxlPlxuXG4gICAgICA8IS0tXG4gICAgICBUaGUgaW52aXNpYmxlIGNvcHlDb250YWluZXIgY29udGFpbnMgYW4gZXh0cmFTcGFjZSBlbGVtZW50IHRoYXQgZW5zdXJlcyB0aGF0LFxuICAgICAgZXZlbiBpZiB0aGUgbGFzdCBsaW5lIG9mIHRoZSB0ZXh0YXJlYSBpcyBibGFuaywgdGhlcmUgd2lsbCBiZSBzb21ldGhpbmcgaW4gdGhlXG4gICAgICBsaW5lIHRoYXQgZm9yY2VzIHRoZSB0ZXh0IGNvcHkgdG8gZ3JvdyBieSBhIGxpbmUuIFRoaXMgZXh0cmEgc3BhY2UgaXMgYSB0aGluXG4gICAgICBzcGFjZSwgdG8gcmVkdWNlIHRoZSBhbW91bnQgYnkgd2hpY2ggdGhlIHRleHQgY29weSB3aWxsIHByZW1hdHVyZWx5IGdyb3cuXG5cbiAgICAgIFRoZSBjb3B5Q29udGFpbmVyIGFsc28gY29udGFpbnMgYW4gZXh0cmFMaW5lIGVsZW1lbnQgZXhpc3RzIHRvIGRlYWwgd2l0aCB0aGVcbiAgICAgIGZhY3QgdGhhdCwgaWYgdGhlIHVzZXIgcHJlc3NlcyB0aGUgRW50ZXIga2V5IGRvd24sIHRoZSB0ZXh0YXJlYSdzIGNvbnRlbnQgd2lsbFxuICAgICAgbW92ZSBiZWZvcmUgdGhlIGNvbXBsZXRlIHRleHQgaXMgYXZhaWxhYmxlLiBTZWUgbm90ZXMgYXQgX2tleXByZXNzLlxuXG4gICAgICBMYXN0bHksIHdlIHB1dCB0aGUgSFRNTCBjb250ZW50IGVsZW1lbnQgaW50byBhIHNlcGFyYXRlIGNvbnRhaW5lciBzbyB3ZSBjYW5cbiAgICAgIGhpZGUgaXQuIFdlIG5lZWQgdG8gaGF2ZSBhIGNvbnRlbnQgZWxlbWVudCBzb21ld2hlcmUgaW4gdGhlIHRlbXBsYXRlIHRvXG4gICAgICBjb252aW5jZSBQb2x5bWVyIHRoYXQgd2UgY2FyZSBhYm91dCB0aGUgY29udGVudCBpbiB0aGUgU2hhZHkgRE9NIGNhc2UgLS1cbiAgICAgIHdpdGhvdXQgdGhhdCBjb250ZW50IGVsZW1lbnQsIFNoYWR5IERPTSB3aWxsIGNvbmNsdWRlIHRoZSBlbGVtZW50IGRvZXNuJ3RcbiAgICAgIG5lZWQgaXRzIGxpZ2h0IERPTSBjb250ZW50LCBhbmQgd2lsbCB0aHJvdyBpdCBhd2F5LlxuICAgICAgLS0+XG4gICAgICA8ZGl2IGlkPVwiYXV0b1NpemVDb250YWluZXJcIj5cbiAgICAgICAgPHRleHRhcmVhIGlkPVwiaW5uZXJcIj48L3RleHRhcmVhPlxuICAgICAgICA8ZGl2IGlkPVwiY29weUNvbnRhaW5lclwiPjxzcGFuIGlkPVwidGV4dENvcHlcIj48L3NwYW4+PHNwYW4gaWQ9XCJleHRyYVNwYWNlXCI+JnRoaW5zcDs8L3NwYW4+PGRpdiBpZD1cImV4dHJhTGluZVwiPiZuYnNwOzwvZGl2PjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGlkPVwiY29udGVudENvbnRhaW5lclwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGN1cnJlbnRseSBzaG93biBpbiB0aGUgdGV4dGFyZWEuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgdGV4dCBzaG93biBpbiB0aGUgdGV4dGFyZWEgY2FuIGFsc28gYmUgdXBkYXRlZCBieSBjaGFuZ2luZ1xuICAgKiB0aGUgZWxlbWVudCdzIGlubmVySFRNTC90ZXh0Q29udGVudC4gSG93ZXZlciwgaWYgdGhlIHZhbHVlIHByb3BlcnR5IGlzXG4gICAqIGV4cGxpY2l0bHkgc2V0LCB0aGF0IHdpbGwgb3ZlcnJpZGUgdGhlIGlubmVySFRNTC90ZXh0Q29udGVudC5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbm5lci52YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUodGV4dCkge1xuICAgIC8vIEV4cGxpY2l0bHkgc2V0dGluZyB2YWx1ZSBicmVha3MgYXV0b21hdGljIHVwZGF0ZSBvZiB2YWx1ZSBmcm9tIGNvbnRlbnQuXG4gICAgdGhpc1t2YWx1ZVRyYWNrc0NvbnRlbnRTeW1ib2xdID0gZmFsc2U7XG4gICAgdGhpcy5pbm5lci52YWx1ZSA9IHRleHQ7XG4gICAgdmFsdWVDaGFuZ2VkKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgdHlwZXMgaW4gdGhlIHRleHRhcmVhLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQXV0b3NpemVUZXh0YXJlYVxuICAgKiBAZXZlbnQgY2hhbmdlXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50KGVsZW1lbnQpIHtcbiAgbGV0IHRleHQgPSBlbGVtZW50LmRpc3RyaWJ1dGVkVGV4dENvbnRlbnQ7XG5cbiAgLy8gVHJpbSB0aGUgdGV4dC5cbiAgLy8gVGhpcyBpcyBub24tc3RhbmRhcmQgdGV4dGFyZWEgYmVoYXZpb3IuIEEgc3RhbmRhcmQgdGV4dGFyZWEgd2lsbCB0cmltIHRoZVxuICAvLyBmaXJzdCBjaGFyYWN0ZXIgaWYgaXQncyBhIG5ld2xpbmUsIGJ1dCB0aGF0J3MgaXQuIEhvd2V2ZXIsIGF1dGhvcnMgd2lsbFxuICAvLyB3YW50IHRvIGJlIGFibGUgdG8gcGxhY2UgdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFncyBvbiB0aGVpciBvd24gbGluZXMuXG4gIC8vIFNvIGl0IHNlZW1zIG1vcmUgaGVscGZ1bCB0byB0cmltIHdoaXRlc3BhY2Ugb24gZWl0aGVyIHNpZGUuXG4gIHRleHQgPSB0ZXh0LnRyaW0oKTtcblxuICByZXR1cm4gdGV4dDtcbn1cblxuXG4vLyBTZXQgdXAgb25jZSB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiByZW5kZXJlZC5cbi8vXG4vLyBPbiBDaHJvbWUgKGFzIG9mIDEwLzIzLzE0KSBhdCBsZWFzdCwgaWYgYW4gaW5zdGFuY2UgaWYgdGhpcyBjb21wb25lbnQgaXNcbi8vIGFkZGVkIGR5bmFtaWNhbGx5LCBpdHMgYXR0YWNoZWQgaGFuZGxlciBtYXkgdHJpZ2dlciBiZWZvcmUgaXRzIGJlZW5cbi8vIHJlbmRlcmVkLiBUaGF0IHdvdWxkIGNhdXNlIG91ciBsYXlvdXQgY2FsY3VsYXRpb25zIHRvIGJlIGluY29ycmVjdC5cbi8vXG5mdW5jdGlvbiBpbml0aWFsaXplV2hlblJlbmRlcmVkKGVsZW1lbnQpIHtcblxuICAvLyBJZiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIHJlbmRlcmVkLCBvdXIgaGVpZ2h0IHNob3VsZCBiZSBub256ZXJvLlxuICBpZiAoZWxlbWVudC5jbGllbnRIZWlnaHQgPT09IDApIHtcbiAgICAvLyBOb3QgcmVuZGVyZWQgeWV0OiB3YWl0IGEgYml0IGJlZm9yZSB0cnlpbmcgYWdhaW4uXG4gICAgc2V0VGltZW91dCgoKSA9PiBpbml0aWFsaXplV2hlblJlbmRlcmVkKGVsZW1lbnQpLCAxMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgd2UgcmVhY2ggdGhpcyBwb2ludCwgdGhlIGNvbXBvbmVudCdzIGVsZW1lbnRzIHNob3VsZCBieSBzdHlsZWQuXG5cbiAgLy8gRm9yIGF1dG8tc2l6aW5nIHRvIHdvcmssIHdlIG5lZWQgdGhlIHRleHQgY29weSB0byBoYXZlIHRoZSBzYW1lIGJvcmRlcixcbiAgLy8gcGFkZGluZywgYW5kIG90aGVyIHJlbGV2YW50IGNoYXJhY3RlcmlzdGljcyBhcyB0aGUgb3JpZ2luYWwgdGV4dCBhcmVhLlxuICAvLyBTaW5jZSB0aG9zZSBhc3BlY3RzIGFyZSBhZmZlY3RlZCBieSBDU1MsIHdlIGhhdmUgdG8gd2FpdCB1bnRpbCB0aGVcbiAgLy8gZWxlbWVudCBpcyBpbiB0aGUgZG9jdW1lbnQgYmVmb3JlIHdlIGNhbiB1cGRhdGUgdGhlIHRleHQgY29weS5cbiAgY29uc3QgdGV4dEJveFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LmlubmVyKTtcbiAgY29uc3QgY29weUNvbnRhaW5lclN0eWxlID0gZWxlbWVudC4kLmNvcHlDb250YWluZXIuc3R5bGU7XG4gIGNvcHlDb250YWluZXJTdHlsZS5ib3JkZXJCb3R0b21TdHlsZSAgPSB0ZXh0Qm94U3R5bGUuYm9yZGVyQm90dG9tU3R5bGU7XG4gIGNvcHlDb250YWluZXJTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCAgPSB0ZXh0Qm94U3R5bGUuYm9yZGVyQm90dG9tV2lkdGg7XG4gIGNvcHlDb250YWluZXJTdHlsZS5ib3JkZXJMZWZ0U3R5bGUgICAgPSB0ZXh0Qm94U3R5bGUuYm9yZGVyTGVmdFN0eWxlO1xuICBjb3B5Q29udGFpbmVyU3R5bGUuYm9yZGVyTGVmdFdpZHRoICAgID0gdGV4dEJveFN0eWxlLmJvcmRlckxlZnRXaWR0aDtcbiAgY29weUNvbnRhaW5lclN0eWxlLmJvcmRlclJpZ2h0U3R5bGUgICA9IHRleHRCb3hTdHlsZS5ib3JkZXJSaWdodFN0eWxlO1xuICBjb3B5Q29udGFpbmVyU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCAgID0gdGV4dEJveFN0eWxlLmJvcmRlclJpZ2h0V2lkdGg7XG4gIGNvcHlDb250YWluZXJTdHlsZS5ib3JkZXJUb3BTdHlsZSAgICAgPSB0ZXh0Qm94U3R5bGUuYm9yZGVyVG9wU3R5bGU7XG4gIGNvcHlDb250YWluZXJTdHlsZS5ib3JkZXJUb3BXaWR0aCAgICAgPSB0ZXh0Qm94U3R5bGUuYm9yZGVyVG9wV2lkdGg7XG4gIGNvcHlDb250YWluZXJTdHlsZS5wYWRkaW5nQm90dG9tICAgICAgPSB0ZXh0Qm94U3R5bGUucGFkZGluZ0JvdHRvbTtcbiAgY29weUNvbnRhaW5lclN0eWxlLnBhZGRpbmdMZWZ0ICAgICAgICA9IHRleHRCb3hTdHlsZS5wYWRkaW5nTGVmdDtcbiAgY29weUNvbnRhaW5lclN0eWxlLnBhZGRpbmdSaWdodCAgICAgICA9IHRleHRCb3hTdHlsZS5wYWRkaW5nUmlnaHQ7XG4gIGNvcHlDb250YWluZXJTdHlsZS5wYWRkaW5nVG9wICAgICAgICAgPSB0ZXh0Qm94U3R5bGUucGFkZGluZ1RvcDtcblxuICAvLyBVc2UgdGhlIGV4dHJhTGluZSBtZW1iZXIgdG8gZ2F1Z2UgdGhlIGV4cGVjdGVkIGhlaWdodCBvZiBhIHNpbmdsZSBsaW5lIG9mXG4gIC8vIHRleHQuIFdlIGNhbid0IHVzZSBsaW5lSGVpZ2h0LCBiZWNhdXNlIHRoYXQgY2FuIGJlIHJlcG9ydGVkIGFzIFwibm9ybWFsXCIsXG4gIC8vIGFuZCB3ZSB3YW50IHRvIGtub3cgdGhlIGFjdHVhbCBwaXhlbCBoZWlnaHQuXG4gIGVsZW1lbnQuJC5leHRyYUxpbmUuc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0JztcbiAgZWxlbWVudFtsaW5lSGVpZ2h0U3ltYm9sXSA9IGVsZW1lbnQuJC5leHRyYUxpbmUuY2xpZW50SGVpZ2h0O1xuXG4gIC8vIE5vdyB0aGF0IHdlIGtub3cgdGhlIGxpbmUgaGVpZ2h0LCB3ZSBjYW4gaGlkZSB0aGUgZXh0cmEgbGluZS5cbiAgZWxlbWVudC4kLmV4dHJhTGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gIC8vIFVzZSB0aGUgbGluZSBoZWlnaHQgaW4gY29uanVuY3Rpb24gd2l0aCBtaW5pbXVtUm93cyB0byBlc3RhYmxpc2ggdGhlXG4gIC8vIG92ZXJhbGwgbWluaW11bSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudC5cbiAgc2V0TWluaW11bUhlaWdodChlbGVtZW50KTtcbn1cblxuXG4vLyBTcGVjdWxhdGl2ZWx5IGFkZCBhIGxpbmUgdG8gb3VyIGNvcHkgb2YgdGhlIHRleHQuIFdlJ3JlIG5vdCBzdXJlIHdoYXQgdGhlXG4vLyBleGFjdCBlZmZlY3Qgb2YgdHlwaW5nIHRoaXMgY2hhcmFjdGVyIHdpbGwgYmUsIGFuZCBhdCB0aGlzIHBvaW50IGl0J3Mgbm90XG4vLyByZWZsZWN0ZWQgeWV0IGluIHRoZSB0ZXh0YXJlYSdzIGNvbnRlbnQuIFdlIHNwZWN1bGF0ZSB0aGF0IGl0IHdpbGwgYWRkIGFcbi8vIGxpbmUgdG8gdGhlIHRleHQgYW5kIHNpemUgYWNjb3JkaW5nbHkuIChPbmUgb3RoZXIgcG9zc2liaWxpdHkgaXMgdGhhdCB0aGVcbi8vIHVzZXIncyByZXBsYWNpbmcgYSBzZWxlY3RlZCBjaHVuayBvZiB0ZXh0IHdpdGggYSBuZXdsaW5lLikgSW4gYW55IGV2ZW50LFxuLy8gb25jZSB3ZSBnZXQgdGhlIGtleXVwIG9yIGNoYW5nZSBldmVudCwgd2UnbGwgbWFrZSBhbnkgZmluYWwgYWRqdXN0bWVudHMuXG4vL1xuLy8gVE9ETzogSWYgdGhlIHVzZXIgaG9sZHMgZG93biB0aGUgRW50ZXIga2V5LCB3ZSBjYW4gZ2V0IGEgYnVuY2ggb2Yga2V5cHJlc3Ncbi8vIGV2ZW50cyBiZWZvcmUgd2UgZ2V0IGtleXVwLiBUaGlzIGNhdXNlcyBmbGlja2VyLiBJbnN0ZWFkIG9mIHN1cHBvcnRpbmcgb25seVxuLy8gYSBzaW5nbGUgZXh0cmEgc3BlY3VsYXRpdmUgbGluZSwgd2Ugc2hvdWxkIGdyb3cgdGhlIHNwZWN1bGF0aXZlIGVsZW1lbnQgdG9cbi8vIGNvbnRhaW4gdGhlIG51bWJlciBvZiBFbnRlciBrZXlwcmVzc2VzIHdlJ3ZlIHJlY2VpdmVkLlxuZnVuY3Rpb24ga2V5cHJlc3MoZWxlbWVudCwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDEzIC8qIEVudGVyICovKSB7XG4gICAgZWxlbWVudC4kLmV4dHJhTGluZS5zdHlsZS5kaXNwbGF5ID0gJ2luaGVyaXQnO1xuICB9XG59XG5cblxuLy8gU2V0dGluZyB0aGUgbWluaW11bVJvd3MgYXR0cmlidXRlIHRyYW5zbGF0ZXMgaW50byBzZXR0aW5nIHRoZSBtaW5pbXVtXG4vLyBoZWlnaHQgb24gdGhlIHRleHQgY29weSBjb250YWluZXIuXG5mdW5jdGlvbiBzZXRNaW5pbXVtSGVpZ2h0KGVsZW1lbnQpIHtcbiAgY29uc3QgY29weUNvbnRhaW5lciA9IGVsZW1lbnQuJC5jb3B5Q29udGFpbmVyO1xuICBjb25zdCBvdXRlckhlaWdodCA9IGNvcHlDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29weUNvbnRhaW5lcik7XG4gIGNvbnN0IHBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdUb3ApO1xuICBjb25zdCBwYWRkaW5nQm90dG9tID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgY29uc3QgaW5uZXJIZWlnaHQgPSBjb3B5Q29udGFpbmVyLmNsaWVudEhlaWdodCAtIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tO1xuICBjb25zdCBib3JkZXJzUGx1c1BhZGRpbmcgPSBvdXRlckhlaWdodCAtIGlubmVySGVpZ2h0O1xuICBsZXQgbWluSGVpZ2h0ID0gKGVsZW1lbnQubWluaW11bVJvd3MgKiBlbGVtZW50W2xpbmVIZWlnaHRTeW1ib2xdKSArIGJvcmRlcnNQbHVzUGFkZGluZztcbiAgbWluSGVpZ2h0ID0gTWF0aC5jZWlsKG1pbkhlaWdodCk7XG4gIGNvcHlDb250YWluZXIuc3R5bGUubWluSGVpZ2h0ID0gbWluSGVpZ2h0ICsgJ3B4Jztcbn1cblxuXG5mdW5jdGlvbiB1bmVzY2FwZUh0bWwoaHRtbCkge1xuICByZXR1cm4gaHRtbFxuICAgIC5yZXBsYWNlKC8mYW1wOy9nLCAnJicpXG4gICAgLnJlcGxhY2UoLyZsdDsvZywgJzwnKVxuICAgIC5yZXBsYWNlKC8mZ3Q7L2csIFwiPlwiKVxuICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1xcXCInKVxuICAgIC5yZXBsYWNlKC8mIzAzOTsvZywgJ1xcJycpO1xufVxuXG5cbi8qXG4gKiBIYW5kbGUgYSBjaGFuZ2UgaW4gdGhlIGVsZW1lbnQncyB2YWx1ZSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gdmFsdWVDaGFuZ2VkKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5hdXRvU2l6ZSgpO1xuICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCd2YWx1ZS1jaGFuZ2VkJykpO1xufVxuXG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnYmFzaWMtYXV0b3NpemUtdGV4dGFyZWEnLCBBdXRvc2l6ZVRleHRhcmVhKTtcbmV4cG9ydCBkZWZhdWx0IEF1dG9zaXplVGV4dGFyZWE7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHRyYW5zcGlsZWQgdG8gY3JlYXRlIGFuIEVTNS1jb21wYXRpYmxlIGRpc3RyaWJ1dGlvbiBpbiB3aGljaFxuICogdGhlIHBhY2thZ2UncyBtYWluIGZlYXR1cmUocykgYXJlIGF2YWlsYWJsZSB2aWEgdGhlIHdpbmRvdy5CYXNpYyBnbG9iYWwuXG4gKiBJZiB5b3UncmUgYWxyZWFkeSB1c2luZyBFUzYgeW91cnNlbGYsIGlnbm9yZSB0aGlzIGZpbGUsIGFuZCBpbnN0ZWFkIGltcG9ydFxuICogdGhlIHNvdXJjZSBmaWxlKHMpIHlvdSB3YW50IGZyb20gdGhlIHNyYyBmb2xkZXIuXG4gKi9cblxuaW1wb3J0IENhcm91c2VsIGZyb20gJy4vc3JjL0Nhcm91c2VsJztcblxud2luZG93LkJhc2ljID0gd2luZG93LkJhc2ljIHx8IHt9O1xud2luZG93LkJhc2ljLkNhcm91c2VsID0gQ2Fyb3VzZWw7XG4iLCJpbXBvcnQgQW5pbWF0aW9uU3RhZ2UgZnJvbSAnLi4vLi4vYmFzaWMtYW5pbWF0aW9uLXN0YWdlL3NyYy9BbmltYXRpb25TdGFnZSc7XG5pbXBvcnQgSG9yaXpvbnRhbE5hdmlnYXRpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9Ib3Jpem9udGFsTmF2aWdhdGlvbk1peGluJztcblxuXG4vKipcbiAqIExldHMgdGhlIHVzZXIgbmF2aWdhdGUgbGF0ZXJhbGx5IHRocm91Z2ggYSBzZXF1ZW5jZSBvZiBjaGlsZCBlbGVtZW50cy5cbiAqXG4gKiBiYXNpYy1jYXJvdXNlbCBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgY2Fyb3VzZWwgdXNlciBpbnRlcmZhY2UgcGF0dGVybixcbiAqIGNvbW1vbmx5IHVzZWQgZm9yIG5hdmlnYXRpbmcgYmV0d2VlbiBpbWFnZXMsIHBhZ2VzLCBhbmQgb3RoZXIgZWxlbWVudHMuIFRoaXNcbiAqIHBhdHRlcm4gcHJlc2VudHMgdGhlIHVzZXIgd2l0aCBhIGxpbmVhciBzZXF1ZW5jZSBvZiBlbGVtZW50cywgb25seSBvbmUgb2ZcbiAqIHdoaWNoIGlzIHNob3duIGF0IGEgdGltZS4gVGhlIHVzZXIgY2FuIG5hdmlnYXRlIHRvIHRoZSBuZXh0L3ByZXZpb3VzIGVsZW1lbnRcbiAqIHdpdGggYSB2YXJpZXR5IG9mIGlucHV0IG1ldGhvZHMuXG4gKlxuICogW0xpdmUgZGVtb10oaHR0cDovL2Jhc2ljd2ViY29tcG9uZW50cy5vcmcvYmFzaWMtd2ViLWNvbXBvbmVudHMvcGFja2FnZXMvYmFzaWMtY2Fyb3VzZWwvKVxuICpcbiAqIFRoZSBhYm92ZSBkZW1vIGlzIGEgcGxhaW4gY2Fyb3VzZWwuIEl0J3Mgb2Z0ZW4gY29tYmluZWQsIGhvd2V2ZXIsIHdpdGhcbiAqIG1peGlucyBsaWtlXG4gKiBbQXJyb3dTZWxlY3Rpb25NaXhpbl0oLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9kb2NzL0Fycm93U2VsZWN0aW9uTWl4aW4ubWQpLFxuICogW1BhZ2VEb3RzTWl4aW5dKC4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvZG9jcy9QYWdlRG90c01peGluLm1kKSxcbiAqIFtUaW1lclNlbGVjdGlvbk1peGluXSguLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL2RvY3MvVGltZXJTZWxlY3Rpb25NaXhpbi5tZCkuXG4gKiBGb3IgZXhhbXBsZSwgeW91IGNhbiB2aWV3IGFcbiAqIFtkZW1vIHdpdGggYXJyb3dzIGFuZCBwYWdlIGRvdHNdKGh0dHA6Ly9iYXNpY3dlYmNvbXBvbmVudHMub3JnL2Jhc2ljLXdlYi1jb21wb25lbnRzL3BhY2thZ2VzL2RlbW9zL2Nhcm91c2VsLXdpdGgtYXJyb3dzLWFuZC1kb3RzLmh0bWwpLlxuICogU2VlIHRoZSBzcGVjaWZpYyBtaXhpbnMgZm9yIG90aGVyIGNhcm91c2VsIGRlbW9zLlxuICpcbiAqIGJhc2ljLWNhcm91c2VsIHVzZXMgaXRzIGNoaWxkcmVuIGFzIHRoZSBlbGVtZW50cyB0aGUgdXNlciB3aWxsIG5hdmlnYXRlXG4gKiB0aHJvdWdoLiBJbiBhIHR5cGljYWwgdXNlLCBhIGJhc2ljLWNhcm91c2VsIGNhbiBiZSB1c2VkIHRvIG5hdmlnYXRlIGJldHdlZW4gYVxuICogc2VxdWVuY2Ugb2YgaW1hZ2VzOlxuICpcbiAqICAgICA8YmFzaWMtY2Fyb3VzZWw+XG4gKiAgICAgICA8aW1nIHNyYz1cImltYWdlMS5qcGdcIj5cbiAqICAgICAgIDxpbWcgc3JjPVwiaW1hZ2UyLmpwZ1wiPlxuICogICAgICAgPGltZyBzcmM9XCJpbWFnZTMuanBnXCI+XG4gKiAgICAgPC9iYXNpYy1jYXJvdXNlbD5cbiAqXG4gKiBUaGUgY2hpbGQgZWxlbWVudHMgY2FuIGJlIG9mIGFueSB0eXBlIOKAlMKgdGhleSBhcmUgbm90IHJlc3RyaWN0ZWQgdG8gaW1hZ2VzLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGF0dGVtcHRzIHRvIG1lZXQgdGhlIFtHb2xkIFN0YW5kYXJkIGZvciB3ZWIgY29tcG9uZW50c11cbiAqIChodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy9nb2xkLXN0YW5kYXJkL3dpa2kpIHNvIHRoYXQgaXQgaXMgZ2VuZXJhbGx5XG4gKiBhcyBmbGV4aWJsZSBhbmQgcm9idXN0IGFzIHN0YW5kYXJkIEhUTUwgZWxlbWVudHMuIEZvciBleGFtcGxlLCBpdCBtZWV0cyB0aGVcbiAqIFwiQ29udGVudCBDaGFuZ2VzXCIgY3JpdGVyaWE6IHRoZSBjYXJvdXNlbCB3aWxsIGFkYXB0IHRvIG5ldyBjaGlsZCBlbGVtZW50c1xuICogYWRkZWQgb3IgcmVtb3ZlZCBhdCBydW50aW1lLlxuICpcbiAqIEN1cnJlbnRseSwgdGhpcyBjb21wb25lbnQgZG9lcyBub3QgbWVldCB0aGUgR29sZCBTdGFuZGFyZCBjcml0ZXJpYSBcIlNpemUgdG9cbiAqIENvbnRlbnRcIi4gQXMgYSByZXN1bHQsIGZvciB0aGUgdGltZSBiZWluZywgKip5b3UgbXVzdCBtYW51YWxseSBzZXQgYSBzaXplIG9uXG4gKiB0aGlzIGNvbXBvbmVudCoqLiBUd28gYXBwcm9hY2hlcyBhcmUgdG86IDEpIHN0cmV0Y2ggdGhlIGNvbXBvbmVudCBhY3Jvc3NcbiAqIHdoYXRldmVyIHN1cmZhY2UgaXQgaXMgY29udGFpbmVkIHdpdGhpbiwgb3IgMikgc2V0IGl0IHRvIGJlIGxhcmdlciB0aGFuIHRoZVxuICogbGFyZ2VzdCBjaGlsZCBlbGVtZW50IHlvdSB3YW50IHRvIGRpc3BsYXkuIFRoZSBmb3JtZXIgYXBwcm9hY2ggaXMgbW9yZVxuICogY29tbW9uLCBhbmQgY2FuIGJlIGFjaGlldmVkIHdpdGggQ1NTIHN0eWxpbmcgc3VjaCBhczpcbiAqXG4gKiAgICAgaHRtbCB7XG4gKiAgICAgICBoZWlnaHQ6IDEwMCU7XG4gKiAgICAgfVxuICpcbiAqICAgICBib2R5IHtcbiAqICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAqICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gKiAgICAgICBoZWlnaHQ6IDEwMCU7XG4gKiAgICAgICBtYXJnaW46IDA7XG4gKiAgICAgfVxuICpcbiAqICAgICBiYXNpYy1jYXJvdXNlbCB7XG4gKiAgICAgICAtd2Via2l0LWZsZXg6IDE7XG4gKiAgICAgICBmbGV4OiAxO1xuICogICAgIH1cbiAqXG4gKiBUaGUgc3RhbmRhcmQgYmFzaWMtY2Fyb3VzZWwgY29tcG9uZW50IHN1cHBvcnRzIG5hdmlnYXRpb24gdmlhIHRoZSBmb2xsb3dpbmdcbiAqIGlucHV0IG1ldGhvZHM6XG4gKlxuICogKiBLZXlib2FyZC4gV2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGZvY3VzLCB0aGUgdXNlciBjYW4gcHJlc3MgTGVmdCwgUmlnaHQsXG4gKiAgIEhvbWUsIG9yIEVuZC4gVGhlc2UgbmF2aWdhdGUgdG8gdGhlIGV4cGVjdGVkIGVsZW1lbnQuXG4gKiAqIFRvdWNoLiBPbiBtb2JpbGUgYW5kIG90aGVyIHRvdWNoLWVuYWJsZWQgZGV2aWNlcywgdGhlIHVzZXIgY2FuIGRyYWcgbGVmdCBvclxuICogICByaWdodC5cbiAqICogVHJhY2twYWQuIFRoZSB1c2VyIGNhbiBzd2lwZSBsZWZ0IG9yIHJpZ2h0IG9uIGEgdHJhY2twYWQgdG8gbmF2aWdhdGUuXG4gKlxuICogQmVjYXVzZSBjYXJvdXNlbHMgYXJlIHVzZWQgaW4gYSB3aWRlIHZhcmlldHkgb2YgY2lyY3Vtc3RhbmNlcywgYnkgZGVmYXVsdFxuICogYmFzaWMtY2Fyb3VzZWwgcHJvdmlkZXMgYSBtaW5pbWFsIGFwcGVhcmFuY2UgYW5kIG5vIHNlcGFyYXRlbHkgaW50ZXJhY3RpdmVcbiAqIGVsZW1lbnRzIHN1Y2ggYXMgYXJyb3cgYnV0dG9ucyBvbiB0aGUgc2lkZSBvciBkb3RzIGFsb25nIHRoZSBib3R0b20uIFRob3NlXG4gKiBlbGVtZW50cyBjYW4gYmUgYWRkZWQgYnkgd3JhcHBpbmcgYSBDYXJvdXNlbCBpbiBvcHRpb25hbCBtaXhpbnM6XG4gKlxuICogKiBbQXJyb3dTZWxlY3Rpb25NaXhpbl0oLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9kb2NzL0Fycm93U2VsZWN0aW9uTWl4aW4ubWQpLlxuICogICBBZGRzIHByb21pbmVudCBsZWZ0IGFuZCByaWdodCBhcnJvdyBidXR0b25zIG9uIHRoZSBzaWRlIG9mIHRoZSBjYXJvdXNlbC5cbiAqICogW1BhZ2VEb3RzTWl4aW5dKC4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvZG9jcy9QYWdlRG90c01peGluLm1kKS5cbiAqICAgQWRkcyBhIHNlcmllcyBvZiBzbWFsbCBkb3RzIGJlbG93IHRoZSBjYXJvdXNlbCB0byBpbmRpY2F0ZSB0aGUgdXNlcidzXG4gKiAgIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlLlxuICogKiBbVGltZXJTZWxlY3Rpb25NaXhpbl0oLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9kb2NzL1RpbWVyU2VsZWN0aW9uTWl4aW4ubWQpLlxuICogICBBZHZhbmNlcyB0byB0aGUgbmV4dCBpdGVtIG9uIGEgdGltZXIuXG4gKiAqIFtUYWJTdHJpcE1peGluXSguLi9iYXNpYy10YWItc3RyaXApLlxuICogICBBZGRzIGEgc3RyaXAgb2YgdHJhZGl0aW9uYWwgdGFiIGJ1dHRvbnMuXG4gKlxuICogU2VlIHRob3NlIGNvbXBvbmVudHMgZm9yIG1vcmUgZGV0YWlscywgYnV0IGluIGdlbmVyYWwgeW91IGNhbiBjb25zdHJ1Y3QgYVxuICogY29tbW9uIGNhcm91c2VsIHdpdGggYm90aCBhcnJvdyBidXR0b25zIGFuZCBkb3RzIGxpa2Ugc286XG4gKlxuICogICAgIGNsYXNzIE15Q2Fyb3VzZWwgZXh0ZW5kc1xuICogICAgICAgICBBcnJvd1NlbGVjdGlvbk1peGluKFBhZ2VEb3RzTWl4aW4oQ2Fyb3VzZWwpKSB7fVxuICogICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbXktY2Fyb3VzZWwnLCBNeUNhcm91c2VsKTtcbiAqXG4gKiBGb3IgdW5pdmVyc2FsIGFjY2VzcywgYmFzaWMtY2Fyb3VzZWwgYXV0b21hdGljYWxseSBhZGRzIGEgdmFyaWV0eSBvZlxuICogW0FSSUFdKGh0dHA6Ly93d3cudzMub3JnL1dBSS9pbnRyby9hcmlhKSBwcm9wZXJ0aWVzIHRvIGl0c2VsZiBhbmQgdG8gY2hpbGRcbiAqIGVsZW1lbnRzLiBUaGlzIGhlbHBzIHVzZXJzIG5hdmlnYXRlIHRoZSBzZXF1ZW5jZSBvZiBlbGVtZW50cyBpbiB0aGUgY2Fyb3VzZWxcbiAqIHVzaW5nIGFzc2lzdGl2ZSB0ZWNobm9sb2dpZXMuXG4gKlxuICogQGV4dGVuZHMgQW5pbWF0aW9uU3RhZ2VcbiAqIEBtaXhlcyBIb3Jpem9udGFsTmF2aWdhdGlvbk1peGluXG4gKi9cbmNsYXNzIENhcm91c2VsIGV4dGVuZHMgQW5pbWF0aW9uU3RhZ2UuY29tcG9zZShcbiAgSG9yaXpvbnRhbE5hdmlnYXRpb25NaXhpblxuKSB7fVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2Jhc2ljLWNhcm91c2VsJywgQ2Fyb3VzZWwpO1xuZXhwb3J0IGRlZmF1bHQgQ2Fyb3VzZWw7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHRyYW5zcGlsZWQgdG8gY3JlYXRlIGFuIEVTNS1jb21wYXRpYmxlIGRpc3RyaWJ1dGlvbiBpbiB3aGljaFxuICogdGhlIHBhY2thZ2UncyBtYWluIGZlYXR1cmUocykgYXJlIGF2YWlsYWJsZSB2aWEgdGhlIHdpbmRvdy5CYXNpYyBnbG9iYWwuXG4gKiBJZiB5b3UncmUgYWxyZWFkeSB1c2luZyBFUzYgeW91cnNlbGYsIGlnbm9yZSB0aGlzIGZpbGUsIGFuZCBpbnN0ZWFkIGltcG9ydFxuICogdGhlIHNvdXJjZSBmaWxlKHMpIHlvdSB3YW50IGZyb20gdGhlIHNyYyBmb2xkZXIuXG4gKi9cblxuaW1wb3J0IENvbGxhcHNpYmxlUGFuZWwgZnJvbSAnLi9zcmMvQ29sbGFwc2libGVQYW5lbCc7XG5cbndpbmRvdy5CYXNpYyA9IHdpbmRvdy5CYXNpYyB8fCB7fTtcbndpbmRvdy5CYXNpYy5Db2xsYXBzaWJsZVBhbmVsID0gQ29sbGFwc2libGVQYW5lbDtcbiIsImltcG9ydCBFbGVtZW50QmFzZSBmcm9tICcuLi8uLi9iYXNpYy1lbGVtZW50LWJhc2Uvc3JjL0VsZW1lbnRCYXNlJztcbmltcG9ydCBPcGVuQ2xvc2VNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9PcGVuQ2xvc2VNaXhpbic7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zeW1ib2xzJztcblxuXG4vKipcbiAqIEEgcGFuZWwgd2hpY2ggY2FuIGJlIGV4cGFuZGVkL2NvbGxhcHNlZCB3aXRoIGFuIGFuaW1hdGVkIHRyYW5zaXRpb24uXG4gKlxuICogW0xpdmUgZGVtb10oaHR0cDovL2Jhc2ljd2ViY29tcG9uZW50cy5vcmcvYmFzaWMtd2ViLWNvbXBvbmVudHMvcGFja2FnZXMvYmFzaWMtY29sbGFwc2libGUtcGFuZWwvKVxuICpcbiAqIFRoaXMgY29tcG9uZW50IGNvbWJpbmVzIHRoZSBPcGVuQ2xvc2VNaXhpbiBtaXhpbiBhbmQgYSBzaW1wbGUgQ1NTIGhlaWdodFxuICogYW5pbWF0aW9uLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGhhbmRsZXMgb25seSB0aGUgZHV0aWVzIG9mIGNvbGxhcHNpbmcgYW5kIGV4cGFuZGluZy4gSXQgZG9lc1xuICogbm90IHByb3ZpZGUgYSB1c2VyIGludGVyZmFjZSBmb3IgdGhlIHVzZXIgdG8gdHJpZ2dlciB0aGUgY2hhbmdlIGluIHN0YXRlO1xuICogeW91IG11c3QgcHJvdmlkZSB0aGF0IHVzZXIgaW50ZXJmYWNlIHlvdXJzZWxmLlxuICpcbiAqIEBleHRlbmRzIEVsZW1lbnRCYXNlXG4gKiBAbWl4ZXMgT3BlbkNsb3NlTWl4aW5cbiAqL1xuY2xhc3MgQ29sbGFwc2libGVQYW5lbCBleHRlbmRzIE9wZW5DbG9zZU1peGluKEVsZW1lbnRCYXNlKSB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiQub3ZlcmZsb3cuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBoYXJkLWNvZGVkIGhlaWdodCB3ZSBhcHBsaWVkIGZvciB0aGUgdHJhbnNpdGlvbiBzbyB0aGF0XG4gICAgICAgIC8vIHRoZSBlbGVtZW50IHdpbGwgcmVmbG93IGNvcnJlY3RseSwgZS5nLiwgb24gd2luZG93IHJlc2l6ZS5cbiAgICAgICAgdGhpcy4kLm92ZXJmbG93LnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIHRoZSBhbmltYXRpb24gb25seSBwbGF5cyBvbmNlLiBGb3Igc29tZSByZWFzb24sIFNhZmFyaSB3aWxsIHNob3dcbiAgICAgIC8vIHRoZSBhbmltYXRpb24gdHdpY2Ugd2l0aG91dCB0aGlzIGxpbmUsIGV2ZW4gdGhvdWdoIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAgIC8vIGV4cGxpY2l0bHkgcmVtb3ZlcyB0aGlzIGNsYXNzIHdoZW4gaXQgc2V0cyB0aGUgb2xkIGhlaWdodC4gTmVpdGhlclxuICAgICAgLy8gQ2hyb21lIG5vciBGaXJlZm94IHNlZW0gdG8gbmVlZCB0aGlzIGxpbmUuXG4gICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3dUcmFuc2l0aW9uJyk7XG4gICAgfSk7XG4gIH1cblxuICByZW5kZXIoY2xvc2luZykge1xuICAgIHN1cGVyLnJlbmRlcihjbG9zaW5nKTtcblxuICAgIGNvbnN0IG5hdHVyYWxIZWlnaHQgPSB0aGlzLiQuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICBpZiAobmF0dXJhbEhlaWdodCA9PT0gMCkge1xuICAgICAgLy8gTW9zdCBsaWtlbHkgaGF2ZW4ndCBoYWQgYSBjaGFuY2UgdG8gcmVuZGVyIHlldC5cbiAgICAgIHRoaXMuJC5vdmVyZmxvdy5zdHlsZS5oZWlnaHQgPSBjbG9zaW5nID8gMCA6ICcnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdpdGhvdXQgYW5pbWF0aW5nLCBzZXQgc3RhcnRpbmcgaGVpZ2h0IG9mIHRyYW5zaXRpb24uXG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdzaG93VHJhbnNpdGlvbicpO1xuICAgIGNvbnN0IG9sZEhlaWdodCA9IGNsb3NpbmcgPyBuYXR1cmFsSGVpZ2h0IDogMDtcbiAgICB0aGlzLiQub3ZlcmZsb3cuc3R5bGUuaGVpZ2h0ID0gb2xkSGVpZ2h0ICsgJ3B4JztcblxuICAgIC8vIEZvcmNlIGEgcmVsYXlvdXQgc28gdGhhdCB0aGUgc3RhcnRpbmcgaGVpZ2h0IGlzIGFwcGxpZWQuXG4gICAgLy8gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmVhZGluZyBhIHByb3BlcnR5IGxpa2Ugb2Zmc2V0SGVpZ2h0LlxuICAgIHRoaXMuJC5vdmVyZmxvdy5vZmZzZXRIZWlnaHQ7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgLy8gVHVybiBhbmltYXRpb24gb24sIGFuZCBlbmRpbmcgaGVpZ2h0IG9mIHRyYW5zaXRpb24uXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzaG93VHJhbnNpdGlvbicpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IGNsb3NpbmcgPyAwIDogbmF0dXJhbEhlaWdodDtcbiAgICB0aGlzLiQub3ZlcmZsb3cuc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0ICsgJ3B4JztcbiAgfVxuXG4gIGdldCBbc3ltYm9scy50ZW1wbGF0ZV0oKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB9XG5cbiAgICAgIDpob3N0KC5zaG93VHJhbnNpdGlvbikgI292ZXJmbG93IHtcbiAgICAgICAgdHJhbnNpdGlvbjogaGVpZ2h0IDAuMnM7XG4gICAgICB9XG4gICAgICA8L3N0eWxlPlxuXG4gICAgICA8ZGl2IGlkPVwib3ZlcmZsb3dcIiByb2xlPVwibm9uZVwiPlxuICAgICAgICA8ZGl2IGlkPVwiY29udGFpbmVyXCIgcm9sZT1cIm5vbmVcIj5cbiAgICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgfVxuXG59XG5cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdiYXNpYy1jb2xsYXBzaWJsZS1wYW5lbCcsIENvbGxhcHNpYmxlUGFuZWwpO1xuZXhwb3J0IGRlZmF1bHQgQ29sbGFwc2libGVQYW5lbDtcbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgdHJhbnNwaWxlZCB0byBjcmVhdGUgYW4gRVM1LWNvbXBhdGlibGUgZGlzdHJpYnV0aW9uIGluIHdoaWNoXG4gKiB0aGUgcGFja2FnZSdzIG1haW4gZmVhdHVyZShzKSBhcmUgYXZhaWxhYmxlIHZpYSB0aGUgd2luZG93LkJhc2ljIGdsb2JhbC5cbiAqIElmIHlvdSdyZSBhbHJlYWR5IHVzaW5nIEVTNiB5b3Vyc2VsZiwgaWdub3JlIHRoaXMgZmlsZSwgYW5kIGluc3RlYWQgaW1wb3J0XG4gKiB0aGUgc291cmNlIGZpbGUocykgeW91IHdhbnQgZnJvbSB0aGUgc3JjIGZvbGRlci5cbiAqL1xuXG5pbXBvcnQgQXJyb3dTZWxlY3Rpb25NaXhpbiBmcm9tICcuL3NyYy9BcnJvd1NlbGVjdGlvbk1peGluJztcbmltcG9ydCBBdHRyaWJ1dGVNYXJzaGFsbGluZ01peGluIGZyb20gJy4vc3JjL0F0dHJpYnV0ZU1hcnNoYWxsaW5nTWl4aW4nO1xuaW1wb3J0IENsaWNrU2VsZWN0aW9uTWl4aW4gZnJvbSAnLi9zcmMvQ2xpY2tTZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgQ29tcG9zYWJsZU1peGluIGZyb20gJy4vc3JjL0NvbXBvc2FibGVNaXhpbic7XG5pbXBvcnQgQ29udGVudEl0ZW1zTWl4aW4gZnJvbSAnLi9zcmMvQ29udGVudEl0ZW1zTWl4aW4nO1xuaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuL3NyYy9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IERpcmVjdGlvblNlbGVjdGlvbk1peGluIGZyb20gJy4vc3JjL0RpcmVjdGlvblNlbGVjdGlvbk1peGluJztcbmltcG9ydCBEaXN0cmlidXRlZENoaWxkcmVuTWl4aW4gZnJvbSAnLi9zcmMvRGlzdHJpYnV0ZWRDaGlsZHJlbk1peGluJztcbmltcG9ydCBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluIGZyb20gJy4vc3JjL0Rpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4nO1xuaW1wb3J0IEdlbmVyaWNNaXhpbiBmcm9tICcuL3NyYy9HZW5lcmljTWl4aW4nO1xuaW1wb3J0IEtleWJvYXJkTWl4aW4gZnJvbSAnLi9zcmMvS2V5Ym9hcmRNaXhpbic7XG5pbXBvcnQgS2V5Ym9hcmREaXJlY3Rpb25NaXhpbiBmcm9tICcuL3NyYy9LZXlib2FyZERpcmVjdGlvbk1peGluJztcbmltcG9ydCBLZXlib2FyZFBhZ2VkU2VsZWN0aW9uTWl4aW4gZnJvbSAnLi9zcmMvS2V5Ym9hcmRQYWdlZFNlbGVjdGlvbk1peGluJztcbmltcG9ydCBLZXlib2FyZFByZWZpeFNlbGVjdGlvbk1peGluIGZyb20gJy4vc3JjL0tleWJvYXJkUHJlZml4U2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IG1pY3JvdGFzayBmcm9tICcuL3NyYy9taWNyb3Rhc2snO1xuaW1wb3J0IFBhZ2VEb3RzTWl4aW4gZnJvbSAnLi9zcmMvUGFnZURvdHNNaXhpbic7XG5pbXBvcnQgUGxheUNvbnRyb2xzTWl4aW4gZnJvbSAnLi9zcmMvUGxheUNvbnRyb2xzTWl4aW4nO1xuaW1wb3J0IHNhZmVBdHRyaWJ1dGVzIGZyb20gJy4vc3JjL3NhZmVBdHRyaWJ1dGVzJztcbmltcG9ydCBTZWxlY3Rpb25BbmltYXRpb25NaXhpbiBmcm9tICcuL3NyYy9TZWxlY3Rpb25BbmltYXRpb25NaXhpbic7XG5pbXBvcnQgU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluIGZyb20gJy4vc3JjL1NlbGVjdGlvbkFyaWFBY3RpdmVNaXhpbic7XG5pbXBvcnQgU2VsZWN0aW9uSGlnaGxpZ2h0TWl4aW4gZnJvbSAnLi9zcmMvU2VsZWN0aW9uSGlnaGxpZ2h0TWl4aW4nO1xuaW1wb3J0IFNlbGVjdGlvbkluVmlld01peGluIGZyb20gJy4vc3JjL1NlbGVjdGlvbkluVmlld01peGluJztcbmltcG9ydCBTaGFkb3dFbGVtZW50UmVmZXJlbmNlc01peGluIGZyb20gJy4vc3JjL1NoYWRvd0VsZW1lbnRSZWZlcmVuY2VzTWl4aW4nO1xuaW1wb3J0IFNoYWRvd1RlbXBsYXRlTWl4aW4gZnJvbSAnLi9zcmMvU2hhZG93VGVtcGxhdGVNaXhpbic7XG5pbXBvcnQgU2luZ2xlU2VsZWN0aW9uTWl4aW4gZnJvbSAnLi9zcmMvU2luZ2xlU2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IFN3aXBlRGlyZWN0aW9uTWl4aW4gZnJvbSAnLi9zcmMvU3dpcGVEaXJlY3Rpb25NaXhpbic7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuL3NyYy9zeW1ib2xzJztcbmltcG9ydCBUaW1lclNlbGVjdGlvbk1peGluIGZyb20gJy4vc3JjL1RpbWVyU2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IFRyYWNrcGFkRGlyZWN0aW9uTWl4aW4gZnJvbSAnLi9zcmMvVHJhY2twYWREaXJlY3Rpb25NaXhpbic7XG5cbndpbmRvdy5CYXNpYyA9IHdpbmRvdy5CYXNpYyB8fCB7fTtcblxud2luZG93LkJhc2ljLkFycm93U2VsZWN0aW9uTWl4aW4gPSBBcnJvd1NlbGVjdGlvbk1peGluO1xud2luZG93LkJhc2ljLkF0dHJpYnV0ZU1hcnNoYWxsaW5nTWl4aW4gPSBBdHRyaWJ1dGVNYXJzaGFsbGluZ01peGluO1xud2luZG93LkJhc2ljLkNsaWNrU2VsZWN0aW9uTWl4aW4gPSBDbGlja1NlbGVjdGlvbk1peGluO1xud2luZG93LkJhc2ljLkNvbXBvc2FibGVNaXhpbiA9IENvbXBvc2FibGVNaXhpbjtcbndpbmRvdy5CYXNpYy5Db250ZW50SXRlbXNNaXhpbiA9IENvbnRlbnRJdGVtc01peGluO1xud2luZG93LkJhc2ljLmNyZWF0ZVN5bWJvbCA9IGNyZWF0ZVN5bWJvbDtcbndpbmRvdy5CYXNpYy5EaXJlY3Rpb25TZWxlY3Rpb25NaXhpbiA9IERpcmVjdGlvblNlbGVjdGlvbk1peGluO1xud2luZG93LkJhc2ljLkRpc3RyaWJ1dGVkQ2hpbGRyZW5NaXhpbiA9IERpc3RyaWJ1dGVkQ2hpbGRyZW5NaXhpbjtcbndpbmRvdy5CYXNpYy5EaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluID0gRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbjtcbndpbmRvdy5CYXNpYy5nZW5lcmljID0gR2VuZXJpY01peGluO1xud2luZG93LkJhc2ljLktleWJvYXJkTWl4aW4gPSBLZXlib2FyZE1peGluO1xud2luZG93LkJhc2ljLktleWJvYXJkRGlyZWN0aW9uTWl4aW4gPSBLZXlib2FyZERpcmVjdGlvbk1peGluO1xud2luZG93LkJhc2ljLktleWJvYXJkUGFnZWRTZWxlY3Rpb25NaXhpbiA9IEtleWJvYXJkUGFnZWRTZWxlY3Rpb25NaXhpbjtcbndpbmRvdy5CYXNpYy5LZXlib2FyZFByZWZpeFNlbGVjdGlvbk1peGluID0gS2V5Ym9hcmRQcmVmaXhTZWxlY3Rpb25NaXhpbjtcbndpbmRvdy5CYXNpYy5taWNyb3Rhc2sgPSBtaWNyb3Rhc2s7XG53aW5kb3cuQmFzaWMuUGFnZURvdHNNaXhpbiA9IFBhZ2VEb3RzTWl4aW47XG53aW5kb3cuQmFzaWMuUGxheUNvbnRyb2xzTWl4aW4gPSBQbGF5Q29udHJvbHNNaXhpbjtcbndpbmRvdy5CYXNpYy5zYWZlQXR0cmlidXRlcyA9IHNhZmVBdHRyaWJ1dGVzO1xud2luZG93LkJhc2ljLlNlbGVjdGlvbkFuaW1hdGlvbk1peGluID0gU2VsZWN0aW9uQW5pbWF0aW9uTWl4aW47XG53aW5kb3cuQmFzaWMuU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluID0gU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluO1xud2luZG93LkJhc2ljLlNlbGVjdGlvbkhpZ2hsaWdodE1peGluID0gU2VsZWN0aW9uSGlnaGxpZ2h0TWl4aW47XG53aW5kb3cuQmFzaWMuU2VsZWN0aW9uSW5WaWV3TWl4aW4gPSBTZWxlY3Rpb25JblZpZXdNaXhpbjtcbndpbmRvdy5CYXNpYy5TaGFkb3dFbGVtZW50UmVmZXJlbmNlc01peGluID0gU2hhZG93RWxlbWVudFJlZmVyZW5jZXNNaXhpbjtcbndpbmRvdy5CYXNpYy5TaGFkb3dUZW1wbGF0ZU1peGluID0gU2hhZG93VGVtcGxhdGVNaXhpbjtcbndpbmRvdy5CYXNpYy5TaW5nbGVTZWxlY3Rpb25NaXhpbiA9IFNpbmdsZVNlbGVjdGlvbk1peGluO1xud2luZG93LkJhc2ljLlN3aXBlRGlyZWN0aW9uTWl4aW4gPSBTd2lwZURpcmVjdGlvbk1peGluO1xud2luZG93LkJhc2ljLnN5bWJvbHMgPSBzeW1ib2xzO1xud2luZG93LkJhc2ljLlRpbWVyU2VsZWN0aW9uTWl4aW4gPSBUaW1lclNlbGVjdGlvbk1peGluO1xud2luZG93LkJhc2ljLlRyYWNrcGFkRGlyZWN0aW9uTWl4aW4gPSBUcmFja3BhZERpcmVjdGlvbk1peGluO1xuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc3ltYm9scyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IG1vdXNlZG93bkxpc3RlbmVyU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdtb3VzZWRvd25MaXN0ZW5lcicpO1xuY29uc3QgbW91c2Vtb3ZlTGlzdGVuZXJTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ21vdXNlbW92ZUxpc3RlbmVyJyk7XG5jb25zdCBsYXN0TW91c2VYU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdsYXN0TW91c2VYJyk7XG5jb25zdCBsYXN0TW91c2VZU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdsYXN0TW91c2VZJyk7XG5jb25zdCBtb3VzZVRpbWVvdXRTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ21vdXNlVGltZW91dCcpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggQXJyb3dTZWxlY3Rpb24uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBUZW1wbGF0ZSBtaXhpbiB3aGljaCBhZGRzIHByb21pbmVudCBsZWZ0IGFuZCByaWdodCBhcnJvdyBidXR0b25zIHRvIGFcbiAgICogd3JhcHBlZCBjaGlsZCBzdWNoIGFzIGEgY2Fyb3VzZWwuXG4gICAqXG4gICAqIFlvdSBjYW4gc2VlIGFcbiAgICogW2xpdmUgZGVtb10oaHR0cDovL2Jhc2ljd2ViY29tcG9uZW50cy5vcmcvYmFzaWMtd2ViLWNvbXBvbmVudHMvcGFja2FnZXMvZGVtb3MvY2Fyb3VzZWwtd2l0aC1hcnJvd3MuaHRtbClcbiAgICogb2YgdGhpcyBtaXhpbiBhcHBsaWVkIHRvIGEgY2Fyb3VzZWwuXG4gICAqXG4gICAqIENsaWNraW5nIHRoZSBsZWZ0L3JpZ2h0IGJ1dHRvbnMgc2VsZWN0cyB0aGUgcHJldmlvdXMvbmV4dCBpdGVtLlxuICAgKlxuICAgKiBUeXBpY2FsIHVzYWdlOlxuICAgKlxuICAgKiAgICAgY2xhc3MgQ2Fyb3VzZWxXaXRoQXJyb3dzIGV4dGVuZHMgQXJyb3dTZWxlY3Rpb25NaXhpbihDYXJvdXNlbCkge31cbiAgICogICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnY2Fyb3VzZWwtd2l0aC1hcnJvd3MnLCBDYXJvdXNlbFdpdGhBcnJvd3MpO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgYXJyb3cgYnV0dG9ucyBhcmUgc2hvd24gb24gZGV2aWNlcyB3aXRoIGEgbW91c2Ugb3IgbW91c2UtbGlrZVxuICAgKiBwb2ludGluZyBkZXZpY2UuIFRoZXkgYXJlIG5vdCBzaG93biBvbiBhIHRvdWNoLWNhcGFibGUgZGV2aWNlIHVubGVzcyBtb3VzZVxuICAgKiBtb3ZlbWVudCBpcyBkZXRlY3RlZC4gVG8gY2F1c2UgdGhlIGJ1dHRvbnMgdG8gYWx3YXlzIGFwcGVhciwgYXBwbHkgdGhlXG4gICAqICdzaG93QXJyb3dzJyBDU1MgY2xhc3MuXG4gICAqL1xuICBjbGFzcyBBcnJvd1NlbGVjdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICB0aGlzLiQuYnV0dG9uTGVmdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kLmJ1dHRvblJpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnNlbGVjdE5leHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIGFzc3VtZUJ1dHRvbkZvY3VzKHRoaXMsIHRoaXMuJC5idXR0b25MZWZ0KTtcbiAgICAgIGFzc3VtZUJ1dHRvbkZvY3VzKHRoaXMsIHRoaXMuJC5idXR0b25SaWdodCk7XG4gICAgfVxuXG4gICAgZ2V0IGNhblNlbGVjdE5leHQoKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY2FuU2VsZWN0TmV4dDtcbiAgICB9XG4gICAgc2V0IGNhblNlbGVjdE5leHQoY2FuU2VsZWN0TmV4dCkge1xuICAgICAgaWYgKCdjYW5TZWxlY3ROZXh0JyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5jYW5TZWxlY3ROZXh0ID0gY2FuU2VsZWN0TmV4dDsgfVxuICAgICAgdGhpcy4kLmJ1dHRvblJpZ2h0LmRpc2FibGVkID0gIWNhblNlbGVjdE5leHQ7XG4gICAgfVxuXG4gICAgZ2V0IGNhblNlbGVjdFByZXZpb3VzKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLmNhblNlbGVjdFByZXZpb3VzO1xuICAgIH1cbiAgICBzZXQgY2FuU2VsZWN0UHJldmlvdXMoY2FuU2VsZWN0UHJldmlvdXMpIHtcbiAgICAgIGlmICgnY2FuU2VsZWN0UHJldmlvdXMnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLmNhblNlbGVjdFByZXZpb3VzID0gY2FuU2VsZWN0UHJldmlvdXM7IH1cbiAgICAgIHRoaXMuJC5idXR0b25MZWZ0LmRpc2FibGVkID0gIWNhblNlbGVjdFByZXZpb3VzO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgaWYgKHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKSB7IHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7IH1cblxuICAgICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucygnc2hvd0Fycm93cycpKSB7XG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHdlIHNob3VsZCBzaG93IGFycm93IGJ1dHRvbnMgb3Igbm90LlxuICAgICAgICBpZiAoZGV2aWNlU3VwcG9ydHNUb3VjaCgpKSB7XG4gICAgICAgICAgLy8gQSB0b3VjaCBkZXZpY2UgbWlnaHQgYWxzbyBzdXBwb3J0IGEgbW91c2UsIGJ1dCB3ZSBjYW4ndCBrbm93IHdoZXRoZXJcbiAgICAgICAgICAvLyB0aGVyZSdzIGFjdHVhbGx5IGEgbW91c2UgdW50aWwgd2UgaGVhciBmcm9tIGl0LlxuICAgICAgICAgIGxpc3RlbkZvck1vdXNlKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSBkZXZpY2UgZG9lc24ndCBzdXBwb3J0IHRvdWNoLCBzbyBhc3N1bWUgaXQgaGFzIGEgbW91c2UuXG4gICAgICAgICAgc2hvd0Fycm93cyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMubmF2aWdhdGlvbkF4aXMgPSAnaG9yaXpvbnRhbCc7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBUaGUgdGVtcGxhdGUgdXNlcyB0aGUgY2hldnJvbi1sZWZ0IGFuZCBjaGV2cm9uLXJpZ2h0IFNWRyBpY29ucyBmcm9tXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXJFbGVtZW50cy9pcm9uLWljb25zL2Jsb2IvbWFzdGVyL2lyb24taWNvbnMuaHRtbC5cbiAgICAgKi9cbiAgICBnZXQgW3N5bWJvbHMudGVtcGxhdGVdKCkge1xuICAgICAgY29uc3QgYmFzZVRlbXBsYXRlID0gc3VwZXJbc3ltYm9scy50ZW1wbGF0ZV0gfHwgJyc7XG4gICAgICByZXR1cm4gYFxuICAgICAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICAtd2Via2l0LWFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIC13ZWJraXQtZmxleDogMTtcbiAgICAgICAgICBmbGV4OiAxO1xuICAgICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIH1cblxuICAgICAgICAjYXJyb3dOYXZpZ2F0aW9uQ29udGFpbmVyIHtcbiAgICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAtd2Via2l0LWZsZXg6IDE7XG4gICAgICAgICAgZmxleDogMTtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cblxuICAgICAgICAubmF2aWdhdGlvbkJ1dHRvbiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xuICAgICAgICAgIGZpbGw6IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgICAgICBvdXRsaW5lOiBub25lOyAvKiBSRVZJRVc6IEFjY2Vzc2liaWxpdHkgc2hvdWxkIGJlIHByb3ZpZGVkIGJ5IG90aGVyIGVsZW1lbnRzLiAqL1xuICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAxcztcbiAgICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLm5hdmlnYXRpb25CdXR0b246aG92ZXI6bm90KDpkaXNhYmxlZCkge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC41KTtcbiAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjgpO1xuICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgfVxuICAgICAgICAubmF2aWdhdGlvbkJ1dHRvbjphY3RpdmU6bm90KDpkaXNhYmxlZCkge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjkpO1xuICAgICAgICB9XG4gICAgICAgIC5uYXZpZ2F0aW9uQnV0dG9uOmRpc2FibGVkIHtcbiAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgOmhvc3QoOm5vdCguc2hvd0Fycm93cykpIC5uYXZpZ2F0aW9uQnV0dG9uIHtcbiAgICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC5uYXZpZ2F0aW9uQnV0dG9uIC5pY29uIHtcbiAgICAgICAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgICAgICAgd2lkdGg6IDQ4cHg7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBPdmVybGF5IHZhcmlhbnQgKi9cbiAgICAgICAgOmhvc3QoLm92ZXJsYXlBcnJvd3MpIHtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QoLm92ZXJsYXlBcnJvd3MpIC5uYXZpZ2F0aW9uQnV0dG9uIHtcbiAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KTtcbiAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgIDpob3N0KC5vdmVybGF5QXJyb3dzKSAjYnV0dG9uTGVmdCB7XG4gICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdCgub3ZlcmxheUFycm93cykgI2J1dHRvblJpZ2h0IHtcbiAgICAgICAgICByaWdodDogMDtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdCgub3ZlcmxheUFycm93cykgLm5hdmlnYXRpb25CdXR0b246aG92ZXI6bm90KDpkaXNhYmxlZCkge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcbiAgICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuICAgICAgICB9XG4gICAgICAgIDpob3N0KC5vdmVybGF5QXJyb3dzKSAubmF2aWdhdGlvbkJ1dHRvbjphY3RpdmU6bm90KDpkaXNhYmxlZCkge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC40KTtcbiAgICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xuICAgICAgICB9XG4gICAgICAgIDpob3N0KC5vdmVybGF5QXJyb3dzKSAubmF2aWdhdGlvbkJ1dHRvbjpkaXNhYmxlZCB7XG4gICAgICAgICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcbiAgICAgICAgfVxuICAgICAgICA8L3N0eWxlPlxuXG4gICAgICAgIDwhLS1cbiAgICAgICAgQWNjZXNzaWJpbGl0eSBub3RlOiBzaW5jZSB0aGUgbmF2aWdhdGlvbiBvZmZlcmVkIGJ5IHRoZSBhcnJvdyBidXR0b25zIHNob3VsZFxuICAgICAgICBiZSByZWR1bmRhbnQgKHRoYXQgaXMsIHRoZXJlIHNob3VsZCBiZSBvdGhlciB3YXlzIG9mIG5hdmlnYXRpbmcgdGhlIGxpc3QpLFxuICAgICAgICB3ZSBtYXJrIHRoZSBidXR0b24gYXMgYXJpYS1oaWRkZW4gc28gdGhhdCBhc3Npc3RpdmUgZGV2aWNlcyBpZ25vcmUgdGhlbS5cbiAgICAgICAgLS0+XG4gICAgICAgIDxidXR0b24gaWQ9XCJidXR0b25MZWZ0XCIgY2xhc3M9XCJuYXZpZ2F0aW9uQnV0dG9uXCIgZGlzYWJsZWQgdGFiaW5kZXg9XCItMVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgICAgIDxzdmcgY2xhc3M9XCJpY29uXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCI+XG4gICAgICAgICAgICA8ZyBpZD1cImNoZXZyb24tbGVmdFwiPlxuICAgICAgICAgICAgICA8cGF0aCBkPVwiTTE1LjQxIDcuNDFMMTQgNmwtNiA2IDYgNiAxLjQxLTEuNDFMMTAuODMgMTJ6XCIvPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGRpdiBpZD1cImFycm93TmF2aWdhdGlvbkNvbnRhaW5lclwiIHJvbGU9XCJub25lXCI+XG4gICAgICAgICAgJHtiYXNlVGVtcGxhdGV9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8YnV0dG9uIGlkPVwiYnV0dG9uUmlnaHRcIiBjbGFzcz1cIm5hdmlnYXRpb25CdXR0b25cIiBkaXNhYmxlZCB0YWJpbmRleD1cIi0xXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICAgICAgPHN2ZyBjbGFzcz1cImljb25cIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIj5cbiAgICAgICAgICAgIDxnIGlkPVwiY2hldnJvbi1yaWdodFwiPlxuICAgICAgICAgICAgICA8cGF0aCBkPVwiTTEwIDZMOC41OSA3LjQxIDEzLjE3IDEybC00LjU4IDQuNTlMMTAgMThsNi02elwiLz5cbiAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICBgO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEFycm93U2VsZWN0aW9uO1xufTtcblxuXG4vKlxuICogQnkgZGVmYXVsdCwgYSBidXR0b24gd2lsbCBhbHdheXMgdGFrZSBmb2N1cyBvbiBtb3VzZWRvd24uIEZvciB0aGlzIGNvbXBvbmVudCxcbiAqIHdlIHdhbnQgdG8gb3ZlcnJpZGUgdGhhdCBiZWhhdmlvciwgc3VjaCB0aGF0IGEgbW91c2Vkb3duIG9uIGEgYnV0dG9uIGtlZXBzXG4gKiB0aGUgZm9jdXMgb24gdGhlIG91dGVyIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gYXNzdW1lQnV0dG9uRm9jdXMoZWxlbWVudCwgYnV0dG9uKSB7XG4gIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBldmVudCA9PiB7XG4gICAgLy8gR2l2ZW4gdGhlIG1haW4gZWxlbWVudCB0aGUgZm9jdXMgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGhhdmUgaXQuXG4gICAgZWxlbWVudC5mb2N1cygpO1xuICAgIC8vIFByZXZlbnQgdGhlIGRlZmF1bHQgZm9jdXMtb24tbW91c2Vkb3duIGJlaGF2aW9yLlxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZXZpY2VTdXBwb3J0c1RvdWNoKCkge1xuICByZXR1cm4gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8XG4gICAgICAod2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCk7XG59XG5cbi8vIFdlIHRyeSB0byBkZXRlY3QgdGhlIHByZXNlbmNlIG9mIGEgbW91c2UgYnkgbGlzdGVuaW5nIGZvciBtb3VzZW1vdmUgZXZlbnRzXG4vLyB3aGljaCBhcmUgKm5vdCogdGhlIHJlc3VsdCBvZiBhIG1vdXNlZG93bi4gT24gYSB0b3VjaCBkZXZpY2UsIGEgdGFwIG9uIHRoZVxuLy8gcGFnZSB3aWxsIGdlbmVyYXRlIGEgZmFrZSBtb3VzZW1vdmUsIGZvbGxvd2VkIGJ5IGEgbW91c2Vkb3duLiBXZSBkb24ndCB3YW50XG4vLyB0byByZXNwb25kIHRvIHRob3NlIGZha2UgbW91c2Vtb3ZlIGV2ZW50cy4gVG8gZGlzY3JpbWluYXRlIGJldHdlZW4gZmFrZSBhbmRcbi8vIHJlYWwgbW91c2Vtb3ZlIGV2ZW50cywgd2hlbiB3ZSBnZXQgYSBtb3VzZW1vdmUgZXZlbnQsIHdlIHdhaXQgZm9yIGEgYml0IHRvXG4vLyBzZWUgaWYgdGhlIHNhbWUgbG9jYXRpb24gaXMgcmVwb3J0ZWQgYXMgdGhlIGxvY2F0aW9uIG9mIGEgc3Vic2VxdWVudFxuLy8gbW91c2Vkb3duLlxuZnVuY3Rpb24gbGlzdGVuRm9yTW91c2UoZWxlbWVudCkge1xuXG4gIGVsZW1lbnRbbW91c2Vkb3duTGlzdGVuZXJTeW1ib2xdID0gZXZlbnQgPT4ge1xuICAgIGlmIChlbGVtZW50W21vdXNlVGltZW91dFN5bWJvbF0pIHtcbiAgICAgIGNsZWFyVGltZW91dChlbGVtZW50W21vdXNlVGltZW91dFN5bWJvbF0pO1xuICAgIH1cbiAgICBlbGVtZW50W2xhc3RNb3VzZVhTeW1ib2xdID0gZXZlbnQucGFnZVg7XG4gICAgZWxlbWVudFtsYXN0TW91c2VZU3ltYm9sXSA9IGV2ZW50LnBhZ2VZO1xuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZWxlbWVudFttb3VzZWRvd25MaXN0ZW5lclN5bWJvbF0pO1xuXG4gIGVsZW1lbnRbbW91c2Vtb3ZlTGlzdGVuZXJTeW1ib2xdID0gZXZlbnQgPT4ge1xuICAgIC8vIFBvc3Rwb25lIGNoZWNraW5nIHRoZSBtb3VzZW1vdmUgbG9jYXRpb24gdG8gZ2l2ZSB0aGUgbW91c2Vkb3duIGV2ZW50IGFcbiAgICAvLyBjaGFuY2UgdG8gZmlyZS4gVGhlIDI1MCBtcyBkZWxheSBpcyBqdXN0IGd1ZXNzd29yazsgYSBzaG9ydGVyIGRlbGF5XG4gICAgLy8gZG9lc24ndCBzZWVtIHRvIHdvcmsuXG4gICAgZWxlbWVudFttb3VzZVRpbWVvdXRTeW1ib2xdID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoZWxlbWVudFtsYXN0TW91c2VYU3ltYm9sXSAhPSBudWxsICYmIGV2ZW50LnBhZ2VYICE9PSBlbGVtZW50W2xhc3RNb3VzZVhTeW1ib2xdIHx8XG4gICAgICAgICAgZWxlbWVudFtsYXN0TW91c2VZU3ltYm9sXSAhPSBudWxsICYmIGV2ZW50LnBhZ2VZICE9PSBlbGVtZW50W2xhc3RNb3VzZVlTeW1ib2xdKSB7XG4gICAgICAgIC8vIG1vdXNlbW92ZSBldmVudCB3YXMgYXQgYSBsb2NhdGlvbiBvdGhlciB0aGFuIHRoZSBsYXN0IG1vdXNlZG93bixcbiAgICAgICAgLy8gYW5kIGhlbmNlIG1vc3QgbGlrZWx5IGEgcmVhbCBtb3VzZW1vdmUgZXZlbnQuXG4gICAgICAgIG1vdXNlRGV0ZWN0ZWQoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50W2xhc3RNb3VzZVhTeW1ib2xdID0gZXZlbnQucGFnZVg7XG4gICAgICAgIGVsZW1lbnRbbGFzdE1vdXNlWVN5bWJvbF0gPSBldmVudC5wYWdlWTtcbiAgICAgIH1cbiAgICB9LCAyNTApO1xuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZWxlbWVudFttb3VzZW1vdmVMaXN0ZW5lclN5bWJvbF0pO1xufVxuXG5mdW5jdGlvbiBtb3VzZURldGVjdGVkKGVsZW1lbnQpIHtcbiAgc2hvd0Fycm93cyhlbGVtZW50KTtcblxuICAvLyBXZSBjYW4gc3RvcCBsaXN0ZW5pbmcgZm9yIG1vdXNlIGV2ZW50cyBub3cuXG4gIGlmIChlbGVtZW50W21vdXNlVGltZW91dFN5bWJvbF0pIHtcbiAgICBjbGVhclRpbWVvdXQoZWxlbWVudFttb3VzZVRpbWVvdXRTeW1ib2xdKTtcbiAgfVxuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZWxlbWVudFttb3VzZWRvd25MaXN0ZW5lclN5bWJvbF0pO1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZWxlbWVudFttb3VzZW1vdmVMaXN0ZW5lclN5bWJvbF0pO1xuICBlbGVtZW50W21vdXNlZG93bkxpc3RlbmVyU3ltYm9sXSA9IG51bGw7XG4gIGVsZW1lbnRbbW91c2Vtb3ZlTGlzdGVuZXJTeW1ib2xdID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2hvd0Fycm93cyhlbGVtZW50KSB7XG4gIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2hvd0Fycm93cycpO1xufVxuIiwiaW1wb3J0IHNhZmVBdHRyaWJ1dGVzIGZyb20gJy4vc2FmZUF0dHJpYnV0ZXMnO1xuXG5cbi8vIE1lbW9pemVkIG1hcHMgb2YgYXR0cmlidXRlIHRvIHByb3BlcnR5IG5hbWVzIGFuZCB2aWNlIHZlcnNhLlxuY29uc3QgYXR0cmlidXRlVG9Qcm9wZXJ0eU5hbWVzID0ge307XG5jb25zdCBwcm9wZXJ0eU5hbWVzVG9BdHRyaWJ1dGVzID0ge307XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBBdHRyaWJ1dGVNYXJzaGFsbGluZy4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIG1hcnNoYWxscyBhdHRyaWJ1dGVzIHRvIHByb3BlcnRpZXMgYW5kIHZpY2UgdmVyc2EuXG4gICAqXG4gICAqIElmIHlvdXIgY29tcG9uZW50IGV4cG9zZXMgYSBzZXR0ZXIgZm9yIGEgcHJvcGVydHksIGl0J3MgZ2VuZXJhbGx5IGEgZ29vZFxuICAgKiBpZGVhIHRvIGxldCBkZXZzIHVzaW5nIHlvdXIgY29tcG9uZW50IGJlIGFibGUgdG8gc2V0IHRoYXQgcHJvcGVydHkgaW4gSFRNTFxuICAgKiB2aWEgYW4gZWxlbWVudCBhdHRyaWJ1dGUuIFlvdSBjYW4gY29kZSB0aGF0IHlvdXJzZWxmIGJ5IHdyaXRpbmcgYW5cbiAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AsIG9yIHlvdSBjYW4gdXNlIHRoaXMgbWl4aW4gdG8gZ2V0IGEgZGVncmVlIG9mXG4gICAqIGF1dG9tYXRpYyBzdXBwb3J0LlxuICAgKlxuICAgKiBUaGlzIG1peGluIGltcGxlbWVudHMgYW4gYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgdGhhdCB3aWxsIGF0dGVtcHQgdG9cbiAgICogY29udmVydCBhIGNoYW5nZSBpbiBhbiBlbGVtZW50IGF0dHJpYnV0ZSBpbnRvIGEgY2FsbCB0byB0aGUgY29ycmVzcG9uZGluZ1xuICAgKiBwcm9wZXJ0eSBzZXR0ZXIuIEF0dHJpYnV0ZXMgdHlwaWNhbGx5IGZvbGxvdyBoeXBoZW5hdGVkIG5hbWVzIChcImZvby1iYXJcIiksXG4gICAqIHdoZXJlYXMgcHJvcGVydGllcyB0eXBpY2FsbHkgdXNlIGNhbWVsQ2FzZSBuYW1lcyAoXCJmb29CYXJcIikuIFRoaXMgbWl4aW5cbiAgICogcmVzcGVjdHMgdGhhdCBjb252ZW50aW9uLCBhdXRvbWF0aWNhbGx5IG1hcHBpbmcgdGhlIGh5cGhlbmF0ZWQgYXR0cmlidXRlXG4gICAqIG5hbWUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2FtZWxDYXNlIHByb3BlcnR5IG5hbWUuXG4gICAqXG4gICAqIEV4YW1wbGU6IFlvdSBkZWZpbmUgYSBjb21wb25lbnQgdXNpbmcgdGhpcyBtaXhpbjpcbiAgICpcbiAgICogICAgIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIEF0dHJpYnV0ZU1hcnNoYWxsaW5nTWl4aW4oSFRNTEVsZW1lbnQpIHtcbiAgICogICAgICAgZ2V0IGZvb0JhcigpIHsgcmV0dXJuIHRoaXMuX2Zvb0JhcjsgfVxuICAgKiAgICAgICBzZXQgZm9vQmFyKHZhbHVlKSB7IHRoaXMuX2Zvb0JhciA9IHZhbHVlOyB9XG4gICAqICAgICB9XG4gICAqICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ215LWVsZW1lbnQnLCBNeUVsZW1lbnQpO1xuICAgKlxuICAgKiBJZiBzb21lb25lIHRoZW4gaW5zdGFudGlhdGVzIHlvdXIgY29tcG9uZW50IGluIEhUTUw6XG4gICAqXG4gICAqICAgICA8bXktZWxlbWVudCBmb28tYmFyPVwiSGVsbG9cIj48L215LWVsZW1lbnQ+XG4gICAqXG4gICAqIFRoZW4sIGFmdGVyIHRoZSBlbGVtZW50IGhhcyBiZWVuIHVwZ3JhZGVkLCB0aGUgYGZvb0JhcmAgc2V0dGVyIHdpbGxcbiAgICogYXV0b21hdGljYWxseSBiZSBpbnZva2VkIHdpdGggdGhlIGluaXRpYWwgdmFsdWUgXCJIZWxsb1wiLlxuICAgKlxuICAgKiBGb3IgdGhlIHRpbWUgYmVpbmcsIHRoaXMgbWl4aW4gb25seSBzdXBwb3J0cyBzdHJpbmctdmFsdWVkIHByb3BlcnRpZXMuXG4gICAqIElmIHlvdSdkIGxpa2UgdG8gY29udmVydCBzdHJpbmcgYXR0cmlidXRlcyB0byBvdGhlciB0eXBlcyAobnVtYmVycyxcbiAgICogYm9vbGVhbnMpLCB5b3UgbmVlZCB0byBpbXBsZW1lbnQgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgeW91cnNlbGYuXG4gICAqL1xuICBjbGFzcyBBdHRyaWJ1dGVNYXJzaGFsbGluZyBleHRlbmRzIGJhc2Uge1xuXG4gICAgLypcbiAgICAgKiBIYW5kbGUgYSBjaGFuZ2UgdG8gdGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyaWJ1dGVOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgIGlmIChzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spIHsgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCk7IH1cbiAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGF0dHJpYnV0ZVRvUHJvcGVydHlOYW1lKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgLy8gSWYgdGhlIGF0dHJpYnV0ZSBuYW1lIGNvcnJlc3BvbmRzIHRvIGEgcHJvcGVydHkgbmFtZSwgc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICAgIC8vIElnbm9yZSBzdGFuZGFyZCBIVE1MRWxlbWVudCBwcm9wZXJ0aWVzIGhhbmRsZWQgYnkgdGhlIERPTS5cbiAgICAgIGlmIChwcm9wZXJ0eU5hbWUgaW4gdGhpcyAmJiAhKHByb3BlcnR5TmFtZSBpbiBIVE1MRWxlbWVudC5wcm90b3R5cGUpKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgaWYgKHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKSB7IHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7IH1cbiAgICAgIHNhZmVBdHRyaWJ1dGVzLmNvbm5lY3RlZCh0aGlzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzRm9yQ2xhc3ModGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0L3Vuc2V0IHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgaW5kaWNhdGVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBleGlzdHMgcHJpbWFyaWx5IHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbiBlbGVtZW50IHdhbnRzIHRvXG4gICAgICogc2V0IGEgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZSB0aGF0IHNob3VsZCBiZSByZWZsZWN0ZWQgYXMgYW4gYXR0cmlidXRlLiBBblxuICAgICAqIGltcG9ydGFudCBsaW1pdGF0aW9uIG9mIGN1c3RvbSBlbGVtZW50IGNvbnN0dXJjdG9ycyBpcyB0aGF0IHRoZXkgY2Fubm90XG4gICAgICogc2V0IGF0dHJpYnV0ZXMuIEEgY2FsbCB0byBgcmVmbGVjdEF0dHJpYnV0ZWAgZHVyaW5nIHRoZSBjb25zdHJ1Y3RvciB3aWxsXG4gICAgICogYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVsZW1lbnQgaXMgY29ubmVjdGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgLSBUaGUgbmFtZSBvZiB0aGUgKmF0dHJpYnV0ZSogKG5vdCBwcm9wZXJ0eSkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQuIElmIG51bGwsIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlZmxlY3RBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNhZmVBdHRyaWJ1dGVzLnNldEF0dHJpYnV0ZSh0aGlzLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQvdW5zZXQgdGhlIGNsYXNzIHdpdGggdGhlIGluZGljYXRlZCBuYW1lLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZXhpc3RzIHByaW1hcmlseSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYW4gZWxlbWVudCB3YW50cyB0b1xuICAgICAqIHNldCBhIGRlZmF1bHQgcHJvcGVydHkgdmFsdWUgdGhhdCBzaG91bGQgYmUgcmVmbGVjdGVkIGFzIGFzIGNsYXNzLiBBblxuICAgICAqIGltcG9ydGFudCBsaW1pdGF0aW9uIG9mIGN1c3RvbSBlbGVtZW50IGNvbnN0dXJjdG9ycyBpcyB0aGF0IHRoZXkgY2Fubm90XG4gICAgICogc2V0IGF0dHJpYnV0ZXMsIGluY2x1ZGluZyB0aGUgYGNsYXNzYCBhdHRyaWJ1dGUuIEEgY2FsbCB0b1xuICAgICAqIGByZWZsZWN0Q2xhc3NgIGR1cmluZyB0aGUgY29uc3RydWN0b3Igd2lsbCBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgZWxlbWVudFxuICAgICAqIGlzIGNvbm5lY3RlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNsYXNzIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgLSBUcnVlIHRvIHNldCB0aGUgY2xhc3MsIGZhbHNlIHRvIHJlbW92ZSBpdC5cbiAgICAgKi9cbiAgICByZWZsZWN0Q2xhc3MoY2xhc3NOYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNhZmVBdHRyaWJ1dGVzLnRvZ2dsZUNsYXNzKHRoaXMsIGNsYXNzTmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEF0dHJpYnV0ZU1hcnNoYWxsaW5nO1xufTtcblxuXG4vLyBDb252ZXJ0IGh5cGhlbmF0ZWQgZm9vLWJhciBhdHRyaWJ1dGUgbmFtZSB0byBjYW1lbCBjYXNlIGZvb0JhciBwcm9wZXJ0eSBuYW1lLlxuZnVuY3Rpb24gYXR0cmlidXRlVG9Qcm9wZXJ0eU5hbWUoYXR0cmlidXRlTmFtZSkge1xuICBsZXQgcHJvcGVydHlOYW1lID0gYXR0cmlidXRlVG9Qcm9wZXJ0eU5hbWVzW2F0dHJpYnV0ZU5hbWVdO1xuICBpZiAoIXByb3BlcnR5TmFtZSkge1xuICAgIC8vIENvbnZlcnQgYW5kIG1lbW9pemUuXG4gICAgY29uc3QgaHlwZW5SZWdFeCA9IC8tKFthLXpdKS9nO1xuICAgIHByb3BlcnR5TmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShoeXBlblJlZ0V4LFxuICAgICAgICBtYXRjaCA9PiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpKTtcbiAgICBhdHRyaWJ1dGVUb1Byb3BlcnR5TmFtZXNbYXR0cmlidXRlTmFtZV0gPSBwcm9wZXJ0eU5hbWU7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5TmFtZTtcbn1cblxuZnVuY3Rpb24gYXR0cmlidXRlc0ZvckNsYXNzKGNsYXNzRm4pIHtcblxuICAvLyBXZSB0cmVhdCB0aGUgZWxlbWVudCBiYXNlIGNsYXNzZXMgYXMgaWYgdGhleSBoYXZlIG5vIGF0dHJpYnV0ZXMsIHNpbmNlIHdlXG4gIC8vIGRvbid0IHdhbnQgdG8gcmVjZWl2ZSBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgZm9yIHRoZW0uXG4gIGlmIChjbGFzc0ZuID09PSBIVE1MRWxlbWVudCB8fCBjbGFzc0ZuID09PSBPYmplY3QpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyBHZXQgYXR0cmlidXRlcyBmb3IgcGFyZW50IGNsYXNzLlxuICBjb25zdCBiYXNlQ2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2xhc3NGbi5wcm90b3R5cGUpLmNvbnN0cnVjdG9yO1xuICBjb25zdCBiYXNlQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXNGb3JDbGFzcyhiYXNlQ2xhc3MpO1xuXG4gIC8vIEdldCBhdHRyaWJ1dGVzIGZvciB0aGlzIGNsYXNzLlxuICBjb25zdCBwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2xhc3NGbi5wcm90b3R5cGUpO1xuICBjb25zdCBzZXR0ZXJOYW1lcyA9IHByb3BlcnR5TmFtZXMuZmlsdGVyKHByb3BlcnR5TmFtZSA9PlxuICAgIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICBjbGFzc0ZuLnByb3RvdHlwZSwgcHJvcGVydHlOYW1lKS5zZXQgPT09ICdmdW5jdGlvbicpO1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc2V0dGVyTmFtZXMubWFwKHNldHRlck5hbWUgPT5cbiAgICAgIHByb3BlcnR5TmFtZVRvQXR0cmlidXRlKHNldHRlck5hbWUpKTtcblxuICAvLyBNZXJnZS5cbiAgY29uc3QgZGlmZiA9IGF0dHJpYnV0ZXMuZmlsdGVyKGF0dHJpYnV0ZSA9PlxuICAgICAgYmFzZUF0dHJpYnV0ZXMuaW5kZXhPZihhdHRyaWJ1dGUpIDwgMCk7XG4gIHJldHVybiBiYXNlQXR0cmlidXRlcy5jb25jYXQoZGlmZik7XG59XG5cbi8vIENvbnZlcnQgYSBjYW1lbCBjYXNlIGZvb0JhciBwcm9wZXJ0eSBuYW1lIHRvIGEgaHlwaGVuYXRlZCBmb28tYmFyIGF0dHJpYnV0ZS5cbmZ1bmN0aW9uIHByb3BlcnR5TmFtZVRvQXR0cmlidXRlKHByb3BlcnR5TmFtZSkge1xuICBsZXQgYXR0cmlidXRlID0gcHJvcGVydHlOYW1lc1RvQXR0cmlidXRlc1twcm9wZXJ0eU5hbWVdO1xuICBpZiAoIWF0dHJpYnV0ZSkge1xuICAgIC8vIENvbnZlcnQgYW5kIG1lbW9pemUuXG4gICAgY29uc3QgdXBwZXJjYXNlUmVnRXggPSAvKFtBLVpdKS9nO1xuICAgIGF0dHJpYnV0ZSA9IHByb3BlcnR5TmFtZS5yZXBsYWNlKHVwcGVyY2FzZVJlZ0V4LCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuICByZXR1cm4gYXR0cmlidXRlO1xufVxuIiwiLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBDbGlja1NlbGVjdGlvbi4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIG1hcHMgYSBjbGljayAoYWN0dWFsbHksIGEgbW91c2Vkb3duKSB0byBhIHNlbGVjdGlvbi5cbiAgICpcbiAgICogVGhpcyBzaW1wbGUgbWl4aW4gaXMgdXNlZnVsIGluIGxpc3QgYm94LWxpa2UgZWxlbWVudHMsIHdoZXJlIGEgY2xpY2sgb24gYVxuICAgKiBsaXN0IGl0ZW0gaW1wbGljaXRseSBzZWxlY3RzIGl0LlxuICAgKlxuICAgKiBUaGlzIG1peGluIGV4cGVjdHMgdGhlIGNvbXBvbmVudCB0byBwcm92aWRlIGFuIGBpdGVtc2AgcHJvcGVydHkuIFlvdSBjYW5cbiAgICogcHJvdmlkZSB0aGF0IHByb3BlcnR5IHlvdXJzZWxmLCBvciB1c2VcbiAgICogW0NvbnRlbnRJdGVtc01peGluXShDb250ZW50SXRlbXNNaXhpbi5tZCkuIFRoaXMgbWl4aW4gYWxzbyBleHBlY3RzIHRoZVxuICAgKiBjb21wb25lbnQgdG8gZGVmaW5lIGEgYHNlbGVjdGVkSW5kZXhgIHByb3BlcnR5LiBZb3UgY2FuIHByb3ZpZGUgdGhhdFxuICAgKiB5b3Vyc2VsZiwgb3IgdXNlIFtTaW5nbGVTZWxlY3Rpb25NaXhpbl0oU2luZ2xlU2VsZWN0aW9uTWl4aW4ubWQpLlxuICAgKi9cbiAgY2xhc3MgQ2xpY2tTZWxlY3Rpb24gZXh0ZW5kcyBiYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qXG4gICAgICAgKiBSRVZJRVc6IFdoaWNoIGV2ZW50IHNob3VsZCB3ZSBsaXN0ZW4gdG8gaGVyZT9cbiAgICAgICAqXG4gICAgICAgKiBUaGUgc3RhbmRhcmQgdXNlIGZvciB0aGlzIG1peGluIGlzIGluIGxpc3QgYm94ZXMuIExpc3QgYm94ZXMgZG9uJ3RcbiAgICAgICAqIGFwcGVhciB0byBiZSBjb25zaXN0ZW50IHdpdGggcmVnYXJkIHRvIHdoZXRoZXIgdGhleSBzZWxlY3Qgb24gbW91c2Vkb3duXG4gICAgICAgKiBvciBjbGljay9tb3VzZXVwLlxuICAgICAgICovXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGV2ZW50ID0+IHtcbiAgICAgICAgLy8gSEFDSzogSWYgdGhlIGl0ZW0gaXMgYSBidXR0b24sIHRoZSBldmVudCBzZWVtcyB0byBiZSByYWlzZWQgaW5cbiAgICAgICAgLy8gcGhhc2UgMiAoQVRfVEFSR0VUKSwgYnV0IHRoZSB0YXJnZXQgaXMgdGhlIGNvbXBvbmVudCwgbm90IGl0ZW0uXG4gICAgICAgIC8vIE5lZWQgdG8gaW52ZXNpZ2F0ZS5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0ID09PSB0aGlzID9cbiAgICAgICAgICBldmVudC5wYXRoWzBdIDpcbiAgICAgICAgICBldmVudC50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhPZkNvbnRhaW5pbmdJdGVtKHRoaXMsIHRhcmdldCk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgLy8gTm90ZTogV2UgZG9uJ3QgY2FsbCBwcmV2ZW50RGVmYXVsdCBoZXJlLiBUaGUgZGVmYXVsdCBiZWhhdmlvciBmb3JcbiAgICAgICAgICAvLyBtb3VzZWRvd24gaW5jbHVkZXMgc2V0dGluZyBrZXlib2FyZCBmb2N1cyBpZiB0aGUgZWxlbWVudCBkb2Vzbid0XG4gICAgICAgICAgLy8gYWxyZWFkeSBoYXZlIHRoZSBmb2N1cywgYW5kIHdlIHdhbnQgdG8gcHJlc2VydmUgdGhhdCBiZWhhdmlvci5cbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbi4gVGhpcyB3aWxsIHR5cGljYWxseSBiZSBoYW5kbGVkIGJ5IG90aGVyIG1peGlucy5cbiAgICBnZXQgc2VsZWN0ZWRJbmRleCgpIHtcbiAgICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEluZGV4O1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWRJbmRleChpbmRleCkge1xuICAgICAgaWYgKCdzZWxlY3RlZEluZGV4JyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3RlZEluZGV4ID0gaW5kZXg7IH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBDbGlja1NlbGVjdGlvbjtcbn07XG5cblxuLypcbiAqIFJldHVybiBpbmRleCBvZiB0aGUgZWxlbWVudCBpdGVtcyB0aGF0IGVpdGhlciBpcyBvciBjb250YWlucyB0aGUgaW5kaWNhdGVkXG4gKiB0YXJnZXQuIFJldHVybiAtMSBpZiBub3QgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGluZGV4T2ZDb250YWluaW5nSXRlbShlbGVtZW50LCB0YXJnZXQpIHtcbiAgY29uc3QgaXRlbXMgPSBlbGVtZW50Lml0ZW1zO1xuICBjb25zdCBpdGVtQ291bnQgPSBpdGVtcyA/IGl0ZW1zLmxlbmd0aCA6IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbUNvdW50OyBpKyspIHtcbiAgICBsZXQgaXRlbSA9IGl0ZW1zW2ldO1xuICAgIGlmIChpdGVtID09PSB0YXJnZXQgfHwgaXRlbS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIiwiLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBDb21wb3NhYmxlLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gdG8gbWFrZSBhIGNsYXNzIG1vcmUgZWFzaWx5IGNvbXBvc2FibGUgd2l0aCBvdGhlciBtaXhpbnMuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gY29udHJpYnV0ZXMgYSBgY29tcG9zZWAgbWV0aG9kIHRoYXQgYXBwbGllcyBhIHNldCBvZiBtaXhpblxuICAgKiBmdW5jdGlvbnMgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBuZXcgY2xhc3MuIFRoaXMgc3VnYXIgY2FuIG1ha2UgdGhlXG4gICAqIGFwcGxpY2F0aW9uIG9mIG1hbnkgbWl4aW5zIGF0IG9uY2UgZWFzaWVyIHRvIHJlYWQuXG4gICAqL1xuICBjbGFzcyBDb21wb3NhYmxlIGV4dGVuZHMgYmFzZSB7XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBhIHNldCBvZiBtaXhpbiBmdW5jdGlvbnMgb3IgbWl4aW4gb2JqZWN0cyB0byB0aGUgcHJlc2VudCBjbGFzcyBhbmRcbiAgICAgKiByZXR1cm4gdGhlIG5ldyBjbGFzcy5cbiAgICAgKlxuICAgICAqIEluc3RlYWQgb2Ygd3JpdGluZzpcbiAgICAgKlxuICAgICAqICAgICBsZXQgTXlDbGFzcyA9IE1peGluMShNaXhpbjIoTWl4aW4zKE1peGluNChNaXhpbjUoQmFzZUNsYXNzKSkpKSk7XG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHdyaXRlOlxuICAgICAqXG4gICAgICogICAgIGxldCBNeUNsYXNzID0gQ29tcG9zYWJsZU1peGluKEJhc2VDbGFzcykuY29tcG9zZShcbiAgICAgKiAgICAgICBNaXhpbjEsXG4gICAgICogICAgICAgTWl4aW4yLFxuICAgICAqICAgICAgIE1peGluMyxcbiAgICAgKiAgICAgICBNaXhpbjQsXG4gICAgICogICAgICAgTWl4aW41XG4gICAgICogICAgICk7XG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBhbHNvIHRha2UgbWl4aW4gb2JqZWN0cy4gQSBtaXhpbiBvYmplY3QgaXMganVzdCBhXG4gICAgICogc2hvcnRoYW5kIGZvciBhIG1peGluIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBzdWJjbGFzcyB3aXRoIHRoZSBnaXZlblxuICAgICAqIG1lbWJlcnMuIFRoZSBtaXhpbiBvYmplY3QncyBtZW1iZXJzIGFyZSAqbm90KiBjb3BpZWQgZGlyZWN0bHkgb250byB0aGVcbiAgICAgKiBwcm90b3R5cGUgb2YgdGhlIGJhc2UgY2xhc3MsIGFzIHdpdGggdHJhZGl0aW9uYWwgbWl4aW5zLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gcHJvdmlkaW5nIHN5bnRhY3RpYyBzdWdhciwgdGhpcyBtaXhpbiBjYW4gYmUgdXNlZCB0b1xuICAgICAqIGRlZmluZSBhIGNsYXNzIGluIEVTNSwgd2hpY2ggbGFja3MgRVM2J3MgYGNsYXNzYCBrZXl3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi5taXhpbnN9IG1peGlucyAtIEEgc2V0IG9mIG1peGluIGZ1bmN0aW9ucyBvciBvYmplY3RzIHRvIGFwcGx5LlxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wb3NlKC4uLm1peGlucykge1xuICAgICAgLy8gV2UgY3JlYXRlIGEgbmV3IHN1YmNsYXNzIGZvciBlYWNoIG1peGluIGluIHR1cm4uIFRoZSByZXN1bHQgYmVjb21lc1xuICAgICAgLy8gdGhlIGJhc2UgY2xhc3MgZXh0ZW5kZWQgYnkgYW55IHN1YnNlcXVlbnQgbWl4aW5zLiBJdCB0dXJucyBvdXQgdGhhdFxuICAgICAgLy8gd2UgY2FuIHVzZSBBcnJheS5yZWR1Y2UoKSB0byBjb25jaXNlbHkgZXhwcmVzcyB0aGlzLCB1c2luZyB0aGUgY3VycmVudFxuICAgICAgLy8gb2JqZWN0IGFzIHRoZSBzZWVkIGZvciByZWR1Y2UoKS5cbiAgICAgIHJldHVybiBtaXhpbnMucmVkdWNlKGNvbXBvc2VDbGFzcywgdGhpcyk7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQ29tcG9zYWJsZTtcbn07XG5cblxuLy8gUHJvcGVydGllcyBkZWZpbmVkIGJ5IE9iamVjdCB0aGF0IHdlIGRvbid0IHdhbnQgdG8gbWl4aW4uXG5jb25zdCBOT05fTUlYQUJMRV9PQkpFQ1RfUFJPUEVSVElFUyA9IFtcbiAgJ2NvbnN0cnVjdG9yJ1xuXTtcblxuLypcbiAqIEFwcGx5IHRoZSBtaXhpbiB0byB0aGUgZ2l2ZW4gYmFzZSBjbGFzcyB0byByZXR1cm4gYSBuZXcgY2xhc3MuXG4gKiBUaGUgbWl4aW4gY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbW9kaWZpZWQgY2xhc3MsIG9yIGFcbiAqIHBsYWluIG9iamVjdCB3aG9zZSBtZW1iZXJzIHdpbGwgYmUgY29waWVkIHRvIHRoZSBuZXcgY2xhc3MnIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gY29tcG9zZUNsYXNzKGJhc2UsIG1peGluKSB7XG4gIGlmICh0eXBlb2YgbWl4aW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBNaXhpbiBmdW5jdGlvblxuICAgIHJldHVybiBtaXhpbihiYXNlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBNaXhpbiBvYmplY3RcbiAgICBjbGFzcyBTdWJjbGFzcyBleHRlbmRzIGJhc2Uge31cbiAgICBjb3B5T3duUHJvcGVydGllcyhtaXhpbiwgU3ViY2xhc3MucHJvdG90eXBlLCBOT05fTUlYQUJMRV9PQkpFQ1RfUFJPUEVSVElFUyk7XG4gICAgcmV0dXJuIFN1YmNsYXNzO1xuICB9XG59XG5cblxuLypcbiAqIENvcHkgdGhlIGdpdmVuIHByb3BlcnRpZXMvbWV0aG9kcyB0byB0aGUgdGFyZ2V0LlxuICogUmV0dXJuIHRoZSB1cGRhdGVkIHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gY29weU93blByb3BlcnRpZXMoc291cmNlLCB0YXJnZXQsIGlnbm9yZVByb3BlcnR5TmFtZXMgPSBbXSkge1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgaWYgKGlnbm9yZVByb3BlcnR5TmFtZXMuaW5kZXhPZihuYW1lKSA8IDApIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgbmFtZSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuL2NyZWF0ZVN5bWJvbCc7XG5pbXBvcnQgdG9nZ2xlQ2xhc3MgZnJvbSAnLi90b2dnbGVDbGFzcyc7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuL3N5bWJvbHMnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBpdGVtc1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnaXRlbXMnKTtcbmNvbnN0IGl0ZW1Jbml0aWFsaXplZFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnaXRlbUluaXRpYWxpemVkJyk7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBDb250ZW50SXRlbXMuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYXBzIGNvbnRlbnQgc2VtYW50aWNzIChlbGVtZW50cykgdG8gbGlzdCBpdGVtIHNlbWFudGljcy5cbiAgICpcbiAgICogSXRlbXMgZGlmZmVyIGZyb20gZWxlbWVudCBjb250ZW50cyBpbiBzZXZlcmFsIHdheXM6XG4gICAqXG4gICAqICogVGhleSBhcmUgb2Z0ZW4gcmVmZXJlbmNlZCB2aWEgaW5kZXguXG4gICAqICogVGhleSBtYXkgaGF2ZSBhIHNlbGVjdGlvbiBzdGF0ZS5cbiAgICogKiBJdCdzIGNvbW1vbiB0byBkbyB3b3JrIHRvIGluaXRpYWxpemUgdGhlIGFwcGVhcmFuY2Ugb3Igc3RhdGUgb2YgYSBuZXdcbiAgICogICBpdGVtLlxuICAgKiAqIEF1eGlsaWFyeSBpbnZpc2libGUgY2hpbGQgZWxlbWVudHMgYXJlIGZpbHRlcmVkIG91dCBhbmQgbm90IGNvdW50ZWQgYXNcbiAgICogICBpdGVtcy4gQXV4aWxpYXJ5IGVsZW1lbnRzIGluY2x1ZGUgbGluaywgc2NyaXB0LCBzdHlsZSwgYW5kIHRlbXBsYXRlXG4gICAqICAgZWxlbWVudHMuIFRoaXMgZmlsdGVyaW5nIGVuc3VyZXMgdGhhdCB0aG9zZSBhdXhpbGlhcnkgZWxlbWVudHMgY2FuIGJlXG4gICAqICAgdXNlZCBpbiBtYXJrdXAgaW5zaWRlIG9mIGEgbGlzdCB3aXRob3V0IGJlaW5nIHRyZWF0ZWQgYXMgbGlzdCBpdGVtcy5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBleHBlY3RzIGEgY29tcG9uZW50IHRvIHByb3ZpZGUgYSBgY29udGVudGAgcHJvcGVydHkgcmV0dXJuaW5nIGFcbiAgICogcmF3IHNldCBvZiBlbGVtZW50cy4gWW91IGNhbiBwcm92aWRlIHRoYXQgeW91cnNlbGYsIG9yIHVzZVxuICAgKiBbRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbl0oRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbi5tZCkuXG4gICAqXG4gICAqIFRoZSBtb3N0IGNvbW1vbmx5IHJlZmVyZW5jZWQgcHJvcGVydHkgZGVmaW5lZCBieSB0aGlzIG1peGluIGlzIHRoZSBgaXRlbXNgXG4gICAqIHByb3BlcnR5LiBUbyBhdm9pZCBoYXZpbmcgdG8gZG8gd29yayBlYWNoIHRpbWUgdGhhdCBwcm9wZXJ0eSBpcyByZXF1ZXN0ZWQsXG4gICAqIHRoaXMgbWl4aW4gc3VwcG9ydHMgYW4gb3B0aW1pemVkIG1vZGUuIElmIHlvdSBpbnZva2UgdGhlIGBjb250ZW50Q2hhbmdlZGBcbiAgICogbWV0aG9kIHdoZW4gdGhlIHNldCBvZiBpdGVtcyBjaGFuZ2VzLCB0aGUgbWl4aW4gY29uY2x1ZGVzIHRoYXQgeW91J2xsIHRha2VcbiAgICogY2FyZSBvZiBub3RpZnlpbmcgaXQgb2YgZnV0dXJlIGNoYW5nZXMsIGFuZCB0dXJucyBvbiB0aGUgb3B0aW1pemF0aW9uLiBXaXRoXG4gICAqIHRoYXQgb24sIHRoZSBtaXhpbiBzYXZlcyBhIHJlZmVyZW5jZSB0byB0aGUgY29tcHV0ZWQgc2V0IG9mIGl0ZW1zLCBhbmQgd2lsbFxuICAgKiByZXR1cm4gdGhhdCBpbW1lZGlhdGVseSBvbiBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSBgaXRlbXNgIHByb3BlcnR5LiBJZiB5b3VcbiAgICogdXNlIHRoaXMgbWl4aW4gaW4gY29uanVuY3Rpb24gd2l0aFxuICAgKiBbRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbl0oRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbi5tZCksIHRoZVxuICAgKiBgY29udGVudENoYW5nZWRgIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgZm9yIHlvdSB3aGVuIHRoZSBlbGVtZW50J3MgY2hpbGRyZW5cbiAgICogY2hhbmdlLCB0dXJuaW5nIG9uIHRoZSBvcHRpbWl6YXRpb24gYXV0b21hdGljYWxseS5cbiAgICovXG4gIGNsYXNzIENvbnRlbnRJdGVtcyBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29udGVudENoYW5nZWQoKSB7XG4gICAgICBpZiAoc3VwZXIuY29udGVudENoYW5nZWQpIHsgc3VwZXIuY29udGVudENoYW5nZWQoKTsgfVxuXG4gICAgICAvLyBTaW5jZSB3ZSBnb3QgdGhlIGNvbnRlbnRDaGFuZ2VkIGNhbGwsIHdlJ2xsIGFzc3VtZSB3ZSdsbCBiZSBub3RpZmllZCBpZlxuICAgICAgLy8gdGhlIHNldCBvZiBpdGVtcyBjaGFuZ2VzIGxhdGVyLiBXZSB0dXJuIG9uIG1lbW9pemF0aW9uIG9mIHRoZSBpdGVtc1xuICAgICAgLy8gcHJvcGVydHkgYnkgc2V0dGluZyBvdXIgaW50ZXJuYWwgcHJvcGVydHkgdG8gbnVsbCAoaW5zdGVhZCBvZlxuICAgICAgLy8gdW5kZWZpbmVkKS5cbiAgICAgIHRoaXNbaXRlbXNTeW1ib2xdID0gbnVsbDtcblxuICAgICAgdGhpc1tzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW5ldmVyIGEgbmV3IGl0ZW0gaXMgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuIFlvdSBjYW4gb3ZlcnJpZGVcbiAgICAgKiB0aGlzIHRvIHBlcmZvcm0gcGVyLWl0ZW0gaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIC0gVGhlIGl0ZW0gdGhhdCB3YXMgYWRkZWQuXG4gICAgICovXG4gICAgW3N5bWJvbHMuaXRlbUFkZGVkXShpdGVtKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtQWRkZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbUFkZGVkXShpdGVtKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3Rpb24gc3RhdGUgZm9yIGEgc2luZ2xlIGl0ZW0gaGFzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBJbnZva2UgdGhpcyBtZXRob2QgdG8gc2lnbmFsIHRoYXQgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIHRoZSBpbmRpY2F0ZWQgaXRlbVxuICAgICAqIGhhcyBjaGFuZ2VkLiBCeSBkZWZhdWx0LCB0aGlzIGFwcGxpZXMgYSBgc2VsZWN0ZWRgIENTUyBjbGFzcyBpZiB0aGUgaXRlbVxuICAgICAqIGlzIHNlbGVjdGVkLCBhbmQgcmVtb3ZlZCBpdCBpZiBub3Qgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIC0gVGhlIGl0ZW0gd2hvc2Ugc2VsZWN0aW9uIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgLSBUcnVlIGlmIHRoZSBpdGVtIGlzIHNlbGVjdGVkLCBmYWxzZSBpZiBub3QuXG4gICAgICovXG4gICAgW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuaXRlbVNlbGVjdGVkXSkgeyBzdXBlcltzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgc2VsZWN0ZWQpOyB9XG4gICAgICB0b2dnbGVDbGFzcyhpdGVtLCAnc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc2V0IG9mIGl0ZW1zIGluIHRoZSBsaXN0LiBTZWUgdGhlIHRvcC1sZXZlbCBkb2N1bWVudGF0aW9uIGZvclxuICAgICAqIG1peGluIGZvciBhIGRlc2NyaXB0aW9uIG9mIGhvdyBpdGVtcyBkaWZmZXIgZnJvbSBwbGFpbiBjb250ZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XG4gICAgICovXG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgbGV0IGl0ZW1zO1xuICAgICAgaWYgKHRoaXNbaXRlbXNTeW1ib2xdID09IG51bGwpIHtcbiAgICAgICAgaXRlbXMgPSBmaWx0ZXJBdXhpbGlhcnlFbGVtZW50cyh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAvLyBOb3RlOiB0ZXN0IGZvciAqZXF1YWxpdHkqIHdpdGggbnVsbDsgZG9uJ3QgdHJlYXQgdW5kZWZpbmVkIGFzIGEgbWF0Y2guXG4gICAgICAgIGlmICh0aGlzW2l0ZW1zU3ltYm9sXSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIE1lbW9pemUgdGhlIHNldCBvZiBpdGVtcy5cbiAgICAgICAgICB0aGlzW2l0ZW1zU3ltYm9sXSA9IGl0ZW1zO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIG1lbW9pemVkIGl0ZW1zLlxuICAgICAgICBpdGVtcyA9IHRoaXNbaXRlbXNTeW1ib2xdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdW5kZXJseWluZyBjb250ZW50cyBjaGFuZ2UuIEl0IGlzIGFsc29cbiAgICAgKiBpbnZva2VkIG9uIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbiDigJMgc2luY2UgdGhlIGl0ZW1zIGhhdmUgXCJjaGFuZ2VkXCIgZnJvbVxuICAgICAqIGJlaW5nIG5vdGhpbmcuXG4gICAgICovXG4gICAgW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1zQ2hhbmdlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtc0NoYW5nZWRdKCk7IH1cblxuICAgICAgLy8gUGVyZm9ybSBwZXItaXRlbSBpbml0aWFsaXphdGlvbi5cbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodGhpcy5pdGVtcywgaXRlbSA9PiB7XG4gICAgICAgIGlmICghaXRlbVtpdGVtSW5pdGlhbGl6ZWRTeW1ib2xdKSB7XG4gICAgICAgICAgdGhpc1tzeW1ib2xzLml0ZW1BZGRlZF0oaXRlbSk7XG4gICAgICAgICAgaXRlbVtpdGVtSW5pdGlhbGl6ZWRTeW1ib2xdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2l0ZW1zLWNoYW5nZWQnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgaXRlbXMgaW4gdGhlIGxpc3QgY2hhbmdlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvbnRlbnRJdGVtc1xuICAgICAqIEBldmVudCBpdGVtcy1jaGFuZ2VkXG4gICAgICovXG4gIH1cblxuICByZXR1cm4gQ29udGVudEl0ZW1zO1xufTtcblxuXG4vLyBSZXR1cm4gdGhlIGdpdmVuIGVsZW1lbnRzLCBmaWx0ZXJpbmcgb3V0IGF1eGlsaWFyeSBlbGVtZW50cyB0aGF0IGFyZW4ndFxuLy8gdHlwaWNhbGx5IHZpc2libGUuIEl0ZW1zIHdoaWNoIGFyZSBub3QgZWxlbWVudHMgYXJlIHJldHVybmVkIGFzIGlzLlxuZnVuY3Rpb24gZmlsdGVyQXV4aWxpYXJ5RWxlbWVudHMoaXRlbXMpIHtcbiAgY29uc3QgYXV4aWxpYXJ5VGFncyA9IFtcbiAgICAnbGluaycsXG4gICAgJ3NjcmlwdCcsXG4gICAgJ3N0eWxlJyxcbiAgICAndGVtcGxhdGUnXG4gIF07XG4gIHJldHVybiBbXS5maWx0ZXIuY2FsbChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiAhaXRlbS5sb2NhbE5hbWUgfHwgYXV4aWxpYXJ5VGFncy5pbmRleE9mKGl0ZW0ubG9jYWxOYW1lKSA8IDA7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi9zeW1ib2xzJztcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIERpcmVjdGlvblNlbGVjdGlvbi4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIG1hcHMgZGlyZWN0aW9uIHNlbWFudGljcyAoZ29MZWZ0LCBnb1JpZ2h0LCBldGMuKSB0byBzZWxlY3Rpb25cbiAgICogc2VtYW50aWNzIChzZWxlY3RQcmV2aW91cywgc2VsZWN0TmV4dCwgZXRjLikuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aFxuICAgKiBbS2V5Ym9hcmREaXJlY3Rpb25NaXhpbl0oS2V5Ym9hcmREaXJlY3Rpb25NaXhpbi5tZCkgKHdoaWNoIG1hcHMga2V5Ym9hcmRcbiAgICogZXZlbnRzIHRvIGRpcmVjdGlvbnMpIGFuZCBhIG1peGluIHRoYXQgaGFuZGxlcyBzZWxlY3Rpb24gbGlrZVxuICAgKiBbU2luZ2xlU2VsZWN0aW9uTWl4aW5dKFNpbmdsZVNlbGVjdGlvbk1peGluLm1kKS5cbiAgICovXG4gIGNsYXNzIERpcmVjdGlvblNlbGVjdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgW3N5bWJvbHMuZ29Eb3duXSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvRG93bl0pIHsgc3VwZXJbc3ltYm9scy5nb0Rvd25dKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdE5leHQoKTtcbiAgICB9XG5cbiAgICBbc3ltYm9scy5nb0VuZF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0VuZF0pIHsgc3VwZXJbc3ltYm9scy5nb0VuZF0oKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0TGFzdCgpO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLmdvTGVmdF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0xlZnRdKSB7IHN1cGVyW3N5bWJvbHMuZ29MZWZ0XSgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RQcmV2aW91cygpO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLmdvUmlnaHRdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuZ29SaWdodF0pIHsgc3VwZXJbc3ltYm9scy5nb1JpZ2h0XSgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3ROZXh0KCk7XG4gICAgfVxuXG4gICAgW3N5bWJvbHMuZ29TdGFydF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb1N0YXJ0XSkgeyBzdXBlcltzeW1ib2xzLmdvU3RhcnRdKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdEZpcnN0KCk7XG4gICAgfVxuXG4gICAgW3N5bWJvbHMuZ29VcF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb1VwXSkgeyBzdXBlcltzeW1ib2xzLmdvVXBdKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbi4gVGhpcyB3aWxsIHR5cGljYWxseSBiZSBoYW5kbGVkIGJ5IG90aGVyIG1peGlucy5cbiAgICBnZXQgc2VsZWN0ZWRGcmFjdGlvbigpIHtcbiAgICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEZyYWN0aW9uO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWRGcmFjdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCdzZWxlY3RlZEZyYWN0aW9uJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3RlZEZyYWN0aW9uID0gdmFsdWU7IH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uLiBUaGlzIHdpbGwgdHlwaWNhbGx5IGJlIGhhbmRsZWQgYnkgb3RoZXIgbWl4aW5zLlxuICAgIHNlbGVjdEZpcnN0KCkge1xuICAgICAgaWYgKHN1cGVyLnNlbGVjdEZpcnN0KSB7IHJldHVybiBzdXBlci5zZWxlY3RGaXJzdCgpOyB9XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbi4gVGhpcyB3aWxsIHR5cGljYWxseSBiZSBoYW5kbGVkIGJ5IG90aGVyIG1peGlucy5cbiAgICBzZWxlY3RMYXN0KCkge1xuICAgICAgaWYgKHN1cGVyLnNlbGVjdExhc3QpIHsgcmV0dXJuIHN1cGVyLnNlbGVjdExhc3QoKTsgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24uIFRoaXMgd2lsbCB0eXBpY2FsbHkgYmUgaGFuZGxlZCBieSBvdGhlciBtaXhpbnMuXG4gICAgc2VsZWN0TmV4dCgpIHtcbiAgICAgIGlmIChzdXBlci5zZWxlY3ROZXh0KSB7IHJldHVybiBzdXBlci5zZWxlY3ROZXh0KCk7IH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uLiBUaGlzIHdpbGwgdHlwaWNhbGx5IGJlIGhhbmRsZWQgYnkgb3RoZXIgbWl4aW5zLlxuICAgIHNlbGVjdFByZXZpb3VzKCkge1xuICAgICAgaWYgKHN1cGVyLnNlbGVjdFByZXZpb3VzKSB7IHJldHVybiBzdXBlci5zZWxlY3RQcmV2aW91cygpOyB9XG4gICAgfVxuXG4gICAgLy8gTWFwIGRyYWcgdHJhdmVsIGZyYWN0aW9uIHRvIHNlbGVjdGlvbiBmcmFjdGlvbi5cbiAgICBnZXQgdHJhdmVsRnJhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3VwZXIudHJhdmVsRnJhY3Rpb247XG4gICAgfVxuICAgIHNldCB0cmF2ZWxGcmFjdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCd0cmF2ZWxGcmFjdGlvbicgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIudHJhdmVsRnJhY3Rpb24gPSB2YWx1ZTsgfVxuICAgICAgdGhpcy5zZWxlY3RlZEZyYWN0aW9uID0gdmFsdWU7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gRGlyZWN0aW9uU2VsZWN0aW9uO1xufTtcbiIsImltcG9ydCBtaWNyb3Rhc2sgZnJvbSAnLi9taWNyb3Rhc2snO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnQuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBkZWZpbmVzIGEgY29tcG9uZW50J3MgY29udGVudCBhcyBpdHMgY2hpbGRyZW4sIGV4cGFuZGluZyBhbnlcbiAgICogbm9kZXMgZGlzdHJpYnV0ZWQgdG8gdGhlIGNvbXBvbmVudCdzIHNsb3RzLlxuICAgKlxuICAgKiBUaGlzIGFsc28gcHJvdmlkZXMgbm90aWZpY2F0aW9uIG9mIGNoYW5nZXMgdG8gYSBjb21wb25lbnQncyBjb250ZW50LiBJdFxuICAgKiB3aWxsIGludm9rZSBhIGBjb250ZW50Q2hhbmdlZGAgbWV0aG9kIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBmaXJzdFxuICAgKiBpbnN0YW50aWF0ZWQsIGFuZCB3aGVuZXZlciBpdHMgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gY2hhbmdlLiBUaGlzIGlzIGFuXG4gICAqIGVhc3kgd2F5IHRvIHNhdGlzZnkgdGhlIEdvbGQgU3RhbmRhcmQgY2hlY2tsaXN0IGl0ZW0gZm9yIG1vbml0b3JpbmdcbiAgICogW0NvbnRlbnQgQ2hhbmdlc10oaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvZ29sZC1zdGFuZGFyZC93aWtpL0NvbnRlbnQtQ2hhbmdlcykuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYFxuICAgKiBsZXQgYmFzZSA9IERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4oRGlzdHJpYnV0ZWRDaGlsZHJlbk1peGluKEhUTUxFbGVtZW50KSk7XG4gICAqIGNsYXNzIENvdW50aW5nRWxlbWVudCBleHRlbmRzIGJhc2Uge1xuICAgKlxuICAgKiAgIGNvbnN0cnVjdG9yKCkge1xuICAgKiAgICAgc3VwZXIoKTtcbiAgICogICAgIGxldCByb290ID0gdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAqICAgICByb290LmlubmVySFRNTCA9IGA8c2xvdD48L3Nsb3Q+YDtcbiAgICogICB9XG4gICAqXG4gICAqICAgY29udGVudENoYW5nZWQoKSB7XG4gICAqICAgICAvLyBDb3VudCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4sIGJvdGggaW5pdGlhbGx5IGFuZCB3aGVuIGNoYW5nZWQuXG4gICAqICAgICB0aGlzLmNvdW50ID0gdGhpcy5kaXN0cmlidXRlZENoaWxkcmVuLmxlbmd0aDtcbiAgICogICB9XG4gICAqXG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIE5vdGUgdGhhdCBjb250ZW50IGNoYW5nZSBkZXRlY3Rpb24gZGVwZW5kcyB1cG9uIHRoZSBlbGVtZW50IGhhdmluZyBhdCBsZWFzdFxuICAgKiBvbmUgYHNsb3RgIGVsZW1lbnQgaW4gaXRzIHNoYWRvdyBzdWJ0cmVlLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGlzIGludGVuZGVkIGZvciB1c2Ugd2l0aCB0aGVcbiAgICogW0Rpc3RyaWJ1dGVkQ2hpbGRyZW5NaXhpbl0oRGlzdHJpYnV0ZWRDaGlsZHJlbk1peGluLm1kKS4gU2VlIHRoYXQgbWl4aW4gZm9yXG4gICAqIGEgZGlzY3Vzc2lvbiBvZiBob3cgdGhhdCB3b3Jrcy4gVGhpcyBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluXG4gICAqIHByb3ZpZGVzIGFuIGVhc3kgd2F5IG9mIGRlZmluaW5nIHRoZSBcImNvbnRlbnRcIiBvZiBhIGNvbXBvbmVudCBhcyB0aGVcbiAgICogY29tcG9uZW50J3MgZGlzdHJpYnV0ZWQgY2hpbGRyZW4uIFRoYXQgaW4gdHVybiBsZXRzIG1peGlucyBsaWtlXG4gICAqIFtDb250ZW50SXRlbXNNaXhpbl0oQ29udGVudEl0ZW1zTWl4aW4ubWQpIG1hbmlwdWxhdGUgdGhlIGNoaWxkcmVuIGFzIGxpc3RcbiAgICogaXRlbXMuXG4gICAqL1xuICBjbGFzcyBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudCBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICBpZiAodGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIC8vIExpc3RlbiB0byBjaGFuZ2VzIG9uIGFsbCBzbG90cy5cbiAgICAgICAgY29uc3Qgc2xvdHMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnc2xvdCcpO1xuICAgICAgICBzbG90cy5mb3JFYWNoKHNsb3QgPT4gc2xvdC5hZGRFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgZXZlbnQgPT4ge1xuICAgICAgICAgIHRoaXMuY29udGVudENoYW5nZWQoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIGFuIGluaXRpYWwgY2FsbCB0byBjb250ZW50Q2hhbmdlZCgpIHNvIHRoYXQgdGhlIGNvbXBvbmVudCBjYW4gZG9cbiAgICAgIC8vIGluaXRpYWxpemF0aW9uIHRoYXQgaXQgbm9ybWFsbHkgZG9lcyB3aGVuIGNvbnRlbnQgY2hhbmdlcy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIHdpbGwgaW52b2tlIGNvbnRlbnRDaGFuZ2VkKCkgaGFuZGxlcnMgaW4gb3RoZXIgbWl4aW5zLiBJbiBvcmRlclxuICAgICAgLy8gdGhhdCB0aG9zZSBtaXhpbnMgaGF2ZSBhIGNoYW5jZSB0byBjb21wbGV0ZSB0aGVpciBvd24gaW5pdGlhbGl6YXRpb24sXG4gICAgICAvLyB3ZSBhZGQgdGhlIGNvbnRlbnRDaGFuZ2VkKCkgY2FsbCB0byB0aGUgbWljcm90YXNrIHF1ZXVlLlxuICAgICAgbWljcm90YXNrKCgpID0+IHRoaXMuY29udGVudENoYW5nZWQoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb250ZW50cyBvZiB0aGUgY29tcG9uZW50IChpbmNsdWRpbmcgZGlzdHJpYnV0ZWRcbiAgICAgKiBjaGlsZHJlbikgaGF2ZSBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgYWxzbyBpbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgZmlyc3QgaW5zdGFudGlhdGVkOyB0aGVcbiAgICAgKiBjb250ZW50cyBoYXZlIGVzc2VudGlhbGx5IFwiY2hhbmdlZFwiIGZyb20gYmVpbmcgbm90aGluZy4gVGhpcyBhbGxvd3MgdGhlXG4gICAgICogY29tcG9uZW50IHRvIHBlcmZvcm0gaW5pdGlhbCBwcm9jZXNzaW5nIG9mIGl0cyBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBjb250ZW50Q2hhbmdlZCgpIHtcbiAgICAgIGlmIChzdXBlci5jb250ZW50Q2hhbmdlZCkgeyBzdXBlci5jb250ZW50Q2hhbmdlZCgpOyB9XG4gICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY29udGVudC1jaGFuZ2VkJyk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IG9mIHRoaXMgY29tcG9uZW50LCBkZWZpbmVkIHRvIGJlIHRoZSBmbGF0dGVuZWQgYXJyYXkgb2ZcbiAgICAgKiBjaGlsZHJlbiBkaXN0cmlidXRlZCB0byB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XG4gICAgICovXG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICBjb25zdCBkaXN0cmlidXRlZENoaWxkcmVuID0gdGhpcy5kaXN0cmlidXRlZENoaWxkcmVuO1xuICAgICAgaWYgKHR5cGVvZiBkaXN0cmlidXRlZENoaWxkcmVuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLndhcm4oYERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4gZXhwZWN0cyB0aGUgY29tcG9uZW50IHRvIGRlZmluZSBhIFwiZGlzdHJpYnV0ZWRDaGlsZHJlblwiIHByb3BlcnR5LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpc3RyaWJ1dGVkQ2hpbGRyZW47XG4gICAgfVxuICAgIHNldCBjb250ZW50KHZhbHVlKSB7XG4gICAgICBpZiAoJ2NvbnRlbnQnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLmNvbnRlbnQgPSB2YWx1ZTsgfVxuICAgICAgLy8gVE9ETzogU2V0IHRoZSBjaGlsZHJlbiB0byB0aGUgZ2l2ZW4gdmFsdWUgKHdoaWNoIHNob3VsZCBiZSBhbiBhcnJheSBvZlxuICAgICAgLy8gZWxlbWVudHMpP1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgcmFpc2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIGNvbnRlbnRzIChpbmNsdWRpbmcgZGlzdHJpYnV0ZWRcbiAgICAgKiBjaGlsZHJlbikgaGF2ZSBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50XG4gICAgICogQGV2ZW50IGNvbnRlbnQtY2hhbmdlZFxuICAgICAqL1xuICB9XG5cbiAgcmV0dXJuIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50O1xufTtcbiIsIi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggRGlzdHJpYnV0ZWRDaGlsZHJlbi4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIGRlZmluZXMgaGVscGVycyBmb3IgYWNjZXNzaW5nIGEgY29tcG9uZW50J3MgZGlzdHJpYnV0ZWRcbiAgICogY2hpbGRyZW4gYXMgYSBmbGF0dGVuZWQgYXJyYXkgb3Igc3RyaW5nLlxuICAgKlxuICAgKiBUaGUgc3RhbmRhcmQgRE9NIEFQSSBwcm92aWRlcyBzZXZlcmFsIHdheXMgb2YgYWNjZXNzaW5nIGNoaWxkIGNvbnRlbnQ6XG4gICAqIGBjaGlsZHJlbmAsIGBjaGlsZE5vZGVzYCwgYW5kIGB0ZXh0Q29udGVudGAuIE5vbmUgb2YgdGhlc2UgZnVuY3Rpb25zIGFyZVxuICAgKiBTaGFkb3cgRE9NIGF3YXJlLiBUaGlzIG1peGluIGRlZmluZXMgdmFyaWF0aW9ucyBvZiB0aG9zZSBmdW5jdGlvbnMgdGhhdFxuICAgKiAqYXJlKiBTaGFkb3cgRE9NIGF3YXJlLlxuICAgKlxuICAgKiBFeGFtcGxlOiB5b3UgY3JlYXRlIGEgY29tcG9uZW50IGA8Y291bnQtY2hpbGRyZW4+YCB0aGF0IGRpc3BsYXlzIGEgbnVtYmVyXG4gICAqIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gcGxhY2VkIGluc2lkZSB0aGF0IGNvbXBvbmVudC4gSWYgc29tZW9uZVxuICAgKiBpbnN0YW50aWF0ZXMgeW91ciBjb21wb25lbnQgbGlrZTpcbiAgICpcbiAgICogICAgIDxjb3VudC1jaGlsZHJlbj5cbiAgICogICAgICAgPGRpdj48L2Rpdj5cbiAgICogICAgICAgPGRpdj48L2Rpdj5cbiAgICogICAgICAgPGRpdj48L2Rpdj5cbiAgICogICAgIDwvY291bnQtY2hpbGRyZW4+XG4gICAqXG4gICAqIFRoZW4gdGhlIGNvbXBvbmVudCBzaG91bGQgc2hvdyBcIjNcIiwgYmVjYXVzZSB0aGVyZSBhcmUgdGhyZWUgY2hpbGRyZW4uIFRvXG4gICAqIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuLCB0aGUgY29tcG9uZW50IGNhbiBqdXN0IGNhbGN1bGF0ZVxuICAgKiBgdGhpcy5jaGlsZHJlbi5sZW5ndGhgLiBIb3dldmVyLCBzdXBwb3NlIHNvbWVvbmUgaW5zdGFudGlhdGVzIHlvdXJcbiAgICogY29tcG9uZW50IGluc2lkZSBvbmUgb2YgdGhlaXIgb3duIGNvbXBvbmVudHMsIGFuZCBwdXRzIGEgYDxzbG90PmAgZWxlbWVudFxuICAgKiBpbnNpZGUgeW91ciBjb21wb25lbnQ6XG4gICAqXG4gICAqICAgICA8Y291bnQtY2hpbGRyZW4+XG4gICAqICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICogICAgIDwvY291bnQtY2hpbGRyZW4+XG4gICAqXG4gICAqIElmIHlvdXIgY29tcG9uZW50IG9ubHkgbG9va3MgYXQgYHRoaXMuY2hpbGRyZW5gLCBpdCB3aWxsIGFsd2F5cyBzZWUgZXhhY3RseVxuICAgKiBvbmUgY2hpbGQg4oCUwqB0aGUgYDxzbG90PmAgZWxlbWVudC4gQnV0IHRoZSB1c2VyIGxvb2tpbmcgYXQgdGhlIHBhZ2Ugd2lsbFxuICAgKiAqc2VlKiBhbnkgbm9kZXMgZGlzdHJpYnV0ZWQgdG8gdGhhdCBzbG90LiBUbyBtYXRjaCB3aGF0IHRoZSB1c2VyIHNlZXMsIHlvdXJcbiAgICogY29tcG9uZW50IHNob3VsZCBleHBhbmQgYW55IGA8c2xvdD5gIGVsZW1lbnRzIGl0IGNvbnRhaW5zLlxuICAgKlxuICAgKiBUaGF0IGlzIHRoZSBwcm9ibGVtIHRoaXMgbWl4aW4gc29sdmVzLiBBZnRlciBhcHBseWluZyB0aGlzIG1peGluLCB5b3VyXG4gICAqIGNvbXBvbmVudCBjb2RlIGhhcyBhY2Nlc3MgdG8gYHRoaXMuZGlzdHJpYnV0ZWRDaGlsZHJlbmAsIHdob3NlIGBsZW5ndGhgXG4gICAqIHdpbGwgcmV0dXJuIHRoZSB0b3RhbCBudW1iZXIgb2YgYWxsIGNoaWxkcmVuIGRpc3RyaWJ1dGVkIHRvIHlvdXIgY29tcG9uZW50XG4gICAqIGluIHRoZSBjb21wb3NlZCB0cmVlLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgbGF0ZXN0IEN1c3RvbSBFbGVtZW50cyBBUEkgZGVzaWduIGNhbGxzIGZvciBhIG5ldyBmdW5jdGlvbixcbiAgICogYGdldEFzc2lnbmVkTm9kZXNgIHRoYXQgdGFrZXMgYW4gb3B0aW9uYWwgYGRlZXBgIHBhcmFtZXRlciwgdGhhdCB3aWxsIHNvbHZlXG4gICAqIHRoaXMgcHJvYmxlbSBhdCB0aGUgQVBJIGxldmVsLlxuICAgKi9cbiAgY2xhc3MgRGlzdHJpYnV0ZWRDaGlsZHJlbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgLyoqXG4gICAgICogQW4gaW4tb3JkZXIgY29sbGVjdGlvbiBvZiBkaXN0cmlidXRlZCBjaGlsZHJlbiwgZXhwYW5kaW5nIGFueSBzbG90XG4gICAgICogZWxlbWVudHMuIExpa2UgdGhlIHN0YW5kYXJkIGNoaWxkcmVuIHByb3BlcnR5LCB0aGlzIHNraXBzIHRleHQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX1cbiAgICAgKi9cbiAgICBnZXQgZGlzdHJpYnV0ZWRDaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBleHBhbmRDb250ZW50RWxlbWVudHModGhpcy5jaGlsZHJlbiwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGluLW9yZGVyIGNvbGxlY3Rpb24gb2YgZGlzdHJpYnV0ZWQgY2hpbGQgbm9kZXMsIGV4cGFuZGluZyBhbnkgc2xvdFxuICAgICAqIGVsZW1lbnRzLiBMaWtlIHRoZSBzdGFuZGFyZCBjaGlsZE5vZGVzIHByb3BlcnR5LCB0aGlzIGluY2x1ZGVzIHRleHRcbiAgICAgKiBub2Rlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOb2RlW119XG4gICAgICovXG4gICAgZ2V0IGRpc3RyaWJ1dGVkQ2hpbGROb2RlcygpIHtcbiAgICAgIHJldHVybiBleHBhbmRDb250ZW50RWxlbWVudHModGhpcy5jaGlsZE5vZGVzLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uY2F0ZW5hdGVkIHRleHQgY29udGVudCBvZiBhbGwgZGlzdHJpYnV0ZWQgY2hpbGQgbm9kZXMsIGV4cGFuZGluZ1xuICAgICAqIGFueSBzbG90IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgZGlzdHJpYnV0ZWRUZXh0Q29udGVudCgpIHtcbiAgICAgIGNvbnN0IHN0cmluZ3MgPSB0aGlzLmRpc3RyaWJ1dGVkQ2hpbGROb2Rlcy5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLnRleHRDb250ZW50O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3RyaW5ncy5qb2luKCcnKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBEaXN0cmlidXRlZENoaWxkcmVuO1xufTtcblxuXG4vKlxuICogR2l2ZW4gYSBhcnJheSBvZiBub2RlcywgcmV0dXJuIGEgbmV3IGFycmF5IHdpdGggYW55IGNvbnRlbnQgZWxlbWVudHMgZXhwYW5kZWRcbiAqIHRvIHRoZSBub2RlcyBkaXN0cmlidXRlZCB0byB0aGF0IGNvbnRlbnQgZWxlbWVudC4gVGhpcyBydWxlIGlzIGFwcGxpZWRcbiAqIHJlY3Vyc2l2ZWx5LlxuICpcbiAqIElmIGluY2x1ZGVUZXh0Tm9kZXMgaXMgdHJ1ZSwgdGV4dCBub2RlcyB3aWxsIGJlIGluY2x1ZGVkLCBhcyBpbiB0aGVcbiAqIHN0YW5kYXJkIGNoaWxkTm9kZXMgcHJvcGVydHk7IGJ5IGRlZmF1bHQsIHRoaXMgc2tpcHMgdGV4dCBub2RlcywgbGlrZSB0aGVcbiAqIHN0YW5kYXJkIGNoaWxkcmVuIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBleHBhbmRDb250ZW50RWxlbWVudHMobm9kZXMsIGluY2x1ZGVUZXh0Tm9kZXMpIHtcbiAgY29uc3QgZXhwYW5kZWQgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwobm9kZXMsIG5vZGUgPT4ge1xuICAgIC8vIFdlIHdhbnQgdG8gc2VlIGlmIHRoZSBub2RlIGlzIGFuIGluc3RhbmNlb2YgSFRNTFNsb3RFTGVtZW50LCBidXRcbiAgICAvLyB0aGF0IGNsYXNzIHdvbid0IGV4aXN0IGlmIHRoZSBicm93c2VyIHRoYXQgZG9lc24ndCBzdXBwb3J0IG5hdGl2ZVxuICAgIC8vIFNoYWRvdyBET00gYW5kIGlmIHRoZSBTaGFkb3cgRE9NIHBvbHlmaWxsIGhhc24ndCBiZWVuIGxvYWRlZC4gSW5zdGVhZCxcbiAgICAvLyB3ZSBkbyBhIHNpbXBsaXN0aWMgY2hlY2sgdG8gc2VlIGlmIHRoZSB0YWcgbmFtZSBpcyBcInNsb3RcIi5cbiAgICBjb25zdCBpc1Nsb3QgPSB0eXBlb2YgSFRNTFNsb3RFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICBub2RlIGluc3RhbmNlb2YgSFRNTFNsb3RFbGVtZW50IDpcbiAgICAgIG5vZGUubG9jYWxOYW1lID09PSAnc2xvdCc7XG4gICAgaWYgKGlzU2xvdCkge1xuICAgICAgLy8gVXNlIHRoZSBub2RlcyBhc3NpZ25lZCB0byB0aGlzIG5vZGUgaW5zdGVhZC5cbiAgICAgIGNvbnN0IGFzc2lnbmVkTm9kZXMgPSBub2RlLmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuIGFzc2lnbmVkTm9kZXMgP1xuICAgICAgICBleHBhbmRDb250ZW50RWxlbWVudHMoYXNzaWduZWROb2RlcywgaW5jbHVkZVRleHROb2RlcykgOlxuICAgICAgICBbXTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgLy8gUGxhaW4gZWxlbWVudDsgdXNlIGFzIGlzLlxuICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBUZXh0ICYmIGluY2x1ZGVUZXh0Tm9kZXMpIHtcbiAgICAgIC8vIFRleHQgbm9kZS5cbiAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbW1lbnQsIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24sIGV0Yy47IHNraXAuXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZmxhdHRlbmVkID0gW10uY29uY2F0KC4uLmV4cGFuZGVkKTtcbiAgcmV0dXJuIGZsYXR0ZW5lZDtcbn1cbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi9jcmVhdGVTeW1ib2wnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBzZWxlY3RlZEZyYWN0aW9uU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdzZWxlY3RlZEZyYWN0aW9uJyk7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBGcmFjdGlvbmFsU2VsZWN0aW9uLiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWl4aW4oYmFzZSkge1xuXG4gIC8qKlxuICAgKiBBZGRzIHN1cHBvcnQgZm9yIGZyYWN0aW9uYWwgc2VsZWN0aW9uOiB0cmVhdGluZyBhIHNlbGVjdGlvbiBhcyBhIHJlYWxcbiAgICogbnVtYmVyIHRoYXQgY29tYmluZXMgYW4gaW50ZWdlciBwb3J0aW9uIChhbiBpbmRleCBpbnRvIGEgbGlzdCksIGFuZCBhXG4gICAqIGZyYWN0aW9uIChpbmRpY2F0aW5nIGhvdyBmYXIgb2YgdGhlIHdheSB3ZSBhcmUgdG8gdGhlIG5leHQgb3IgcHJldmlvdXNcbiAgICogaXRlbSkuXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIGluIGNvbXBvbmVudHMgdGhhdCBzdXBwb3J0IGluY3JlbWVudGFsIG9wZXJhdGlvbnMgZHVyaW5nXG4gICAqIGRyYWdnaW5nIGFuZCBzd2lwaW5nLiBFeGFtcGxlOiBhIGNhcm91c2VsIGNvbXBvbmVudCBoYXMgc2V2ZXJhbCBpdGVtcywgYW5kIHRoZVxuICAgKiBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSBpcyBpdGVtIDMuIFRoZSB1c2VyIGJlZ2lucyBzd2lwaW5nIHRvIHRoZSBsZWZ0LFxuICAgKiBtb3ZpbmcgdG93YXJkcyBzZWxlY3RpbmcgaXRlbSA0LiBIYWxmd2F5IHRocm91Z2ggdGhpcyBvcGVyYXRpb24sIHRoZVxuICAgKiBmcmFjdGlvbmFsIHNlbGVjdGlvbiB2YWx1ZSBpcyAzLjUuXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgcGVybWl0cyBjb21tdW5pY2F0aW9uIGJldHdlZW4gbWl4aW5zIGxpa2VcbiAgICogW1N3aXBlRGlyZWN0aW9uTWl4aW5dKC4vU3dpcGVEaXJlY3Rpb25NaXhpbi5tZCkgYW5kXG4gICAqIFtUcmFja3BhZERpcmVjdGlvbk1peGluXSguL1RyYWNrcGFkRGlyZWN0aW9uTWl4aW4ubWQpLCB3aGljaCBnZW5lcmF0ZVxuICAgKiBmcmFjdGlvbmFsIHNlbGVjdGlvbiB2YWx1ZXMsIGFuZCBtaXhpbnMgbGlrZVxuICAgKiBbU2VsZWN0aW9uQW5pbWF0aW9uTWl4aW5dKC4vU2VsZWN0aW9uQW5pbWF0aW9uTWl4aW4ubWQpLCB3aGljaCBjYW4gcmVuZGVyXG4gICAqIHNlbGVjdGlvbiBhdCBhIGZyYWN0aW9uYWwgdmFsdWUuXG4gICAqL1xuICBjbGFzcyBGcmFjdGlvbmFsU2VsZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgICB0aGlzLnNlbGVjdGVkRnJhY3Rpb24gPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZnJhY3Rpb25hbCB2YWx1ZSBpbmRpY2F0aW5nIGhvdyBmYXIgdGhlIHVzZXIgaGFzIGN1cnJlbnRseSBhZHZhbmNlZCB0b1xuICAgICAqIHRoZSBuZXh0L3ByZXZpb3VzIGl0ZW0uIEUuZy4sIGEgYHNlbGVjdGVkRnJhY3Rpb25gIG9mIDMuNSBpbmRpY2F0ZXMgdGhlXG4gICAgICogdXNlciBpcyBoYWxmd2F5IGJldHdlZW4gaXRlbXMgMyBhbmQgNC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkRnJhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpc1tzZWxlY3RlZEZyYWN0aW9uU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkRnJhY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXNbc2VsZWN0ZWRGcmFjdGlvblN5bWJvbF0gPSB2YWx1ZTtcbiAgICAgIGlmICgnc2VsZWN0ZWRGcmFjdGlvbicgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRGcmFjdGlvbiA9IHZhbHVlOyB9XG4gICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc2VsZWN0ZWQtZnJhY3Rpb24tY2hhbmdlZCcpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBGcmFjdGlvbmFsU2VsZWN0aW9uO1xufVxuXG5cbm1peGluLmhlbHBlcnMgPSB7XG5cbiAgLypcbiAgICogRGFtcGVuIGEgc2VsZWN0aW9uIHRoYXQgZ29lcyBwYXN0IHRoZSBiZWdpbm5pbmcgb3IgZW5kIG9mIGEgbGlzdC4gVGhpcyBpc1xuICAgKiBnZW5lcmFsbHkgdXNlZCB0byBwcm9kdWNlIGEgdmlzdWFsIGVmZmVjdCBvZiB0ZW5zaW9uIGFzIHRoZSB1c2VyIHRyaWVzIHRvXG4gICAqIGdvIGZ1cnRoZXIgaW4gYSBkaXJlY3Rpb24gdGhhdCBoYXMgbm8gbW9yZSBpdGVtcy5cbiAgICpcbiAgICogRXhhbXBsZTogc3VwcG9zZSBgaXRlbUNvdW50YCBpcyA1LCBpbmRpY2F0aW5nIGEgbGlzdCBvZiA1IGl0ZW1zLiBUaGUgaW5kZXggb2ZcbiAgICogdGhlIGxhc3QgaXRlbSBpcyA0LiBJZiB0aGUgYHNlbGVjdGlvbmAgcGFyYW1ldGVyIGlzIDQuNSwgdGhlIHVzZXIgaXMgdHJ5aW5nXG4gICAqIHRvIGdvIHBhc3QgdGhpcyBsYXN0IGl0ZW0uIFdoZW4gYSBkYW1waW5nIGZ1bmN0aW9uIGlzIGFwcGxpZWQsIHRoZSByZXN1bHRpbmdcbiAgICogdmFsdWUgd2lsbCBiZSBsZXNzIHRoYW4gNC41ICh0aGUgYWN0dWFsIHZhbHVlIHdpbGwgYmUgNC4yNSkuIFdoZW4gdGhpc1xuICAgKiBzZWxlY3Rpb24gc3RhdGUgaXMgcmVuZGVyZWQsIHRoZSB1c2VyIHdpbGwgc2VlIHRoYXQsIGVhY2ggdW5pdCBkaXN0YW5jZSB0aGVcbiAgICogZHJhZyB0cmF2ZWxzIGhhcyBsZXNzIGFuZCBsZXNzIHZpc2libGUgZWZmZWN0LiBUaGlzIGlzIHBlcmNlaXZlZCBhcyB0ZW5zaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2VsZWN0aW9uIC0gQSByZWFsIG51bWJlciBpbmRpY2F0aW5nIGEgc2VsZWN0aW9uIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtQ291bnQgLSBBbiBpbnRlZ2VyIGZvciB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEEgcmVhbCBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBkYW1wZWQgc2VsZWN0aW9uIHZhbHVlLlxuICAgKi9cbiAgZGFtcGVkU2VsZWN0aW9uKHNlbGVjdGlvbiwgaXRlbUNvdW50KSB7XG4gICAgY29uc3QgYm91bmQgPSBpdGVtQ291bnQgLSAxO1xuICAgIGxldCBkYW1wZWQ7XG4gICAgaWYgKHNlbGVjdGlvbiA8IDApIHtcbiAgICAgIC8vIFRyeWluZyB0byBnbyBwYXN0IGJlZ2lubmluZyBvZiBsaXN0LiBBcHBseSB0ZW5zaW9uIGZyb20gdGhlIGxlZnQgZWRnZS5cbiAgICAgIGRhbXBlZCA9IC1taXhpbi5oZWxwZXJzLmRhbXBpbmcoLXNlbGVjdGlvbik7XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rpb24gPj0gYm91bmQpIHtcbiAgICAgIC8vIFRyeWluZyB0byBnbyBwYXN0IGVuZCBvZiBsaXN0LiBBcHBseSB0ZW5zaW9uIGZyb20gdGhlIHJpZ2h0IGVkZ2UuXG4gICAgICBkYW1wZWQgPSBib3VuZCArIG1peGluLmhlbHBlcnMuZGFtcGluZyhzZWxlY3Rpb24gLSBib3VuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGRhbXBpbmcgcmVxdWlyZWQuXG4gICAgICBkYW1wZWQgPSBzZWxlY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBkYW1wZWQ7XG4gIH0sXG5cbiAgLypcbiAgICogQ2FsY3VsYXRlIGRhbXBpbmcgYXMgYSBmdW5jdGlvbiBvZiB0aGUgZGlzdGFuY2UgcGFzdCB0aGUgbWluaW11bS9tYXhpbXVtXG4gICAqIHZhbHVlcy5cbiAgICpcbiAgICogV2Ugd2FudCB0byBhc3ltcHRvdGljYWxseSBhcHByb2FjaCBhbiBhYnNvbHV0ZSBtaW5pbXVtIG9mIDEgdW5pdFxuICAgKiBiZWxvdy9hYm92ZSB0aGUgYWN0dWFsIG1pbmltdW0vbWF4aW11bS4gVGhpcyByZXF1aXJlcyBjYWxjdWxhdGluZyBhXG4gICAqIGh5cGVyYm9saWMgZnVuY3Rpb24uXG4gICAqXG4gICAqIFNlZSBodHRwOi8vd3d3LndvbGZyYW1hbHBoYS5jb20vaW5wdXQvP2k9eSslM0QrLTElMkYlMjh4JTJCMSUyOSslMkIrMVxuICAgKiBmb3IgdGhlIG9uZSB3ZSB1c2UuIFRoZSBvbmx5IHBvcnRpb24gb2YgdGhhdCBmdW5jdGlvbiB3ZSBjYXJlIGFib3V0IGlzIHdoZW5cbiAgICogeCBpcyB6ZXJvIG9yIGdyZWF0ZXIuIEFuIGltcG9ydGFudCBjb25zaWRlcmF0aW9uIGlzIHRoYXQgdGhlIGN1cnZlIGJlXG4gICAqIHRhbmdlbnQgdG8gdGhlIGRpYWdvbmFsIGxpbmUgeD15IGF0ICgwLCAwKS4gVGhpcyBlbnN1cmVzIHNtb290aCBjb250aW51aXR5XG4gICAqIHdpdGggdGhlIG5vcm1hbCBkcmFnIGJlaGF2aW9yLCBpbiB3aGljaCB0aGUgdmlzaWJsZSBzbGlkaW5nIGlzIGxpbmVhciB3aXRoXG4gICAqIHRoZSBkaXN0YW5jZSB0aGUgdG91Y2hwb2ludCBoYXMgYmVlbiBkcmFnZ2VkLlxuICAgKi9cbiAgZGFtcGluZyh4KSB7XG4gICAgY29uc3QgeSA9ICgtMSAvICh4ICsgMSkpICsgMTtcbiAgICByZXR1cm4geTtcbiAgfSxcblxuICAvKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgZnJhY3Rpb25hbCBzZWxlY3Rpb24gdmFsdWUgZm9yIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBUaGlzIHNpbXBseSBhZGRzIHRoZSBlbGVtZW50J3MgYHNlbGVjdGVkSW5kZXhgIGFuZCBgc2VsZWN0ZWRGcmFjdGlvbmBcbiAgICogcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEFuIGVsZW1lbnQgdGhhdCBzdXBwb3J0cyBzZWxlY3Rpb25cbiAgICovXG4gIGVsZW1lbnRTZWxlY3Rpb24oZWxlbWVudCkge1xuICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBlbGVtZW50LnNlbGVjdGVkSW5kZXg7XG4gICAgaWYgKHNlbGVjdGVkSW5kZXggPCAwKSB7XG4gICAgICAvLyBObyBzZWxlY3Rpb25cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRGcmFjdGlvbiA9IGVsZW1lbnQuc2VsZWN0ZWRGcmFjdGlvbiB8fCAwO1xuICAgIHJldHVybiBzZWxlY3RlZEluZGV4ICsgc2VsZWN0ZWRGcmFjdGlvbjtcbiAgfSxcblxuICAvKlxuICAgKiBCcmVha3MgYSBmcmFjdGlvbmFsIHNlbGVjdGlvbiBpbnRvIGl0cyBpbnRlZ2VyIGFuZCBmcmFjdGlvbmFsIHBhcnRzLlxuICAgKlxuICAgKiBFeGFtcGxlOiBpZiBwYXNzZWQgMy41LCB0aGlzIHJldHVybnMgeyBpbmRleDogMywgZnJhY3Rpb246IDUgfS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlbGVjdGlvbiDigJPCoEEgcmVhbCBudW1iZXIgcmVwcmVzZW50aW5nIGEgc2VsZWN0aW9uIHBvaW50XG4gICAqIEByZXR1cm5zIHtvYmplY3R9IC0gQW4gb2JqZWN0IHdpdGggYW4gYGluZGV4YCBwcm9wZXJ0eSBob2xkaW5nIHRoZVxuICAgKiBzZWxlY3Rpb24ncyBpbnRlZ2VyIGNvbXBvbmVudCwgYW5kIGEgYGZyYWN0aW9uYCBwcm9wZXJ0eSBob2xkaW5nIHRoZVxuICAgKiBzZWxlY3Rpb24ncyBmcmFjdGlvbmFsIGNvbXBvbmVudC5cbiAgICovXG4gIHNlbGVjdGlvblBhcnRzKHNlbGVjdGlvbikge1xuICAgIC8vIFN0dXBpZCBJRSBkb2Vzbid0IGhhdmUgTWF0aC50cnVuYy5cbiAgICAvLyBjb25zdCBpbmRleCA9IE1hdGgudHJ1bmMoc2VsZWN0aW9uKTtcbiAgICBjb25zdCBpbmRleCA9IHNlbGVjdGlvbiA8IDAgPyBNYXRoLmNlaWwoc2VsZWN0aW9uKSA6IE1hdGguZmxvb3Ioc2VsZWN0aW9uKTtcbiAgICBjb25zdCBmcmFjdGlvbiA9IHNlbGVjdGlvbiAtIGluZGV4O1xuICAgIHJldHVybiB7IGluZGV4LCBmcmFjdGlvbiB9O1xuICB9LFxuXG4gIC8qXG4gICAqIFJldHVybnMgYSBmcmFjdGlvbmFsIHNlbGVjdGlvbiBwb2ludCBhZnRlciBhY2NvdW50aW5nIGZvciB3cmFwcGluZywgZW5zdXJpbmdcbiAgICogdGhhdCB0aGUgaW50ZWdlciBwb3J0aW9uIG9mIHRoZSBzZWxlY3Rpb24gc3RheXMgYmV0d2VlbiAwIGFuZCBgaXRlbUNvdW50YC0xLlxuICAgKiBUaGF0IGlzLCB0aGUgaW50ZWdlciBwb3J0aW9uIHdpbGwgYWx3YXlzIGJlIGEgdmFsaWQgaW5kZXggaW50byB0aGUgbGlzdC5cbiAgICpcbiAgICogRXhhbXBsZSBvZiB3cmFwcGluZyBwYXN0IHRoZSBlbmQgb2YgdGhlIGxpc3Q6IGlmIGBzZWxlY3Rpb25gIGlzIDUuNSBhbmRcbiAgICogYGl0ZW1Db3VudGAgaXMgNSwgdGhpcyByZXR1cm5zIDAuNS4gRXhhbXBsZSBvZiB3cmFwcGluZyBwYXN0IHRoZSBiZWdpbm5pbmcgb2ZcbiAgICogdGhlIGxpc3Q6IGlmIGBzZWxlY3Rpb25gIGlzIDAuNSBhbmQgYGl0ZW1Db3VudGAgaXMgNSwgdGhpcyByZXR1cm5zIDQuNS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlbGVjdGlvbiAtIEEgcmVhbCBudW1iZXIgcmVwcmVzZW50aW5nIGEgc2VsZWN0aW9uIHBvaW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtQ291bnQgLSBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIHJlc3VsdCBvZiB3cmFwcGluZyB0aGUgc2VsZWN0aW9uIHBvaW50XG4gICAqL1xuICB3cmFwcGVkU2VsZWN0aW9uKHNlbGVjdGlvbiwgaXRlbUNvdW50KSB7XG4gICAgLy8gSGFuZGxlcyBwb3NzaWJpbGl0eSBvZiBuZWdhdGl2ZSBtb2QuXG4gICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE4NjE4MjUwLzc2NDcyXG4gICAgcmV0dXJuICgoc2VsZWN0aW9uICUgaXRlbUNvdW50KSArIGl0ZW1Db3VudCkgJSBpdGVtQ291bnQ7XG4gIH0sXG5cbiAgLypcbiAgICogUmV0dXJuIHRoZSBwYXJ0cyBvZiBhIHNlbGVjdGlvbiwgZmlyc3Qgd3JhcHBpbmcgaWYgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2VsZWN0aW9uIOKAkyBBIHJlYWwgbnVtYmVyIHJlcHJlc2VudGluZyBhIHNlbGVjdGlvbiBwb2ludFxuICAgKiBAcGFyYW0ge251bWJlcn0gaXRlbUNvdW50IC0gVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdyYXAg4oCTIFRydWUgaWYgdGhlIHNlbGVjdGlvbiBzaG91bGQgd3JhcCB0byBzdGF5IHdpdGhpbiB0aGVcbiAgICogbGlzdFxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSDigJMgVGhlIHBhcnRzIG9mIHRoZSBzZWxlY3Rpb24sIHVzaW5nIHRoZSBzYW1lIGZvcm1hdCBhc1xuICAgKiBgc2VsZWN0aW9uUGFydHNgLlxuICAgKi9cbiAgd3JhcHBlZFNlbGVjdGlvblBhcnRzKHNlbGVjdGlvbiwgaXRlbUNvdW50LCB3cmFwKSB7XG4gICAgaWYgKHdyYXApIHtcbiAgICAgIHNlbGVjdGlvbiA9IG1peGluLmhlbHBlcnMud3JhcHBlZFNlbGVjdGlvbihzZWxlY3Rpb24sIGl0ZW1Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiBtaXhpbi5oZWxwZXJzLnNlbGVjdGlvblBhcnRzKHNlbGVjdGlvbik7XG4gIH1cblxufTtcbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IHNhZmVBdHRyaWJ1dGVzIGZyb20gJy4vc2FmZUF0dHJpYnV0ZXMnO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi9zeW1ib2xzJztcblxuXG4vLyBTeW1ib2xzIGZvciBwcml2YXRlIGRhdGEgbWVtYmVycyBvbiBhbiBlbGVtZW50LlxuY29uc3QgZ2VuZXJpY1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnZ2VuZXJpYycpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggR2VuZXJpYy4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIGFsbG93cyBhIGNvbXBvbmVudCB0byBzdXBwb3J0IGEgXCJnZW5lcmljXCIgc3R5bGU6IGEgbWluaW1hbGlzdFxuICAgKiBzdHlsZSB0aGF0IGNhbiBlYXNpbHkgYmUgcmVtb3ZlZCB0byByZXNldCBpdHMgdmlzdWFsIGFwcGVhcmFuY2UgdG8gYVxuICAgKiBiYXNlbGluZSBzdGF0ZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYSBjb21wb25lbnQgc2hvdWxkIHByb3ZpZGUgYSBtaW5pbWFsIHZpc3VhbCBwcmVzZW50YXRpb24gdGhhdFxuICAgKiBhbGxvd3MgdGhlIGNvbXBvbmVudCB0byBmdW5jdGlvbi4gSG93ZXZlciwgdGhlIG1vcmUgc3R5bGluZyB0aGUgY29tcG9uZW50XG4gICAqIHByb3ZpZGVzIGJ5IGRlZmF1bHQsIHRoZSBoYXJkZXIgaXQgYmVjb21lcyB0byBnZXQgdGhlIGNvbXBvbmVudCB0byBmaXQgaW5cbiAgICogaW4gb3RoZXIgc2V0dGluZ3MuIEVhY2ggQ1NTIHJ1bGUgaGFzIHRvIGJlIG92ZXJyaWRkZW4uIFdvcnNlLCBuZXcgQ1NTIHJ1bGVzXG4gICAqIGFkZGVkIHRvIHRoZSBkZWZhdWx0IHN0eWxlIHdvbid0IGJlIG92ZXJyaWRkZW4gYnkgZGVmYXVsdCwgbWFraW5nIGl0IGhhcmRcbiAgICogdG8ga25vdyB3aGV0aGVyIGEgbmV3IHZlcnNpb24gb2YgYSBjb21wb25lbnQgd2lsbCBzdGlsbCBsb29rIG9rYXkuXG4gICAqXG4gICAqIEFzIGEgY29tcHJvbWlzZSwgdGhlIG1peGluIGRlZmluZXMgYSBgZ2VuZXJpY2AgYXR0cmlidXRlLiBUaGlzIGF0dHJpYnV0ZSBpc1xuICAgKiBub3JtYWxseSBzZXQgYnkgZGVmYXVsdCwgYW5kIHN0eWxlcyBjYW4gYmUgd3JpdHRlbiB0aGF0IGFwcGx5IG9ubHkgd2hlbiB0aGVcbiAgICogZ2VuZXJpYyBhdHRyaWJ1dGUgaXMgc2V0LiBUaGlzIGFsbG93cyB0aGUgY29uc3RydWN0aW9uIG9mIENTUyBydWxlcyB0aGF0XG4gICAqIHdpbGwgb25seSBhcHBseSB0byBnZW5lcmljIGNvbXBvbmVudHMgbGlrZTpcbiAgICpcbiAgICogICAgIDpob3N0KFtnZW5lcmljPVwiXCJdKSB7XG4gICAqICAgICAgIC4uLiBnZW5lcmljIGFwcGVhcmFuY2UgZGVmaW5lZCBoZXJlIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gcmVtb3ZlIGFsbCBkZWZhdWx0IHN0eWxpbmcg4oCUIHNldCB0aGUgYEdlbmVyaWNNaXhpbmBcbiAgICogYXR0cmlidXRlIHRvIGZhbHNlLCBhbmQgYWxsIGRlZmF1bHQgc3R5bGluZyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqL1xuICBjbGFzcyBHZW5lcmljIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICAvLyBTZXQgZGVmYXVsdHMuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuZ2VuZXJpYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5nZW5lcmljID0gdGhpc1tzeW1ib2xzLmRlZmF1bHRzXS5nZW5lcmljO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgbWl4aW4gZG9lc24ndCBhY3R1YWxseSByZXNwb25kIHRvIGF0dHJpYnV0ZSBjaGFuZ2VzLCBidXQgcmVsaWVzXG4gICAgLy8gb24gc2VwYXJhdGVseS1kZWZpbmVkIGJlaGF2aW9yIChlLmcuLCBpbiBBdHRyaWJ1dGVNYXJzaGFsbGluZ01peGluKSBmb3IgdGhhdC5cbiAgICAvLyBTdGlsbCwgd2UgbmVlZCBkZWZpbmUgYSBiYXNlbGluZSBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgdGhhdCBkb2VzXG4gICAgLy8gbm90aGluZywgaW4gY2FzZSB0aGlzIG1peGluIGdldHMgdXNlZCBvbiBpdHMgb3duLlxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgIGlmIChzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spIHsgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7IH1cbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgICBzYWZlQXR0cmlidXRlcy5jb25uZWN0ZWQodGhpcyk7XG4gICAgfVxuXG4gICAgZ2V0IFtzeW1ib2xzLmRlZmF1bHRzXSgpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRzID0gc3VwZXJbc3ltYm9scy5kZWZhdWx0c10gfHwge307XG4gICAgICBkZWZhdWx0cy5nZW5lcmljID0gdHJ1ZTtcbiAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBjb21wb25lbnQgd291bGQgbGlrZSB0byByZWNlaXZlIGdlbmVyaWMgc3R5bGluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgdHJ1ZSBieSBkZWZhdWx0IOKAlMKgc2V0IGl0IHRvIGZhbHNlIHRvIHR1cm4gb2ZmIGFsbFxuICAgICAqIGdlbmVyaWMgc3R5bGVzLiBUaGlzIG1ha2VzIGl0IGVhc2llciB0byBhcHBseSBjdXN0b20gc3R5bGluZzsgeW91IHdvbid0XG4gICAgICogaGF2ZSB0byBleHBsaWNpdGx5IG92ZXJyaWRlIHN0eWxpbmcgeW91IGRvbid0IHdhbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGdldCBnZW5lcmljKCkge1xuICAgICAgcmV0dXJuIHRoaXNbZ2VuZXJpY1N5bWJvbF07XG4gICAgfVxuICAgIHNldCBnZW5lcmljKHZhbHVlKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID9cbiAgICAgICAgU3RyaW5nKHZhbHVlKSAhPT0gJ2ZhbHNlJyA6XG4gICAgICAgIHZhbHVlO1xuICAgICAgdGhpc1tnZW5lcmljU3ltYm9sXSA9IHBhcnNlZDtcblxuICAgICAgaWYgKCdnZW5lcmljJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5nZW5lcmljID0gdmFsdWU7IH1cblxuICAgICAgLy8gV2Ugcm9sbCBvdXIgb3duIGF0dHJpYnV0ZSBzZXR0aW5nIHNvIHRoYXQgYW4gZXhwbGljaXRseSBmYWxzZSB2YWx1ZVxuICAgICAgLy8gc2hvd3MgdXAgYXMgR2VuZXJpY01peGluPVwiZmFsc2VcIi5cbiAgICAgIGlmIChwYXJzZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGZhbHNlIHN0cmluZy5cbiAgICAgICAgc2FmZUF0dHJpYnV0ZXMuc2V0QXR0cmlidXRlKHRoaXMsICdnZW5lcmljJywgJ2ZhbHNlJyk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlZCA9PSBudWxsKSB7XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgcmVtb3ZlIGF0dHJpYnV0ZS4gKEFsd2F5cyBzYWZlIHRvIGRvIHRoaXMuKVxuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnZ2VuZXJpYycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlIHRoZSBlbXB0eSBzdHJpbmcgdG8gZ2V0IGF0dHJpYnV0ZSB0byBhcHBlYXIgd2l0aCBubyB2YWx1ZS5cbiAgICAgICAgc2FmZUF0dHJpYnV0ZXMuc2V0QXR0cmlidXRlKHRoaXMsICdnZW5lcmljJywgJycpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEdlbmVyaWM7XG59O1xuXG5cbiIsImltcG9ydCBEaXJlY3Rpb25TZWxlY3Rpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9EaXJlY3Rpb25TZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgS2V5Ym9hcmREaXJlY3Rpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9LZXlib2FyZERpcmVjdGlvbk1peGluJztcbmltcG9ydCBLZXlib2FyZE1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0tleWJvYXJkTWl4aW4nO1xuaW1wb3J0IFN3aXBlRGlyZWN0aW9uTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU3dpcGVEaXJlY3Rpb25NaXhpbic7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zeW1ib2xzJztcbmltcG9ydCBUcmFja3BhZERpcmVjdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1RyYWNrcGFkRGlyZWN0aW9uTWl4aW4nO1xuXG5cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgY29uc3QgbWl4aW5zID0gW1xuICAgIERpcmVjdGlvblNlbGVjdGlvbk1peGluLFxuICAgIEtleWJvYXJkTWl4aW4sXG4gICAgS2V5Ym9hcmREaXJlY3Rpb25NaXhpbixcbiAgICBTd2lwZURpcmVjdGlvbk1peGluLFxuICAgIFRyYWNrcGFkRGlyZWN0aW9uTWl4aW5cbiAgXTtcblxuICAvLyBEb24ndCBhc3N1bWUgYmFzZSBjbGFzcyB1c2VzIENvbXBvc2FibGVNaXhpbi4gRG8gY29tcG9zaXRpb24gYnkgaGFuZC5cbiAgY29uc3QgYmFzZVdpdGhNaXhpbnMgPSBtaXhpbnMucmVkdWNlKChjLCBtaXhpbikgPT4gbWl4aW4oYyksIGJhc2UpO1xuXG4gIC8qKlxuICAgKiBAbWl4ZXMgS2V5Ym9hcmRNaXhpblxuICAgKiBAbWl4ZXMgS2V5Ym9hcmREaXJlY3Rpb25NaXhpblxuICAgKiBAbWl4ZXMgU3dpcGVEaXJlY3Rpb25NaXhpblxuICAgKiBAbWl4ZXMgVHJhY2twYWREaXJlY3Rpb25NaXhpblxuICAgKi9cbiAgY2xhc3MgSG9yaXpvbnRhbE5hdmlnYXRpb24gZXh0ZW5kcyBiYXNlV2l0aE1peGlucyB7XG5cbiAgICBnZXQgW3N5bWJvbHMuZGVmYXVsdHNdKCkge1xuICAgICAgY29uc3QgZGVmYXVsdHMgPSBzdXBlcltzeW1ib2xzLmRlZmF1bHRzXSB8fCB7fTtcbiAgICAgIGRlZmF1bHRzLm5hdmlnYXRpb25BeGlzID0gJ2hvcml6b250YWwnO1xuICAgICAgZGVmYXVsdHMuc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0ID0gJ3NsaWRlV2l0aEdhcCc7XG4gICAgICAvLyBkZWZhdWx0cy5zZWxlY3Rpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gSG9yaXpvbnRhbE5hdmlnYXRpb247XG5cbn07XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IG5hdmlnYXRpb25BeGlzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCduYXZpZ2F0aW9uQXhpcycpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggS2V5Ym9hcmREaXJlY3Rpb24uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYXBzIGRpcmVjdGlvbiBrZXlzIChMZWZ0LCBSaWdodCwgZXRjLikgdG8gZGlyZWN0aW9uIHNlbWFudGljc1xuICAgKiAoZ28gbGVmdCwgZ28gcmlnaHQsIGV0Yy4pLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGV4cGVjdHMgdGhlIGNvbXBvbmVudCB0byBpbnZva2UgYSBga2V5ZG93bmAgbWV0aG9kIHdoZW4gYSBrZXkgaXNcbiAgICogcHJlc3NlZC4gWW91IGNhbiB1c2UgW0tleWJvYXJkTWl4aW5dKEtleWJvYXJkTWl4aW4ubWQpIGZvciB0aGF0XG4gICAqIHB1cnBvc2UsIG9yIHdpcmUgdXAgeW91ciBvd24ga2V5Ym9hcmQgaGFuZGxpbmcgYW5kIGNhbGwgYGtleWRvd25gIHlvdXJzZWxmLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGNhbGxzIG1ldGhvZHMgc3VjaCBhcyBgZ29MZWZ0YCBhbmQgYGdvUmlnaHRgLiBZb3UgY2FuIGRlZmluZVxuICAgKiB3aGF0IHRoYXQgbWVhbnMgYnkgaW1wbGVtZW50aW5nIHRob3NlIG1ldGhvZHMgeW91cnNlbGYuIElmIHlvdSB3YW50IHRvIHVzZVxuICAgKiBkaXJlY3Rpb24ga2V5cyB0byBuYXZpZ2F0ZSBhIHNlbGVjdGlvbiwgdXNlIHRoaXMgbWl4aW4gd2l0aFxuICAgKiBbRGlyZWN0aW9uU2VsZWN0aW9uTWl4aW5dKERpcmVjdGlvblNlbGVjdGlvbk1peGluLm1kKS5cbiAgICovXG4gIGNsYXNzIEtleWJvYXJkRGlyZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICAvLyBTZXQgZGVmYXVsdHMuXG4gICAgICBpZiAodHlwZW9mIHRoaXMubmF2aWdhdGlvbkF4aXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkF4aXMgPSB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLm5hdmlnYXRpb25BeGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMubmF2aWdhdGlvbkF4aXMgPSAnYm90aCc7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIGRvd24uXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgICAqL1xuICAgIFtzeW1ib2xzLmdvRG93bl0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0Rvd25dKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvRG93bl0oKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSB0byB0aGUgZW5kIChlLmcuLCBvZiBhIGxpc3QpLlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBbc3ltYm9scy5nb0VuZF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0VuZF0pIHsgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZ29FbmRdKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgbGVmdC5cbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICovXG4gICAgW3N5bWJvbHMuZ29MZWZ0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvTGVmdF0pIHsgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZ29MZWZ0XSgpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIHJpZ2h0LlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBbc3ltYm9scy5nb1JpZ2h0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvUmlnaHRdKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvUmlnaHRdKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgdG8gdGhlIHN0YXJ0IChlLmcuLCBvZiBhXG4gICAgICogbGlzdCkuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBbc3ltYm9scy5nb1N0YXJ0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvU3RhcnRdKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvU3RhcnRdKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgdXAuXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgICAqL1xuICAgIFtzeW1ib2xzLmdvVXBdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuZ29VcF0pIHsgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZ29VcF0oKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgZGlyZWN0aW9uIG9mIHBlcm1pdHRlZCBuYXZpZ2F0aW9uIHdpdGggdGhlIGtleWJvYXJkLlxuICAgICAqXG4gICAgICogQWNjZXB0ZWQgdmFsdWVzIGFyZSBcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiLCBvciBcImJvdGhcIiAodGhlIGRlZmF1bHQpLlxuICAgICAqIElmIHRoaXMgcHJvcGVydHkgaXMgXCJob3Jpem9udGFsXCIsIHRoZSBVcCBBcnJvdyBhbmQgRG93biBBcnJvdyBrZXlzIHdpbGxcbiAgICAgKiBiZSBpZ25vcmVkLiBDb252ZXJzZWx5LCBpZiB0aGlzIGlzIFwidmVydGljYWxcIiwgdGhlIExlZnQgQXJyb3cgYW5kIFJpZ2h0XG4gICAgICogQXJyb3cga2V5cyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBuYXZpZ2F0aW9uQXhpcygpIHtcbiAgICAgIHJldHVybiB0aGlzW25hdmlnYXRpb25BeGlzU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IG5hdmlnYXRpb25BeGlzKHZhbHVlKSB7XG4gICAgICB0aGlzW25hdmlnYXRpb25BeGlzU3ltYm9sXSA9IHZhbHVlO1xuICAgICAgaWYgKCduYXZpZ2F0aW9uQXhpcycgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIubmF2aWdhdGlvbkF4aXMgPSB2YWx1ZTsgfVxuICAgIH1cblxuICAgIFtzeW1ib2xzLmtleWRvd25dKGV2ZW50KSB7XG4gICAgICBsZXQgaGFuZGxlZDtcblxuICAgICAgY29uc3QgYXhpcyA9IHRoaXMubmF2aWdhdGlvbkF4aXM7XG4gICAgICBjb25zdCBob3Jpem9udGFsID0gKGF4aXMgPT09ICdob3Jpem9udGFsJyB8fCBheGlzID09PSAnYm90aCcpO1xuICAgICAgY29uc3QgdmVydGljYWwgPSAoYXhpcyA9PT0gJ3ZlcnRpY2FsJyB8fCBheGlzID09PSAnYm90aCcpO1xuXG4gICAgICAvLyBJZ25vcmUgTGVmdC9SaWdodCBrZXlzIHdoZW4gbWV0YUtleSBvciBhbHRLZXkgbW9kaWZpZXIgaXMgYWxzbyBwcmVzc2VkLFxuICAgICAgLy8gYXMgdGhlIHVzZXIgbWF5IGJlIHRyeWluZyB0byBuYXZpZ2F0ZSBiYWNrIG9yIGZvcndhcmQgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAzNTogLy8gRW5kXG4gICAgICAgICAgaGFuZGxlZCA9IHRoaXNbc3ltYm9scy5nb0VuZF0oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNjogLy8gSG9tZVxuICAgICAgICAgIGhhbmRsZWQgPSB0aGlzW3N5bWJvbHMuZ29TdGFydF0oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNzogLy8gTGVmdFxuICAgICAgICAgIGlmIChob3Jpem9udGFsICYmICFldmVudC5tZXRhS2V5ICYmICFldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0aGlzW3N5bWJvbHMuZ29MZWZ0XSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzODogLy8gVXBcbiAgICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSBldmVudC5hbHRLZXkgPyB0aGlzW3N5bWJvbHMuZ29TdGFydF0oKSA6IHRoaXNbc3ltYm9scy5nb1VwXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOTogLy8gUmlnaHRcbiAgICAgICAgICBpZiAoaG9yaXpvbnRhbCAmJiAhZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdGhpc1tzeW1ib2xzLmdvUmlnaHRdKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOiAvLyBEb3duXG4gICAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gZXZlbnQuYWx0S2V5ID8gdGhpc1tzeW1ib2xzLmdvRW5kXSgpIDogdGhpc1tzeW1ib2xzLmdvRG93bl0oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBQcmVmZXIgbWl4aW4gcmVzdWx0IGlmIGl0J3MgZGVmaW5lZCwgb3RoZXJ3aXNlIHVzZSBiYXNlIHJlc3VsdC5cbiAgICAgIHJldHVybiBoYW5kbGVkIHx8IChzdXBlcltzeW1ib2xzLmtleWRvd25dICYmIHN1cGVyW3N5bWJvbHMua2V5ZG93bl0oZXZlbnQpKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBLZXlib2FyZERpcmVjdGlvbjtcbn07XG4iLCJpbXBvcnQgc3ltYm9scyBmcm9tICcuL3N5bWJvbHMnO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggS2V5Ym9hcmQuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYW5hZ2VzIHRoZSBrZXlkb3duIGhhbmRsaW5nIGZvciBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBoYW5kbGVzIHNldmVyYWwga2V5Ym9hcmQtcmVsYXRlZCBmZWF0dXJlcy5cbiAgICpcbiAgICogRmlyc3QsIGl0IHdpcmVzIHVwIGEgc2luZ2xlIGtleWRvd24gZXZlbnQgaGFuZGxlciB0aGF0IGNhbiBiZSBzaGFyZWQgYnlcbiAgICogbXVsdGlwbGUgbWl4aW5zIG9uIGEgY29tcG9uZW50LiBUaGUgZXZlbnQgaGFuZGxlciB3aWxsIGludm9rZSBhIGBrZXlkb3duYFxuICAgKiBtZXRob2Qgd2l0aCB0aGUgZXZlbnQgb2JqZWN0LCBhbmQgYW55IG1peGluIGFsb25nIHRoZSBwcm90b3R5cGUgY2hhaW4gdGhhdFxuICAgKiB3YW50cyB0byBoYW5kbGUgdGhhdCBtZXRob2QgY2FuIGRvIHNvLlxuICAgKlxuICAgKiBJZiBhIG1peGluIHdhbnRzIHRvIGluZGljYXRlIHRoYXQga2V5Ym9hcmQgZXZlbnQgaGFzIGJlZW4gaGFuZGxlZCwgYW5kIHRoYXRcbiAgICogb3RoZXIgbWl4aW5zIHNob3VsZCAqbm90KiBoYW5kbGUgaXQsIHRoZSBtaXhpbidzIGBrZXlkb3duYCBoYW5kbGVyIHNob3VsZFxuICAgKiByZXR1cm4gYSB2YWx1ZSBvZiB0cnVlLiBUaGUgY29udmVudGlvbiB0aGF0IHNlZW1zIHRvIHdvcmsgd2VsbCBpcyB0aGF0IGFcbiAgICogbWl4aW4gc2hvdWxkIHNlZSBpZiBpdCB3YW50cyB0byBoYW5kbGUgdGhlIGV2ZW50IGFuZCwgaWYgbm90LCB0aGVuIGFzayB0aGVcbiAgICogc3VwZXJjbGFzcyB0byBzZWUgaWYgaXQgd2FudHMgdG8gaGFuZGxlIHRoZSBldmVudC4gVGhpcyBoYXMgdGhlIGVmZmVjdCBvZlxuICAgKiBnaXZpbmcgdGhlIG1peGluIHRoYXQgd2FzIGFwcGxpZWQgbGFzdCB0aGUgZmlyc3QgY2hhbmNlIGF0IGhhbmRsaW5nIGFcbiAgICoga2V5Ym9hcmQgZXZlbnQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBbc3ltYm9scy5rZXlkb3duXShldmVudCkge1xuICAgKiAgICAgICBsZXQgaGFuZGxlZDtcbiAgICogICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAqICAgICAgICAgLy8gSGFuZGxlIHRoZSBrZXlzIHlvdSB3YW50LCBzZXR0aW5nIGhhbmRsZWQgPSB0cnVlIGlmIGFwcHJvcHJpYXRlLlxuICAgKiAgICAgICB9XG4gICAqICAgICAgIC8vIFByZWZlciBtaXhpbiByZXN1bHQgaWYgaXQncyBkZWZpbmVkLCBvdGhlcndpc2UgdXNlIGJhc2UgcmVzdWx0LlxuICAgKiAgICAgICByZXR1cm4gaGFuZGxlZCB8fCAoc3VwZXJbc3ltYm9scy5rZXlkb3duXSAmJiBzdXBlcltzeW1ib2xzLmtleWRvd25dKGV2ZW50KSk7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEEgc2Vjb25kIGZlYXR1cmUgcHJvdmlkZWQgYnkgdGhpcyBtaXhpbiBpcyB0aGF0IGl0IGltcGxpY2l0bHkgbWFrZXMgdGhlXG4gICAqIGNvbXBvbmVudCBhIHRhYiBzdG9wIGlmIGl0IGlzbid0IGFscmVhZHksIGJ5IHNldHRpbmcgYHRhYkluZGV4YCB0byAwLiBUaGlzXG4gICAqIGhhcyB0aGUgZWZmZWN0IG9mIGFkZGluZyB0aGUgY29tcG9uZW50IHRvIHRoZSB0YWIgb3JkZXIgaW4gZG9jdW1lbnQgb3JkZXIuXG4gICAqL1xuICBjbGFzcyBLZXlib2FyZCBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVkID0gdGhpc1tzeW1ib2xzLmtleWRvd25dKGV2ZW50KTtcbiAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgPT0gbnVsbCAmJiB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnRhYmluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRoaXNbc3ltYm9scy5kZWZhdWx0c10udGFiaW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgLy8gVGhlIGRlZmF1bHQgdGFiIGluZGV4IGlzIDAgKGRvY3VtZW50IG9yZGVyKS5cbiAgICAgIGRlZmF1bHRzLnRhYmluZGV4ID0gMDtcbiAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGluZGljYXRlZCBrZXlib2FyZCBldmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy4gVGhpcyB3aWxsXG4gICAgICogdHlwaWNhbGx5IGJlIGhhbmRsZWQgYnkgb3RoZXIgbWl4aW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIHRoZSBrZXlib2FyZCBldmVudFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGV2ZW50IHdhcyBoYW5kbGVkXG4gICAgICovXG4gICAgW3N5bWJvbHMua2V5ZG93bl0oZXZlbnQpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmtleWRvd25dKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmtleWRvd25dKGV2ZW50KTsgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEtleWJvYXJkO1xufTtcbiIsImltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBLZXlib2FyZFBhZ2VkU2VsZWN0aW9uLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gd2hpY2ggbWFwcyBwYWdlIGtleXMgKFBhZ2UgVXAsIFBhZ2UgRG93bikgaW50byBvcGVyYXRpb25zIHRoYXQgbW92ZVxuICAgKiB0aGUgc2VsZWN0aW9uIGJ5IG9uZSBwYWdlLlxuICAgKlxuICAgKiBUaGUga2V5Ym9hcmQgaW50ZXJhY3Rpb24gbW9kZWwgZ2VuZXJhbGx5IGZvbGxvd3MgdGhhdCBvZiBNaWNyb3NvZnQgV2luZG93cydcbiAgICogbGlzdCBib3hlcyBpbnN0ZWFkIG9mIHRob3NlIGluIE9TIFg6XG4gICAqXG4gICAqICogVGhlIFBhZ2UgVXAvRG93biBhbmQgSG9tZS9FbmQga2V5cyBhY3R1YWxseSBjaGFuZ2UgdGhlIHNlbGVjdGlvbiwgcmF0aGVyXG4gICAqICAgdGhhbiBqdXN0IHNjcm9sbGluZy4gVGhlIGZvcm1lciBiZWhhdmlvciBzZWVtcyBtb3JlIGdlbmVyYWxseSB1c2VmdWwgZm9yXG4gICAqICAga2V5Ym9hcmQgdXNlcnMuXG4gICAqXG4gICAqICogUHJlc3NpbmcgUGFnZSBVcC9Eb3duIHdpbGwgY2hhbmdlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHRvcG1vc3QvYm90dG9tbW9zdFxuICAgKiAgIHZpc2libGUgaXRlbSBpZiB0aGUgc2VsZWN0aW9uIGlzIG5vdCBhbHJlYWR5IHRoZXJlLiBUaGVyZWFmdGVyLCB0aGUga2V5XG4gICAqICAgd2lsbCBtb3ZlIHRoZSBzZWxlY3Rpb24gdXAvZG93biBieSBhIHBhZ2UsIGFuZCAocGVyIHRoZSBhYm92ZSBwb2ludCkgbWFrZVxuICAgKiAgIHRoZSBzZWxlY3RlZCBpdGVtIHZpc2libGUuXG4gICAqXG4gICAqIFRvIGVuc3VyZSB0aGUgc2VsZWN0ZWQgaXRlbSBpcyBpbiB2aWV3IGZvbGxvd2luZyB1c2Ugb2YgUGFnZSBVcC9Eb3duLCB1c2VcbiAgICogdGhlIHJlbGF0ZWQgW1NlbGVjdGlvbkluVmlld01peGluXShTZWxlY3Rpb25JblZpZXdNaXhpbi5tZCkuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyB0aGUgY29tcG9uZW50IHRvIGludm9rZSBhIGBrZXlkb3duYCBtZXRob2Qgd2hlbiBhIGtleSBpc1xuICAgKiBwcmVzc2VkLiBZb3UgY2FuIHVzZSBbS2V5Ym9hcmRNaXhpbl0oS2V5Ym9hcmRNaXhpbi5tZCkgZm9yIHRoYXRcbiAgICogcHVycG9zZSwgb3Igd2lyZSB1cCB5b3VyIG93biBrZXlib2FyZCBoYW5kbGluZyBhbmQgY2FsbCBga2V5ZG93bmAgeW91cnNlbGYuXG4gICAqL1xuICBjbGFzcyBLZXlib2FyZFBhZ2VkU2VsZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBbc3ltYm9scy5rZXlkb3duXShldmVudCkge1xuICAgICAgbGV0IGhhbmRsZWQ7XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAzMzogLy8gUGFnZSBVcFxuICAgICAgICAgIGhhbmRsZWQgPSB0aGlzLnBhZ2VVcCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM0OiAvLyBQYWdlIERvd25cbiAgICAgICAgICBoYW5kbGVkID0gdGhpcy5wYWdlRG93bigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gUHJlZmVyIG1peGluIHJlc3VsdCBpZiBpdCdzIGRlZmluZWQsIG90aGVyd2lzZSB1c2UgYmFzZSByZXN1bHQuXG4gICAgICByZXR1cm4gaGFuZGxlZCB8fCAoc3VwZXJbc3ltYm9scy5rZXlkb3duXSAmJiBzdXBlcltzeW1ib2xzLmtleWRvd25dKGV2ZW50KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xsIGRvd24gb25lIHBhZ2UuXG4gICAgICovXG4gICAgcGFnZURvd24oKSB7XG4gICAgICBpZiAoc3VwZXIucGFnZURvd24pIHsgc3VwZXIucGFnZURvd24oKTsgfVxuICAgICAgcmV0dXJuIHNjcm9sbE9uZVBhZ2UodGhpcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHVwIG9uZSBwYWdlLlxuICAgICAqL1xuICAgIHBhZ2VVcCgpIHtcbiAgICAgIGlmIChzdXBlci5wYWdlVXApIHsgc3VwZXIucGFnZVVwKCk7IH1cbiAgICAgIHJldHVybiBzY3JvbGxPbmVQYWdlKHRoaXMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBzY3JvbGxlZCB3aXRoIHRoZSBQYWdlIFVwL0Rvd24ga2V5cy5cbiAgICAgKiBEZWZhdWx0IGlzIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0IHNjcm9sbFRhcmdldCgpIHtcbiAgICAgIC8vIFByZWZlciBiYXNlIHJlc3VsdC5cbiAgICAgIHJldHVybiAnc2Nyb2xsVGFyZ2V0JyBpbiBiYXNlLnByb3RvdHlwZSA/IHN1cGVyLnNjcm9sbFRhcmdldCA6IHRoaXM7XG4gICAgfVxuICAgIHNldCBzY3JvbGxUYXJnZXQoZWxlbWVudCkge1xuICAgICAgaWYgKCdzY3JvbGxUYXJnZXQnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNjcm9sbFRhcmdldCA9IGVsZW1lbnQ7IH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gS2V5Ym9hcmRQYWdlZFNlbGVjdGlvbjtcbn07XG5cblxuLy8gUmV0dXJuIHRoZSBpdGVtIHdob3NlIGNvbnRlbnQgc3BhbnMgdGhlIGdpdmVuIHkgcG9zaXRpb24gKHJlbGF0aXZlIHRvIHRoZVxuLy8gdG9wIG9mIHRoZSBsaXN0J3Mgc2Nyb2xsaW5nIGNsaWVudCBhcmVhKSwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4vL1xuLy8gSWYgZG93bndhcmQgaXMgdHJ1ZSwgbW92ZSBkb3duIHRoZSBsaXN0IG9mIGl0ZW1zIHRvIGZpbmQgdGhlIGZpcnN0IGl0ZW1cbi8vIGZvdW5kIGF0IHRoZSBnaXZlbiB5IHBvc2l0aW9uOyBpZiBkb3dud2FyZCBpcyBmYWxzZSwgbW92ZSB1cCB0aGUgbGlzdCBvZlxuLy8gaXRlbXMgdG8gZmluZCB0aGUgbGFzdCBpdGVtIGF0IHRoYXQgcG9zaXRpb24uXG5mdW5jdGlvbiBnZXRJbmRleE9mSXRlbUF0WShlbGVtZW50LCB5LCBkb3dud2FyZCkge1xuICBjb25zdCBpdGVtcyA9IGVsZW1lbnQuaXRlbXM7XG4gIGNvbnN0IHN0YXJ0ID0gZG93bndhcmQgPyAwIDogaXRlbXMubGVuZ3RoIC0gMTtcbiAgY29uc3QgZW5kID0gZG93bndhcmQgPyBpdGVtcy5sZW5ndGggOiAwO1xuICBjb25zdCBzdGVwID0gZG93bndhcmQgPyAxIDogLTE7XG4gIGNvbnN0IHNjcm9sbFRhcmdldCA9IGVsZW1lbnQuc2Nyb2xsVGFyZ2V0O1xuICBjb25zdCB0b3BPZkNsaWVudEFyZWEgPSBzY3JvbGxUYXJnZXQub2Zmc2V0VG9wICsgc2Nyb2xsVGFyZ2V0LmNsaWVudFRvcDtcblxuICAvLyBGaW5kIHRoZSBpdGVtIHNwYW5uaW5nIHRoZSBpbmRpY2F0ZWQgeSBjb29yZGluYXRlLlxuICBsZXQgaXRlbTtcbiAgbGV0IGl0ZW1JbmRleCA9IHN0YXJ0O1xuICBsZXQgaXRlbVRvcDtcbiAgbGV0IGZvdW5kID0gZmFsc2U7XG4gIHdoaWxlIChpdGVtSW5kZXggIT09IGVuZCkge1xuICAgIGl0ZW0gPSBpdGVtc1tpdGVtSW5kZXhdO1xuICAgIGl0ZW1Ub3AgPSBpdGVtLm9mZnNldFRvcCAtIHRvcE9mQ2xpZW50QXJlYTtcbiAgICBjb25zdCBpdGVtQm90dG9tID0gaXRlbVRvcCArIGl0ZW0ub2Zmc2V0SGVpZ2h0O1xuICAgIGlmIChpdGVtVG9wIDw9IHkgJiYgaXRlbUJvdHRvbSA+PSB5KSB7XG4gICAgICAvLyBJdGVtIHNwYW5zIHRoZSBpbmRpY2F0ZWQgeSBjb29yZGluYXRlLlxuICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGl0ZW1JbmRleCArPSBzdGVwO1xuICB9XG5cbiAgaWYgKCFmb3VuZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gV2UgbWF5IGhhdmUgZm91bmQgYW4gaXRlbSB3aG9zZSBwYWRkaW5nIHNwYW5zIHRoZSBnaXZlbiB5IGNvb3JkaW5hdGUsXG4gIC8vIGJ1dCB3aG9zZSBjb250ZW50IGlzIGFjdHVhbGx5IGFib3ZlL2JlbG93IHRoYXQgcG9pbnQuXG4gIC8vIFRPRE86IElmIHRoZSBpdGVtIGhhcyBhIGJvcmRlciwgdGhlbiBwYWRkaW5nIHNob3VsZCBiZSBpbmNsdWRlZCBpblxuICAvLyBjb25zaWRlcmluZyBhIGhpdC5cbiAgY29uc3QgaXRlbVN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShpdGVtKTtcbiAgY29uc3QgaXRlbVBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KGl0ZW1TdHlsZS5wYWRkaW5nVG9wKTtcbiAgY29uc3QgaXRlbVBhZGRpbmdCb3R0b20gPSBwYXJzZUZsb2F0KGl0ZW1TdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgY29uc3QgY29udGVudFRvcCA9IGl0ZW1Ub3AgKyBpdGVtLmNsaWVudFRvcCArIGl0ZW1QYWRkaW5nVG9wO1xuICBjb25zdCBjb250ZW50Qm90dG9tID0gY29udGVudFRvcCArIGl0ZW0uY2xpZW50SGVpZ2h0IC0gaXRlbVBhZGRpbmdUb3AgLSBpdGVtUGFkZGluZ0JvdHRvbTtcbiAgaWYgKGRvd253YXJkICYmIGNvbnRlbnRUb3AgPD0geSB8fCAhZG93bndhcmQgJiYgY29udGVudEJvdHRvbSA+PSB5KSB7XG4gICAgLy8gVGhlIGluZGljYXRlZCBjb29yZGluYXRlIGhpdHMgdGhlIGFjdHVhbCBpdGVtIGNvbnRlbnQuXG4gICAgcmV0dXJuIGl0ZW1JbmRleDtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBUaGUgaW5kaWNhdGVkIGNvb3JkaW5hdGUgZmFsbHMgd2l0aGluIHRoZSBpdGVtJ3MgcGFkZGluZy4gQmFjayB1cCB0b1xuICAgIC8vIHRoZSBpdGVtIGJlbG93L2Fib3ZlIHRoZSBpdGVtIHdlIGZvdW5kIGFuZCByZXR1cm4gdGhhdC5cbiAgICByZXR1cm4gaXRlbUluZGV4IC0gc3RlcDtcbiAgfVxufVxuXG4vLyBNb3ZlIGJ5IG9uZSBwYWdlIGRvd253YXJkIChpZiBkb3dud2FyZCBpcyB0cnVlKSwgb3IgdXB3YXJkIChpZiBmYWxzZSkuXG4vLyBSZXR1cm4gdHJ1ZSBpZiB3ZSBlbmRlZCB1cCBjaGFuZ2luZyB0aGUgc2VsZWN0aW9uLCBmYWxzZSBpZiBub3QuXG4vLyBUT0RPOiBCZXR0ZXIgc3VwcG9ydCBmb3IgaG9yaXpvbnRhbCBsaXN0cy5cbmZ1bmN0aW9uIHNjcm9sbE9uZVBhZ2UoZWxlbWVudCwgZG93bndhcmQpIHtcblxuICAvLyBEZXRlcm1pbmUgdGhlIGl0ZW0gdmlzaWJsZSBqdXN0IGF0IHRoZSBlZGdlIG9mIGRpcmVjdGlvbiB3ZSdyZSBoZWFkaW5nLlxuICAvLyBXZSdsbCBzZWxlY3QgdGhhdCBpdGVtIGlmIGl0J3Mgbm90IGFscmVhZHkgc2VsZWN0ZWQuXG4gIGNvbnN0IHNjcm9sbFRhcmdldCA9IGVsZW1lbnQuc2Nyb2xsVGFyZ2V0O1xuICBjb25zdCBlZGdlID0gc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCArIChkb3dud2FyZCA/IHNjcm9sbFRhcmdldC5jbGllbnRIZWlnaHQgOiAwKTtcbiAgY29uc3QgaW5kZXhPZkl0ZW1BdEVkZ2UgPSBnZXRJbmRleE9mSXRlbUF0WShlbGVtZW50LCBlZGdlLCBkb3dud2FyZCk7XG5cbiAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IGVsZW1lbnQuc2VsZWN0ZWRJbmRleDtcbiAgbGV0IG5ld0luZGV4O1xuICBpZiAoaW5kZXhPZkl0ZW1BdEVkZ2UgJiYgc2VsZWN0ZWRJbmRleCA9PT0gaW5kZXhPZkl0ZW1BdEVkZ2UpIHtcbiAgICAvLyBUaGUgaXRlbSBhdCB0aGUgZWRnZSB3YXMgYWxyZWFkeSBzZWxlY3RlZCwgc28gc2Nyb2xsIGluIHRoZSBpbmRpY2F0ZWRcbiAgICAvLyBkaXJlY3Rpb24gYnkgb25lIHBhZ2UuIExlYXZlIHRoZSBuZXcgaXRlbSBhdCB0aGF0IGVkZ2Ugc2VsZWN0ZWQuXG4gICAgY29uc3QgZGVsdGEgPSAoZG93bndhcmQgPyAxIDogLTEpICogc2Nyb2xsVGFyZ2V0LmNsaWVudEhlaWdodDtcbiAgICBuZXdJbmRleCA9IGdldEluZGV4T2ZJdGVtQXRZKGVsZW1lbnQsIGVkZ2UgKyBkZWx0YSwgZG93bndhcmQpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIFRoZSBpdGVtIGF0IHRoZSBlZGdlIHdhc24ndCBzZWxlY3RlZCB5ZXQuIEluc3RlYWQgb2Ygc2Nyb2xsaW5nLCB3ZSdsbFxuICAgIC8vIGp1c3Qgc2VsZWN0IHRoYXQgaXRlbS4gVGhhdCBpcywgdGhlIGZpcnN0IGF0dGVtcHQgdG8gcGFnZSB1cC9kb3duXG4gICAgLy8gdXN1YWxseSBqdXN0IG1vdmVzIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVkZ2UgaW4gdGhhdCBkaXJlY3Rpb24uXG4gICAgbmV3SW5kZXggPSBpbmRleE9mSXRlbUF0RWRnZTtcbiAgfVxuXG4gIGlmICghbmV3SW5kZXgpIHtcbiAgICAvLyBXZSBjYW4ndCBmaW5kIGFuIGl0ZW0gaW4gdGhlIGRpcmVjdGlvbiB3ZSB3YW50IHRvIHRyYXZlbC4gU2VsZWN0IHRoZVxuICAgIC8vIGxhc3QgaXRlbSAoaWYgbW92aW5nIGRvd253YXJkKSBvciBmaXJzdCBpdGVtIChpZiBtb3ZpbmcgdXB3YXJkKS5cbiAgICBuZXdJbmRleCA9IChkb3dud2FyZCA/IGVsZW1lbnQuaXRlbXMubGVuZ3RoIC0gMSA6IDApO1xuICB9XG5cbiAgaWYgKG5ld0luZGV4ICE9PSBzZWxlY3RlZEluZGV4KSB7XG4gICAgZWxlbWVudC5zZWxlY3RlZEluZGV4ID0gbmV3SW5kZXg7XG4gICAgcmV0dXJuIHRydWU7IC8vIFdlIGhhbmRsZWQgdGhlIHBhZ2UgdXAvZG93biBvdXJzZWx2ZXMuXG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBXZSBkaWRuJ3QgZG8gYW55dGhpbmcuXG4gIH1cbn1cbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi9zeW1ib2xzJztcblxuXG4vLyBTeW1ib2xzIGZvciBwcml2YXRlIGRhdGEgbWVtYmVycyBvbiBhbiBlbGVtZW50LlxuY29uc3QgaXRlbVRleHRDb250ZW50c1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnaXRlbVRleHRDb250ZW50cycpO1xuY29uc3QgdHlwZWRQcmVmaXhTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3R5cGVkUHJlZml4Jyk7XG5jb25zdCBwcmVmaXhUaW1lb3V0U3ltYm9sID0gY3JlYXRlU3ltYm9sKCdwcmVmaXhUaW1lb3V0Jyk7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBLZXlib2FyZFByZWZpeFNlbGVjdGlvbi4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHRoYXQgaGFuZGxlcyBsaXN0IGJveC1zdHlsZSBwcmVmaXggdHlwaW5nLCBpbiB3aGljaCB0aGUgdXNlciBjYW4gdHlwZVxuICAgKiBhIHN0cmluZyB0byBzZWxlY3QgdGhlIGZpcnN0IGl0ZW0gdGhhdCBiZWdpbnMgd2l0aCB0aGF0IHN0cmluZy5cbiAgICpcbiAgICogRXhhbXBsZTogc3VwcG9zZSBhIGNvbXBvbmVudCB1c2luZyB0aGlzIG1peGluIGhhcyB0aGUgZm9sbG93aW5nIGl0ZW1zOlxuICAgKlxuICAgKiAgICAgPHNhbXBsZS1saXN0LWNvbXBvbmVudD5cbiAgICogICAgICAgPGRpdj5BcHBsZTwvZGl2PlxuICAgKiAgICAgICA8ZGl2PkFwcmljb3Q8L2Rpdj5cbiAgICogICAgICAgPGRpdj5CYW5hbmE8L2Rpdj5cbiAgICogICAgICAgPGRpdj5CbGFja2JlcnJ5PC9kaXY+XG4gICAqICAgICAgIDxkaXY+Qmx1ZWJlcnJ5PC9kaXY+XG4gICAqICAgICAgIDxkaXY+Q2FudGFsb3VwZTwvZGl2PlxuICAgKiAgICAgICA8ZGl2PkNoZXJyeTwvZGl2PlxuICAgKiAgICAgICA8ZGl2PkxlbW9uPC9kaXY+XG4gICAqICAgICAgIDxkaXY+TGltZTwvZGl2PlxuICAgKiAgICAgPC9zYW1wbGUtbGlzdC1jb21wb25lbnQ+XG4gICAqXG4gICAqIElmIHRoaXMgY29tcG9uZW50IHJlY2VpdmVzIHRoZSBmb2N1cywgYW5kIHRoZSB1c2VyIHByZXNzZXMgdGhlIFwiYlwiIG9yIFwiQlwiXG4gICAqIGtleSwgdGhlIFwiQmFuYW5hXCIgaXRlbSB3aWxsIGJlIHNlbGVjdGVkLCBiZWNhdXNlIGl0J3MgdGhlIGZpcnN0IGl0ZW0gdGhhdFxuICAgKiBtYXRjaGVzIHRoZSBwcmVmaXggXCJiXCIuIChNYXRjaGluZyBpcyBjYXNlLWluc2Vuc2l0aXZlLikgSWYgdGhlIHVzZXIgbm93XG4gICAqIHByZXNzZXMgdGhlIFwibFwiIG9yIFwiTFwiIGtleSBxdWlja2x5LCB0aGUgcHJlZml4IHRvIG1hdGNoIGJlY29tZXMgXCJibFwiLCBzb1xuICAgKiBcIkJsYWNrYmVycnlcIiB3aWxsIGJlIHNlbGVjdGVkLlxuICAgKlxuICAgKiBUaGUgcHJlZml4IHR5cGluZyBmZWF0dXJlIGhhcyBhIG9uZSBzZWNvbmQgdGltZW91dCDigJTCoHRoZSBwcmVmaXggdG8gbWF0Y2hcbiAgICogd2lsbCBiZSByZXNldCBhZnRlciBhIHNlY29uZCBoYXMgcGFzc2VkIHNpbmNlIHRoZSB1c2VyIGxhc3QgdHlwZWQgYSBrZXkuXG4gICAqIElmLCBpbiB0aGUgYWJvdmUgZXhhbXBsZSwgdGhlIHVzZXIgd2FpdHMgYSBzZWNvbmQgYmV0d2VlbiB0eXBpbmcgXCJiXCIgYW5kXG4gICAqIFwibFwiLCB0aGUgcHJlZml4IHdpbGwgYmVjb21lIFwibFwiLCBzbyBcIkxlbW9uXCIgd291bGQgYmUgc2VsZWN0ZWQuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyB0aGUgY29tcG9uZW50IHRvIGludm9rZSBhIGBrZXlkb3duYCBtZXRob2Qgd2hlbiBhIGtleSBpc1xuICAgKiBwcmVzc2VkLiBZb3UgY2FuIHVzZSBbS2V5Ym9hcmRNaXhpbl0oS2V5Ym9hcmRNaXhpbi5tZCkgZm9yIHRoYXRcbiAgICogcHVycG9zZSwgb3Igd2lyZSB1cCB5b3VyIG93biBrZXlib2FyZCBoYW5kbGluZyBhbmQgY2FsbCBga2V5ZG93bmAgeW91cnNlbGYuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gYWxzbyBleHBlY3RzIHRoZSBjb21wb25lbnQgdG8gcHJvdmlkZSBhbiBgaXRlbXNgIHByb3BlcnR5LiBUaGVcbiAgICogYHRleHRDb250ZW50YCBvZiB0aG9zZSBpdGVtcyB3aWxsIGJlIHVzZWQgZm9yIHB1cnBvc2VzIG9mIHByZWZpeCBtYXRjaGluZy5cbiAgICovXG4gIGNsYXNzIEtleWJvYXJkUHJlZml4U2VsZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICAvLyBUT0RPOiBJZiB0aGUgc2V0IG9mIGl0ZW1zIGlzIGNoYW5nZWQsIHJlc2V0IHRoZSBwcmVmaXguXG4gICAgLy8gW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpIHtcbiAgICAvLyAgIHRoaXNbaXRlbVRleHRDb250ZW50c1N5bWJvbF0gPSBudWxsO1xuICAgIC8vICAgcmVzZXRUeXBlZFByZWZpeCh0aGlzKTtcbiAgICAvLyB9XG5cbiAgICAvLyBUT0RPOiBJZiB0aGUgc2VsZWN0aW9uIGlzIGNoYW5nZWQgYnkgc29tZSBvdGhlciBtZWFucyAoZS5nLiwgYXJyb3cga2V5cylcbiAgICAvLyBvdGhlciB0aGFuIHByZWZpeCB0eXBpbmcsIHRoZW4gdGhhdCBhY3Qgc2hvdWxkIHJlc2V0IHRoZSBwcmVmaXguXG5cbiAgICBbc3ltYm9scy5rZXlkb3duXShldmVudCkge1xuICAgICAgbGV0IGhhbmRsZWQ7XG4gICAgICBsZXQgcmVzZXRQcmVmaXggPSB0cnVlO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSA4OiAvLyBCYWNrc3BhY2VcbiAgICAgICAgICBoYW5kbGVCYWNrc3BhY2UodGhpcyk7XG4gICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzZXRQcmVmaXggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNzogLy8gRXNjYXBlXG4gICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFldmVudC5jdHJsS2V5ICYmICFldmVudC5tZXRhS2V5ICYmICFldmVudC5hbHRLZXkgJiZcbiAgICAgICAgICAgICAgZXZlbnQud2hpY2ggIT09IDMyIC8qIFNwYWNlICovKSB7XG4gICAgICAgICAgICBoYW5kbGVQbGFpbkNoYXJhY3Rlcih0aGlzLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LndoaWNoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc2V0UHJlZml4ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXNldFByZWZpeCkge1xuICAgICAgICByZXNldFR5cGVkUHJlZml4KHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVmZXIgbWl4aW4gcmVzdWx0IGlmIGl0J3MgZGVmaW5lZCwgb3RoZXJ3aXNlIHVzZSBiYXNlIHJlc3VsdC5cbiAgICAgIHJldHVybiBoYW5kbGVkIHx8IChzdXBlcltzeW1ib2xzLmtleWRvd25dICYmIHN1cGVyW3N5bWJvbHMua2V5ZG93bl0oZXZlbnQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIGZpcnN0IGl0ZW0gd2hvc2UgdGV4dCBjb250ZW50IGJlZ2lucyB3aXRoIHRoZSBnaXZlbiBwcmVmaXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJlZml4IFtTdHJpbmddIFRoZSBwcmVmaXggc3RyaW5nIHRvIHNlYXJjaCBmb3JcbiAgICAgKi9cbiAgICBzZWxlY3RJdGVtV2l0aFRleHRQcmVmaXgocHJlZml4KSB7XG4gICAgICBpZiAoc3VwZXIuc2VsZWN0SXRlbVdpdGhUZXh0UHJlZml4KSB7IHN1cGVyLnNlbGVjdEl0ZW1XaXRoVGV4dFByZWZpeChwcmVmaXgpOyB9XG4gICAgICBpZiAocHJlZml4ID09IG51bGwgfHwgcHJlZml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4T2ZJdGVtV2l0aFRleHRQcmVmaXgodGhpcywgcHJlZml4KTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEtleWJvYXJkUHJlZml4U2VsZWN0aW9uO1xufTtcblxuXG4vLyBUaW1lIGluIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCB0aGUgdXNlciBpcyBjb25zaWRlcmVkIHRvIGhhdmUgc3RvcHBlZFxuLy8gdHlwaW5nLlxuY29uc3QgUFJFRklYX1RJTUVPVVRfRFVSQVRJT04gPSAxMDAwO1xuXG5cbi8vIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gd2l0aCB0aGUgZ2l2ZW4gcHJlZml4LCBlbHNlIC0xLlxuZnVuY3Rpb24gZ2V0SW5kZXhPZkl0ZW1XaXRoVGV4dFByZWZpeChlbGVtZW50LCBwcmVmaXgpIHtcbiAgY29uc3QgaXRlbVRleHRDb250ZW50cyA9IGdldEl0ZW1UZXh0Q29udGVudHMoZWxlbWVudCk7XG4gIGNvbnN0IHByZWZpeExlbmd0aCA9IHByZWZpeC5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbVRleHRDb250ZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGl0ZW1UZXh0Q29udGVudCA9IGl0ZW1UZXh0Q29udGVudHNbaV07XG4gICAgaWYgKGl0ZW1UZXh0Q29udGVudC5zdWJzdHIoMCwgcHJlZml4TGVuZ3RoKSA9PT0gcHJlZml4KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vLyBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHRleHQgY29udGVudCAoaW4gbG93ZXJjYXNlKSBvZiBhbGwgaXRlbXMuXG4vLyBDYWNoZSB0aGVzZSByZXN1bHRzLlxuZnVuY3Rpb24gZ2V0SXRlbVRleHRDb250ZW50cyhlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudFtpdGVtVGV4dENvbnRlbnRzU3ltYm9sXSkge1xuICAgIGNvbnN0IGl0ZW1zID0gZWxlbWVudC5pdGVtcztcbiAgICBlbGVtZW50W2l0ZW1UZXh0Q29udGVudHNTeW1ib2xdID0gaXRlbXMubWFwKGNoaWxkID0+IHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaGlsZC50ZXh0Q29udGVudCB8fCBjaGlsZC5hbHQ7XG4gICAgICByZXR1cm4gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlbGVtZW50W2l0ZW1UZXh0Q29udGVudHNTeW1ib2xdO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVCYWNrc3BhY2UoZWxlbWVudCkge1xuICBjb25zdCBsZW5ndGggPSBlbGVtZW50W3R5cGVkUHJlZml4U3ltYm9sXSA/IGVsZW1lbnRbdHlwZWRQcmVmaXhTeW1ib2xdLmxlbmd0aCA6IDA7XG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudFt0eXBlZFByZWZpeFN5bWJvbF0gPSBlbGVtZW50W3R5cGVkUHJlZml4U3ltYm9sXS5zdWJzdHIoMCwgbGVuZ3RoIC0gMSk7XG4gIH1cbiAgZWxlbWVudC5zZWxlY3RJdGVtV2l0aFRleHRQcmVmaXgoZWxlbWVudFt0eXBlZFByZWZpeFN5bWJvbF0pO1xuICBzZXRQcmVmaXhUaW1lb3V0KGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVQbGFpbkNoYXJhY3RlcihlbGVtZW50LCBjaGFyKSB7XG4gIGNvbnN0IHByZWZpeCA9IGVsZW1lbnRbdHlwZWRQcmVmaXhTeW1ib2xdIHx8ICcnO1xuICBlbGVtZW50W3R5cGVkUHJlZml4U3ltYm9sXSA9IHByZWZpeCArIGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgZWxlbWVudC5zZWxlY3RJdGVtV2l0aFRleHRQcmVmaXgoZWxlbWVudFt0eXBlZFByZWZpeFN5bWJvbF0pO1xuICBzZXRQcmVmaXhUaW1lb3V0KGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiByZXNldFByZWZpeFRpbWVvdXQoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudFtwcmVmaXhUaW1lb3V0U3ltYm9sXSkge1xuICAgIGNsZWFyVGltZW91dChlbGVtZW50W3ByZWZpeFRpbWVvdXRTeW1ib2xdKTtcbiAgICBlbGVtZW50W3ByZWZpeFRpbWVvdXRTeW1ib2xdID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRUeXBlZFByZWZpeChlbGVtZW50KSB7XG4gIGVsZW1lbnRbdHlwZWRQcmVmaXhTeW1ib2xdID0gJyc7XG4gIHJlc2V0UHJlZml4VGltZW91dChlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gc2V0UHJlZml4VGltZW91dChlbGVtZW50KSB7XG4gIHJlc2V0UHJlZml4VGltZW91dChlbGVtZW50KTtcbiAgZWxlbWVudFtwcmVmaXhUaW1lb3V0U3ltYm9sXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHJlc2V0VHlwZWRQcmVmaXgoZWxlbWVudCk7XG4gIH0sIFBSRUZJWF9USU1FT1VUX0RVUkFUSU9OKTtcbn1cbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IHNhZmVBdHRyaWJ1dGVzIGZyb20gJy4vc2FmZUF0dHJpYnV0ZXMnO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi9zeW1ib2xzJztcblxuXG4vLyBTeW1ib2xzIGZvciBwcml2YXRlIGRhdGEgbWVtYmVycyBvbiBhbiBlbGVtZW50LlxuY29uc3QgY2xvc2VkU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdjbG9zZWQnKTtcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIE9wZW5DbG9zZS4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIGFkZHMgY2xvc2Uvb3BlbiBzZW1hbnRpY3MuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZG9lcyBub3QgcHJvZHVjZSBhbnkgdXNlci12aXNpYmxlIGVmZmVjdHMuIEluc3RlYWQgaXQgYXBwbGllc1xuICAgKiBhIGBiYXNpYy1jbG9zZWRgIENTUyBjbGFzcyB0byB0aGUgY29tcG9uZW50IGhvc3QgaWYgdGhlIGhvc3QgaXNcbiAgICogY2xvc2VkLCBhbmQgYSBgYmFzaWMtb3BlbmVkYCBjbGFzcyBpZiBvcGVuZWQuIEl0IGFsc28gaW52b2tlcyBhIGByZW5kZXJgXG4gICAqIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4gdG8gYXBwbHkgY3VzdG9tIGVmZmVjdHMuXG4gICAqL1xuICBjbGFzcyBPcGVuQ2xvc2UgZXh0ZW5kcyBiYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8vIFNldCBkZWZhdWx0cy5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5jbG9zZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdGhpc1tzeW1ib2xzLmRlZmF1bHRzXS5jbG9zZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIHRoZSBgY2xvc2VkYCBwcm9wZXJ0eSB0byB0cnVlLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyBjdXJlbnRseSBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICByZXR1cm4gdGhpc1tjbG9zZWRTeW1ib2xdO1xuICAgIH1cbiAgICBzZXQgY2xvc2VkKHZhbHVlKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0Nsb3NlZCA9IHRoaXNbY2xvc2VkU3ltYm9sXTtcbiAgICAgIHRoaXNbY2xvc2VkU3ltYm9sXSA9IHZhbHVlO1xuICAgICAgaWYgKCdjbG9zZWQnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLmNsb3NlZCA9IHZhbHVlOyB9XG4gICAgICBpZiAodmFsdWUgIT09IHByZXZpb3VzQ2xvc2VkKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKHZhbHVlKTtcblxuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2xvc2VkLWNoYW5nZWQnKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgICBzYWZlQXR0cmlidXRlcy5jb25uZWN0ZWQodGhpcyk7XG4gICAgICB0aGlzLnJlbmRlcih0aGlzLmNsb3NlZCk7XG4gICAgfVxuXG4gICAgZ2V0IFtzeW1ib2xzLmRlZmF1bHRzXSgpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRzID0gc3VwZXJbc3ltYm9scy5kZWZhdWx0c10gfHwge307XG4gICAgICBkZWZhdWx0cy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gc2V0dGluZyB0aGUgYGNsb3NlZGAgcHJvcGVydHkgdG8gZmFsc2UuXG4gICAgICovXG4gICAgb3BlbigpIHtcbiAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBjdXN0b20gcmVuZGVyaW5nIG9mIHRoZSBjbG9zZS9vcGVuIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gY3VzdG9tIGVmZmVjdHMuIElmIHlvdSBkbyBzbyxcbiAgICAgKiBiZSBzdXJlIHRvIGludm9rZSBgc3VwZXIoKWAgaW4geW91ciBpbXBsZW1lbnRhdGlvbiB0byBnZXQgdGhlIGJhc2VsaW5lXG4gICAgICogYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsb3NpbmcgLSBUcnVlIGlmIHRoZSBjb21wb25lbnQgaXMgYmVpbmcgY2xvc2VkLFxuICAgICAqICAgICAgICBmYWxzZSBpZiBpdCdzIGJlaW5nIG9wZW5lZC5cbiAgICAgKi9cbiAgICByZW5kZXIoY2xvc2luZykge1xuICAgICAgaWYgKHN1cGVyLnJlbmRlcikgeyBzdXBlci5yZW5kZXIoKTsgfVxuICAgICAgc2FmZUF0dHJpYnV0ZXMudG9nZ2xlQ2xhc3ModGhpcywgJ2Jhc2ljLWNsb3NlZCcsIGNsb3NpbmcpO1xuICAgICAgc2FmZUF0dHJpYnV0ZXMudG9nZ2xlQ2xhc3ModGhpcywgJ2Jhc2ljLW9wZW5lZCcsICFjbG9zaW5nKTtcbiAgICAgIHNhZmVBdHRyaWJ1dGVzLnNldEF0dHJpYnV0ZSh0aGlzLCAnYXJpYS1leHBhbmRlZCcsICFjbG9zaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIGNvbXBvbmVudCdzIG9wZW4vY2xvc2VkIHN0YXRlLlxuICAgICAqL1xuICAgIHRvZ2dsZSgpIHtcbiAgICAgIHRoaXMuY2xvc2VkID0gIXRoaXMuY2xvc2VkO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIE9wZW5DbG9zZTtcbn07XG4iLCJpbXBvcnQgcmVuZGVyQXJyYXlBc0VsZW1lbnRzIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3JlbmRlckFycmF5QXNFbGVtZW50cyc7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zeW1ib2xzJztcbmltcG9ydCB0b2dnbGVDbGFzcyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy90b2dnbGVDbGFzcyc7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBQYWdlRG90cy4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIFRlbXBsYXRlIG1peGluIHdoaWNoIGFkZHMgc21hbGwgZG90cyB0byBzaG93IHRoZSBudW1iZXIgb2YgaXRlbXMgYW5kIGxldFxuICAgKiB0aGUgdXNlciBzZWxlY3QgYSBzcGVjaWZpYyBpdGVtLlxuICAgKlxuICAgKiBZb3UgY2FuIHNlZSBhXG4gICAqIFtsaXZlIGRlbW9dKGh0dHA6Ly9iYXNpY3dlYmNvbXBvbmVudHMub3JnL2Jhc2ljLXdlYi1jb21wb25lbnRzL3BhY2thZ2VzL2RlbW9zL2Nhcm91c2VsLXdpdGgtZG90cy5odG1sKVxuICAgKiBvZiB0aGlzIG1peGluIGFwcGxpZWQgdG8gYSBjYXJvdXNlbC5cbiAgICpcbiAgICogVGhlcmUgd2lsbCBiZSBvbmUgZG90IGZvciBlYWNoIGl0ZW0sIGFuZCB0aGUgZG90IGZvciB0aGUgY3VycmVudGx5IHNlbGVjdGVkXG4gICAqIGl0ZW0gd2lsbCBiZSBzaG93biBzZWxlY3RlZC5cbiAgICpcbiAgICogVHlwaWNhbCB1c2FnZTpcbiAgICpcbiAgICogICAgIGNsYXNzIENhcm91c2VsV2l0aERvdHMgZXh0ZW5kcyBQYWdlRG90c01peGluKENhcm91c2VsKSB7fVxuICAgKiAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdjYXJvdXNlbC13aXRoLWRvdHMnLCBDYXJvdXNlbFdpdGhEb3RzKTtcbiAgICpcbiAgICogQWx0aG91Z2ggdGhlIGRvdHMgYXJlIHF1aXRlIHNtYWxsIGJ5IGRlZmF1bHQsIGNsaWNraW5nL3RhcHBpbmcgYSBkb3Qgd2lsbFxuICAgKiB3aWxsIHNlbGVjdCB0aGUgY29ycmVzcG9uZGluZyBsaXN0IGl0ZW0uXG4gICAqL1xuICBjbGFzcyBQYWdlRG90cyBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICB0aGlzLiQuZG90cy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgZG90ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBjb25zdCBkb3RJbmRleCA9IHRoaXMuZG90cy5pbmRleE9mKGRvdCk7XG4gICAgICAgIGlmIChkb3RJbmRleCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gZG90SW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldCBkb3RzKCkge1xuICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodGhpcy4kLmRvdHMucXVlcnlTZWxlY3RvckFsbCgnLmRvdCcpKTtcbiAgICB9XG5cbiAgICBbc3ltYm9scy5pdGVtc0NoYW5nZWRdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSkgeyBzdXBlcltzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKTsgfVxuICAgICAgcmVuZGVyQXJyYXlBc0VsZW1lbnRzKHRoaXMuaXRlbXMsIHRoaXMuJC5kb3RzLCAoaXRlbSwgZWxlbWVudCkgPT4ge1xuICAgICAgICAvLyBXZSBkb24ndCB1c2UgdGhlIGl0ZW0gcGFyYW1ldGVyLCBiZWNhdXNlIGFueSBpdGVtIHdpbGwgcHJvZHVjZSBhblxuICAgICAgICAvLyBpZGVudGljYWwgY29ycmVzcG9uZGluZyBkb3QuXG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2RvdCcpO1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc3R5bGUtc2NvcGUnKTtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2Jhc2ljLXBhZ2UtZG90cycpO1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ25vbmUnKTtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZWZyZXNoRG90cyh0aGlzKTtcbiAgICB9XG5cbiAgICBbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIHNlbGVjdGVkKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCk7IH1cbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgLy8gU2VlIGlmIHRoZSBjb3JyZXNwb25kaW5nIGRvdCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQuXG4gICAgICAvLyBJZiBub3QsIHRoZSBjb3JyZWN0IGRvdCB3aWxsIGJlIHNlbGVjdGVkIHdoZW4gaXQgZ2V0cyBjcmVhdGVkLlxuICAgICAgY29uc3QgZG90cyA9IHRoaXMuZG90cztcbiAgICAgIGlmIChkb3RzICYmIGRvdHMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgICAgY29uc3QgZG90ID0gdGhpcy5kb3RzW2luZGV4XTtcbiAgICAgICAgaWYgKGRvdCkge1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRvdCwgJ3NlbGVjdGVkJywgc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIHRoZSB1c2VyIGhhcyBtb3ZlZCB0aGUgZmlyc3QgdG91Y2hwb2ludCBzaW5jZSB0aGUgYmVnaW5uaW5nXG4gICAgICogb2YgYSBkcmFnLCBleHByZXNzZWQgYXMgYSBmcmFjdGlvbiBvZiB0aGUgZWxlbWVudCdzIHdpZHRoLlxuICAgICAqXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkRnJhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3VwZXIuc2VsZWN0ZWRGcmFjdGlvbjtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkRnJhY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICgnc2VsZWN0ZWRGcmFjdGlvbicgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRGcmFjdGlvbiA9IHZhbHVlOyB9XG4gICAgICByZW5kZXJUcmFuc2l0aW9uKHRoaXMsIHRoaXMuc2VsZWN0ZWRJbmRleCwgdmFsdWUpO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnNlbGVjdGVkSW5kZXg7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEluZGV4KGluZGV4KSB7XG4gICAgICBpZiAoJ3NlbGVjdGVkSW5kZXgnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGVkSW5kZXggPSBpbmRleDsgfVxuICAgICAgcmVmcmVzaERvdHModGhpcyk7XG4gICAgfVxuXG4gICAgZ2V0IFtzeW1ib2xzLnRlbXBsYXRlXSgpIHtcbiAgICAgIGNvbnN0IGJhc2VUZW1wbGF0ZSA9IHN1cGVyW3N5bWJvbHMudGVtcGxhdGVdIHx8ICcnO1xuICAgICAgcmV0dXJuIGBcbiAgICAgICAgPHN0eWxlPlxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB9XG5cbiAgICAgICAgI2RvdHMge1xuICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAtd2Via2l0LWp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgI2RvdE5hdmlnYXRpb25Db250YWluZXIge1xuICAgICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIC13ZWJraXQtZmxleDogMTtcbiAgICAgICAgICBmbGV4OiAxO1xuICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICB6LWluZGV4OiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgI2NvbnRhaW5lciA6OnNsb3R0ZWQoKikge1xuICAgICAgICAgIC13ZWJraXQtZmxleDogMTtcbiAgICAgICAgICBmbGV4OiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLmRvdCB7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmdiKDI1NSwgMjU1LCAyNTUpO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDdweDtcbiAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMXB4IDFweCByZ2JhKDAsIDAsIDAsIDAuNSk7XG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgaGVpZ2h0OiA4cHg7XG4gICAgICAgICAgbWFyZ2luOiA3cHggNXB4O1xuICAgICAgICAgIG9wYWNpdHk6IDAuNDtcbiAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQgMC4ycyBib3gtc2hhZG93IDAuMnM7XG4gICAgICAgICAgd2lkdGg6IDhweDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kb3Q6aG92ZXIge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gICAgICAgICAgYm94LXNoYWRvdzogMCAwIDFweCAzcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLmRvdC5zZWxlY3RlZCB7XG4gICAgICAgICAgb3BhY2l0eTogMC45NTtcbiAgICAgICAgfVxuXG4gICAgICAgIEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xuICAgICAgICAgIC5kb3Qge1xuICAgICAgICAgICAgaGVpZ2h0OiAxMnB4O1xuICAgICAgICAgICAgd2lkdGg6IDEycHg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIDwvc3R5bGU+XG5cbiAgICAgICAgPGRpdiBpZD1cImRvdHNcIiByb2xlPVwibm9uZVwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwiZG90TmF2aWdhdGlvbkNvbnRhaW5lclwiIHJvbGU9XCJub25lXCI+XG4gICAgICAgICAgJHtiYXNlVGVtcGxhdGV9XG4gICAgICAgIDwvZGl2PlxuICAgICAgYDtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBQYWdlRG90cztcbn07XG5cblxuLy8gUmV0dXJuIHRoZSBpbmRleCwgZW5zdXJpbmcgaXQgc3RheXMgYmV0d2VlbiAwIGFuZCB0aGUgZ2l2ZW4gbGVuZ3RoLlxuZnVuY3Rpb24ga2VlcEluZGV4V2l0aGluQm91bmRzKGxlbmd0aCwgaW5kZXgpIHtcbiAgLy8gSGFuZGxlIHBvc3NpYmlsaXR5IG9mIG5lZ2F0aXZlIG1vZC5cbiAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE4NjE4MjUwLzc2NDcyXG4gIHJldHVybiAoKGluZGV4ICUgbGVuZ3RoKSArIGxlbmd0aCkgJSBsZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclRyYW5zaXRpb24oZWxlbWVudCwgc2VsZWN0ZWRJbmRleCwgc2VsZWN0ZWRGcmFjdGlvbikge1xuICBjb25zdCBkb3RzID0gZWxlbWVudC5kb3RzO1xuICBpZiAoIWRvdHMgfHwgZG90cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZG90Q291bnQgPSBkb3RzLmxlbmd0aDtcbiAgY29uc3Qgb3BhY2l0eU1pbmltdW0gPSAwLjQ7XG4gIGNvbnN0IG9wYWNpdHlNYXhpbXVtID0gMC45NTtcbiAgY29uc3Qgb3BhY2l0eVJhbmdlID0gb3BhY2l0eU1heGltdW0gLSBvcGFjaXR5TWluaW11bTtcbiAgY29uc3QgZnJhY3Rpb25hbEluZGV4ID0gc2VsZWN0ZWRJbmRleCArIHNlbGVjdGVkRnJhY3Rpb247XG4gIGNvbnN0IGxlZnRJbmRleCA9IE1hdGguZmxvb3IoZnJhY3Rpb25hbEluZGV4KTtcbiAgY29uc3QgcmlnaHRJbmRleCA9IE1hdGguY2VpbChmcmFjdGlvbmFsSW5kZXgpO1xuICBjb25zdCBzZWxlY3Rpb25XcmFwcyA9IGVsZW1lbnQuc2VsZWN0aW9uV3JhcHM7XG4gIGxldCBhd2F5SW5kZXggPSBzZWxlY3RlZEZyYWN0aW9uID49IDAgPyBsZWZ0SW5kZXggOiByaWdodEluZGV4O1xuICBsZXQgdG93YXJkSW5kZXggPSBzZWxlY3RlZEZyYWN0aW9uID49IDAgPyByaWdodEluZGV4IDogbGVmdEluZGV4O1xuICBpZiAoc2VsZWN0aW9uV3JhcHMpIHtcbiAgICBhd2F5SW5kZXggPSBrZWVwSW5kZXhXaXRoaW5Cb3VuZHMoZG90Q291bnQsIGF3YXlJbmRleCk7XG4gICAgdG93YXJkSW5kZXggPSBrZWVwSW5kZXhXaXRoaW5Cb3VuZHMoZG90Q291bnQsIHRvd2FyZEluZGV4KTtcbiAgfVxuICAvLyBTdHVwaWQgSUUgZG9lc24ndCBoYXZlIE1hdGgudHJ1bmMuXG4gIC8vIGNvbnN0IHRydW5jYXRlZFNlbGVjdGVkRnJhY3Rpb24gPSBNYXRoLnRydW5jKHNlbGVjdGVkRnJhY3Rpb24pO1xuICBjb25zdCB0cnVuY2F0ZWRTZWxlY3RlZEZyYWN0aW9uID0gc2VsZWN0ZWRGcmFjdGlvbiA8IDAgPyBNYXRoLmNlaWwoc2VsZWN0ZWRGcmFjdGlvbikgOiBNYXRoLmZsb29yKHNlbGVjdGVkRnJhY3Rpb24pO1xuICBjb25zdCBwcm9ncmVzcyA9IHNlbGVjdGVkRnJhY3Rpb24gLSB0cnVuY2F0ZWRTZWxlY3RlZEZyYWN0aW9uO1xuICBjb25zdCBvcGFjaXR5UHJvZ3Jlc3NUaHJvdWdoUmFuZ2UgPSBNYXRoLmFicyhwcm9ncmVzcykgKiBvcGFjaXR5UmFuZ2U7XG4gIGRvdHMuZm9yRWFjaCgoZG90LCBpbmRleCkgPT4ge1xuICAgIGxldCBkb3RPcGFjaXR5O1xuICAgIGlmIChzZWxlY3RlZEZyYWN0aW9uID09PSAwKSB7XG4gICAgICAvLyBSZW1vdmUgZXhwbGljaXQgb3BhY2l0eSBhbmQgcmVseSBvbiBzdHlsaW5nLlxuICAgICAgZG90T3BhY2l0eSA9ICcnO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGF3YXlJbmRleCkge1xuICAgICAgZG90T3BhY2l0eSA9IG9wYWNpdHlNYXhpbXVtIC0gb3BhY2l0eVByb2dyZXNzVGhyb3VnaFJhbmdlO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IHRvd2FyZEluZGV4KSB7XG4gICAgICBkb3RPcGFjaXR5ID0gb3BhY2l0eU1pbmltdW0gKyBvcGFjaXR5UHJvZ3Jlc3NUaHJvdWdoUmFuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvdE9wYWNpdHkgPSBvcGFjaXR5TWluaW11bTtcbiAgICB9XG4gICAgZG90LnN0eWxlLm9wYWNpdHkgPSBkb3RPcGFjaXR5O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVmcmVzaERvdHMoZWxlbWVudCkge1xuICBjb25zdCBzZWxlY3RlZEluZGV4ID0gZWxlbWVudC5zZWxlY3RlZEluZGV4O1xuICBlbGVtZW50LmRvdHMuZm9yRWFjaCgoZG90LCBpKSA9PiB7XG4gICAgdG9nZ2xlQ2xhc3MoZG90LCAnc2VsZWN0ZWQnLCBpID09PSBzZWxlY3RlZEluZGV4KTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgc2FmZUF0dHJpYnV0ZXMgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc2FmZUF0dHJpYnV0ZXMnO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc3ltYm9scyc7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBQbGF5Q29udHJvbHMuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBUZW1wbGF0ZSBtaXhpbiB3aGljaCBhZGRzIGJ1dHRvbnMgZm9yIG1hbmFnaW5nIHBsYXliYWNrIG9mIGEgc2xpZGVzaG93LFxuICAgKiBhdWRpbyBwbGF5bGlzdCwgZXRjLlxuICAgKlxuICAgKiBUeXBpY2FsIHVzYWdlOlxuICAgKlxuICAgKiAgICAgY2xhc3MgU2xpZGVzaG93V2l0aENvbnRyb2xzIGV4dGVuZHMgUGxheUNvbnRyb2xzTWl4aW4oU2xpZGVzaG93KSB7fVxuICAgKiAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzbGlkZXNob3ctd2l0aC1jb250cm9scycsIFNsaWRlc2hvd1dpdGhDb250cm9scyk7XG4gICAqXG4gICAqL1xuICBjbGFzcyBQbGF5Q29udHJvbHMgZXh0ZW5kcyBiYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuJC5wcmV2aW91c0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLiQucGxheUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gIXRoaXMucGxheWluZztcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kLm5leHRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0TmV4dCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBpZiAoc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2spIHsgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTsgfVxuICAgICAgc2FmZUF0dHJpYnV0ZXMuY29ubmVjdGVkKHRoaXMpO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLmtleWRvd25dKGV2ZW50KSB7XG4gICAgICBsZXQgaGFuZGxlZDtcblxuICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgMzI6IC8qIFNwYWNlICovXG4gICAgICAgICAgdGhpcy5wbGF5aW5nID0gIXRoaXMucGxheWluZztcbiAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gUHJlZmVyIG1peGluIHJlc3VsdCBpZiBpdCdzIGRlZmluZWQsIG90aGVyd2lzZSB1c2UgYmFzZSByZXN1bHQuXG4gICAgICByZXR1cm4gaGFuZGxlZCB8fCAoc3VwZXJbc3ltYm9scy5rZXlkb3duXSAmJiBzdXBlcltzeW1ib2xzLmtleWRvd25dKGV2ZW50KSk7XG4gICAgfVxuXG4gICAgZ2V0IHBsYXlpbmcoKSB7XG4gICAgICByZXR1cm4gc3VwZXIucGxheWluZztcbiAgICB9XG4gICAgc2V0IHBsYXlpbmcodmFsdWUpIHtcbiAgICAgIGlmICgncGxheWluZycgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIucGxheWluZyA9IHZhbHVlOyB9XG4gICAgICBzYWZlQXR0cmlidXRlcy50b2dnbGVDbGFzcyh0aGlzLCAncGxheWluZycsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBnZXQgW3N5bWJvbHMudGVtcGxhdGVdKCkge1xuICAgICAgY29uc3QgYmFzZVRlbXBsYXRlID0gc3VwZXJbc3ltYm9scy50ZW1wbGF0ZV0gfHwgJyc7XG4gICAgICByZXR1cm4gYFxuICAgICAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cblxuICAgICAgICAjYnV0dG9ucyB7XG4gICAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgICAgcGFkZGluZzogMC41ZW07XG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgYnV0dG9uIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgICAgZmlsbDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xuICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgdHJhbnNpdGlvbjogZmlsbCAwLjVzO1xuICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QoOmhvdmVyKSBidXR0b24ge1xuICAgICAgICAgIGZpbGw6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KTtcbiAgICAgICAgfVxuICAgICAgICBidXR0b246aG92ZXIge1xuICAgICAgICAgIGZpbGw6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44NSk7XG4gICAgICAgIH1cbiAgICAgICAgYnV0dG9uOmFjdGl2ZSB7XG4gICAgICAgICAgZmlsbDogd2hpdGU7XG4gICAgICAgIH1cblxuICAgICAgICAuaWNvbiB7XG4gICAgICAgICAgaGVpZ2h0OiAzMHB4O1xuICAgICAgICAgIHdpZHRoOiAzMHB4O1xuICAgICAgICB9XG4gICAgICAgICNwbGF5QnV0dG9uIC5pY29uIHtcbiAgICAgICAgICBoZWlnaHQ6IDQwcHg7XG4gICAgICAgICAgd2lkdGg6IDQwcHg7XG4gICAgICAgIH1cblxuICAgICAgICA6aG9zdCgucGxheWluZykgLnBhdXNlZENvbnRyb2wge1xuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QoOm5vdCgucGxheWluZykpIC5wbGF5aW5nQ29udHJvbCB7XG4gICAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgICNjb250YWluZXIge1xuICAgICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIC13ZWJraXQtZmxleDogMTtcbiAgICAgICAgICBmbGV4OiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgI2NvbnRhaW5lciA6OnNsb3R0ZWQoKikge1xuICAgICAgICAgIC13ZWJraXQtZmxleDogMTtcbiAgICAgICAgICBmbGV4OiAxO1xuICAgICAgICB9XG4gICAgICAgIDwvc3R5bGU+XG5cbiAgICAgICAgPGRpdiBpZD1cImJ1dHRvbnNcIj5cbiAgICAgICAgICA8YnV0dG9uIGlkPVwicHJldmlvdXNCdXR0b25cIj5cbiAgICAgICAgICAgIDxzdmcgY2xhc3M9XCJpY29uXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCI+XG4gICAgICAgICAgICAgIDxnIGlkPVwic2tpcC1wcmV2aW91c1wiPlxuICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNNiA2aDJ2MTJINnptMy41IDZsOC41IDZWNnpcIi8+XG4gICAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDxidXR0b24gaWQ9XCJwbGF5QnV0dG9uXCI+XG4gICAgICAgICAgICA8c3ZnIGNsYXNzPVwiaWNvbiBwbGF5aW5nQ29udHJvbFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pZFlNaWQgbWVldFwiPlxuICAgICAgICAgICAgICA8ZyBpZD1cInBhdXNlLWNpcmNsZS1vdXRsaW5lXCI+XG4gICAgICAgICAgICAgICAgPHBhdGggZD1cIk05IDE2aDJWOEg5djh6bTMtMTRDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTAgMThjLTQuNDEgMC04LTMuNTktOC04czMuNTktOCA4LTggOCAzLjU5IDggOC0zLjU5IDgtOCA4em0xLTRoMlY4aC0ydjh6XCI+PC9wYXRoPlxuICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgIDxzdmcgY2xhc3M9XCJpY29uIHBhdXNlZENvbnRyb2xcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIj5cbiAgICAgICAgICAgICAgPGcgaWQ9XCJwbGF5LWNpcmNsZS1vdXRsaW5lXCI+XG4gICAgICAgICAgICAgICAgPHBhdGggZD1cIk0xMCAxNi41bDYtNC41LTYtNC41djl6TTEyIDJDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTAgMThjLTQuNDEgMC04LTMuNTktOC04czMuNTktOCA4LTggOCAzLjU5IDggOC0zLjU5IDgtOCA4elwiPjwvcGF0aD5cbiAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvbiBpZD1cIm5leHRCdXR0b25cIj5cbiAgICAgICAgICAgIDxzdmcgY2xhc3M9XCJpY29uXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCI+XG4gICAgICAgICAgICAgIDxnIGlkPVwic2tpcC1uZXh0XCI+XG4gICAgICAgICAgICAgICAgPHBhdGggZD1cIk02IDE4bDguNS02TDYgNnYxMnpNMTYgNnYxMmgyVjZoLTJ6XCIvPlxuICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBpZD1cImNvbnRhaW5lclwiIHJvbGU9XCJub25lXCI+XG4gICAgICAgICAgJHtiYXNlVGVtcGxhdGV9XG4gICAgICAgIDwvZGl2PlxuICAgICAgYDtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBQbGF5Q29udHJvbHM7XG59O1xuIiwiLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTZWxlY3RlZEl0ZW1UZXh0VmFsdWUuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBkZWZpbmVzIGEgYHZhbHVlYCBwcm9wZXJ0eSB0aGF0IHJlZmxlY3RzIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYVxuICAgKiBzZWxlY3RlZCBpdGVtLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGV4aXN0cyBmb3IgbGlzdC1saWtlIGNvbXBvbmVudHMgdGhhdCB3YW50IHRvIHByb3ZpZGUgYSBtb3JlXG4gICAqIGNvbnZlbmllbnQgd2F5IHRvIGdldC9zZXQgdGhlIHNlbGVjdGVkIGl0ZW0gdXNpbmcgdGV4dC5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBleHBlY3RzIGEgY29tcG9uZW50IHRvIHByb3ZpZGUgYW4gYGl0ZW1zYCBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICogaW4gdGhlIGxpc3QuIEEgc3RhbmRhcmQgd2F5IHRvIGRvIHRoYXQgd2l0aCBpc1xuICAgKiBbQ29udGVudEl0ZW1zTWl4aW5dKENvbnRlbnRJdGVtc01peGluLm1kKS4gVGhpcyBhbHNvIGV4cGVjdHMgdGhlIGRlZmluaXRpb25cbiAgICogb2YgYHNlbGVjdGVkSW5kZXhgIGFuZCBgc2VsZWN0ZWRJdGVtYCBwcm9wZXJ0aWVzLCB3aGljaCBjYW4gYmUgb2J0YWluZWRcbiAgICogZnJvbSBbU2luZ2xlU2VsZWN0aW9uTWl4aW5dKFNpbmdsZVNlbGVjdGlvbk1peGluLm1kKS5cbiAgICovXG4gIGNsYXNzIFNlbGVjdGVkSXRlbVRleHRWYWx1ZSBleHRlbmRzIGJhc2Uge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudCBvZiB0aGUgc2VsZWN0ZWQgaXRlbS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyB2YWx1ZSB0byBhIHN0cmluZyB3aWxsIGF0dGVtcHQgdG8gc2VsZWN0IHRoZSBmaXJzdCBsaXN0IGl0ZW1cbiAgICAgKiB3aG9zZSB0ZXh0IGNvbnRlbnQgbWF0Y2ggdGhhdCBzdHJpbmcuIFNldHRpbmcgdGhpcyB0byBhIHN0cmluZyBub3QgbWF0Y2hpbmdcbiAgICAgKiBhbnkgbGlzdCBpdGVtIHdpbGwgcmVzdWx0IGluIG5vIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRJdGVtID09IG51bGwgfHwgdGhpcy5zZWxlY3RlZEl0ZW0udGV4dENvbnRlbnQgPT0gbnVsbCA/XG4gICAgICAgICcnIDpcbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0udGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIHNldCB2YWx1ZSh0ZXh0KSB7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuc2VsZWN0ZWRJbmRleDtcbiAgICAgIGxldCBuZXdJbmRleCA9IC0xOyAvLyBBc3N1bWUgd2Ugd29uJ3QgZmluZCB0aGUgdGV4dC5cblxuICAgICAgLy8gRmluZCB0aGUgaXRlbSB3aXRoIHRoZSBpbmRpY2F0ZWQgdGV4dC5cbiAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlbXNbaV0udGV4dENvbnRlbnQgPT09IHRleHQpIHtcbiAgICAgICAgICBuZXdJbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0luZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gbmV3SW5kZXg7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCd2YWx1ZS1jaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFNlbGVjdGVkSXRlbVRleHRWYWx1ZTtcbn07XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCBGcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4gZnJvbSAnLi9GcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi9zeW1ib2xzJztcblxuXG4vLyBTeW1ib2xzIGZvciBwcml2YXRlIGRhdGEgbWVtYmVycyBvbiBhbiBlbGVtZW50LlxuY29uc3QgYW5pbWF0aW9uU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdhbmltYXRpb24nKTtcbmNvbnN0IGRyYWdnaW5nU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdkcmFnZ2luZycpO1xuY29uc3QgbGFzdEFuaW1hdGlvblN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbGFzdEFuaW1hdGlvbicpO1xuY29uc3QgcGxheWluZ0FuaW1hdGlvblN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnYW5pbWF0aW5nU2VsZWN0aW9uJyk7XG5jb25zdCBwcmV2aW91c1NlbGVjdGlvblN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncHJldmlvdXNTZWxlY3Rpb24nKTtcbmNvbnN0IHNlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdzZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvbicpO1xuY29uc3Qgc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0U3ltYm9sID0gY3JlYXRlU3ltYm9sKCdzZWxlY3Rpb25BbmltYXRpb25FZmZlY3QnKTtcbmNvbnN0IHNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lc1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzJyk7XG5jb25zdCByZXNldEFuaW1hdGlvbnNPbk5leHRSZW5kZXJTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3Jlc2V0QW5pbWF0aW9uc09uTmV4dFJlbmRlcicpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggU2VsZWN0aW9uQW5pbWF0aW9uLiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWl4aW4oYmFzZSkge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCB1c2VzIGFuaW1hdGlvbiB0byBzaG93IHRyYW5zaXRpb25zIGJldHdlZW4gc2VsZWN0aW9uIHN0YXRlcy5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBjYW4gYmUgdXNlZCBieSBjb21wb25lbnRzIHRoYXQgd2FudCB0byBwcm92aWRlIHZpc2libGVcbiAgICogYW5pbWF0aW9ucyB3aGVuIGNoYW5naW5nIHRoZSBzZWxlY3Rpb24uIEZvciBleGFtcGxlLCBhIGNhcm91c2VsIGNvbXBvbmVudFxuICAgKiBtYXkgd2FudCB0byBkZWZpbmUgYSBzbGlkaW5nIGFuaW1hdGlvbiBlZmZlY3Qgc2hvd24gd2hlbiBtb3ZpbmcgYmV0d2VlblxuICAgKiBpdGVtcy5cbiAgICpcbiAgICogVGhlIGFuaW1hdGlvbiBpcyBkZWZpbmVkIGJ5IGEgYHNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lc2AgcHJvcGVydHk7IHNlZVxuICAgKiB0aGF0IHByb3BlcnR5IGZvciBkZXRhaWxzIG9uIGhvdyB0byBkZWZpbmUgdGhlc2Uga2V5ZnJhbWVzLiBUaGlzIGFuaW1hdGlvblxuICAgKiB3aWxsIGJlIHVzZWQgaW4gdHdvIHdheXMuIEZpcnN0LCB3aGVuIG1vdmluZyBzdHJpY3RseSBiZXR3ZWVuIGl0ZW1zLCB0aGVcbiAgICogYW5pbWF0aW9uIHdpbGwgcGxheSBzbW9vdGhseSB0byBzaG93IHRoZSBzZWxlY3Rpb24gY2hhbmdpbmcuIFNlY29uZCwgdGhlXG4gICAqIGFuaW1hdGlvbiBjYW4gYmUgdXNlZCB0byByZW5kZXIgdGhlIHNlbGVjdGlvbiBhdCBhIGZpeGVkIHBvaW50IGluIHRoZVxuICAgKiB0cmFuc2l0aW9uIGJldHdlZW4gc3RhdGVzLiBFLmcuLCBpZiB0aGUgdXNlciBwYXVzZXMgaGFsZndheSB0aHJvdWdoXG4gICAqIGRyYWdnaW5nIGFuIGVsZW1lbnQgdXNpbmcgW1N3aXBlRGlyZWN0aW9uTWl4aW5dKFN3aXBlRGlyZWN0aW9uTWl4aW4ubWQpXG4gICAqIG9yIFtUcmFja3BhZERpcmVjdGlvbk1peGluXShUcmFja3BhZERpcmVjdGlvbk1peGluLm1kKXMsIHRoZW4gdGhlIHNlbGVjdGlvblxuICAgKiBhbmltYXRpb24gd2lsbCBiZSBzaG93biBhdCB0aGUgcG9pbnQgZXhhY3RseSBoYWxmd2F5IHRocm91Z2guXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyBhIGNvbXBvbmVudCB0byBwcm92aWRlIGFuIGBpdGVtc2AgYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAqIGluIHRoZSBsaXN0LCB3aGljaCBjYW4gYmUgcHJvdmlkZWQgdmlhXG4gICAqIFtDb250ZW50SXRlbXNNaXhpbl0oQ29udGVudEl0ZW1zTWl4aW4ubWQpLiBUaGlzIG1peGluIGFsc28gZXhwZWN0c1xuICAgKiBgc2VsZWN0ZWRJbmRleGAgYW5kIGBzZWxlY3RlZEl0ZW1gIHByb3BlcnRpZXMsIHdoaWNoIGNhbiBiZSBwcm92aWRlZCB2aWFcbiAgICogW1NpbmdsZVNlbGVjdGlvbk1peGluXShTaW5nbGVTZWxlY3Rpb25NaXhpbi5tZCkuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gc3VwcG9ydHMgYSBgc2VsZWN0aW9uV3JhcHNgIHByb3BlcnR5LiBXaGVuIHRydWUsIHRoZSB1c2VyIGNhblxuICAgKiBuYXZpZ2F0ZSBmb3J3YXJkIGZyb20gdGhlIGxhc3QgaXRlbSBpbiB0aGUgbGlzdCBhbmQgd3JhcCBhcm91bmQgdG8gdGhlXG4gICAqIGZpcnN0IGl0ZW0sIG9yIG5hdmlnYXRlIGJhY2t3YXJkIGZyb20gdGhlIGZpcnN0IGl0ZW0gYW5kIHdyYXAgYXJvdW5kIHRvIHRoZVxuICAgKiBsYXN0IGl0ZW0uXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gdXNlcyB0aGUgV2ViIEFuaW1hdGlvbnMgQVBJLiBGb3IgdXNlIG9uIGJyb3dzZXJzIHdoaWNoXG4gICAqIGRvIG5vdCBzdXBwb3J0IHRoYXQgQVBJIG5hdGl2ZWx5LCB5b3Ugd2lsbCBuZWVkIHRvIGxvYWQgdGhlXG4gICAqIFtXZWIgQW5pbWF0aW9ucyBwb2x5ZmlsbF0oaHR0cHM6Ly9naXRodWIuY29tL3dlYi1hbmltYXRpb25zL3dlYi1hbmltYXRpb25zLWpzKS5cbiAgICovXG4gIGNsYXNzIFNlbGVjdGlvbkFuaW1hdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICAvLyBTZXQgZGVmYXVsdHMuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb24gPSB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnNlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdCA9PT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5zZWxlY3Rpb25BbmltYXRpb25LZXlmcmFtZXMgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdCA9IHRoaXNbc3ltYm9scy5kZWZhdWx0c10uc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0O1xuICAgICAgfVxuXG4gICAgICB0aGlzW3N5bWJvbHMuZHJhZ2dpbmddID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IFtzeW1ib2xzLmRlZmF1bHRzXSgpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRzID0gc3VwZXJbc3ltYm9scy5kZWZhdWx0c10gfHwge307XG4gICAgICBkZWZhdWx0cy5zZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvbiA9IDI1MDtcbiAgICAgIGRlZmF1bHRzLnNlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdCA9ICdzbGlkZSc7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBQcm92aWRlIGJhY2tpbmcgZm9yIHRoZSBkcmFnZ2luZyBwcm9wZXJ0eS5cbiAgICAgKiBBbHNvLCB3aGVuIGEgZHJhZyBiZWdpbnMsIHJlc2V0IHRoZSBhbmltYXRpb25zLlxuICAgICAqL1xuICAgIGdldCBbc3ltYm9scy5kcmFnZ2luZ10oKSB7XG4gICAgICByZXR1cm4gdGhpc1tkcmFnZ2luZ1N5bWJvbF07XG4gICAgfVxuICAgIHNldCBbc3ltYm9scy5kcmFnZ2luZ10odmFsdWUpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzW3N5bWJvbHMuZHJhZ2dpbmddO1xuICAgICAgdGhpc1tkcmFnZ2luZ1N5bWJvbF0gPSB2YWx1ZTtcbiAgICAgIGlmIChzeW1ib2xzLmRyYWdnaW5nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyW3N5bWJvbHMuZHJhZ2dpbmddID0gdmFsdWU7IH1cbiAgICAgIGlmICh2YWx1ZSAmJiAhcHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAvLyBIYXZlIGJlZ3VuIGEgZHJhZy5cbiAgICAgICAgdGhpc1tyZXNldEFuaW1hdGlvbnNPbk5leHRSZW5kZXJTeW1ib2xdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBbc3ltYm9scy5pdGVtQWRkZWRdKGl0ZW0pIHtcbiAgICAgIC8vIFdlIG1hcmsgbmV3IGl0ZW1zIGluIHRoZSBsaXN0IGFzIGV4cGxpY2l0bHkgdmlzaWJsZSB0byBBUklBLiBPdGhlcndpc2UsXG4gICAgICAvLyB3aGVuIGFuIGl0ZW0gaXNuJ3QgdmlzaWJsZSBvbiB0aGUgc2NyZWVuLCBBUklBIHdpbGwgYXNzdW1lIHRoZSBpdGVtIGlzXG4gICAgICAvLyBvZiBubyBpbnRlcmVzdCB0byB0aGUgdXNlciwgYW5kIGxlYXZlIGl0IG91dCBvZiB0aGUgYWNjZXNzaWJpbGl0eSB0cmVlLlxuICAgICAgLy8gSWYgdGhlIGxpc3QgY29udGFpbnMgMTAgaXRlbXMsIGJ1dCBvbmx5IDMgYXJlIHZpc2libGUsIGEgc2NyZWVuIHJlYWRlclxuICAgICAgLy8gbWlnaHQgdGhlbiBhbm5vdW5jZSB0aGUgbGlzdCBvbmx5IGhhcyAzIGl0ZW1zLiBUbyBlbnN1cmUgdGhhdCBzY3JlZW5cbiAgICAgIC8vIHJlYWRlcnMgYW5kIG90aGVyIGFzc2lzdGl2ZSB0ZWNobm9sb2dpZXMgYW5ub3VuY2UgdGhlIGNvcnJlY3QgdG90YWxcbiAgICAgIC8vIG51bWJlciBvZiBpdGVtcywgd2UgZXhwbGljaXRseSBtYXJrIGFsbCBpdGVtcyBhcyBub3QgaGlkZGVuLiBUaGlzIHdpbGxcbiAgICAgIC8vIGV4cG9zZSB0aGVtIGFsbCBpbiB0aGUgYWNjZXNzaWJpbGl0eSB0cmVlLCBldmVuIHRoZSBpdGVtcyB3aGljaCBhcmVcbiAgICAgIC8vIGN1cnJlbnRseSBub3QgcmVuZGVyZWQuXG4gICAgICAvL1xuICAgICAgLy8gVE9ETzogR2VuZXJhbGx5IHNwZWFraW5nLCB0aGlzIGVudGlyZSBtaXhpbiBhc3N1bWVzIHRoYXQgdGhlIHVzZXIgY2FuXG4gICAgICAvLyBuYXZpZ2F0ZSB0aHJvdWdoIGFsbCBpdGVtcyBpbiBhIGxpc3QuIEJ1dCBhbiBhcHAgY291bGQgc3R5bGUgYW4gaXRlbSBhc1xuICAgICAgLy8gZGlzcGxheTpub25lIG9yIHZpc2liaWxpdHk6aGlkZGVuIGJlY2F1c2UgdGhlIHVzZXIgaXMgbm90IGFsbG93ZWQgdG9cbiAgICAgIC8vIGludGVyYWN0IHdpdGggdGhhdCBpdGVtIGF0IHRoZSBtb21lbnQuIFN1cHBvcnQgZm9yIHRoaXMgc2NlbmFyaW8gc2hvdWxkXG4gICAgICAvLyBiZSBhZGRlZC4gVGhpcyB3b3VsZCBlbnRhaWwgY2hhbmdpbmcgYWxsIGxvY2F0aW9ucyB3aGVyZSBhIG1peGluXG4gICAgICAvLyBmdW5jdGlvbiBpcyBjb3VudGluZyBpdGVtcywgaXRlcmF0aW5nIG92ZXIgdGhlICh2aXNpYmxlKSBpdGVtcywgYW5kXG4gICAgICAvLyBzaG93aW5nIG9yIGhpZGluZyBpdGVtcy4gQW1vbmcgb3RoZXIgdGhpbmdzLCB0aGUgY29kZSBiZWxvdyB0byBtYWtlXG4gICAgICAvLyBpdGVtcyB2aXNpYmxlIHRvIEFSSUEgd291bGQgbmVlZCB0byBkaXNjcmltaW5hdGUgYmV0d2VlbiBpdGVtcyB3aGljaFxuICAgICAgLy8gYXJlIGludmlzaWJsZSBiZWNhdXNlIG9mIGFuaW1hdGlvbiBzdGF0ZSwgb3IgaW52aXNpYmxlIGJlY2F1c2UgdGhlIHVzZXJcbiAgICAgIC8vIHNob3VsZG4ndCBpbnRlcmFjdCB3aXRoIHRoZW0uXG4gICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1zQ2hhbmdlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtc0NoYW5nZWRdKCk7IH1cblxuICAgICAgcmVzZXRBbmltYXRpb25zKHRoaXMpO1xuXG4gICAgICAvLyBUT0RPOiBBbHNvIHJlc2V0IG91ciBub3Rpb24gb2YgdGhlIGxhc3QgcmVuZGVyZWQgc2VsZWN0aW9uPyBUaGlzIGNvbWVzXG4gICAgICAvLyB1cCB3aGVuIGEgRE9NIHJlbW92YWwgY2F1c2VzIHRoZSBzZWxlY3RlZCBpdGVtIHRvIGNoYW5nZSBwb3NpdGlvbi5cbiAgICAgIC8vIHRoaXNbcHJldmlvdXNTZWxlY3Rpb25TeW1ib2xdID0gbnVsbDtcblxuICAgICAgcmVuZGVyU2VsZWN0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIHJlc2V0QW5pbWF0aW9ucygpIHtcbiAgICAgIHJlc2V0QW5pbWF0aW9ucyh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZyYWN0aW9uYWwgdmFsdWUgaW5kaWNhdGluZyBob3cgZmFyIHRoZSB1c2VyIGhhcyBjdXJyZW50bHkgYWR2YW5jZWQgdG9cbiAgICAgKiB0aGUgbmV4dC9wcmV2aW91cyBpdGVtLiBFLmcuLCBhIGBzZWxlY3RlZEZyYWN0aW9uYCBvZiAzLjUgaW5kaWNhdGVzIHRoZVxuICAgICAqIHVzZXIgaXMgaGFsZndheSBiZXR3ZWVuIGl0ZW1zIDMgYW5kIDQuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgW0ZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbl0oRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluLm1kKVxuICAgICAqIG1peGluLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWRGcmFjdGlvbigpIHtcbiAgICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEZyYWN0aW9uIHx8IDA7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEZyYWN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoJ3NlbGVjdGVkRnJhY3Rpb24nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGVkRnJhY3Rpb24gPSB2YWx1ZTsgfVxuICAgICAgcmVuZGVyU2VsZWN0aW9uKHRoaXMsIHRoaXMuc2VsZWN0ZWRJbmRleCwgdmFsdWUpO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnNlbGVjdGVkSW5kZXg7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEluZGV4KGluZGV4KSB7XG4gICAgICBpZiAoJ3NlbGVjdGVkSW5kZXgnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGVkSW5kZXggPSBpbmRleDsgfVxuICAgICAgcmVuZGVyU2VsZWN0aW9uKHRoaXMsIGluZGV4LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZHVyYXRpb24gb2YgYSBzZWxlY3Rpb24gYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWVhc3VyZXMgdGhlIGFtb3VudCBvZiB0aW1lIHJlcXVpcmVkIGZvciBhIHNlbGVjdGlvbiBhbmltYXRpb24gdG9cbiAgICAgKiBjb21wbGV0ZS4gVGhpcyBudW1iZXIgcmVtYWlucyBjb25zdGFudCwgZXZlbiBpZiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGJlaW5nXG4gICAgICogYW5pbWF0ZWQgaW5jcmVhc2VzLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgMjUwIG1pbGxpc2Vjb25kcyAoYSBxdWFydGVyIGEgc2Vjb25kKS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMjUwXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNbc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb25TeW1ib2xdO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb24odmFsdWUpIHtcbiAgICAgIHRoaXNbc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb25TeW1ib2xdID0gdmFsdWU7XG4gICAgICBpZiAoJ3NlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvbiA9IHZhbHVlOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgYSBzdGFuZGFyZCBzZWxlY3Rpb24gYW5pbWF0aW9uIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBzaG9ydGhhbmQgZm9yIHNldHRpbmcgdGhlIGBzZWxlY3Rpb25BbmltYXRpb25LZXlmcmFtZXNgXG4gICAgICogcHJvcGVydHkgdG8gc3RhbmRhcmQga2V5ZnJhbWVzLiBTdXBwb3J0ZWQgc3RyaW5nIHZhbHVlczpcbiAgICAgKlxuICAgICAqICogXCJjcm9zc2ZhZGVcIlxuICAgICAqICogXCJyZXZlYWxcIlxuICAgICAqICogXCJyZXZlYWxXaXRoRmFkZVwiXG4gICAgICogKiBcInNob3dBZGphY2VudFwiXG4gICAgICogKiBcInNsaWRlXCJcbiAgICAgKiAqIFwic2xpZGVXaXRoR2FwXCJcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJzbGlkZVwiXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdCgpIHtcbiAgICAgIHJldHVybiB0aGlzW3NlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdFN5bWJvbF07XG4gICAgfVxuICAgIHNldCBzZWxlY3Rpb25BbmltYXRpb25FZmZlY3QodmFsdWUpIHtcbiAgICAgIHRoaXNbc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0U3ltYm9sXSA9IHZhbHVlO1xuICAgICAgaWYgKCdzZWxlY3Rpb25BbmltYXRpb25FZmZlY3QnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGlvbkFuaW1hdGlvbkVmZmVjdCA9IHZhbHVlOyB9XG4gICAgICB0aGlzLnNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lcyA9IG1peGluLnN0YW5kYXJkRWZmZWN0S2V5ZnJhbWVzW3ZhbHVlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUga2V5ZnJhbWVzIHRoYXQgZGVmaW5lIGFuIGFuaW1hdGlvbiB0aGF0IHBsYXlzIGZvciBhbiBpdGVtIHdoZW4gbW92aW5nXG4gICAgICogZm9yd2FyZCBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGFuIGFycmF5IG9mIENTUyBydWxlcyB0aGF0IHdpbGwgYmUgYXBwbGllZC4gVGhlc2UgYXJlIHVzZWQgYXNcbiAgICAgKiBba2V5ZnJhbWVzXShodHRwOi8vdzNjLmdpdGh1Yi5pby93ZWItYW5pbWF0aW9ucy8ja2V5ZnJhbWVzLXNlY3Rpb24pXG4gICAgICogdG8gYW5pbWF0ZSB0aGUgaXRlbSB3aXRoIHRoZVxuICAgICAqIFtXZWIgQW5pbWF0aW9ucyBBUEldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9hbmltYXRpb24pLlxuICAgICAqXG4gICAgICogVGhlIGFuaW1hdGlvbiByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgbmV4dCBpdGVtIGFzIGl0IG1vdmVzIGZyb21cbiAgICAgKiBjb21wbGV0ZWx5IHVuc2VsZWN0ZWQgKG9mZnN0YWdlLCB1c3VhbGx5IHJpZ2h0KSwgdG8gc2VsZWN0ZWQgKGNlbnRlclxuICAgICAqIHN0YWdlKSwgdG8gY29tcGxldGVseSB1bnNlbGVjdGVkIChvZmZzdGFnZSwgdXN1YWxseSBsZWZ0KS4gVGhlIGNlbnRlciB0aW1lXG4gICAgICogb2YgdGhlIGFuaW1hdGlvbiBzaG91bGQgY29ycmVzcG9uZCB0byB0aGUgaXRlbSdzIHF1aXNjZW50IHNlbGVjdGVkIHN0YXRlLFxuICAgICAqIHR5cGljYWxseSBpbiB0aGUgY2VudGVyIG9mIHRoZSBzdGFnZSBhbmQgYXQgdGhlIGl0ZW0ncyBsYXJnZXN0IHNpemUuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3J3YXJkIGFuaW1hdGlvbiBpcyBhIHNtb290aCBzbGlkZSBhdCBmdWxsIHNpemUgZnJvbSByaWdodCB0b1xuICAgICAqIGxlZnQuXG4gICAgICpcbiAgICAgKiBXaGVuIG1vdmluZyB0aGUgc2VsZWN0aW9uIGJhY2t3YXJkLCB0aGlzIGFuaW1hdGlvbiBpcyBwbGF5ZWQgaW4gcmV2ZXJzZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtjc3NSdWxlc1tdfVxuICAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25BbmltYXRpb25LZXlmcmFtZXMoKSB7XG4gICAgICAvLyBTdGFuZGFyZCBhbmltYXRpb24gc2xpZGVzIGxlZnQvcmlnaHQsIGtlZXBzIGFkamFjZW50IGl0ZW1zIG91dCBvZiB2aWV3LlxuICAgICAgcmV0dXJuIHRoaXNbc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lcyh2YWx1ZSkge1xuICAgICAgdGhpc1tzZWxlY3Rpb25BbmltYXRpb25LZXlmcmFtZXNTeW1ib2xdID0gdmFsdWU7XG4gICAgICBpZiAoJ3NlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lcycgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzID0gdmFsdWU7IH1cbiAgICAgIHJlc2V0QW5pbWF0aW9ucyh0aGlzKTtcbiAgICAgIHJlbmRlclNlbGVjdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0aW9uV3JhcHMoKSB7XG4gICAgICByZXR1cm4gc3VwZXIuc2VsZWN0aW9uV3JhcHM7XG4gICAgfVxuICAgIHNldCBzZWxlY3Rpb25XcmFwcyh2YWx1ZSkge1xuICAgICAgaWYgKCdzZWxlY3Rpb25XcmFwcycgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0aW9uV3JhcHMgPSB2YWx1ZTsgfVxuICAgICAgcmVzZXRBbmltYXRpb25zKHRoaXMpO1xuICAgICAgcmVuZGVyU2VsZWN0aW9uKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBTZWxlY3Rpb25BbmltYXRpb247XG59XG5cblxuLy8gV2UgZXhwb3NlIGhlbHBlcnMgb24gdGhlIG1peGluIGZ1bmN0aW9uIHRoYXQgd2Ugd2FudCB0byBiZSBhYmxlIHRvIHVuaXQgdGVzdC5cbi8vIFNpbmNlIHRoZXNlIGFyZSBvbiB0aGUgZnVuY3Rpb24sIG5vdCBvbiB0aGUgY2xhc3MgZW1pdHRlZCBieSB0aGUgZnVuY3Rpb24sXG4vLyB0aGV5IGRvbid0IGVuZCB1cCBnZXR0aW5nIGV4cG9zZWQgb24gYWN0dWFsIGVsZW1lbnQgaW5zdGFuY2VzLlxubWl4aW4uaGVscGVycyA9IHtcblxuICAvKlxuICAgKiBDYWxjdWxhdGUgdGhlIGFuaW1hdGlvbiBmcmFjdGlvbnMgZm9yIGFuIGVsZW1lbnQncyBpdGVtcyBhdCB0aGUgZ2l2ZW5cbiAgICogc2VsZWN0aW9uIHBvaW50LiBUaGlzIGlzIHVzZWQgd2hlbiByZW5kZXJpbmcgdGhlIGVsZW1lbnQncyBzZWxlY3Rpb24gc3RhdGVcbiAgICogaW5zdGFudGFuZW91c2x5LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNvbnNpZGVycyB0aGUgc2VsZWN0ZWRJbmRleCBwYXJhbWV0ZXIsIHdoaWNoIGNhbiBiZSBhIHdob2xlXG4gICAqIG9yIGZyYWN0aW9uYWwgbnVtYmVyLCBhbmQgZGV0ZXJtaW5lcyB3aGljaCBpdGVtcyB3aWxsIGJlIHZpc2libGUgYXQgdGhhdFxuICAgKiBpbmRleC4gVGhpcyBmdW5jdGlvbiB0aGVuIGNhbGN1bGF0ZXMgYSBjb3JyZXNwb25kaW5nIGFuaW1hdGlvbiBmcmFjdGlvbjogYVxuICAgKiBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIGluZGljYXRpbmcgaG93IGZhciB0aHJvdWdoIHRoZSBzZWxlY3Rpb24gYW5pbWF0aW9uXG4gICAqIGFuIGl0ZW0gc2hvdWxkIGJlIHNob3duLCBvciBudWxsIGlmIHRoZSBpdGVtIHNob3VsZCBub3QgYmUgdmlzaWJsZSBhdCB0aGF0XG4gICAqIHNlbGVjdGlvbiBpbmRleC4gVGhlc2UgZnJhY3Rpb25zIGFyZSByZXR1cm5lZCBhcyBhbiBhcnJheSwgd2hlcmUgdGhlXG4gICAqIGFuaW1hdGlvbiBmcmFjdGlvbiBhdCBwb3NpdGlvbiBOIGNvcnJlc3BvbmRzIHRvIGhvdyBpdGVtIE4gc2hvdWxkIGJlIHNob3duLlxuICAgKi9cbiAgYW5pbWF0aW9uRnJhY3Rpb25zRm9yU2VsZWN0aW9uKGVsZW1lbnQsIHNlbGVjdGlvbikge1xuXG4gICAgY29uc3QgaXRlbXMgPSBlbGVtZW50Lml0ZW1zO1xuICAgIGlmICghaXRlbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtQ291bnQgPSBpdGVtcy5sZW5ndGg7XG4gICAgY29uc3Qgc2VsZWN0aW9uV3JhcHMgPSBlbGVtZW50LnNlbGVjdGlvbldyYXBzO1xuXG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICAvLyBIb3cgbWFueSBzdGVwcyBmcm9tIHRoZSBzZWxlY3Rpb24gcG9pbnQgdG8gdGhpcyBpdGVtP1xuICAgICAgY29uc3Qgc3RlcHMgPSBzdGVwc1RvSW5kZXgoaXRlbUNvdW50LCBzZWxlY3Rpb25XcmFwcywgc2VsZWN0aW9uLCBpdGVtSW5kZXgpO1xuICAgICAgLy8gVG8gY29udmVydCBzdGVwcyB0byBhbmltYXRpb24gZnJhY3Rpb246XG4gICAgICAvLyBzdGVwcyAgICAgIGFuaW1hdGlvbiBmcmFjdGlvblxuICAgICAgLy8gIDEgICAgICAgICAwICAgICAoc3RhZ2UgcmlnaHQpXG4gICAgICAvLyAgMCAgICAgICAgIDAuNSAgIChjZW50ZXIgc3RhZ2UpXG4gICAgICAvLyAtMSAgICAgICAgIDEgICAgIChzdGFnZSBsZWZ0KVxuICAgICAgY29uc3QgYW5pbWF0aW9uRnJhY3Rpb24gPSAoMSAtIHN0ZXBzKSAvIDI7XG4gICAgICByZXR1cm4gKGFuaW1hdGlvbkZyYWN0aW9uID49IDAgJiYgYW5pbWF0aW9uRnJhY3Rpb24gPD0gMSkgP1xuICAgICAgICBhbmltYXRpb25GcmFjdGlvbiA6XG4gICAgICAgIG51bGw7IC8vIE91dHNpZGUgYW5pbWF0aW9uIHJhbmdlXG4gICAgfSk7XG4gIH0sXG5cbiAgLypcbiAgICogQ2FsY3VsYXRlIHRoZSBhbmltYXRpb24gdGltaW5ncyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHNtb290aGx5IGFuaW1hdGUgdGhlXG4gICAqIGVsZW1lbnQncyBpdGVtcyBmcm9tIG9uZSBzZWxlY3Rpb24gc3RhdGUgdG8gYW5vdGhlci5cbiAgICpcbiAgICogVGhpcyByZXR1cm5zIGFuIGFycmF5IG9mIHRpbWluZ3MsIHdoZXJlIHRoZSB0aW1pbmcgYXQgcG9zaXRpb24gTiBzaG91bGQgYmVcbiAgICogdXNlZCB0byBhbmltYXRlIGl0ZW0gTi4gSWYgYW4gaXRlbSdzIHRpbWluZyBpcyBudWxsLCB0aGVuIHRoYXQgaXRlbSBzaG91bGRcbiAgICogbm90IHRha2UgcGxhY2UgaW4gdGhlIGFuaW1hdGlvbiwgYW5kIHNob3VsZCBiZSBoaWRkZW4gaW5zdGVhZC5cbiAgICovXG4gIGVmZmVjdFRpbWluZ3NGb3JTZWxlY3Rpb25BbmltYXRpb24oZWxlbWVudCwgZnJvbVNlbGVjdGlvbiwgdG9TZWxlY3Rpb24pIHtcblxuICAgIGNvbnN0IGl0ZW1zID0gZWxlbWVudC5pdGVtcztcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1Db3VudCA9IGl0ZW1zLmxlbmd0aDtcbiAgICBjb25zdCBzZWxlY3Rpb25XcmFwcyA9IGVsZW1lbnQuc2VsZWN0aW9uV3JhcHM7XG4gICAgY29uc3QgdG9JbmRleCA9IEZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbi5oZWxwZXJzLndyYXBwZWRTZWxlY3Rpb25QYXJ0cyh0b1NlbGVjdGlvbiwgaXRlbUNvdW50LCBzZWxlY3Rpb25XcmFwcykuaW5kZXg7XG4gICAgY29uc3QgdG90YWxTdGVwcyA9IHN0ZXBzVG9JbmRleChpdGVtQ291bnQsIHNlbGVjdGlvbldyYXBzLCBmcm9tU2VsZWN0aW9uLCB0b1NlbGVjdGlvbik7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdG90YWxTdGVwcyA+PSAwID8gJ25vcm1hbCc6ICdyZXZlcnNlJztcbiAgICBjb25zdCBmaWxsID0gJ2JvdGgnO1xuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBlbGVtZW50LnNlbGVjdGlvbkFuaW1hdGlvbkR1cmF0aW9uO1xuICAgIGNvbnN0IHN0ZXBEdXJhdGlvbiA9IHRvdGFsU3RlcHMgIT09IDAgP1xuICAgICAgdG90YWxEdXJhdGlvbiAqIDIgLyBNYXRoLmNlaWwoTWF0aC5hYnModG90YWxTdGVwcykpIDpcbiAgICAgIDA7ICAvLyBObyBzdGVwcyByZXF1aXJlZCwgYW5pbWF0aW9uIHdpbGwgYmUgaW5zdGFudGVub3VzLlxuXG4gICAgY29uc3QgdGltaW5ncyA9IGl0ZW1zLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzdGVwcyA9IHN0ZXBzVG9JbmRleChpdGVtQ291bnQsIHNlbGVjdGlvbldyYXBzLCBpdGVtSW5kZXgsIHRvU2VsZWN0aW9uKTtcbiAgICAgIC8vIElmIHdlIGluY2x1ZGUgdGhpcyBpdGVtIGluIHRoZSBzdGFnZ2VyZWQgc2VxdWVuY2Ugb2YgYW5pbWF0aW9ucyB3ZSdyZVxuICAgICAgLy8gY3JlYXRpbmcsIHdoZXJlIHdvdWxkIHRoZSBpdGVtIGFwcGVhciBpbiB0aGUgc2VxdWVuY2U/XG4gICAgICBsZXQgcG9zaXRpb25JblNlcXVlbmNlID0gdG90YWxTdGVwcyAtIHN0ZXBzO1xuICAgICAgaWYgKHRvdGFsU3RlcHMgPCAwKSB7XG4gICAgICAgIHBvc2l0aW9uSW5TZXF1ZW5jZSA9IC1wb3NpdGlvbkluU2VxdWVuY2U7XG4gICAgICB9XG4gICAgICAvLyBTbywgaXMgdGhpcyBpdGVtIHJlYWxseSBpbmNsdWRlZCBpbiB0aGUgc2VxdWVuY2U/XG4gICAgICBpZiAoTWF0aC5jZWlsKHBvc2l0aW9uSW5TZXF1ZW5jZSkgPj0gMCAmJiBwb3NpdGlvbkluU2VxdWVuY2UgPD0gTWF0aC5hYnModG90YWxTdGVwcykpIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IGRlbGF5IGZvciBmaXJzdCBpdGVtIHdpbGwgYmUgbmVnYXRpdmUuIFRoYXQgd2lsbCBjYXVzZVxuICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIHRvIHN0YXJ0IGhhbGZ3YXkgdGhyb3VnaCwgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LlxuICAgICAgICBjb25zdCBkZWxheSA9IHN0ZXBEdXJhdGlvbiAqIChwb3NpdGlvbkluU2VxdWVuY2UgLSAxKS8yO1xuICAgICAgICBjb25zdCBlbmREZWxheSA9IGl0ZW1JbmRleCA9PT0gdG9JbmRleCA/XG4gICAgICAgICAgLXN0ZXBEdXJhdGlvbi8yIDogICAvLyBTdG9wIGhhbGZ3YXkgdGhyb3VnaC5cbiAgICAgICAgICAwOyAgICAgICAgICAgICAgLy8gUGxheSBhbmltYXRpb24gdW50aWwgZW5kLlxuICAgICAgICByZXR1cm4geyBkdXJhdGlvbjogc3RlcER1cmF0aW9uLCBkaXJlY3Rpb24sIGZpbGwsIGRlbGF5LCBlbmREZWxheSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGltaW5ncztcbiAgfVxuXG59O1xuXG5cbi8vIEtleWZyYW1lcyBmb3Igc3RhbmRhcmQgc2VsZWN0aW9uIGFuaW1hdGlvbiBlZmZlY3RzLlxubWl4aW4uc3RhbmRhcmRFZmZlY3RLZXlmcmFtZXMgPSB7XG5cbiAgLy8gU2ltcGxlIGNyb3NzZmFkZVxuICBjcm9zc2ZhZGU6IFtcbiAgICB7IG9wYWNpdHk6IDAgfSxcbiAgICB7IG9wYWNpdHk6IDEgfSxcbiAgICB7IG9wYWNpdHk6IDAgfVxuICBdLFxuXG4gIC8vIFJldmVhbCwgYXMgaWYgc2xpZGluZyB0aGUgdG9wIGNhcmQgb2ZmIGEgZGVjayBvZiBjYXJkc1xuICByZXZlYWw6IFtcbiAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCUpJywgekluZGV4OiAwIH0sXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDAlKScsIHpJbmRleDogMSB9LFxuICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtMTAwJSknLCB6SW5kZXg6IDIgfVxuICBdLFxuXG4gIC8vIEdvb2dsZSBQaG90b3Mtc3R5bGUgcmV2ZWFsLXdpdGgtZmFkZSBhbmltYXRpb25cbiAgcmV2ZWFsV2l0aEZhZGU6IFtcbiAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCUpIHNjYWxlKDAuNzUpJywgb3BhY2l0eTogMCwgekluZGV4OiAwIH0sXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDAlKSBzY2FsZSgxLjApJywgb3BhY2l0eTogMSwgekluZGV4OiAxIH0sXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC0xMDAlKSBzY2FsZSgxLjApJywgb3BhY2l0eTogMSwgekluZGV4OiAyIH1cbiAgXSxcblxuICAvLyBDYXJvdXNlbCB2YXJpYW50IHdpdGggYSBiaXQgb2Ygb2ZmLXN0YWdlIGVsZW1lbnRzIHNob3dpbmdcbiAgc2hvd0FkamFjZW50OiBbXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDc4JSkgc2NhbGUoMC43KScsIHpJbmRleDogMCB9LFxuICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwJSkgc2NhbGUoMC44MiknLCB6SW5kZXg6IDEgfSxcbiAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTc4JSkgc2NhbGUoMC43KScsIHpJbmRleDogMCB9XG4gIF0sXG5cbiAgLy8gU2ltcGxlIHNsaWRlXG4gIHNsaWRlOiBbXG4gICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDEwMCUpJyB9LFxuICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtMTAwJSknIH1cbiAgXSxcblxuICAvLyBTbGlkZSwgd2l0aCBhIGdhcCBiZXR3ZWVuXG4gIHNsaWRlV2l0aEdhcDogW1xuICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgxMTAlKScgfSxcbiAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTExMCUpJyB9XG4gIF1cblxufTtcblxuXG4vKlxuICogU21vb3RobHkgYW5pbWF0ZSB0aGUgc2VsZWN0aW9uIGJldHdlZW4gdGhlIGluZGljYXRlZCBcImZyb21cIiBhbmQgXCJ0b1wiXG4gKiBpbmRpY2VzLiBUaGUgZm9ybWVyIGNhbiBiZSBhIGZyYWN0aW9uLCBlLmcuLCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEgZmluZ2VyXG4gKiB0byBjb21wbGV0ZSBhIHRvdWNoIGRyYWcsIGFuZCB0aGUgc2VsZWN0aW9uIHdpbGwgc25hcCB0byB0aGUgY2xvc2VzdCB3aG9sZVxuICogaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGVTZWxlY3Rpb24oZWxlbWVudCwgZnJvbVNlbGVjdGlvbiwgdG9TZWxlY3Rpb24pIHtcblxuICByZXNldEFuaW1hdGlvbnMoZWxlbWVudCk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBhbmltYXRpb24gdGltaW5ncy5cbiAgY29uc3QgaXRlbXMgPSBlbGVtZW50Lml0ZW1zO1xuICBjb25zdCBrZXlmcmFtZXMgPSBlbGVtZW50LnNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lcztcbiAgZWxlbWVudFtwbGF5aW5nQW5pbWF0aW9uU3ltYm9sXSA9IHRydWU7XG4gIGNvbnN0IHRpbWluZ3MgPSBtaXhpbi5oZWxwZXJzLmVmZmVjdFRpbWluZ3NGb3JTZWxlY3Rpb25BbmltYXRpb24oZWxlbWVudCwgZnJvbVNlbGVjdGlvbiwgdG9TZWxlY3Rpb24pO1xuXG4gIC8vIEZpZ3VyZSBvdXQgd2hpY2ggaXRlbSB3aWxsIGJlIHRoZSBvbmUgKmFmdGVyKiB0aGUgb25lIHdlJ3JlIHNlbGVjdGluZy5cbiAgY29uc3QgaXRlbUNvdW50ID0gaXRlbXMubGVuZ3RoO1xuICBjb25zdCBzZWxlY3Rpb25XcmFwcyA9IGVsZW1lbnQuc2VsZWN0aW9uV3JhcHM7XG4gIGNvbnN0IHNlbGVjdGlvbkluZGV4ID0gRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluLmhlbHBlcnMuc2VsZWN0aW9uUGFydHModG9TZWxlY3Rpb24sIGl0ZW1Db3VudCwgc2VsZWN0aW9uV3JhcHMpLmluZGV4O1xuICBjb25zdCB0b3RhbFN0ZXBzID0gc3RlcHNUb0luZGV4KGl0ZW1Db3VudCwgc2VsZWN0aW9uV3JhcHMsIGZyb21TZWxlY3Rpb24sIHRvU2VsZWN0aW9uKTtcbiAgY29uc3QgZm9yd2FyZCA9IHRvdGFsU3RlcHMgPj0gMDtcbiAgbGV0IG5leHRVcEluZGV4ID0gc2VsZWN0aW9uSW5kZXggKyAoZm9yd2FyZCA/IDEgOiAtIDEpO1xuICBpZiAoc2VsZWN0aW9uV3JhcHMpIHtcbiAgICBuZXh0VXBJbmRleCA9IEZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbi5oZWxwZXJzLndyYXBwZWRTZWxlY3Rpb24obmV4dFVwSW5kZXgsIGl0ZW1Db3VudCk7XG4gIH0gZWxzZSBpZiAoIWlzSXRlbUluZGV4SW5Cb3VuZHMoZWxlbWVudCwgbmV4dFVwSW5kZXgpKSB7XG4gICAgbmV4dFVwSW5kZXggPSBudWxsOyAvLyBBdCBzdGFydC9lbmQgb2YgbGlzdDsgZG9uJ3QgaGF2ZSBhIG5leHQgaXRlbSB0byBzaG93LlxuICB9XG5cbiAgLy8gUGxheSB0aGUgYW5pbWF0aW9ucyB1c2luZyB0aG9zZSB0aW1pbmdzLlxuICBsZXQgbGFzdEFuaW1hdGlvbkRldGFpbHM7XG4gIHRpbWluZ3MuZm9yRWFjaCgodGltaW5nLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpbmRleF07XG4gICAgaWYgKHRpbWluZykge1xuICAgICAgc2hvd0l0ZW0oaXRlbSwgdHJ1ZSk7XG4gICAgICBjb25zdCBhbmltYXRpb24gPSBpdGVtLmFuaW1hdGUoa2V5ZnJhbWVzLCB0aW1pbmcpO1xuICAgICAgZWxlbWVudFthbmltYXRpb25TeW1ib2xdW2luZGV4XSA9IGFuaW1hdGlvbjtcbiAgICAgIGlmIChpbmRleCA9PT0gbmV4dFVwSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpdGVtIHdpbGwgYmUgYW5pbWF0ZWQsIHNvIHdpbGwgYWxyZWFkeSBiZSBpbiB0aGUgZGVzaXJlZCBzdGF0ZVxuICAgICAgICAvLyBhZnRlciB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgbmV4dFVwSW5kZXggPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWluZy5lbmREZWxheSAhPT0gMCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBhbmltYXRpb24gZm9yIHRoZSBpdGVtIHRoYXQgd2lsbCBiZSBsZWZ0IHNlbGVjdGVkLlxuICAgICAgICAvLyBXZSB3YW50IHRvIGNsZWFuIHVwIHdoZW4gdGhpcyBhbmltYXRpb24gY29tcGxldGVzLlxuICAgICAgICBsYXN0QW5pbWF0aW9uRGV0YWlscyA9IHsgYW5pbWF0aW9uLCBpbmRleCwgdGltaW5nLCBmb3J3YXJkIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXRlbSBkb2Vzbid0IHBhcnRpY2lwYXRlIGluIHRoZSBhbmltYXRpb24uXG4gICAgICBzaG93SXRlbShpdGVtLCBmYWxzZSk7XG4gICAgfVxuICB9KTtcblxuICBpZiAobGFzdEFuaW1hdGlvbkRldGFpbHMgIT0gbnVsbCkge1xuICAgIC8vIEFycmFuZ2UgZm9yIGNsZWFuLXVwIHdvcmsgdG8gYmUgcGVyZm9ybWVkLlxuICAgIGxhc3RBbmltYXRpb25EZXRhaWxzLm5leHRVcEluZGV4ID0gbmV4dFVwSW5kZXg7XG4gICAgbGFzdEFuaW1hdGlvbkRldGFpbHMuYW5pbWF0aW9uLm9uZmluaXNoID0gZXZlbnQgPT4gc2VsZWN0aW9uQW5pbWF0aW9uRmluaXNoZWQoZWxlbWVudCwgbGFzdEFuaW1hdGlvbkRldGFpbHMpO1xuICAgIGVsZW1lbnRbbGFzdEFuaW1hdGlvblN5bWJvbF0gPSBsYXN0QW5pbWF0aW9uRGV0YWlscy5hbmltYXRpb247XG4gIH0gZWxzZSB7XG4gICAgLy8gU2hvdWxkbid0IGhhcHBlbiAtLSB3ZSBzaG91bGQgYWx3YXlzIGhhdmUgYXQgbGVhc3Qgb25lIGFuaW1hdGlvbi5cbiAgICBlbGVtZW50W3BsYXlpbmdBbmltYXRpb25TeW1ib2xdID0gZmFsc2U7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBnZXRBbmltYXRpb25Gb3JJdGVtSW5kZXgoZWxlbWVudCwgaW5kZXgpIHtcbiAgaWYgKGVsZW1lbnRbYW5pbWF0aW9uU3ltYm9sXSA9PSBudWxsKSB7XG4gICAgLy8gTm90IHJlYWR5IHlldDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgYW5pbWF0aW9uID0gZWxlbWVudFthbmltYXRpb25TeW1ib2xdW2luZGV4XTtcbiAgaWYgKCFhbmltYXRpb24pIHtcbiAgICBjb25zdCBpdGVtID0gZWxlbWVudC5pdGVtc1tpbmRleF07XG4gICAgYW5pbWF0aW9uID0gaXRlbS5hbmltYXRlKGVsZW1lbnQuc2VsZWN0aW9uQW5pbWF0aW9uS2V5ZnJhbWVzLCB7XG4gICAgICBkdXJhdGlvbjogZWxlbWVudC5zZWxlY3Rpb25BbmltYXRpb25EdXJhdGlvbixcbiAgICAgIGZpbGw6ICdib3RoJ1xuICAgIH0pO1xuICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgIGVsZW1lbnRbYW5pbWF0aW9uU3ltYm9sXVtpbmRleF0gPSBhbmltYXRpb247XG4gIH1cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn1cblxuZnVuY3Rpb24gaXNJdGVtSW5kZXhJbkJvdW5kcyhlbGVtZW50LCBpbmRleCkge1xuICByZXR1cm4gaW5kZXggPj0gMCAmJiBlbGVtZW50Lml0ZW1zICYmIGluZGV4IDwgZWxlbWVudC5pdGVtcy5sZW5ndGg7XG59XG5cbi8qXG4gKiBSZW5kZXIgdGhlIHNlbGVjdGlvbiBzdGF0ZSBvZiB0aGUgZWxlbWVudC5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIHJlLXJlbmRlciBhIHByZXZpb3VzIHNlbGVjdGlvbiBzdGF0ZSAoaWYgdGhlXG4gKiBzZWxlY3RlZEluZGV4IHBhcmFtIGlzIG9taXR0ZWQpLCByZW5kZXIgdGhlIHNlbGVjdGlvbiBpbnN0YW50bHkgYXQgYSBnaXZlblxuICogd2hvbGUgb3IgZnJhY3Rpb25hbCBzZWxlY3Rpb24gaW5kZXgsIG9yIGFuaW1hdGUgdG8gYSBnaXZlbiBzZWxlY3Rpb24gaW5kZXguXG4gKlxuICogVGhlcmUgYXJlIHNldmVyYWwgZGlzdGluY3Qgc2NlbmFyaW9zIHdlIG5lZWQgdG8gY292ZXI6XG4gKlxuICogMS4gSW5pdGlhbCBwb3NpdGlvbmluZywgb3IgcmVwb3NpdGlvbmluZyBhZnRlciBjaGFuZ2luZyBhIHByb3BlcnR5IGxpa2VcbiAqICAgIHNlbGVjdGlvbkFuaW1hdGlvbktleWZyYW1lcyB0aGF0IGFmZmVjdHMgcmVuZGVyaW5nLlxuICogMi4gQW5pbWF0ZSBvbiBzZWxlY3RlZEluZGV4IGNoYW5nZS4gVGhpcyBzaG91bGQgb3ZlcnJpZGUgYW55IGFuaW1hdGlvbi9zd2lwZVxuICogICAgYWxyZWFkeSBpbiBwcm9ncmVzcy5cbiAqIDMuIEluc3RhbnRseSByZW5kZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgYSBkcmFnIG9wZXJhdGlvbiBpbiBwcm9ncmVzcy5cbiAqIDQuIENvbXBsZXRlIGEgZHJhZyBvcGVyYXRpb24uIElmIHRoZSBkcmFnIHdhc24ndCBmYXIgZW5vdWdoIHRvIGFmZmVjdFxuICogICAgc2VsZWN0aW9uLCB3ZSdsbCBqdXN0IGJlIHJlc3RvcmluZyB0aGUgc2VsZWN0ZWRGcmFjdGlvbiB0byAwLlxuICpcbiAqIElmIHRoZSBsaXN0IGRvZXMgbm90IHdyYXAsIGFueSBzZWxlY3Rpb24gcG9zaXRpb24gb3V0c2lkZSB0aGUgbGlzdCdzIGJvdW5kc1xuICogd2lsbCBiZSBkYW1wZWQgdG8gcHJvZHVjZSBhIHZpc3VhbCBlZmZlY3Qgb2YgdGVuc2lvbi5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2VsZWN0aW9uKGVsZW1lbnQsIHNlbGVjdGVkSW5kZXg9ZWxlbWVudC5zZWxlY3RlZEluZGV4LCBzZWxlY3RlZEZyYWN0aW9uPWVsZW1lbnQuc2VsZWN0ZWRGcmFjdGlvbikge1xuICBjb25zdCBpdGVtQ291bnQgPSBlbGVtZW50Lml0ZW1zID8gZWxlbWVudC5pdGVtcy5sZW5ndGggOiAwO1xuICBpZiAoaXRlbUNvdW50ID09PSAwKSB7XG4gICAgLy8gTm90aGluZyB0byByZW5kZXIuXG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzZWxlY3RlZEluZGV4IDwgMCkge1xuICAgIC8vIFRPRE86IEhhbmRsZSBubyBzZWxlY3Rpb24uXG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzZWxlY3Rpb24gPSBzZWxlY3RlZEluZGV4ICsgc2VsZWN0ZWRGcmFjdGlvbjtcbiAgaWYgKGVsZW1lbnQuc2VsZWN0aW9uV3JhcHMpIHtcbiAgICAvLyBBcHBseSB3cmFwcGluZyB0byBlbnN1cmUgY29uc2lzdGVudCByZXByZXNlbnRhdGlvbiBvZiBzZWxlY3Rpb24uXG4gICAgc2VsZWN0aW9uID0gRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluLmhlbHBlcnMud3JhcHBlZFNlbGVjdGlvbihzZWxlY3Rpb24sIGl0ZW1Db3VudCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXBwbHkgZGFtcGluZyBpZiBuZWNlc3NhcnkuXG4gICAgc2VsZWN0aW9uID0gRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluLmhlbHBlcnMuZGFtcGVkU2VsZWN0aW9uKHNlbGVjdGlvbiwgaXRlbUNvdW50KTtcbiAgfVxuICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbiA9IGVsZW1lbnRbcHJldmlvdXNTZWxlY3Rpb25TeW1ib2xdO1xuICAvLyBUT0RPOiBJZiBhbiBpdGVtIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIERPTSwgd2UgZW5kIHVwIGFuaW1hdGluZyBmcm9tXG4gIC8vIGl0cyBvbGQgaW5kZXggdG8gaXRzIG5ldyBpbmRleCwgYnV0IHdlIHJlYWxseSBkb24ndCB3YW50IHRvIGFuaW1hdGUgYXQgYWxsLlxuICBpZiAoIWVsZW1lbnRbc3ltYm9scy5kcmFnZ2luZ10gJiYgcHJldmlvdXNTZWxlY3Rpb24gIT0gbnVsbCAmJlxuICAgICAgcHJldmlvdXNTZWxlY3Rpb24gIT09IHNlbGVjdGlvbikge1xuICAgIC8vIEFuaW1hdGUgc2VsZWN0aW9uIGZyb20gcHJldmlvdXMgc3RhdGUgdG8gbmV3IHN0YXRlLlxuICAgIGFuaW1hdGVTZWxlY3Rpb24oZWxlbWVudCwgcHJldmlvdXNTZWxlY3Rpb24sIHNlbGVjdGlvbik7XG4gIH0gZWxzZSBpZiAoc2VsZWN0ZWRGcmFjdGlvbiA9PT0gMCAmJiBlbGVtZW50W3BsYXlpbmdBbmltYXRpb25TeW1ib2xdKSB7XG4gICAgLy8gQWxyZWFkeSBpbiBwcm9jZXNzIG9mIGFuaW1hdGluZyB0byBmcmFjdGlvbiAwLiBEdXJpbmcgdGhhdCBwcm9jZXNzLFxuICAgIC8vIGlnbm9yZSBzdWJzZXF1ZW50IGF0dGVtcHRzIHRvIHJlbmRlclNlbGVjdGlvbiB0byBmcmFjdGlvbiAwLlxuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZW5kZXIgY3VycmVudCBzZWxlY3Rpb24gc3RhdGUgaW5zdGFudGx5LlxuICAgIHJlbmRlclNlbGVjdGlvbkluc3RhbnRseShlbGVtZW50LCBzZWxlY3Rpb24pO1xuICB9XG4gIGVsZW1lbnRbcHJldmlvdXNTZWxlY3Rpb25TeW1ib2xdID0gc2VsZWN0aW9uO1xufVxuXG4vKlxuICogSW5zdGFudGx5IHJlbmRlciAoZG9uJ3QgYW5pbWF0ZSkgdGhlIGVsZW1lbnQncyBpdGVtcyBhdCB0aGUgZ2l2ZW4gd2hvbGUgb3JcbiAqIGZyYWN0aW9uYWwgc2VsZWN0aW9uIGluZGV4LlxuICovXG5mdW5jdGlvbiByZW5kZXJTZWxlY3Rpb25JbnN0YW50bHkoZWxlbWVudCwgdG9TZWxlY3Rpb24pIHtcbiAgaWYgKGVsZW1lbnRbcmVzZXRBbmltYXRpb25zT25OZXh0UmVuZGVyU3ltYm9sXSkge1xuICAgIHJlc2V0QW5pbWF0aW9ucyhlbGVtZW50KTtcbiAgICBlbGVtZW50W3Jlc2V0QW5pbWF0aW9uc09uTmV4dFJlbmRlclN5bWJvbF0gPSBmYWxzZTtcbiAgfVxuICBjb25zdCBhbmltYXRpb25GcmFjdGlvbnMgPSBtaXhpbi5oZWxwZXJzLmFuaW1hdGlvbkZyYWN0aW9uc0ZvclNlbGVjdGlvbihlbGVtZW50LCB0b1NlbGVjdGlvbik7XG4gIGFuaW1hdGlvbkZyYWN0aW9ucy5tYXAoKGFuaW1hdGlvbkZyYWN0aW9uLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSBlbGVtZW50Lml0ZW1zW2luZGV4XTtcbiAgICBpZiAoYW5pbWF0aW9uRnJhY3Rpb24gIT0gbnVsbCkge1xuICAgICAgc2hvd0l0ZW0oaXRlbSwgdHJ1ZSk7XG4gICAgICBzZXRBbmltYXRpb25GcmFjdGlvbihlbGVtZW50LCBpbmRleCwgYW5pbWF0aW9uRnJhY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG93SXRlbShpdGVtLCBmYWxzZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLypcbiAqIFdlIG1haW50YWluIGFuIGFycmF5IGNvbnRhaW5pbmcgYW4gYW5pbWF0aW9uIHBlciBpdGVtLiBUaGlzIGlzIHVzZWQgZm9yIHR3b1xuICogcmVhc29uczpcbiAqXG4gKiAqIER1cmluZyBhIGRyYWcgb3BlcmF0aW9uLCB3ZSB3YW50IHRvIGJlIGFibGUgdG8gcmV1c2UgYW5pbWF0aW9ucyBiZXR3ZWVuXG4gKiAgIGRyYWcgdXBkYXRlcy5cbiAqICogV2hlbiBhIHNlbGVjdGlvbiBhbmltYXRpb24gY29tcGxldGVzLCB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gbGVhdmUgdGhlXG4gKiAgIHZpc2liaWxlIGl0ZW1zIGluIGEgcGF1c2VkIHN0YXRlLiBMYXRlciwgd2UnbGwgd2FudCB0byBiZSBhYmxlIHRvIGNsZWFuIHVwXG4gKiAgIHRob3NlIGFuaW1hdGlvbnMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgYXJyYXkgaXMgc3BhcnNlOiBpdCB3aWxsIG9ubHkgaG9sZCB1cCBmcm9tIDDigJMzIGFuaW1hdGlvbnMgYXRcbiAqIGFueSBnaXZlbiBwb2ludC5cbiAqL1xuZnVuY3Rpb24gcmVzZXRBbmltYXRpb25zKGVsZW1lbnQpIHtcbiAgY29uc3QgYW5pbWF0aW9ucyA9IGVsZW1lbnRbYW5pbWF0aW9uU3ltYm9sXTtcbiAgaWYgKGFuaW1hdGlvbnMpIHtcbiAgICAvLyBDYW5jZWwgZXhpc3RpbmcgYW5pbWF0aW9ucyB0byByZW1vdmUgdGhlIGVmZmVjdHMgdGhleSdyZSBhcHBseWluZy5cbiAgICBhbmltYXRpb25zLmZvckVhY2goKGFuaW1hdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICBhbmltYXRpb25zW2luZGV4XSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgaXRlbUNvdW50ID0gZWxlbWVudC5pdGVtcyA/IGVsZW1lbnQuaXRlbXMubGVuZ3RoIDogMDtcbiAgaWYgKCFhbmltYXRpb25zIHx8IGFuaW1hdGlvbnMubGVuZ3RoICE9PSBpdGVtQ291bnQpIHtcbiAgICAvLyBIYXZlbid0IGFuaW1hdGVkIGJlZm9yZSB3aXRoIHRoaXMgbnVtYmVyIG9mIGl0ZW1zOyAocmUpY3JlYXRlIGFycmF5LlxuICAgIGVsZW1lbnRbYW5pbWF0aW9uU3ltYm9sXSA9IG5ldyBBcnJheShpdGVtQ291bnQpO1xuICB9XG59XG5cbi8qXG4gKiBUaGUgbGFzdCBhbmltYXRpb24gaW4gb3VyIHNlbGVjdGlvbiBhbmltYXRpb24gaGFzIGNvbXBsZXRlZC4gQ2xlYW4gdXAuXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdGlvbkFuaW1hdGlvbkZpbmlzaGVkKGVsZW1lbnQsIGRldGFpbHMpIHtcblxuICAvLyBXaGVuIHRoZSBsYXN0IGFuaW1hdGlvbiBjb21wbGV0ZXMsIHNob3cgdGhlIG5leHQgaXRlbSBpbiB0aGUgZGlyZWN0aW9uXG4gIC8vIHdlJ3JlIGdvaW5nLiBXYWl0aW5nIHRvIHRoYXQgdW50aWwgdGhpcyBwb2ludCBpcyBhIGJpdCBvZiBhIGhhY2sgdG8gYXZvaWRcbiAgLy8gaGF2aW5nIGEgbmV4dCBpdGVtIHRoYXQncyBoaWdoZXIgaW4gdGhlIG5hdHVyYWwgei1vcmRlciBvYnNjdXJlIG90aGVyIGl0ZW1zXG4gIC8vIGR1cmluZyBhbmltYXRpb24uXG4gIGNvbnN0IG5leHRVcEluZGV4ID0gZGV0YWlscy5uZXh0VXBJbmRleDtcbiAgaWYgKG5leHRVcEluZGV4ICE9IG51bGwpIHtcbiAgICBpZiAoZWxlbWVudFthbmltYXRpb25TeW1ib2xdW25leHRVcEluZGV4XSkge1xuICAgICAgLy8gQ2FuY2VsIGV4aXN0aW5nIHNlbGVjdGlvbiBhbmltYXRpb24gc28gd2UgY2FuIGNvbnN0cnVjdCBhIG5ldyBvbmUuXG4gICAgICBlbGVtZW50W2FuaW1hdGlvblN5bWJvbF1bbmV4dFVwSW5kZXhdLmNhbmNlbCgpO1xuICAgICAgZWxlbWVudFthbmltYXRpb25TeW1ib2xdW25leHRVcEluZGV4XSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbkZyYWN0aW9uID0gZGV0YWlscy5mb3J3YXJkID8gMCA6IDE7XG4gICAgc2V0QW5pbWF0aW9uRnJhY3Rpb24oZWxlbWVudCwgbmV4dFVwSW5kZXgsIGFuaW1hdGlvbkZyYWN0aW9uKTtcbiAgICBzaG93SXRlbShlbGVtZW50Lml0ZW1zW25leHRVcEluZGV4XSwgdHJ1ZSk7XG4gIH1cblxuICBlbGVtZW50W2xhc3RBbmltYXRpb25TeW1ib2xdLm9uZmluaXNoID0gbnVsbDtcbiAgZWxlbWVudFtwbGF5aW5nQW5pbWF0aW9uU3ltYm9sXSA9IGZhbHNlO1xufVxuXG4vKlxuICogUGF1c2UgdGhlIGluZGljYXRlZCBhbmltYXRpb24gYW5kIGhhdmUgaXQgc2hvdyB0aGUgYW5pbWF0aW9uIGF0IHRoZSBnaXZlblxuICogZnJhY3Rpb24gKGJldHdlZW4gMCBhbmQgMSkgb2YgdGhlIHdheSB0aHJvdWdoIHRoZSBhbmltYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHNldEFuaW1hdGlvbkZyYWN0aW9uKGVsZW1lbnQsIGl0ZW1JbmRleCwgZnJhY3Rpb24pIHtcbiAgY29uc3QgYW5pbWF0aW9uID0gZ2V0QW5pbWF0aW9uRm9ySXRlbUluZGV4KGVsZW1lbnQsIGl0ZW1JbmRleCk7XG4gIGlmIChhbmltYXRpb24pIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IGVsZW1lbnQuc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb247XG4gICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICBhbmltYXRpb24uY3VycmVudFRpbWUgPSBmcmFjdGlvbiAqIGR1cmF0aW9uO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzaG93SXRlbShpdGVtLCBmbGFnKSB7XG4gIGl0ZW0uc3R5bGUudmlzaWJpbGl0eSA9IGZsYWcgPyAndmlzaWJsZScgOiAnaGlkZGVuJztcbn1cblxuLypcbiAqIEZpZ3VyZSBvdXQgaG93IG1hbnkgc3RlcHMgaXQgd2lsbCB0YWtlIHRvIGdvIGZyb20gZnJvbVNlbGVjdGlvbiB0b1xuICogdG9TZWxlY3Rpb24uIFRvIGdvIGZyb20gaXRlbSAzIHRvIGl0ZW0gNCBpcyBvbmUgc3RlcC5cbiAqXG4gKiBJZiB3cmFwcGluZyBpcyBhbGxvd2VkLCB0aGVuIGdvaW5nIGZyb20gdGhlIGxhc3QgaXRlbSB0byB0aGUgZmlyc3Qgd2lsbCB0YWtlXG4gKiBvbmUgc3RlcCAoZm9yd2FyZCksIGFuZCBnb2luZyBmcm9tIHRoZSBmaXJzdCBpdGVtIHRvIHRoZSBsYXN0IHdpbGwgdGFrZSBvbmVcbiAqIHN0ZXAgKGJhY2t3YXJkKS5cbiAqL1xuZnVuY3Rpb24gc3RlcHNUb0luZGV4KGxlbmd0aCwgYWxsb3dXcmFwLCBmcm9tU2VsZWN0aW9uLCB0b1NlbGVjdGlvbikge1xuICBsZXQgc3RlcHMgPSB0b1NlbGVjdGlvbiAtIGZyb21TZWxlY3Rpb247XG4gIC8vIFdyYXBwaW5nIG9ubHkga2lja3MgaW4gd2hlbiBsaXN0IGhhcyBtb3JlIHRoYW4gMSBpdGVtLlxuICBpZiAoYWxsb3dXcmFwICYmIGxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCB3cmFwU3RlcHMgPSBsZW5ndGggLSBNYXRoLmFicyhzdGVwcyk7XG4gICAgaWYgKHdyYXBTdGVwcyA8PSAxKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2VcbiAgICAgIHN0ZXBzID0gc3RlcHMgPCAwID9cbiAgICAgICAgd3JhcFN0ZXBzIDogICAvLyBXcmFwIGZvcndhcmQgZnJvbSBsYXN0IGl0ZW0gdG8gZmlyc3QuXG4gICAgICAgIC13cmFwU3RlcHM7ICAgLy8gV3JhcCBiYWNrd2FyZCBmcm9tIGZpcnN0IGl0ZW0gdG8gbGFzdC5cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0ZXBzO1xufVxuIiwiaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi9zeW1ib2xzJztcblxuXG4vLyBVc2VkIHRvIGFzc2lnbiB1bmlxdWUgSURzIHRvIGl0ZW0gZWxlbWVudHMgd2l0aG91dCBJRHMuXG5sZXQgaWRDb3VudCA9IDA7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTZWxlY3Rpb25BcmlhQWN0aXZlLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gd2hpY2ggdHJlYXRzIHRoZSBzZWxlY3RlZCBpdGVtIGluIGEgbGlzdCBhcyB0aGUgYWN0aXZlIGl0ZW0gaW4gQVJJQVxuICAgKiBhY2Nlc3NpYmlsaXR5IHRlcm1zLlxuICAgKlxuICAgKiBIYW5kbGluZyBBUklBIHNlbGVjdGlvbiBzdGF0ZSBwcm9wZXJseSBpcyBhY3R1YWxseSBxdWl0ZSBjb21wbGV4OlxuICAgKlxuICAgKiAqIFRoZSBpdGVtcyBpbiB0aGUgbGlzdCBuZWVkIHRvIGJlIGluZGljYXRlZCBhcyBwb3NzaWJsZSBpdGVtcyB2aWEgYW4gQVJJQVxuICAgKiAgIGByb2xlYCBhdHRyaWJ1dGUgdmFsdWUgc3VjaCBhcyBcIm9wdGlvblwiLlxuICAgKiAqIFRoZSBzZWxlY3RlZCBpdGVtIG5lZWQgdG8gYmUgbWFya2VkIGFzIHNlbGVjdGVkIGJ5IHNldHRpbmcgdGhlIGl0ZW0nc1xuICAgKiAgIGBhcmlhLXNlbGVjdGVkYCBhdHRyaWJ1dGUgdG8gdHJ1ZSAqYW5kKiB0aGUgb3RoZXIgaXRlbXMgbmVlZCBiZSBtYXJrZWQgYXNcbiAgICogICAqbm90KiBzZWxlY3RlZCBieSBzZXR0aW5nIGBhcmlhLXNlbGVjdGVkYCB0byBmYWxzZS5cbiAgICogKiBUaGUgb3V0ZXJtb3N0IGVsZW1lbnQgd2l0aCB0aGUga2V5Ym9hcmQgZm9jdXMgbmVlZHMgdG8gaGF2ZSBhdHRyaWJ1dGVzXG4gICAqICAgc2V0IG9uIGl0IHNvIHRoYXQgdGhlIHNlbGVjdGlvbiBpcyBrbm93YWJsZSBhdCB0aGUgbGlzdCBsZXZlbCB2aWEgdGhlXG4gICAqICAgYGFyaWEtYWN0aXZlZGVzY2VuZGFudGAgYXR0cmlidXRlLlxuICAgKiAqIFVzZSBvZiBgYXJpYS1hY3RpdmVkZXNjZW5kYW50YCBpbiB0dXJuIHJlcXVpcmVzIHRoYXQgYWxsIGl0ZW1zIGluIHRoZVxuICAgKiAgIGxpc3QgaGF2ZSBJRCBhdHRyaWJ1dGVzIGFzc2lnbmVkIHRvIHRoZW0uXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gdHJpZXMgdG8gYWRkcmVzcyBhbGwgb2YgdGhlIGFib3ZlIHJlcXVpcmVtZW50cy4gVG8gdGhhdCBlbmQsXG4gICAqIHRoaXMgbWl4aW4gd2lsbCBhc3NpZ24gZ2VuZXJhdGVkIElEcyB0byBhbnkgaXRlbSB0aGF0IGRvZXNuJ3QgYWxyZWFkeSBoYXZlXG4gICAqIGFuIElELlxuICAgKlxuICAgKiBBUklBIHJlbGllcyBvbiBlbGVtZW50cyB0byBwcm92aWRlIGByb2xlYCBhdHRyaWJ1dGVzLiBUaGlzIG1peGluIHdpbGwgYXBwbHlcbiAgICogYSBkZWZhdWx0IHJvbGUgb2YgXCJsaXN0Ym94XCIgb24gdGhlIG91dGVyIGxpc3QgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGhhdmUgYW5cbiAgICogZXhwbGljaXQgcm9sZS4gU2ltaWxhcmx5LCB0aGlzIG1peGluIHdpbGwgYXBwbHkgYSBkZWZhdWx0IHJvbGUgb2YgXCJvcHRpb25cIlxuICAgKiB0byBhbnkgbGlzdCBpdGVtIHRoYXQgZG9lcyBub3QgYWxyZWFkeSBoYXZlIGEgcm9sZSBzcGVjaWZpZWQuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyBhIHNldCBvZiBtZW1iZXJzIHRoYXQgbWFuYWdlIHRoZSBzdGF0ZSBvZiB0aGUgc2VsZWN0aW9uOlxuICAgKiBgW3N5bWJvbHMuaXRlbVNlbGVjdGVkXWAsIGBpdGVtQWRkZWRgLCBhbmQgYHNlbGVjdGVkSW5kZXhgLiBZb3UgY2FuXG4gICAqIHN1cHBseSB0aGVzZSB5b3Vyc2VsZiwgb3IgZG8gc28gdmlhXG4gICAqIFtTaW5nbGVTZWxlY3Rpb25NaXhpbl0oU2luZ2xlU2VsZWN0aW9uTWl4aW4ubWQpLlxuICAgKi9cbiAgY2xhc3MgU2VsZWN0aW9uQXJpYUFjdGl2ZSBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBpZiAoc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2spIHsgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTsgfVxuICAgICAgLy8gU2V0IGRlZmF1bHQgQVJJQSByb2xlLlxuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT0gbnVsbCAmJiB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnJvbGUpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnJvbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMucm9sZSA9ICdsaXN0Ym94JztcbiAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICBbc3ltYm9scy5pdGVtQWRkZWRdKGl0ZW0pIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1BZGRlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtQWRkZWRdKGl0ZW0pOyB9XG5cbiAgICAgIGlmICghaXRlbS5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSkge1xuICAgICAgICAvLyBBc3NpZ24gYSBkZWZhdWx0IEFSSUEgcm9sZS5cbiAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnb3B0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSBlYWNoIGl0ZW0gaGFzIGFuIElEIHNvIHdlIGNhbiBzZXQgYXJpYS1hY3RpdmVkZXNjZW5kYW50IG9uIHRoZVxuICAgICAgLy8gb3ZlcmFsbCBsaXN0IHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgSUQgd2lsbCB0YWtlIHRoZSBmb3JtIG9mIGEgYmFzZSBJRCBwbHVzIGEgdW5pcXVlIGludGVnZXIuIFRoZSBiYXNlXG4gICAgICAvLyBJRCB3aWxsIGJlIGluY29ycG9yYXRlIHRoZSBjb21wb25lbnQncyBvd24gSUQuIEUuZy4sIGlmIGEgY29tcG9uZW50IGhhc1xuICAgICAgLy8gSUQgXCJmb29cIiwgdGhlbiBpdHMgaXRlbXMgd2lsbCBoYXZlIElEcyB0aGF0IGxvb2sgbGlrZSBcIl9mb29PcHRpb24xXCIuIElmXG4gICAgICAvLyB0aGUgY29tcG5lbnQgaGFzIG5vIElEIGl0c2VsZiwgaXRzIGl0ZW1zIHdpbGwgZ2V0IElEcyB0aGF0IGxvb2sgbGlrZVxuICAgICAgLy8gXCJfb3B0aW9uMVwiLiBJdGVtIElEcyBhcmUgcHJlZml4ZWQgd2l0aCBhbiB1bmRlcnNjb3JlIHRvIGRpZmZlcmVudGlhdGVcbiAgICAgIC8vIHRoZW0gZnJvbSBtYW51YWxseS1hc3NpZ25lZCBJRHMsIGFuZCB0byBtaW5pbWl6ZSB0aGUgcG90ZW50aWFsIGZvciBJRFxuICAgICAgLy8gY29uZmxpY3RzLlxuICAgICAgaWYgKCFpdGVtLmlkKSB7XG4gICAgICAgIGNvbnN0IGJhc2VJZCA9IHRoaXMuaWQgP1xuICAgICAgICAgICAgXCJfXCIgKyB0aGlzLmlkICsgXCJPcHRpb25cIiA6XG4gICAgICAgICAgICBcIl9vcHRpb25cIjtcbiAgICAgICAgaXRlbS5pZCA9IGJhc2VJZCArIGlkQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIHNlbGVjdGVkKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCk7IH1cbiAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgc2VsZWN0ZWQpO1xuICAgICAgY29uc3QgaXRlbUlkID0gaXRlbS5pZDtcbiAgICAgIGlmIChpdGVtSWQgJiYgc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIGl0ZW1JZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHNlbGVjdGVkSXRlbSgpIHtcbiAgICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEl0ZW07XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEl0ZW0oaXRlbSkge1xuICAgICAgaWYgKCdzZWxlY3RlZEl0ZW0nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGVkSXRlbSA9IGl0ZW07IH1cbiAgICAgIGlmIChpdGVtID09IG51bGwpIHtcbiAgICAgICAgLy8gU2VsZWN0aW9uIHdhcyByZW1vdmVkLlxuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gU2VsZWN0aW9uQXJpYUFjdGl2ZTtcbn07XG4iLCJpbXBvcnQgc3ltYm9scyBmcm9tICcuLi9zcmMvc3ltYm9scyc7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTZWxlY3Rpb25IaWdobGlnaHQuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBUZW1wbGF0ZSBtaXhpbiB3aGljaCBhcHBsaWVzIHN0YW5kYXJkIGhpZ2hsaWdodCBjb2xvcnMgdG8gYSBzZWxlY3RlZCBpdGVtLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGhpZ2hsaWdodHMgdGV4dHVhbCBpdGVtcyAoZS5nLiwgaW4gYSBsaXN0KSBpbiBhIHN0YW5kYXJkIHdheSBieVxuICAgKiB1c2luZyB0aGUgQ1NTIGBoaWdobGlnaHRgIGFuZCBgaGlnaGxpZ2h0dGV4dGAgY29sb3IgdmFsdWVzLiBUaGVzZSB2YWx1ZXNcbiAgICogcmVzcGVjdCBvcGVyYXRpbmcgc3lzdGVtIGRlZmF1bHRzIGFuZCB1c2VyIHByZWZlcmVuY2VzLCBhbmQgaGVuY2UgYXJlIGdvb2RcbiAgICogZGVmYXVsdCB2YWx1ZXMgZm9yIGhpZ2hsaWdodCBjb2xvcnMuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyBhIGBzZWxlY3RlZGAgY2xhc3MgdG8gYmUgYXBwbGllZCB0byBzZWxlY3RlZCBpdGVtcy4gWW91XG4gICAqIGNhbiB1c2UgW0NvbnRlbnRJdGVtc01peGluXShDb250ZW50SXRlbXNNaXhpbi5tZCkgZm9yIHRoYXQgcHVycG9zZS5cbiAgICovXG4gIGNsYXNzIFNlbGVjdGlvbkhpZ2hsaWdodCBleHRlbmRzIGJhc2Uge1xuXG4gICAgZ2V0IFtzeW1ib2xzLnRlbXBsYXRlXSgpIHtcbiAgICAgIGNvbnN0IGJhc2VUZW1wbGF0ZSA9IHN1cGVyW3N5bWJvbHMudGVtcGxhdGVdIHx8ICcnO1xuICAgICAgcmV0dXJuIGBcbiAgICAgICAgPHN0eWxlPlxuICAgICAgICAgIDpob3N0KFtnZW5lcmljPVwiXCJdKSA6OnNsb3R0ZWQoLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBoaWdobGlnaHQ7XG4gICAgICAgICAgICBjb2xvcjogaGlnaGxpZ2h0dGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIDwvc3R5bGU+XG4gICAgICAgICR7YmFzZVRlbXBsYXRlfVxuICAgICAgYDtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBTZWxlY3Rpb25IaWdobGlnaHQ7XG59O1xuIiwiLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTZWxlY3Rpb25JblZpZXcuICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBzY3JvbGxzIGEgY29udGFpbmVyIHRvIGVuc3VyZSB0aGF0IGEgbmV3bHktc2VsZWN0ZWQgaXRlbSBpc1xuICAgKiB2aXNpYmxlIHRvIHRoZSB1c2VyLlxuICAgKlxuICAgKiBXaGVuIHRoZSBzZWxlY3RlZCBpdGVtIGluIGEgbGlzdC1saWtlIGNvbXBvbmVudCBjaGFuZ2VzLCBpdCdzIGVhc2llciBmb3JcbiAgICogdGhlIHRvIGNvbmZpcm0gdGhhdCB0aGUgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkIHRvIGFuIGFwcHJvcHJpYXRlIGl0ZW0gaWYgdGhlXG4gICAqIHVzZXIgY2FuIGFjdHVhbGx5IHNlZSB0aGF0IGl0ZW0uXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyBhIGBzZWxlY3RlZEl0ZW1gIHByb3BlcnR5IHRvIGJlIHNldCB3aGVuIHRoZSBzZWxlY3Rpb25cbiAgICogY2hhbmdlcy4gWW91IGNhbiBzdXBwbHkgdGhhdCB5b3Vyc2VsZiwgb3IgdXNlXG4gICAqIFtTaW5nbGVTZWxlY3Rpb25NaXhpbl0oU2luZ2xlU2VsZWN0aW9uTWl4aW4ubWQpLlxuICAgKi9cbiAgY2xhc3MgU2VsZWN0aW9uSW5WaWV3IGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgICBjb25zdCBzZWxlY3RlZEl0ZW0gPSB0aGlzLnNlbGVjdGVkSXRlbTtcbiAgICAgIGlmIChzZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgdGhpcy5zY3JvbGxJdGVtSW50b1ZpZXcoc2VsZWN0ZWRJdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRJdGVtKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnNlbGVjdGVkSXRlbTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkSXRlbShpdGVtKSB7XG4gICAgICBpZiAoJ3NlbGVjdGVkSXRlbScgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRJdGVtID0gaXRlbTsgfVxuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgLy8gS2VlcCB0aGUgc2VsZWN0ZWQgaXRlbSBpbiB2aWV3LlxuICAgICAgICB0aGlzLnNjcm9sbEl0ZW1JbnRvVmlldyhpdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGwgdGhlIGdpdmVuIGVsZW1lbnQgY29tcGxldGVseSBpbnRvIHZpZXcsIG1pbmltaXppbmcgdGhlIGRlZ3JlZSBvZlxuICAgICAqIHNjcm9sbGluZyBwZXJmb3JtZWQuXG4gICAgICpcbiAgICAgKiBCbGluayBoYXMgYSBgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCgpYCBmdW5jdGlvbiB0aGF0IGRvZXMgc29tZXRoaW5nXG4gICAgICogc2ltaWxhciwgYnV0IHVuZm9ydHVuYXRlbHkgaXQncyBub24tc3RhbmRhcmQsIGFuZCBpbiBhbnkgZXZlbnQgb2Z0ZW4gZW5kc1xuICAgICAqIHVwIHNjcm9sbGluZyBtb3JlIHRoYW4gaXMgYWJzb2x1dGVseSBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIC0gdGhlIGl0ZW0gdG8gc2Nyb2xsIGludG8gdmlldy5cbiAgICAgKi9cbiAgICBzY3JvbGxJdGVtSW50b1ZpZXcoaXRlbSkge1xuICAgICAgaWYgKHN1cGVyLnNjcm9sbEl0ZW1JbnRvVmlldykgeyBzdXBlci5zY3JvbGxJdGVtSW50b1ZpZXcoKTsgfVxuICAgICAgLy8gR2V0IHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSB3aXRoIHJlc3BlY3QgdG8gdGhlIHRvcCBvZiB0aGVcbiAgICAgIC8vIGxpc3QncyBzY3JvbGxhYmxlIGNhbnZhcy4gQW4gaXRlbSBhdCB0aGUgdG9wIG9mIHRoZSBsaXN0IHdpbGwgaGF2ZSBhXG4gICAgICAvLyBlbGVtZW50VG9wIG9mIDAuXG5cbiAgICAgIGNvbnN0IHNjcm9sbFRhcmdldCA9IHRoaXMuc2Nyb2xsVGFyZ2V0O1xuICAgICAgY29uc3QgZWxlbWVudFRvcCA9IGl0ZW0ub2Zmc2V0VG9wIC0gc2Nyb2xsVGFyZ2V0Lm9mZnNldFRvcCAtIHNjcm9sbFRhcmdldC5jbGllbnRUb3A7XG4gICAgICBjb25zdCBlbGVtZW50Qm90dG9tID0gZWxlbWVudFRvcCArIGl0ZW0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBib3R0b20gb2YgdGhlIHNjcm9sbGFibGUgY2FudmFzLlxuICAgICAgY29uc3Qgc2Nyb2xsQm90dG9tID0gc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCArIHNjcm9sbFRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgICBpZiAoZWxlbWVudEJvdHRvbSA+IHNjcm9sbEJvdHRvbSkge1xuICAgICAgICAvLyBTY3JvbGwgdXAgdW50aWwgaXRlbSBpcyBlbnRpcmVseSB2aXNpYmxlLlxuICAgICAgICBzY3JvbGxUYXJnZXQuc2Nyb2xsVG9wICs9IGVsZW1lbnRCb3R0b20gLSBzY3JvbGxCb3R0b207XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbGVtZW50VG9wIDwgc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCkge1xuICAgICAgICAvLyBTY3JvbGwgZG93biB1bnRpbCBpdGVtIGlzIGVudGlyZWx5IHZpc2libGUuXG4gICAgICAgIHNjcm9sbFRhcmdldC5zY3JvbGxUb3AgPSBlbGVtZW50VG9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHNjcm9sbGVkIHRvIGJyaW5nIGFuIGl0ZW0gaW50byB2aWV3LlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSBpcyB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0IHNjcm9sbFRhcmdldCgpIHtcbiAgICAgIC8vIFByZWZlciBiYXNlIHJlc3VsdC5cbiAgICAgIHJldHVybiAnc2Nyb2xsVGFyZ2V0JyBpbiBiYXNlLnByb3RvdHlwZSA/IHN1cGVyLnNjcm9sbFRhcmdldCA6IHRoaXM7XG4gICAgfVxuICAgIHNldCBzY3JvbGxUYXJnZXQoZWxlbWVudCkge1xuICAgICAgaWYgKCdzY3JvbGxUYXJnZXQnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNjcm9sbFRhcmdldCA9IGVsZW1lbnQ7IH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBTZWxlY3Rpb25JblZpZXc7XG59O1xuIiwiLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTaGFkb3dFbGVtZW50UmVmZXJlbmNlcy4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHRvIGNyZWF0ZSByZWZlcmVuY2VzIHRvIGVsZW1lbnRzIGluIGEgY29tcG9uZW50J3MgU2hhZG93IERPTSBzdWJ0cmVlLlxuICAgKlxuICAgKiBUaGlzIGFkZHMgYSBtZW1iZXIgb24gdGhlIGNvbXBvbmVudCBjYWxsZWQgYHRoaXMuJGAgdGhhdCBjYW4gYmUgdXNlZCB0b1xuICAgKiByZWZlcmVuY2Ugc2hhZG93IGVsZW1lbnRzIHdpdGggSURzLiBFLmcuLCBpZiBjb21wb25lbnQncyBzaGFkb3cgY29udGFpbnMgYW5cbiAgICogZWxlbWVudCBgPGJ1dHRvbiBpZD1cImZvb1wiPmAsIHRoZW4gdGhpcyBtaXhpbiB3aWxsIGNyZWF0ZSBhIG1lbWJlclxuICAgKiBgdGhpcy4kLmZvb2AgdGhhdCBwb2ludHMgdG8gdGhhdCBidXR0b24uXG4gICAqXG4gICAqIFN1Y2ggcmVmZXJlbmNlcyBzaW1wbGlmeSBhIGNvbXBvbmVudCdzIGFjY2VzcyB0byBpdHMgb3duIGVsZW1lbnRzLiBJblxuICAgKiBleGNoYW5nZSwgdGhpcyBtaXhpbiB0cmFkZXMgb2ZmIGEgb25lLXRpbWUgY29zdCBvZiBxdWVyeWluZyBhbGwgZWxlbWVudHMgaW5cbiAgICogdGhlIHNoYWRvdyB0cmVlIGluc3RlYWQgb2YgcGF5aW5nIGFuIG9uZ29pbmcgY29zdCB0byBxdWVyeSBmb3IgYW4gZWxlbWVudFxuICAgKiBlYWNoIHRpbWUgdGhlIGNvbXBvbmVudCB3YW50cyB0byBpbnNwZWN0IG9yIG1hbmlwdWxhdGUgaXQuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyB0aGUgY29tcG9uZW50IHRvIGRlZmluZSBhIFNoYWRvdyBET00gc3VidHJlZS4gWW91IGNhblxuICAgKiBjcmVhdGUgdGhhdCB0cmVlIHlvdXJzZWxmLCBvciBtYWtlIHVzZSBvZlxuICAgKiBbU2hhZG93VGVtcGxhdGVNaXhpbl0oU2hhZG93VGVtcGxhdGVNaXhpbi5tZCkuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gaXMgaW5zcGlyZWQgYnkgUG9seW1lcidzIFthdXRvbWF0aWNcbiAgICogbm9kZSBmaW5kaW5nXShodHRwczovL3d3dy5wb2x5bWVyLXByb2plY3Qub3JnLzEuMC9kb2NzL2Rldmd1aWRlL2xvY2FsLWRvbS5odG1sI25vZGUtZmluZGluZylcbiAgICogZmVhdHVyZS5cbiAgICovXG4gIGNsYXNzIFNoYWRvd0VsZW1lbnRSZWZlcmVuY2VzIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICBpZiAodGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIC8vIExvb2sgZm9yIGVsZW1lbnRzIGluIHRoZSBzaGFkb3cgc3VidHJlZSB0aGF0IGhhdmUgaWQgYXR0cmlidXRlcy5cbiAgICAgICAgLy8gQW4gYWx0ZXJuYXRpdmVseSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1peGluIHdvdWxkIGJlIHRvIGp1c3QgZGVmaW5lXG4gICAgICAgIC8vIGEgdGhpcy4kIGdldHRlciB0aGF0IGxhemlseSBkb2VzIHRoaXMgc2VhcmNoIHRoZSBmaXJzdCB0aW1lIHNvbWVvbmVcbiAgICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIHRoaXMuJC4gVGhhdCBtaWdodCBpbnRyb2R1Y2Ugc29tZSBjb21wbGV4aXR5IOKAkyBpZiB0aGVcbiAgICAgICAgLy8gdGhlIHRyZWUgY2hhbmdlZCBhZnRlciBpdCB3YXMgZmlyc3QgcG9wdWxhdGVkLCB0aGUgcmVzdWx0IG9mXG4gICAgICAgIC8vIHNlYXJjaGluZyBmb3IgYSBub2RlIG1pZ2h0IGJlIHNvbWV3aGF0IHVucHJlZGljdGFibGUuXG4gICAgICAgIHRoaXMuJCA9IHt9O1xuICAgICAgICBjb25zdCBub2Rlc1dpdGhJZHMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnW2lkXScpO1xuICAgICAgICBbXS5mb3JFYWNoLmNhbGwobm9kZXNXaXRoSWRzLCBub2RlID0+IHtcbiAgICAgICAgICBjb25zdCBpZCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgIHRoaXMuJFtpZF0gPSBub2RlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29sbGVjdGlvbiBvZiByZWZlcmVuY2VzIHRvIHRoZSBlbGVtZW50cyB3aXRoIElEcyBpbiBhIGNvbXBvbmVudCdzXG4gICAgICogU2hhZG93IERPTSBzdWJ0cmVlLlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAbWVtYmVyICRcbiAgICAgKi9cbiAgfVxuXG4gIHJldHVybiBTaGFkb3dFbGVtZW50UmVmZXJlbmNlcztcbn07XG4iLCJpbXBvcnQgc3ltYm9scyBmcm9tICcuLi9zcmMvc3ltYm9scyc7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTaGFkb3dUZW1wbGF0ZS4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIGZvciBzdGFtcGluZyBhIHRlbXBsYXRlIGludG8gYSBTaGFkb3cgRE9NIHN1YnRyZWUgdXBvbiBjb21wb25lbnRcbiAgICogaW5zdGFudGlhdGlvbi5cbiAgICpcbiAgICogVG8gdXNlIHRoaXMgbWl4aW4sIGRlZmluZSBhIGB0ZW1wbGF0ZWAgcHJvcGVydHkgYXMgYSBzdHJpbmcgb3IgSFRNTFxuICAgKiBgPHRlbXBsYXRlPmAgZWxlbWVudDpcbiAgICpcbiAgICogICAgIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIFNoYWRvd1RlbXBsYXRlTWl4aW4oSFRNTEVsZW1lbnQpIHtcbiAgICogICAgICAgZ2V0IFtzeW1ib2xzLnRlbXBsYXRlXSgpIHtcbiAgICogICAgICAgICByZXR1cm4gYEhlbGxvLCA8ZW0+d29ybGQ8L2VtPi5gO1xuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqXG4gICAqIFdoZW4geW91ciBjb21wb25lbnQgY2xhc3MgaXMgaW5zdGFudGlhdGVkLCBhIHNoYWRvdyByb290IHdpbGwgYmUgY3JlYXRlZCBvblxuICAgKiB0aGUgaW5zdGFuY2UsIGFuZCB0aGUgY29udGVudHMgb2YgdGhlIHRlbXBsYXRlIHdpbGwgYmUgY2xvbmVkIGludG8gdGhlXG4gICAqIHNoYWRvdyByb290LiBJZiB5b3VyIGNvbXBvbmVudCBkb2VzIG5vdCBkZWZpbmUgYSBgdGVtcGxhdGVgIHByb3BlcnR5LCB0aGlzXG4gICAqIG1peGluIGhhcyBubyBlZmZlY3QuXG4gICAqXG4gICAqIEZvciB0aGUgdGltZSBiZWluZywgdGhpcyBleHRlbnNpb24gcmV0YWlucyBzdXBwb3J0IGZvciBTaGFkb3cgRE9NIHYwLiBUaGF0XG4gICAqIHdpbGwgZXZlbnR1YWxseSBiZSBkZXByZWNhdGVkIGFzIGJyb3dzZXJzIChhbmQgdGhlIFNoYWRvdyBET00gcG9seWZpbGwpXG4gICAqIGltcGxlbWVudCBTaGFkb3cgRE9NIHYxLlxuICAgKi9cbiAgY2xhc3MgU2hhZG93VGVtcGxhdGUgZXh0ZW5kcyBiYXNlIHtcblxuICAgIC8qXG4gICAgICogSWYgdGhlIGNvbXBvbmVudCBkZWZpbmVzIGEgdGVtcGxhdGUsIGEgc2hhZG93IHJvb3Qgd2lsbCBiZSBjcmVhdGVkIG9uIHRoZVxuICAgICAqIGNvbXBvbmVudCBpbnN0YW5jZSwgYW5kIHRoZSB0ZW1wbGF0ZSBzdGFtcGVkIGludG8gaXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgbGV0IHRlbXBsYXRlID0gdGhpc1tzeW1ib2xzLnRlbXBsYXRlXTtcbiAgICAgIC8vIFRPRE86IFNhdmUgdGhlIHByb2Nlc3NlZCB0ZW1wbGF0ZSB3aXRoIHRoZSBjb21wb25lbnQncyBjbGFzcyBwcm90b3R5cGVcbiAgICAgIC8vIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBwcm9jZXNzZWQgd2l0aCBldmVyeSBpbnN0YW50aWF0aW9uLlxuICAgICAgaWYgKHRlbXBsYXRlKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBVcGdyYWRlIHBsYWluIHN0cmluZyB0byByZWFsIHRlbXBsYXRlLlxuICAgICAgICAgIHRlbXBsYXRlID0gY3JlYXRlVGVtcGxhdGVXaXRoSW5uZXJIVE1MKHRlbXBsYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwpIHtcbiAgICAgICAgICBzaGltVGVtcGxhdGVTdHlsZXModGVtcGxhdGUsIHRoaXMubG9jYWxOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBkb2N1bWVudC5pbXBvcnROb2RlKHRlbXBsYXRlLmNvbnRlbnQsIHRydWUpO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBTaGFkb3dUZW1wbGF0ZTtcbn07XG5cblxuLy8gQ29udmVydCBhIHBsYWluIHN0cmluZyBvZiBIVE1MIGludG8gYSByZWFsIHRlbXBsYXRlIGVsZW1lbnQuXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZVdpdGhJbm5lckhUTUwoaW5uZXJIVE1MKSB7XG4gIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgLy8gUkVWSUVXOiBJcyB0aGVyZSBhbiBlYXNpZXIgd2F5IHRvIGRvIHRoaXM/XG4gIC8vIFdlJ2QgbGlrZSB0byBqdXN0IHNldCBpbm5lckhUTUwgb24gdGhlIHRlbXBsYXRlIGNvbnRlbnQsIGJ1dCBzaW5jZSBpdCdzXG4gIC8vIGEgRG9jdW1lbnRGcmFnbWVudCwgdGhhdCBkb2Vzbid0IHdvcmsuXG4gIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuICB3aGlsZSAoZGl2LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgIHRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZGl2LmNoaWxkTm9kZXNbMF0pO1xuICB9XG4gIHJldHVybiB0ZW1wbGF0ZTtcbn1cblxuLy8gSW52b2tlIGJhc2ljIHN0eWxlIHNoaW1taW5nIHdpdGggU2hhZG93Q1NTLlxuZnVuY3Rpb24gc2hpbVRlbXBsYXRlU3R5bGVzKHRlbXBsYXRlLCB0YWcpIHtcbiAgd2luZG93LldlYkNvbXBvbmVudHMuU2hhZG93Q1NTLnNoaW1TdHlsaW5nKHRlbXBsYXRlLmNvbnRlbnQsIHRhZyk7XG59XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IGNhblNlbGVjdE5leHRTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2NhblNlbGVjdE5leHQnKTtcbmNvbnN0IGNhblNlbGVjdFByZXZpb3VzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdjYW5TZWxlY3RQcmV2aW91cycpO1xuY29uc3Qgc2VsZWN0aW9uUmVxdWlyZWRTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3NlbGVjdGlvblJlcXVpcmVkJyk7XG5jb25zdCBzZWxlY3Rpb25XcmFwc1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnc2VsZWN0aW9uV3JhcHMnKTtcblxuLy8gV2Ugd2FudCB0byBleHBvc2UgYm90aCBzZWxlY3RlZEluZGV4IGFuZCBzZWxlY3RlZEl0ZW0gYXMgaW5kZXBlbmRlbnRcbi8vIHByb3BlcnRpZXMgYnV0IGtlZXAgdGhlbSBpbiBzeW5jLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB1c2VyIHRvIHJlZmVyZW5jZVxuLy8gdGhlIHNlbGVjdGlvbiBieSB3aGF0ZXZlciBtZWFucyBpcyBtb3N0IG5hdHVyYWwgZm9yIHRoZWlyIHNpdHVhdGlvbi5cbi8vXG4vLyBUbyBlZmZpY2llbnRseSBrZWVwIHRoZXNlIHByb3BlcnRpZXMgaW4gc3luYywgd2UgdHJhY2sgXCJleHRlcm5hbFwiIGFuZFxuLy8gXCJpbnRlcm5hbFwiIHJlZmVyZW5jZXMgZm9yIGVhY2ggcHJvcGVydHk6XG4vL1xuLy8gVGhlIGV4dGVybmFsIGluZGV4IG9yIGl0ZW0gaXMgdGhlIG9uZSB3ZSByZXBvcnQgdG8gdGhlIG91dHNpZGUgd29ybGQgd2hlblxuLy8gYXNrZWQgZm9yIHNlbGVjdGlvbi4gIFdoZW4gaGFuZGxpbmcgYSBjaGFuZ2UgdG8gaW5kZXggb3IgaXRlbSwgd2UgdXBkYXRlIHRoZVxuLy8gZXh0ZXJuYWwgcmVmZXJlbmNlIGFzIHNvb24gYXMgcG9zc2libGUsIHNvIHRoYXQgaWYgYW55b25lIGltbWVkaWF0ZWx5IGFza3Ncbi8vIGZvciB0aGUgY3VycmVudCBzZWxlY3Rpb24sIHRoZXkgd2lsbCByZWNlaXZlIGEgc3RhYmxlIGFuc3dlci5cbi8vXG4vLyBUaGUgaW50ZXJuYWwgaW5kZXggb3IgaXRlbSB0cmFja3Mgd2hpY2hldmVyIGluZGV4IG9yIGl0ZW0gbGFzdCByZWNlaXZlZCB0aGVcbi8vIGZ1bGwgc2V0IG9mIHByb2Nlc3NpbmcuIFByb2Nlc3NpbmcgaW5jbHVkZXMgcmFpc2luZyBhIGNoYW5nZSBldmVudCBmb3IgdGhlXG4vLyBuZXcgdmFsdWUuIE9uY2Ugd2UndmUgYmVndW4gdGhhdCBwcm9jZXNzaW5nLCB3ZSBzdG9yZSB0aGUgbmV3IHZhbHVlIGFzIHRoZVxuLy8gaW50ZXJuYWwgdmFsdWUgdG8gaW5kaWNhdGUgd2UndmUgaGFuZGxlZCBpdC5cbi8vXG5jb25zdCBleHRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2V4dGVybmFsU2VsZWN0ZWRJbmRleCcpO1xuY29uc3QgZXh0ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2V4dGVybmFsU2VsZWN0ZWRJdGVtJyk7XG5jb25zdCBpbnRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2ludGVybmFsU2VsZWN0ZWRJbmRleCcpO1xuY29uc3QgaW50ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2ludGVybmFsU2VsZWN0ZWRJdGVtJyk7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTaW5nbGVTZWxlY3Rpb24uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYW5hZ2VzIHNpbmdsZS1zZWxlY3Rpb24gc2VtYW50aWNzIGZvciBpdGVtcyBpbiBhIGxpc3QuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gZXhwZWN0cyBhIGNvbXBvbmVudCB0byBwcm92aWRlIGFuIGBpdGVtc2AgQXJyYXkgb3IgTm9kZUxpc3Qgb2ZcbiAgICogYWxsIGVsZW1lbnRzIGluIHRoZSBsaXN0LiBBIHN0YW5kYXJkIHdheSB0byBkbyB0aGF0IHdpdGggaXMgdGhlXG4gICAqIFtDb250ZW50SXRlbXNNaXhpbl0oQ29udGVudEl0ZW1zTWl4aW4ubWQpLCB3aGljaCB0YWtlcyBhIGNvbXBvbmVudCdzXG4gICAqIGNvbnRlbnQgKHR5cGljYWxseSBpdHMgZGlzdHJpYnV0ZWQgY2hpbGRyZW4pIGFzIHRoZSBzZXQgb2YgbGlzdCBpdGVtczsgc2VlXG4gICAqIHRoYXQgbWl4aW4gZm9yIGRldGFpbHMuXG4gICAqXG4gICAqIFRoaXMgbWl4aW4gdHJhY2tzIGEgc2luZ2xlIHNlbGVjdGVkIGl0ZW0gaW4gdGhlIGxpc3QsIGFuZCBwcm92aWRlcyBtZWFucyB0b1xuICAgKiBnZXQgYW5kIHNldCB0aGF0IHN0YXRlIGJ5IGl0ZW0gcG9zaXRpb24gKGBzZWxlY3RlZEluZGV4YCkgb3IgaXRlbSBpZGVudGl0eVxuICAgKiAoYHNlbGVjdGVkSXRlbWApLiBUaGUgc2VsZWN0aW9uIGNhbiBiZSBtb3ZlZCBpbiB0aGUgbGlzdCB2aWEgdGhlIG1ldGhvZHNcbiAgICogYHNlbGVjdEZpcnN0YCwgYHNlbGVjdExhc3RgLCBgc2VsZWN0TmV4dGAsIGFuZCBgc2VsZWN0UHJldmlvdXNgLlxuICAgKlxuICAgKiBUaGlzIG1peGluIGRvZXMgbm90IHByb2R1Y2UgYW55IHVzZXItdmlzaWJsZSBlZmZlY3RzIHRvIHJlcHJlc2VudFxuICAgKiBzZWxlY3Rpb24uIE90aGVyIG1peGlucywgc3VjaCBhc1xuICAgKiBbU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluXShTZWxlY3Rpb25BcmlhQWN0aXZlTWl4aW4ubWQpLFxuICAgKiBbU2VsZWN0aW9uSGlnaGxpZ2h0TWl4aW5dKFNlbGVjdGlvbkhpZ2hsaWdodE1peGluLm1kKSBhbmRcbiAgICogW1NlbGVjdGlvbkluVmlld01peGluXShTZWxlY3Rpb25JblZpZXdNaXhpbi5tZCksIG1vZGlmeSB0aGUgc2VsZWN0ZWQgaXRlbVxuICAgKiBpbiBjb21tb24gd2F5cyB0byBsZXQgdGhlIHVzZXIga25vdyBhIGdpdmVuIGl0ZW0gaXMgc2VsZWN0ZWQgb3Igbm90XG4gICAqIHNlbGVjdGVkLlxuICAgKi9cbiAgY2xhc3MgU2luZ2xlU2VsZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICAvLyBTZXQgZGVmYXVsdHMuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2VsZWN0aW9uUmVxdWlyZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmVxdWlyZWQgPSB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnNlbGVjdGlvblJlcXVpcmVkO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlbGVjdGlvbldyYXBzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbldyYXBzID0gdGhpc1tzeW1ib2xzLmRlZmF1bHRzXS5zZWxlY3Rpb25XcmFwcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBzZWxlY3Rpb24gY2FuIGJlIG1vdmVkIHRvIHRoZSBuZXh0IGl0ZW0sIGZhbHNlIGlmIG5vdCAodGhlXG4gICAgICogc2VsZWN0ZWQgaXRlbSBpcyB0aGUgbGFzdCBpdGVtIGluIHRoZSBsaXN0KS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjYW5TZWxlY3ROZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbY2FuU2VsZWN0TmV4dFN5bWJvbF07XG4gICAgfVxuICAgIHNldCBjYW5TZWxlY3ROZXh0KGNhblNlbGVjdE5leHQpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ2FuU2VsZWN0TmV4dCA9IHRoaXNbY2FuU2VsZWN0TmV4dFN5bWJvbF07XG4gICAgICB0aGlzW2NhblNlbGVjdE5leHRTeW1ib2xdID0gY2FuU2VsZWN0TmV4dDtcbiAgICAgIGlmICgnY2FuU2VsZWN0TmV4dCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuY2FuU2VsZWN0TmV4dCA9IGNhblNlbGVjdE5leHQ7IH1cbiAgICAgIGlmIChjYW5TZWxlY3ROZXh0ICE9PSBwcmV2aW91c0NhblNlbGVjdE5leHQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY2FuLXNlbGVjdC1uZXh0LWNoYW5nZWQnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGNhbiBiZSBtb3ZlZCB0byB0aGUgcHJldmlvdXMgaXRlbSwgZmFsc2UgaWYgbm90XG4gICAgICogKHRoZSBzZWxlY3RlZCBpdGVtIGlzIHRoZSBmaXJzdCBvbmUgaW4gdGhlIGxpc3QpLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNhblNlbGVjdFByZXZpb3VzKCkge1xuICAgICAgcmV0dXJuIHRoaXNbY2FuU2VsZWN0UHJldmlvdXNTeW1ib2xdO1xuICAgIH1cbiAgICBzZXQgY2FuU2VsZWN0UHJldmlvdXMoY2FuU2VsZWN0UHJldmlvdXMpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ2FuU2VsZWN0UHJldmlvdXMgPSB0aGlzW2NhblNlbGVjdFByZXZpb3VzU3ltYm9sXTtcbiAgICAgIHRoaXNbY2FuU2VsZWN0UHJldmlvdXNTeW1ib2xdID0gY2FuU2VsZWN0UHJldmlvdXM7XG4gICAgICBpZiAoJ2NhblNlbGVjdFByZXZpb3VzJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5jYW5TZWxlY3RQcmV2aW91cyA9IGNhblNlbGVjdFByZXZpb3VzOyB9XG4gICAgICBpZiAoY2FuU2VsZWN0UHJldmlvdXMgIT09IHByZXZpb3VzQ2FuU2VsZWN0UHJldmlvdXMpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY2FuLXNlbGVjdC1wcmV2aW91cy1jaGFuZ2VkJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMuc2VsZWN0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgIGRlZmF1bHRzLnNlbGVjdGlvbldyYXBzID0gZmFsc2U7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEgbmV3IGl0ZW0gYmVpbmcgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBzaW1wbHkgc2V0cyB0aGUgaXRlbSdzXG4gICAgICogc2VsZWN0aW9uIHN0YXRlIHRvIGZhbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaXRlbSAtIHRoZSBpdGVtIGJlaW5nIGFkZGVkXG4gICAgICovXG4gICAgW3N5bWJvbHMuaXRlbUFkZGVkXShpdGVtKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtQWRkZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbUFkZGVkXShpdGVtKTsgfVxuICAgICAgdGhpc1tzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgaXRlbSA9PT0gdGhpcy5zZWxlY3RlZEl0ZW0pO1xuICAgIH1cblxuICAgIFtzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtc0NoYW5nZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpOyB9XG5cbiAgICAgIC8vIEluIGNhc2Ugc2VsZWN0ZWQgaXRlbSBjaGFuZ2VkIHBvc2l0aW9uIG9yIHdhcyByZW1vdmVkLlxuICAgICAgdHJhY2tTZWxlY3RlZEl0ZW0odGhpcyk7XG5cbiAgICAgIC8vIEluIGNhc2UgdGhlIGNoYW5nZSBpbiBpdGVtcyBhZmZlY3RlZCB3aGljaCBuYXZpZ2F0aW9ucyBhcmUgcG9zc2libGUuXG4gICAgICB1cGRhdGVQb3NzaWJsZU5hdmlnYXRpb25zKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBpbmRpY2F0ZSBzZWxlY3Rpb24gc3RhdGUgdG8gdGhlIGl0ZW0uXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuIFVzZXItdmlzaWJsZVxuICAgICAqIGVmZmVjdHMgd2lsbCB0eXBpY2FsbHkgYmUgaGFuZGxlZCBieSBvdGhlciBtaXhpbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpdGVtIC0gdGhlIGl0ZW0gYmVpbmcgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgLSB0cnVlIGlmIHRoZSBpdGVtIGlzIHNlbGVjdGVkLCBmYWxzZSBpZiBub3RcbiAgICAgKi9cbiAgICBbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIHNlbGVjdGVkKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gd2hpY2ggaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQSBgc2VsZWN0ZWRJbmRleGAgb2YgLTEgaW5kaWNhdGVzIHRoZXJlIGlzIG5vIHNlbGVjdGlvbi4gU2V0dGluZyB0aGlzXG4gICAgICogcHJvcGVydHkgdG8gLTEgd2lsbCByZW1vdmUgYW55IGV4aXN0aW5nIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkSW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpc1tleHRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdICE9IG51bGwgP1xuICAgICAgICB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJbmRleFN5bWJvbF0gOlxuICAgICAgICAtMTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICAgIC8vIFNlZSBub3RlcyBhdCB0b3AgYWJvdXQgaW50ZXJuYWwgdnMuIGV4dGVybmFsIGNvcGllcyBvZiB0aGlzIHByb3BlcnR5LlxuICAgICAgY29uc3QgcHJldmlvdXNTZWxlY3RlZEluZGV4ID0gdGhpc1tpbnRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdO1xuICAgICAgbGV0IGl0ZW07XG4gICAgICBpZiAoaW5kZXggIT09IHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sXSkge1xuICAgICAgICAvLyBTdG9yZSB0aGUgbmV3IGluZGV4IGFuZCB0aGUgY29ycmVzcG9uZGluZyBpdGVtLlxuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIGNvbnN0IGhhc0l0ZW1zID0gaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKCEoaGFzSXRlbXMgJiYgaW5kZXggPj0gMCAmJiBpbmRleCA8IGl0ZW1zLmxlbmd0aCkpIHtcbiAgICAgICAgICBpbmRleCA9IC0xOyAvLyBObyBpdGVtIGF0IHRoYXQgaW5kZXguXG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tleHRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdID0gaW5kZXg7XG4gICAgICAgIGl0ZW0gPSBoYXNJdGVtcyAmJiBpbmRleCA+PSAwID8gaXRlbXNbaW5kZXhdIDogbnVsbDtcbiAgICAgICAgdGhpc1tleHRlcm5hbFNlbGVjdGVkSXRlbVN5bWJvbF0gPSBpdGVtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbSA9IHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2xdO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3cgbGV0IHN1cGVyIGRvIGFueSB3b3JrLlxuICAgICAgaWYgKCdzZWxlY3RlZEluZGV4JyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3RlZEluZGV4ID0gaW5kZXg7IH1cblxuICAgICAgaWYgKGluZGV4ICE9PSBwcmV2aW91c1NlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdGVkIGluZGV4IGNoYW5nZWQuXG4gICAgICAgIHRoaXNbaW50ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sXSA9IGluZGV4O1xuXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzZWxlY3RlZC1pbmRleC1jaGFuZ2VkJywge1xuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleDogaW5kZXgsXG4gICAgICAgICAgICB2YWx1ZTogaW5kZXggLy8gZm9yIFBvbHltZXIgYmluZGluZy4gVE9ETzogVmVyaWZ5IHN0aWxsIG5lY2Vzc2FyeVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2ludGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sXSAhPT0gaXRlbSkge1xuICAgICAgICAvLyBVcGRhdGUgc2VsZWN0ZWRJdGVtIHByb3BlcnR5IHNvIGl0IGNhbiBoYXZlIGl0cyBvd24gZWZmZWN0cy5cbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSwgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gbnVsbCBkZXNlbGVjdHMgYW55IGN1cnJlbnRseS1zZWxlY3RlZCBpdGVtLlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB0byBhbiBvYmplY3QgdGhhdCBpcyBub3QgaW4gdGhlIGxpc3QgaGFzIG5vIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIFRPRE86IEV2ZW4gaWYgc2VsZWN0aW9uUmVxdWlyZWQsIGNhbiBzdGlsbCBleHBsaWNpdGx5IHNldCBzZWxlY3RlZEl0ZW0gdG8gbnVsbC5cbiAgICAgKiBUT0RPOiBJZiBzZWxlY3Rpb25SZXF1aXJlZCwgbGVhdmUgc2VsZWN0aW9uIGFsb25lP1xuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWRJdGVtKCkge1xuICAgICAgcmV0dXJuIHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2xdIHx8IG51bGw7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEl0ZW0oaXRlbSkge1xuICAgICAgLy8gU2VlIG5vdGVzIGF0IHRvcCBhYm91dCBpbnRlcm5hbCB2cy4gZXh0ZXJuYWwgY29waWVzIG9mIHRoaXMgcHJvcGVydHkuXG4gICAgICBjb25zdCBwcmV2aW91c1NlbGVjdGVkSXRlbSA9IHRoaXNbaW50ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2xdO1xuICAgICAgbGV0IGluZGV4O1xuICAgICAgaWYgKGl0ZW0gIT09IHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEl0ZW1TeW1ib2xdKSB7XG4gICAgICAgIC8vIFN0b3JlIGl0ZW0gYW5kIGxvb2sgdXAgY29ycmVzcG9uZGluZyBpbmRleC5cbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICBjb25zdCBoYXNJdGVtcyA9IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDA7XG4gICAgICAgIGluZGV4ID0gaGFzSXRlbXMgPyBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGl0ZW1zLCBpdGVtKSA6IC0xO1xuICAgICAgICB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJbmRleFN5bWJvbF0gPSBpbmRleDtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGl0ZW0gPSBudWxsOyAvLyBUaGUgaW5kaWNhdGVkIGl0ZW0gaXNuJ3QgYWN0dWFsbHkgaW4gYGl0ZW1zYC5cbiAgICAgICAgfVxuICAgICAgICB0aGlzW2V4dGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sXSA9IGl0ZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IHRoaXNbZXh0ZXJuYWxTZWxlY3RlZEluZGV4U3ltYm9sXTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93IGxldCBzdXBlciBkbyBhbnkgd29yay5cbiAgICAgIGlmICgnc2VsZWN0ZWRJdGVtJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3RlZEl0ZW0gPSBpdGVtOyB9XG5cbiAgICAgIGlmIChpdGVtICE9PSBwcmV2aW91c1NlbGVjdGVkSXRlbSkge1xuICAgICAgICAvLyBUaGUgc2VsZWN0ZWQgaXRlbSBjaGFuZ2VkLlxuICAgICAgICB0aGlzW2ludGVybmFsU2VsZWN0ZWRJdGVtU3ltYm9sXSA9IGl0ZW07XG5cbiAgICAgICAgaWYgKHByZXZpb3VzU2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHNlbGVjdGlvbiBzdGF0ZSBvZiBvbGQgaXRlbS5cbiAgICAgICAgICB0aGlzW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShwcmV2aW91c1NlbGVjdGVkSXRlbSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHNlbGVjdGlvbiBzdGF0ZSB0byBuZXcgaXRlbS5cbiAgICAgICAgICB0aGlzW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZVBvc3NpYmxlTmF2aWdhdGlvbnModGhpcyk7XG5cbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3NlbGVjdGVkLWl0ZW0tY2hhbmdlZCcsIHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIHNlbGVjdGVkSXRlbTogaXRlbSxcbiAgICAgICAgICAgIHZhbHVlOiBpdGVtIC8vIGZvciBQb2x5bWVyIGJpbmRpbmdcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tpbnRlcm5hbFNlbGVjdGVkSW5kZXhTeW1ib2xdICE9PSBpbmRleCkge1xuICAgICAgICAvLyBVcGRhdGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eSBzbyBpdCBjYW4gaGF2ZSBpdHMgb3duIGVmZmVjdHMuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBzZWxlY3RGaXJzdCgpIHtcbiAgICAgIGlmIChzdXBlci5zZWxlY3RGaXJzdCkgeyBzdXBlci5zZWxlY3RGaXJzdCgpOyB9XG4gICAgICByZXR1cm4gc2VsZWN0SW5kZXgodGhpcywgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgbGlzdCBzaG91bGQgYWx3YXlzIGhhdmUgYSBzZWxlY3Rpb24gKGlmIGl0IGhhcyBpdGVtcykuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25SZXF1aXJlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzW3NlbGVjdGlvblJlcXVpcmVkU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGlvblJlcXVpcmVkKHNlbGVjdGlvblJlcXVpcmVkKSB7XG4gICAgICB0aGlzW3NlbGVjdGlvblJlcXVpcmVkU3ltYm9sXSA9IHNlbGVjdGlvblJlcXVpcmVkO1xuICAgICAgaWYgKCdzZWxlY3Rpb25SZXF1aXJlZCcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0aW9uUmVxdWlyZWQgPSBzZWxlY3Rpb25SZXF1aXJlZDsgfVxuICAgICAgdHJhY2tTZWxlY3RlZEl0ZW0odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBzZWxlY3Rpb24gbmF2aWdhdGlvbnMgd3JhcCBmcm9tIGxhc3QgdG8gZmlyc3QsIGFuZCB2aWNlIHZlcnNhLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uV3JhcHMoKSB7XG4gICAgICByZXR1cm4gdGhpc1tzZWxlY3Rpb25XcmFwc1N5bWJvbF07XG4gICAgfVxuICAgIHNldCBzZWxlY3Rpb25XcmFwcyh2YWx1ZSkge1xuICAgICAgdGhpc1tzZWxlY3Rpb25XcmFwc1N5bWJvbF0gPSBTdHJpbmcodmFsdWUpID09PSAndHJ1ZSc7XG4gICAgICBpZiAoJ3NlbGVjdGlvbldyYXBzJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3Rpb25XcmFwcyA9IHZhbHVlOyB9XG4gICAgICB1cGRhdGVQb3NzaWJsZU5hdmlnYXRpb25zKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgbGFzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIHNlbGVjdExhc3QoKSB7XG4gICAgICBpZiAoc3VwZXIuc2VsZWN0TGFzdCkgeyBzdXBlci5zZWxlY3RMYXN0KCk7IH1cbiAgICAgIHJldHVybiBzZWxlY3RJbmRleCh0aGlzLCB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgbmV4dCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIHNlbGVjdE5leHQoKSB7XG4gICAgICBpZiAoc3VwZXIuc2VsZWN0TmV4dCkgeyBzdXBlci5zZWxlY3ROZXh0KCk7IH1cbiAgICAgIHJldHVybiBzZWxlY3RJbmRleCh0aGlzLCB0aGlzLnNlbGVjdGVkSW5kZXggKyAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIHByZXZpb3VzIGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgbGlzdCBoYXMgbm8gc2VsZWN0aW9uLCB0aGUgbGFzdCBpdGVtIHdpbGwgYmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgc2VsZWN0UHJldmlvdXMoKSB7XG4gICAgICBpZiAoc3VwZXIuc2VsZWN0UHJldmlvdXMpIHsgc3VwZXIuc2VsZWN0UHJldmlvdXMoKTsgfVxuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXggPCAwID9cbiAgICAgICAgdGhpcy5pdGVtcy5sZW5ndGggLSAxIDogICAgIC8vIE5vIHNlbGVjdGlvbiB5ZXQ7IHNlbGVjdCBsYXN0IGl0ZW0uXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCAtIDE7XG4gICAgICByZXR1cm4gc2VsZWN0SW5kZXgodGhpcywgbmV3SW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHNlbGVjdGVkSXRlbSBwcm9wZXJ0eSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFNpbmdsZVNlbGVjdGlvblxuICAgICAqIEBldmVudCBzZWxlY3RlZC1pdGVtLWNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkZXRhaWwuc2VsZWN0ZWRJdGVtIFRoZSBuZXcgc2VsZWN0ZWQgaXRlbS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkZXRhaWwucHJldmlvdXNJdGVtIFRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIGl0ZW0uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgU2luZ2xlU2VsZWN0aW9uXG4gICAgICogQGV2ZW50IHNlbGVjdGVkLWluZGV4LWNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGV0YWlsLnNlbGVjdGVkSW5kZXggVGhlIG5ldyBzZWxlY3RlZCBpbmRleC5cbiAgICAgKi9cblxuICB9XG5cbiAgcmV0dXJuIFNpbmdsZVNlbGVjdGlvbjtcbn07XG5cblxuLy8gRW5zdXJlIHRoZSBnaXZlbiBpbmRleCBpcyB3aXRoaW4gYm91bmRzLCBhbmQgc2VsZWN0IGl0IGlmIGl0J3Mgbm90IGFscmVhZHlcbi8vIHNlbGVjdGVkLlxuZnVuY3Rpb24gc2VsZWN0SW5kZXgoZWxlbWVudCwgaW5kZXgpIHtcbiAgY29uc3QgY291bnQgPSBlbGVtZW50Lml0ZW1zLmxlbmd0aDtcblxuICBjb25zdCBib3VuZGVkSW5kZXggPSAoZWxlbWVudC5zZWxlY3Rpb25XcmFwcykgP1xuICAgIC8vIEphdmFTY3JpcHQgbW9kIGRvZXNuJ3QgaGFuZGxlIG5lZ2F0aXZlIG51bWJlcnMgdGhlIHdheSB3ZSB3YW50IHRvIHdyYXAuXG4gICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE4NjE4MjUwLzc2NDcyXG4gICAgKChpbmRleCAlIGNvdW50KSArIGNvdW50KSAlIGNvdW50IDpcblxuICAgIC8vIEtlZXAgaW5kZXggd2l0aGluIGJvdW5kcyBvZiBhcnJheS5cbiAgICBNYXRoLm1heChNYXRoLm1pbihpbmRleCwgY291bnQgLSAxKSwgMCk7XG5cbiAgY29uc3QgcHJldmlvdXNJbmRleCA9IGVsZW1lbnQuc2VsZWN0ZWRJbmRleDtcbiAgaWYgKHByZXZpb3VzSW5kZXggIT09IGJvdW5kZWRJbmRleCkge1xuICAgIGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA9IGJvdW5kZWRJbmRleDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gRm9sbG93aW5nIGEgY2hhbmdlIGluIHRoZSBzZXQgb2YgaXRlbXMsIG9yIGluIHRoZSB2YWx1ZSBvZiB0aGVcbi8vIGBzZWxlY3Rpb25SZXF1aXJlZGAgcHJvcGVydHksIHJlYWNxdWlyZSB0aGUgc2VsZWN0ZWQgaXRlbS4gSWYgaXQncyBtb3ZlZCxcbi8vIHVwZGF0ZSBgc2VsZWN0ZWRJbmRleGAuIElmIGl0J3MgYmVlbiByZW1vdmVkLCBhbmQgYSBzZWxlY3Rpb24gaXMgcmVxdWlyZWQsXG4vLyB0cnkgdG8gc2VsZWN0IGFub3RoZXIgaXRlbS5cbmZ1bmN0aW9uIHRyYWNrU2VsZWN0ZWRJdGVtKGVsZW1lbnQpIHtcblxuICBjb25zdCBpdGVtcyA9IGVsZW1lbnQuaXRlbXM7XG4gIGNvbnN0IGl0ZW1Db3VudCA9IGl0ZW1zID8gaXRlbXMubGVuZ3RoIDogMDtcblxuICBjb25zdCBwcmV2aW91c1NlbGVjdGVkSXRlbSA9IGVsZW1lbnQuc2VsZWN0ZWRJdGVtO1xuICBpZiAoIXByZXZpb3VzU2VsZWN0ZWRJdGVtKSB7XG4gICAgLy8gTm8gaXRlbSB3YXMgcHJldmlvdXNseSBzZWxlY3RlZC5cbiAgICBpZiAoZWxlbWVudC5zZWxlY3Rpb25SZXF1aXJlZCkge1xuICAgICAgLy8gU2VsZWN0IHRoZSBmaXJzdCBpdGVtIGJ5IGRlZmF1bHQuXG4gICAgICBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSAwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVtQ291bnQgPT09IDApIHtcbiAgICAvLyBXZSd2ZSBsb3N0IHRoZSBzZWxlY3Rpb24sIGFuZCB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBzZWxlY3QuXG4gICAgZWxlbWVudC5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIFRyeSB0byBmaW5kIHRoZSBwcmV2aW91c2x5LXNlbGVjdGVkIGl0ZW0gaW4gdGhlIGN1cnJlbnQgc2V0IG9mIGl0ZW1zLlxuICAgIGNvbnN0IGluZGV4SW5DdXJyZW50SXRlbXMgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGl0ZW1zLCBwcmV2aW91c1NlbGVjdGVkSXRlbSk7XG4gICAgY29uc3QgcHJldmlvdXNTZWxlY3RlZEluZGV4ID0gZWxlbWVudC5zZWxlY3RlZEluZGV4O1xuICAgIGlmIChpbmRleEluQ3VycmVudEl0ZW1zIDwgMCkge1xuICAgICAgLy8gUHJldmlvdXNseS1zZWxlY3RlZCBpdGVtIHdhcyByZW1vdmVkIGZyb20gdGhlIGl0ZW1zLlxuICAgICAgLy8gU2VsZWN0IHRoZSBpdGVtIGF0IHRoZSBzYW1lIGluZGV4IChpZiBpdCBleGlzdHMpIG9yIGFzIGNsb3NlIGFzIHBvc3NpYmxlLlxuICAgICAgY29uc3QgbmV3U2VsZWN0ZWRJbmRleCA9IE1hdGgubWluKHByZXZpb3VzU2VsZWN0ZWRJbmRleCwgaXRlbUNvdW50IC0gMSk7XG4gICAgICAvLyBTZWxlY3QgYnkgaXRlbSwgc2luY2UgaW5kZXggbWF5IGJlIHRoZSBzYW1lLCBhbmQgd2Ugd2FudCB0byByYWlzZSB0aGVcbiAgICAgIC8vIHNlbGVjdGVkLWl0ZW0tY2hhbmdlZCBldmVudC5cbiAgICAgIGVsZW1lbnQuc2VsZWN0ZWRJdGVtID0gaXRlbXNbbmV3U2VsZWN0ZWRJbmRleF07XG4gICAgfSBlbHNlIGlmIChpbmRleEluQ3VycmVudEl0ZW1zICE9PSBwcmV2aW91c1NlbGVjdGVkSW5kZXgpIHtcbiAgICAgIC8vIFByZXZpb3VzbHktc2VsZWN0ZWQgaXRlbSBzdGlsbCB0aGVyZSwgYnV0IGNoYW5nZWQgcG9zaXRpb24uXG4gICAgICBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSBpbmRleEluQ3VycmVudEl0ZW1zO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGb2xsb3dpbmcgYSBjaGFuZ2UgaW4gc2VsZWN0aW9uLCByZXBvcnQgd2hldGhlciBpdCdzIG5vdyBwb3NzaWJsZSB0b1xuLy8gZ28gbmV4dC9wcmV2aW91cyBmcm9tIHRoZSBnaXZlbiBpbmRleC5cbmZ1bmN0aW9uIHVwZGF0ZVBvc3NpYmxlTmF2aWdhdGlvbnMoZWxlbWVudCkge1xuICBsZXQgY2FuU2VsZWN0TmV4dDtcbiAgbGV0IGNhblNlbGVjdFByZXZpb3VzO1xuICBjb25zdCBpdGVtcyA9IGVsZW1lbnQuaXRlbXM7XG4gIGlmIChpdGVtcyA9PSBudWxsIHx8IGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIE5vIGl0ZW1zIHRvIHNlbGVjdC5cbiAgICBjYW5TZWxlY3ROZXh0ID0gZmFsc2U7XG4gICAgY2FuU2VsZWN0UHJldmlvdXMgPSBmYWxzZTtcbiAgfSBpZiAoZWxlbWVudC5zZWxlY3Rpb25XcmFwcykge1xuICAgIC8vIFNpbmNlIHRoZXJlIGFyZSBpdGVtcywgY2FuIGFsd2F5cyBnbyBuZXh0L3ByZXZpb3VzLlxuICAgIGNhblNlbGVjdE5leHQgPSB0cnVlO1xuICAgIGNhblNlbGVjdFByZXZpb3VzID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpbmRleCA9IGVsZW1lbnQuc2VsZWN0ZWRJbmRleDtcbiAgICBpZiAoaW5kZXggPCAwICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZS4gSWYgdGhlcmUgYXJlIGl0ZW1zIGJ1dCBubyBzZWxlY3Rpb24sIGRlY2xhcmUgdGhhdCBpdCdzXG4gICAgICAvLyBhbHdheXMgcG9zc2libGUgdG8gZ28gbmV4dC9wcmV2aW91cyB0byBjcmVhdGUgYSBzZWxlY3Rpb24uXG4gICAgICBjYW5TZWxlY3ROZXh0ID0gdHJ1ZTtcbiAgICAgIGNhblNlbGVjdFByZXZpb3VzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9ybWFsIGNhc2U6IHdlIGhhdmUgYW4gaW5kZXggaW4gYSBsaXN0IHRoYXQgaGFzIGl0ZW1zLlxuICAgICAgY2FuU2VsZWN0UHJldmlvdXMgPSAoaW5kZXggPiAwKTtcbiAgICAgIGNhblNlbGVjdE5leHQgPSAoaW5kZXggPCBpdGVtcy5sZW5ndGggLSAxKTtcbiAgICB9XG4gIH1cbiAgaWYgKGVsZW1lbnQuY2FuU2VsZWN0TmV4dCAhPT0gY2FuU2VsZWN0TmV4dCkge1xuICAgIGVsZW1lbnQuY2FuU2VsZWN0TmV4dCA9IGNhblNlbGVjdE5leHQ7XG4gIH1cbiAgaWYgKGVsZW1lbnQuY2FuU2VsZWN0UHJldmlvdXMgIT09IGNhblNlbGVjdFByZXZpb3VzKSB7XG4gICAgZWxlbWVudC5jYW5TZWxlY3RQcmV2aW91cyA9IGNhblNlbGVjdFByZXZpb3VzO1xuICB9XG59XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IGRlbHRhWFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnZGVsdGFYJyk7XG5jb25zdCBkZWx0YVlTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2RlbHRhWScpO1xuY29uc3QgbXVsdGlUb3VjaFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbXVsdGlUb3VjaCcpO1xuY29uc3QgcHJldmlvdXNYU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdwcmV2aW91c1gnKTtcbmNvbnN0IHByZXZpb3VzWVN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncHJldmlvdXNZJyk7XG5jb25zdCBzdGFydFhTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3N0YXJ0WCcpO1xuY29uc3QgdHJhdmVsRnJhY3Rpb25TeW1ib2wgPSBjcmVhdGVTeW1ib2woJ3RyYXZlbEZyYWN0aW9uJyk7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBTd2lwZURpcmVjdGlvbi4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIE1peGluIHdoaWNoIG1hcHMgdG91Y2ggZ2VzdHVyZXMgKHN3aXBlIGxlZnQsIHN3aXBlIHJpZ2h0KSB0byBkaXJlY3Rpb25cbiAgICogc2VtYW50aWNzIChnbyByaWdodCwgZ28gbGVmdCkuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgbWl4aW4gcHJlc2VudHMgbm8gdXNlci12aXNpYmxlIGVmZmVjdHM7IGl0IGp1c3QgaW5kaWNhdGVzXG4gICAqIGEgZGlyZWN0aW9uIGluIHdoaWNoIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBzd2lwaW5nIG9yIGhhcyBmaW5pc2hlZCBzd2lwaW5nLlxuICAgKiBUbyBtYXAgdGhlIGRpcmVjdGlvbiB0byBhIGNoYW5nZSBpbiBzZWxlY3Rpb24sIHVzZVxuICAgKiBbRGlyZWN0aW9uU2VsZWN0aW9uTWl4aW5dKERpcmVjdGlvblNlbGVjdGlvbk1peGluLm1kKS5cbiAgICovXG4gIGNsYXNzIFN3aXBlRGlyZWN0aW9uIGV4dGVuZHMgYmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG5cbiAgICAgIHRoaXMudHJhdmVsRnJhY3Rpb24gPSAwO1xuXG4gICAgICAvLyBJbiBhbGwgdG91Y2ggZXZlbnRzLCBvbmx5IGhhbmRsZSBzaW5nbGUgdG91Y2hlcy4gV2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gaW5hZHZlcnRlbnRseSBkbyB3b3JrIHdoZW4gdGhlIHVzZXIncyB0cnlpbmcgdG8gcGluY2gtem9vbSBmb3IgZXhhbXBsZS5cbiAgICAgIC8vIFRPRE86IEV2ZW4gYmV0dGVyIGFwcHJvYWNoIHRoYW4gYmVsb3cgd291bGQgYmUgdG8gaWdub3JlIHRvdWNoZXMgYWZ0ZXJcbiAgICAgIC8vIHRoZSBmaXJzdCBpZiB0aGUgdXNlciBoYXMgYWxyZWFkeSBiZWd1biBhIHN3aXBlLlxuICAgICAgLy8gVE9ETzogVG91Y2ggZXZlbnRzIHNob3VsZCBwcm9iYWJseSBiZSBmYWN0b3JlZCBvdXQgaW50byBpdHMgb3duIG1peGluLlxuICAgICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICAgICAgLy8gUHJlZmVyIGxpc3RlbmluZyB0byBzdGFuZGFyZCBwb2ludGVyIGV2ZW50cy5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoaXNFdmVudEZvclBlbk9yUHJpbWFyeVRvdWNoKGV2ZW50KSkge1xuICAgICAgICAgICAgdG91Y2hTdGFydCh0aGlzLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChpc0V2ZW50Rm9yUGVuT3JQcmltYXJ5VG91Y2goZXZlbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVkID0gdG91Y2hNb3ZlKHRoaXMsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoaXNFdmVudEZvclBlbk9yUHJpbWFyeVRvdWNoKGV2ZW50KSkge1xuICAgICAgICAgICAgdG91Y2hFbmQodGhpcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBvaW50ZXIgZXZlbnRzIG5vdCBzdXBwb3J0ZWQgLS0gbGlzdGVuIHRvIG9sZGVyIHRvdWNoIGV2ZW50cy5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmICh0aGlzW211bHRpVG91Y2hTeW1ib2xdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50WCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRZID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgICAgIHRvdWNoU3RhcnQodGhpcywgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbbXVsdGlUb3VjaFN5bWJvbF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmICghdGhpc1ttdWx0aVRvdWNoU3ltYm9sXSAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50WCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRZID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZWQgPSB0b3VjaE1vdmUodGhpcywgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBBbGwgdG91Y2hlcyByZW1vdmVkOyBnZXN0dXJlIGlzIGNvbXBsZXRlLlxuICAgICAgICAgICAgaWYgKCF0aGlzW211bHRpVG91Y2hTeW1ib2xdKSB7XG4gICAgICAgICAgICAgIC8vIFNpbmdsZS10b3VjaCBzd2lwZSBoYXMgZmluaXNoZWQuXG4gICAgICAgICAgICAgIGNvbnN0IGNsaWVudFggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgICAgICBjb25zdCBjbGllbnRZID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgICAgICAgdG91Y2hFbmQodGhpcywgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW211bHRpVG91Y2hTeW1ib2xdID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG5cbiAgICAgIC8vIEZvciB0aGUgY29tcG9uZW50IHRvIHJlY2VpdmUgUG9pbnRlckV2ZW50cyBpbiBJRS9FZGdlLCB3ZSBuZWVkIHRvIHNldFxuICAgICAgLy8gdG91Y2gtYWN0aW9uOiBub25lLiBPbmx5IG1ha2UgdGhpcyBjaGFuZ2UgaWYgdG91Y2gtYWN0aW9uIGlzIGN1cnJlbnRseVxuICAgICAgLy8gdGhlIGRlZmF1bHQgdmFsdWUgKFwiYXV0b1wiKSwgaW4gY2FzZSB0aGUgZGV2ZWxvcGVyIGtub3dzIGJldHRlciB0aGFuIHdlXG4gICAgICAvLyBkbyB3aGF0IHRoZXkgd2FudCBpbiB0aGVpciBwYXJ0aWN1bGFyIGNvbnRleHQuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS50b3VjaEFjdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHRoaXMuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbi5cbiAgICBnZXQgW3N5bWJvbHMuZHJhZ2dpbmddKCkge1xuICAgICAgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZHJhZ2dpbmddO1xuICAgIH1cbiAgICBzZXQgW3N5bWJvbHMuZHJhZ2dpbmddKHZhbHVlKSB7XG4gICAgICBpZiAoc3ltYm9scy5kcmFnZ2luZyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlcltzeW1ib2xzLmRyYWdnaW5nXSA9IHZhbHVlOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIGxlZnQuXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgICAqL1xuICAgIFtzeW1ib2xzLmdvTGVmdF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb0xlZnRdKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvTGVmdF0oKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0byBnby9uYXZpZ2F0ZSByaWdodC5cbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICovXG4gICAgW3N5bWJvbHMuZ29SaWdodF0oKSB7XG4gICAgICBpZiAoc3VwZXJbc3ltYm9scy5nb1JpZ2h0XSkgeyByZXR1cm4gc3VwZXJbc3ltYm9scy5nb1JpZ2h0XSgpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIHRoZSBmaXJzdCB0b3VjaHBvaW50IGhhcyB0cmF2ZWxlZCBzaW5jZSB0aGUgYmVnaW5uaW5nIG9mIGFcbiAgICAgKiBkcmFnLCBleHByZXNzZWQgYXMgYSBmcmFjdGlvbiBvZiB0aGUgZWxlbWVudCdzIHdpZHRoLlxuICAgICAqXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IHRyYXZlbEZyYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNbdHJhdmVsRnJhY3Rpb25TeW1ib2xdO1xuICAgIH1cbiAgICBzZXQgdHJhdmVsRnJhY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXNbdHJhdmVsRnJhY3Rpb25TeW1ib2xdID0gdmFsdWU7XG4gICAgICBpZiAoJ3RyYXZlbEZyYWN0aW9uJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci50cmF2ZWxGcmFjdGlvbiA9IHZhbHVlOyB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gU3dpcGVEaXJlY3Rpb247XG59O1xuXG5cbi8vIFJldHVybiB0cnVlIGlmIHRoZSBwb2ludGVyIGV2ZW50IGlzIGZvciB0aGUgcGVuLCBvciB0aGUgcHJpbWFyeSB0b3VjaCBwb2ludC5cbmZ1bmN0aW9uIGlzRXZlbnRGb3JQZW5PclByaW1hcnlUb3VjaChldmVudCkge1xuICByZXR1cm4gZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nIHx8XG4gICAgICAoZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgJiYgZXZlbnQuaXNQcmltYXJ5KTtcbn1cblxuLypcbiAqIEludm9rZWQgd2hlbiB0aGUgdXNlciBoYXMgZmluaXNoZWQgYSB0b3VjaCBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHRvdWNoRW5kKGVsZW1lbnQsIGNsaWVudFgsIGNsaWVudFkpIHtcbiAgZWxlbWVudFtzeW1ib2xzLmRyYWdnaW5nXSA9IGZhbHNlO1xuICBpZiAoZWxlbWVudFtkZWx0YVhTeW1ib2xdID49IDIwKSB7XG4gICAgLy8gRmluaXNoZWQgZ29pbmcgcmlnaHQgYXQgaGlnaCBzcGVlZC5cbiAgICBlbGVtZW50W3N5bWJvbHMuZ29MZWZ0XSgpO1xuICB9IGVsc2UgaWYgKGVsZW1lbnRbZGVsdGFYU3ltYm9sXSA8PSAtMjApIHtcbiAgICAvLyBGaW5pc2hlZCBnb2luZyBsZWZ0IGF0IGhpZ2ggc3BlZWQuXG4gICAgZWxlbWVudFtzeW1ib2xzLmdvUmlnaHRdKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmluaXNoZWQgYXQgbG93IHNwZWVkLlxuICAgIHRyYWNrVG8oZWxlbWVudCwgY2xpZW50WCk7XG4gICAgY29uc3QgdHJhdmVsRnJhY3Rpb24gPSBlbGVtZW50LnRyYXZlbEZyYWN0aW9uO1xuICAgIGlmICh0cmF2ZWxGcmFjdGlvbiA+PSAwLjUpIHtcbiAgICAgIGVsZW1lbnRbc3ltYm9scy5nb1JpZ2h0XSgpO1xuICAgIH0gZWxzZSBpZiAodHJhdmVsRnJhY3Rpb24gPD0gLTAuNSkge1xuICAgICAgZWxlbWVudFtzeW1ib2xzLmdvTGVmdF0oKTtcbiAgICB9XG4gIH1cbiAgZWxlbWVudC50cmF2ZWxGcmFjdGlvbiA9IDA7XG4gIGVsZW1lbnRbZGVsdGFYU3ltYm9sXSA9IG51bGw7XG4gIGVsZW1lbnRbZGVsdGFZU3ltYm9sXSA9IG51bGw7XG59XG5cbi8qXG4gKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgaGFzIG1vdmVkIGR1cmluZyBhIHRvdWNoIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG91Y2hNb3ZlKGVsZW1lbnQsIGNsaWVudFgsIGNsaWVudFkpIHtcblxuICBlbGVtZW50W2RlbHRhWFN5bWJvbF0gPSBjbGllbnRYIC0gZWxlbWVudFtwcmV2aW91c1hTeW1ib2xdO1xuICBlbGVtZW50W2RlbHRhWVN5bWJvbF0gPSBjbGllbnRZIC0gZWxlbWVudFtwcmV2aW91c1lTeW1ib2xdO1xuICBlbGVtZW50W3ByZXZpb3VzWFN5bWJvbF0gPSBjbGllbnRYO1xuICBlbGVtZW50W3ByZXZpb3VzWVN5bWJvbF0gPSBjbGllbnRZO1xuICBpZiAoTWF0aC5hYnMoZWxlbWVudFtkZWx0YVhTeW1ib2xdKSA+IE1hdGguYWJzKGVsZW1lbnRbZGVsdGFZU3ltYm9sXSkpIHtcbiAgICAvLyBNb3ZlIHdhcyBtb3N0bHkgaG9yaXpvbnRhbC5cbiAgICB0cmFja1RvKGVsZW1lbnQsIGNsaWVudFgpO1xuICAgIC8vIEluZGljYXRlIHRoYXQgdGhlIGV2ZW50IHdhcyBoYW5kbGVkLiBJdCdkIGJlIG5pY2VyIGlmIHdlIGRpZG4ndCBoYXZlXG4gICAgLy8gdG8gZG8gdGhpcyBzbyB0aGF0LCBlLmcuLCBhIHVzZXIgY291bGQgYmUgc3dpcGluZyBsZWZ0IGFuZCByaWdodFxuICAgIC8vIHdoaWxlIHNpbXVsdGFuZW91c2x5IHNjcm9sbGluZyB1cCBhbmQgZG93bi4gKE5hdGl2ZSB0b3VjaCBhcHBzIGNhbiBkb1xuICAgIC8vIHRoYXQuKSBIb3dldmVyLCBNb2JpbGUgU2FmYXJpIHdhbnRzIHRvIGhhbmRsZSBzd2lwZSBldmVudHMgbmVhciB0aGVcbiAgICAvLyBwYWdlIGFuZCBpbnRlcnByZXQgdGhlbSBhcyBuYXZpZ2F0aW9ucy4gVG8gYXZvaWQgaGF2aW5nIGEgaG9yaXppb250YWxcbiAgICAvLyBzd2lwZSBtaXNpbnRlcHJldGVkIGFzIGEgbmF2aWdhdGlvbiwgd2UgaW5kaWNhdGUgdGhhdCB3ZSd2ZSBoYW5kbGVkXG4gICAgLy8gdGhlIGV2ZW50LCBhbmQgcHJldmVudCBkZWZhdWx0IGJlaGF2aW9yLlxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIC8vIE1vdmUgd2FzIG1vc3RseSB2ZXJ0aWNhbC5cbiAgICByZXR1cm4gZmFsc2U7IC8vIE5vdCBoYW5kbGVkXG4gIH1cbn1cblxuLypcbiAqIEludm9rZWQgd2hlbiB0aGUgdXNlciBoYXMgYmVndW4gYSB0b3VjaCBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHRvdWNoU3RhcnQoZWxlbWVudCwgY2xpZW50WCwgY2xpZW50WSkge1xuICBlbGVtZW50W3N5bWJvbHMuZHJhZ2dpbmddID0gdHJ1ZTtcbiAgZWxlbWVudFtzdGFydFhTeW1ib2xdID0gY2xpZW50WDtcbiAgZWxlbWVudFtwcmV2aW91c1hTeW1ib2xdID0gY2xpZW50WDtcbiAgZWxlbWVudFtwcmV2aW91c1lTeW1ib2xdID0gY2xpZW50WTtcbiAgZWxlbWVudFtkZWx0YVhTeW1ib2xdID0gMDtcbiAgZWxlbWVudFtkZWx0YVlTeW1ib2xdID0gMDtcbn1cblxuZnVuY3Rpb24gdHJhY2tUbyhlbGVtZW50LCB4KSB7XG4gIGNvbnN0IHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgY29uc3QgZHJhZ0Rpc3RhbmNlID0gZWxlbWVudFtzdGFydFhTeW1ib2xdIC0geDtcbiAgY29uc3QgZnJhY3Rpb24gPSB3aWR0aCA+IDAgP1xuICAgIGRyYWdEaXN0YW5jZSAvIHdpZHRoIDpcbiAgICAwO1xuICBlbGVtZW50LnRyYXZlbEZyYWN0aW9uID0gZnJhY3Rpb247XG59XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4vY3JlYXRlU3ltYm9sJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4vc3ltYm9scyc7XG5cblxuY29uc3QgcGxheWluZ1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncGxheWluZycpO1xuY29uc3Qgc2VsZWN0aW9uVGltZXJEdXJhdGlvblN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnc2VsZWN0aW9uVGltZXJEdXJhdGlvbicpO1xuY29uc3QgdGltZXJUaW1lb3V0U3ltYm9sID0gY3JlYXRlU3ltYm9sKCd0aW1lclRpbWVvdXQnKTtcblxuXG4vKiBFeHBvcnRlZCBmdW5jdGlvbiBleHRlbmRzIGEgYmFzZSBjbGFzcyB3aXRoIFRpbWVyU2VsZWN0aW9uLiAqL1xuZXhwb3J0IGRlZmF1bHQgKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogTWl4aW4gd2hpY2ggcHJvdmlkZXMgZm9yIGF1dG9tYXRpYyB0aW1lZCBjaGFuZ2VzIGluIHNlbGVjdGlvbi5cbiAgICpcbiAgICogVGhpcyBtaXhpbiBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIHNsaWRlc2hvdy1saWtlIGVsZW1lbnRzIHN1Y2ggYXNcbiAgICogW2Jhc2ljLXNsaWRlc2hvd10oLi4vLi4vYmFzaWMtc2xpZGVzaG93KSBhbmRcbiAgICogW2Jhc2ljLXNsaWRlc2hvdy13aXRoLWNvbnRyb2xzXSguLi8uLi9iYXNpYy1zbGlkZXNob3ctd2l0aC1jb250cm9scykuXG4gICAqXG4gICAqIFR5cGljYWwgdXNhZ2U6XG4gICAqXG4gICAqICAgICBjbGFzcyBDYXJvdXNlbFdpdGhUaW1lciBleHRlbmRzIFRpbWVyU2VsZWN0aW9uTWl4aW4oQ2Fyb3VzZWwpIHt9XG4gICAqICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ2Nhcm91c2VsLXdpdGgtYXJyb3dzJywgQ2Fyb3VzZWxXaXRoVGltZXIpO1xuICAgKlxuICAgKiBUaGlzIG1peGluIGV4cGVjdHMgdGhlIGNvbXBvbmVudCB0byBkZWZpbmUgYW4gYGl0ZW1zYCBwcm9wZXJ0eSwgYXMgd2VsbCBhc1xuICAgKiBgc2VsZWN0Rmlyc3RgIGFuZCBgc2VsZWN0TmV4dGAgbWV0aG9kcy4gWW91IGNhbiBpbXBsZW1lbnQgdGhvc2UgeW91cnNlbGYsXG4gICAqIG9yIHVzZSBbQ29udGVudEl0ZW1zTWl4aW5dKENvbnRlbnRJdGVtc01peGluLm1kKSBhbmRcbiAgICogW1NpbmdsZVNlbGVjdGlvbk1peGluXShTaW5nbGVTZWxlY3Rpb25NaXhpbi5tZCkuXG4gICAqL1xuICBjbGFzcyBUaW1lclNlbGVjdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgLy8gU2V0IGRlZmF1bHRzLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnBsYXlpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMucGxheWluZyA9IHRoaXNbc3ltYm9scy5kZWZhdWx0c10ucGxheWluZztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zZWxlY3Rpb25UaW1lckR1cmF0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblRpbWVyRHVyYXRpb24gPSB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnNlbGVjdGlvblRpbWVyRHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGVudENoYW5nZWQoKSB7XG4gICAgICBpZiAoc3VwZXIuY29udGVudENoYW5nZWQpIHsgc3VwZXIuY29udGVudENoYW5nZWQoKTsgfVxuICAgICAgcmVzdGFydFRpbWVyKHRoaXMpO1xuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgICAgZGVmYXVsdHMucGxheWluZyA9IGZhbHNlO1xuICAgICAgZGVmYXVsdHMuc2VsZWN0aW9uVGltZXJEdXJhdGlvbiA9IDEwMDA7XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmVnaW4gYXV0b21hdGljIHByb2dyZXNzaW9uIG9mIHRoZSBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgcGxheSgpIHtcbiAgICAgIGlmIChzdXBlci5wbGF5KSB7IHN1cGVyLnBsYXkoKTsgfVxuICAgICAgc3RhcnRUaW1lcih0aGlzKTtcbiAgICAgIHRoaXNbcGxheWluZ1N5bWJvbF0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdXNlIGF1dG9tYXRpYyBwcm9ncmVzc2lvbiBvZiB0aGUgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgaWYgKHN1cGVyLnBhdXNlKSB7IHN1cGVyLnBhdXNlKCk7IH1cbiAgICAgIGNsZWFyVGltZXIodGhpcyk7XG4gICAgICB0aGlzW3BsYXlpbmdTeW1ib2xdID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGlzIGJlaW5nIGF1dG9tYXRpY2FsbHkgYWR2YW5jZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGdldCBwbGF5aW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXNbcGxheWluZ1N5bWJvbF07XG4gICAgfVxuICAgIHNldCBwbGF5aW5nKHBsYXlpbmcpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzUGxheWluZyA9IHRoaXNbcGxheWluZ1N5bWJvbF07XG4gICAgICBjb25zdCBwYXJzZWQgPSBTdHJpbmcocGxheWluZykgPT09ICd0cnVlJzsgLy8gQ2FzdCB0byBib29sZWFuXG4gICAgICBpZiAoJ3BsYXlpbmcnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnBsYXlpbmcgPSBwbGF5aW5nOyB9XG4gICAgICBpZiAocGFyc2VkICE9PSBwcmV2aW91c1BsYXlpbmcpIHtcbiAgICAgICAgaWYgKHBsYXlpbmcpIHtcbiAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFdoZW4gdGhlIHNlbGVjdGVkIGl0ZW0gY2hhbmdlcyAoYmVjYXVzZSBvZiBzb21ldGhpbmcgdGhpcyBtaXhpbiBkaWQsIG9yXG4gICAgICogd2FzIGNoYW5nZWQgYnkgYW4gb3V0c2lkZSBhZ2VudCBsaWtlIHRoZSB1c2VyKSwgd2Ugd2FpdCBiZWZvcmUgYWR2YW5jaW5nXG4gICAgICogdG8gdGhlIG5leHQgaXRlbS4gQnkgdHJpZ2dlcmluZyB0aGUgbmV4dCBpdGVtIHRoaXMgd2F5LCB3ZSBpbXBsaWNpdGx5IGdldFxuICAgICAqIGEgZGVzaXJhYmxlIGJlaGF2aW9yOiBpZiB0aGUgdXNlciBjaGFuZ2VzIHRoZSBzZWxlY3Rpb24gKGUuZy4sIGluIGFcbiAgICAgKiBjYXJvdXNlbCksIHdlIGxldCB0aGVtIHNlZSB0aGF0IHNlbGVjdGlvbiBzdGF0ZSBmb3IgYSB3aGlsZSBiZWZvcmVcbiAgICAgKiBhZHZhbmNpbmcgdGhlIHNlbGVjdGlvbiBvdXJzZWx2ZXMuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkSXRlbSgpIHtcbiAgICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEl0ZW07XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEl0ZW0oaXRlbSkge1xuICAgICAgaWYgKCdzZWxlY3RlZEl0ZW0nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGVkSXRlbSA9IGl0ZW07IH1cbiAgICAgIHJlc3RhcnRUaW1lcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCB3aWxsIGVsYXBzZSBhZnRlciB0aGUgc2VsZWN0aW9uIGNoYW5nZXNcbiAgICAgKiBiZWZvcmUgdGhlIHNlbGVjdGlvbiB3aWxsIGJlIGFkdmFuY2VkIHRvIHRoZSBuZXh0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSAtIFRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogQGRlZmF1bHQgMTAwMCAoMSBzZWNvbmQpXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblRpbWVyRHVyYXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpc1tzZWxlY3Rpb25UaW1lckR1cmF0aW9uU3ltYm9sXTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGlvblRpbWVyRHVyYXRpb24odmFsdWUpIHtcbiAgICAgIHRoaXNbc2VsZWN0aW9uVGltZXJEdXJhdGlvblN5bWJvbF0gPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICBpZiAoJ3NlbGVjdGlvblRpbWVyRHVyYXRpb24nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGlvblRpbWVyRHVyYXRpb24gPSB2YWx1ZTsgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFRpbWVyU2VsZWN0aW9uO1xufTtcblxuXG5mdW5jdGlvbiBjbGVhclRpbWVyKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnRbdGltZXJUaW1lb3V0U3ltYm9sXSkge1xuICAgIGNsZWFyVGltZW91dChlbGVtZW50W3RpbWVyVGltZW91dFN5bWJvbF0pO1xuICAgIGVsZW1lbnRbdGltZXJUaW1lb3V0U3ltYm9sXSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdGFydFRpbWVyKGVsZW1lbnQpIHtcbiAgY2xlYXJUaW1lcihlbGVtZW50KTtcbiAgaWYgKGVsZW1lbnQucGxheWluZyAmJiBlbGVtZW50Lml0ZW1zICYmIGVsZW1lbnQuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgIHN0YXJ0VGltZXIoZWxlbWVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRUaW1lcihlbGVtZW50KSB7XG4gIC8vIElmIHBsYXkoKSBpcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2UsIGNhbmNlbCBhbnkgZXhpc3RpbmcgdGltZXIuXG4gIGNsZWFyVGltZXIoZWxlbWVudCk7XG4gIGVsZW1lbnRbdGltZXJUaW1lb3V0U3ltYm9sXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHNlbGVjdE5leHRXaXRoV3JhcChlbGVtZW50KTtcbiAgfSwgZWxlbWVudC5zZWxlY3Rpb25UaW1lckR1cmF0aW9uKTtcbn1cblxuLy8gU2VsZWN0IHRoZSBuZXh0IGl0ZW0sIHdyYXBwaW5nIHRvIGZpcnN0IGl0ZW0gaWYgbmVjZXNzYXJ5LlxuZnVuY3Rpb24gc2VsZWN0TmV4dFdpdGhXcmFwKGVsZW1lbnQpIHtcbiAgY29uc3QgaXRlbXMgPSBlbGVtZW50Lml0ZW1zO1xuICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMCkge1xuICAgIGlmIChlbGVtZW50LnNlbGVjdGVkSW5kZXggPT0gbnVsbCB8fCBlbGVtZW50LnNlbGVjdGVkSW5kZXggPT09IGl0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgIGVsZW1lbnQuc2VsZWN0Rmlyc3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZWxlY3ROZXh0KCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgY3JlYXRlU3ltYm9sIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL2NyZWF0ZVN5bWJvbCc7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuL3N5bWJvbHMnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBhYnNvcmJEZWNlbGVyYXRpb25TeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2Fic29yYkRlY2VsZXJhdGlvbicpO1xuY29uc3QgbGFzdERlbHRhWFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbGFzdERlbHRhWCcpO1xuY29uc3QgbGFzdFdoZWVsVGltZW91dFN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnbGFzdFdoZWVsVGltZW91dCcpO1xuY29uc3QgcG9zdE5hdmlnYXRlRGVsYXlDb21wbGV0ZVN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncG9zdE5hdmlnYXRlRGVsYXlDb21wbGV0ZScpO1xuY29uc3Qgd2hlZWxEaXN0YW5jZVN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnd2hlZWxEaXN0YW5jZScpO1xuXG5cbi8qIEV4cG9ydGVkIGZ1bmN0aW9uIGV4dGVuZHMgYSBiYXNlIGNsYXNzIHdpdGggVHJhY2twYWREaXJlY3Rpb24uICovXG5leHBvcnQgZGVmYXVsdCAoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBNaXhpbiB3aGljaCBtYXBzIGEgaG9yaXpvbnRhbCB0cmFja3BhZCBzd2lwZSBnZXN0dXJlcyAob3IgaG9yaXpvbnRhbCBtb3VzZVxuICAgKiB3aGVlbCBhY3Rpb25zKSB0byBkaXJlY3Rpb24gc2VtYW50aWNzLlxuICAgKlxuICAgKiBZb3UgY2FuIHVzZSB0aGlzIG1peGluIHdpdGggYSBtaXhpbiBsaWtlXG4gICAqIFtEaXJlY3Rpb25TZWxlY3Rpb25NaXhpbl0oRGlyZWN0aW9uU2VsZWN0aW9uTWl4aW4ubWQpIHRvIGxldCB0aGUgdXNlclxuICAgKiBjaGFuZ2UgdGhlIHNlbGVjdGlvbiB3aXRoIHRoZSB0cmFja3BhZCBvciBtb3VzZSB3aGVlbC5cbiAgICpcbiAgICogVG8gcmVzcG9uZCB0byB0aGUgdHJhY2twYWQsIHdlIGNhbiBsaXN0ZW4gdG8gdGhlIERPTSdzIFwid2hlZWxcIiBldmVudHMuXG4gICAqIFRoZXNlIGV2ZW50cyBhcmUgZmlyZWQgYXMgdGhlIHVzZXIgZHJhZ3MgdGhlaXIgZmluZ2VycyBhY3Jvc3MgYSB0cmFja3BhZC5cbiAgICogVW5mb3J0dW5hdGVseSwgYnJvd3NlcnMgYXJlIG1pc3NpbmcgYSBjcml0aWNhbCBldmVudCDigJTCoHRoZXJlIGlzIG5vIGV2ZW50XG4gICAqIHdoZW4gdGhlIHVzZXIgKnN0b3BzKiBhIGdlc3R1cmVkIG9uIHRoZSB0cmFja3BhZCBvciBtb3VzZSB3aGVlbC5cbiAgICpcbiAgICogVG8gbWFrZSB0aGluZ3Mgd29yc2UsIHRoZSBtYWluc3RyZWFtIGJyb3dzZXJzIGNvbnRpbnVlIHRvIGdlbmVyYXRlIGZha2VcbiAgICogd2hlZWwgZXZlbnRzIGV2ZW4gYWZ0ZXIgdGhlIHVzZXIgaGFzIHN0b3BwZWQgZHJhZ2dpbmcgdGhlaXIgZmluZ2Vycy4gVGhlc2VcbiAgICogZmFrZSBldmVudHMgc2ltdWxhdGUgdGhlIHVzZXIgZ3JhZHVhbGx5IHNsb3dpbmcgZG93biB0aGUgZHJhZyB1bnRpbCB0aGV5XG4gICAqIGNvbWUgdG8gYSBzbW9vdGggc3RvcC4gSW4gc29tZSBjb250ZXh0cywgdGhlc2UgZmFrZSB3aGVlbCBldmVudHMgbWlnaHQgYmVcbiAgICogaGVscGZ1bCwgYnV0IGluIHRyeWluZyB0byBzdXBwbHkgdHlwaWNhbCB0cmFja3BhZCBzd2lwZSBuYXZpZ2F0aW9uLCB0aGVzZVxuICAgKiBmYWtlIGV2ZW50cyBnZXQgaW4gdGhlIHdheS5cbiAgICpcbiAgICogVGhpcyBjb21wb25lbnQgdXNlcyBoZXVyaXN0aWNzIHRvIHdvcmsgYXJvdW5kIHRoZXNlIHByb2JsZW1zLCBidXQgdGhlXG4gICAqIGNvbXBsZXggbmF0dXJlIG9mIHRoZSBwcm9ibGVtIG1ha2UgaXQgZXh0cmVtZWx5IGRpZmZpY3VsdCB0byBhY2hpZXZlIHRoZVxuICAgKiBzYW1lIGRlZ3JlZSBvZiB0cmFja3BhZCByZXNwb25zaXZlbmVzcyBwb3NzaWJsZSB3aXRoIG5hdGl2ZSBhcHBsaWNhdGlvbnMuXG4gICAqL1xuICBjbGFzcyBUcmFja3BhZERpcmVjdGlvbiBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlZCA9IHdoZWVsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlc2V0V2hlZWxUcmFja2luZyh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uLlxuICAgIGdldCBbc3ltYm9scy5kcmFnZ2luZ10oKSB7XG4gICAgICByZXR1cm4gc3VwZXJbc3ltYm9scy5kcmFnZ2luZ107XG4gICAgfVxuICAgIHNldCBbc3ltYm9scy5kcmFnZ2luZ10odmFsdWUpIHtcbiAgICAgIGlmIChzeW1ib2xzLmRyYWdnaW5nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyW3N5bWJvbHMuZHJhZ2dpbmddID0gdmFsdWU7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgbGVmdC5cbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICovXG4gICAgW3N5bWJvbHMuZ29MZWZ0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvTGVmdF0pIHsgcmV0dXJuIHN1cGVyW3N5bWJvbHMuZ29MZWZ0XSgpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIHJpZ2h0LlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBbc3ltYm9scy5nb1JpZ2h0XSgpIHtcbiAgICAgIGlmIChzdXBlcltzeW1ib2xzLmdvUmlnaHRdKSB7IHJldHVybiBzdXBlcltzeW1ib2xzLmdvUmlnaHRdKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGlzdGFuY2UgdGhlIHVzZXIgaGFzIG1vdmVkIHRoZSBmaXJzdCB0b3VjaHBvaW50IHNpbmNlIHRoZSBiZWdpbm5pbmdcbiAgICAgKiBvZiBhIHRyYWNrcGFkL3doZWVsIG9wZXJhdGlvbiwgZXhwcmVzc2VkIGFzIGEgZnJhY3Rpb24gb2YgdGhlIGVsZW1lbnQnc1xuICAgICAqIHdpZHRoLlxuICAgICAqXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IHRyYXZlbEZyYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnRyYXZlbEZyYWN0aW9uO1xuICAgIH1cbiAgICBzZXQgdHJhdmVsRnJhY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICgndHJhdmVsRnJhY3Rpb24nIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnRyYXZlbEZyYWN0aW9uID0gdmFsdWU7IH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBUcmFja3BhZERpcmVjdGlvbjtcbn07XG5cblxuLy8gVGltZSB3ZSB3YWl0IGZvbGxvd2luZyBhIG5hdmlnYXRpb24gYmVmb3JlIHBheWluZyBhdHRlbnRpb24gdG8gd2hlZWxcbi8vIGV2ZW50cyBhZ2Fpbi5cbmNvbnN0IFBPU1RfTkFWSUdBVEVfVElNRSA9IDI1MDtcblxuLy8gVGltZSB3ZSB3YWl0IGFmdGVyIHRoZSBsYXN0IHdoZWVsIGV2ZW50IGJlZm9yZSB3ZSByZXNldCB0aGluZ3MuXG5jb25zdCBXSEVFTF9USU1FID0gMTAwO1xuXG5cbi8vIEZvbGxvd2luZyBhIG5hdmlnYXRpb24sIHBhcnRpYWxseSByZXNldCBvdXIgd2hlZWwgdHJhY2tpbmcuXG5mdW5jdGlvbiBwb3N0TmF2aWdhdGUoZWxlbWVudCkge1xuICBlbGVtZW50LnRyYXZlbEZyYWN0aW9uID0gMDtcbiAgZWxlbWVudFt3aGVlbERpc3RhbmNlU3ltYm9sXSA9IDA7XG4gIGVsZW1lbnRbcG9zdE5hdmlnYXRlRGVsYXlDb21wbGV0ZVN5bWJvbF0gPSB0cnVlO1xuICBlbGVtZW50W2Fic29yYkRlY2VsZXJhdGlvblN5bWJvbF0gPSB0cnVlO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBlbGVtZW50W3Bvc3ROYXZpZ2F0ZURlbGF5Q29tcGxldGVTeW1ib2xdID0gZmFsc2U7XG4gIH0sIFBPU1RfTkFWSUdBVEVfVElNRSk7XG59XG5cbi8vIFJlc2V0IGFsbCBzdGF0ZSByZWxhdGVkIHRvIHRoZSB0cmFja2luZyBvZiB0aGUgd2hlZWwuXG5mdW5jdGlvbiByZXNldFdoZWVsVHJhY2tpbmcoZWxlbWVudCkge1xuICBlbGVtZW50LnRyYXZlbEZyYWN0aW9uID0gMDtcbiAgZWxlbWVudFt3aGVlbERpc3RhbmNlU3ltYm9sXSA9IDA7XG4gIGVsZW1lbnRbbGFzdERlbHRhWFN5bWJvbF0gPSAwO1xuICBlbGVtZW50W2Fic29yYkRlY2VsZXJhdGlvblN5bWJvbF0gPSBmYWxzZTtcbiAgZWxlbWVudFtwb3N0TmF2aWdhdGVEZWxheUNvbXBsZXRlU3ltYm9sXSA9IGZhbHNlO1xuICBpZiAoZWxlbWVudFtsYXN0V2hlZWxUaW1lb3V0U3ltYm9sXSkge1xuICAgIGNsZWFyVGltZW91dChlbGVtZW50W2xhc3RXaGVlbFRpbWVvdXRTeW1ib2xdKTtcbiAgICBlbGVtZW50W2xhc3RXaGVlbFRpbWVvdXRTeW1ib2xdID0gbnVsbDtcbiAgfVxufVxuXG4vLyBEZWZpbmUgb3VyIG93biBzaWduIGZ1bmN0aW9uLCBzaW5jZSAoYXMgb2YgTWF5IDIwMTUpLCBTYWZhcmkgYW5kIElFIGRvbid0XG4vLyBzdXBwbHkgTWF0aC5zaWduKCkuXG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgcmV0dXJuICh4ID09PSAwKSA/XG4gICAgMCA6XG4gICAgKHggPiAwKSA/XG4gICAgICAxIDpcbiAgICAgIC0xO1xufVxuXG4vLyBUT0RPOiBEYW1waW5nLCBvciBzb21lIG90aGVyIHRyZWF0bWVudCBmb3IgZ29pbmcgcGFzdCB0aGUgZW5kcy5cblxuLypcbiAqIEEgd2hlZWwgZXZlbnQgaGFzIGJlZW4gZ2VuZXJhdGVkLiBUaGlzIGNvdWxkIGJlIGEgcmVhbCB3aGVlbCBldmVudCwgb3IgaXRcbiAqIGNvdWxkIGJlIGZha2UgKHNlZSBub3RlcyBpbiB0aGUgaGVhZGVyKS5cbiAqXG4gKiBUaGlzIGhhbmRsZXIgdXNlcyBzZXZlcmFsIHN0cmF0ZWdpZXMgdG8gdHJ5IHRvIGFwcHJveGltYXRlIG5hdGl2ZSB0cmFja3BhZFxuICogc3dpcGUgbmF2aWdhdGlvbi5cbiAqXG4gKiBJZiB0aGUgdXNlciBoYXMgZHJhZ2dlZCBlbm91Z2ggdG8gY2F1c2UgYSBuYXZpZ2F0aW9uLCB0aGVuIGZvciBhIHNob3J0XG4gKiBkZWxheSBmb2xsb3dpbmcgdGhhdCBuYXZpZ2F0aW9uLCBzdWJzZXF1ZW50IHdoZWVsIGV2ZW50cyB3aWxsIGJlIGlnbm9yZWQuXG4gKlxuICogRnVydGhlcm1vcmUsIGZvbGx3b3dpbmcgYSBuYXZpZ2F0aW9uLCB3ZSBpZ25vcmUgYWxsIHdoZWVsIGV2ZW50cyB1bnRpbCB3ZVxuICogcmVjZWl2ZSBhdCBsZWFzdCBvbmUgZXZlbnQgd2hlcmUgdGhlIGV2ZW50J3MgZGVsdGFYIChkaXN0YW5jZSB0cmF2ZWxlZCkgaXNcbiAqICpncmVhdGVyKiB0aGFuIHRoZSBwcmV2aW91cyBldmVudCdzIGRlbHRhWC4gVGhpcyBoZWxwcyB1cyBmaWx0ZXIgb3V0IHRoZVxuICogZmFrZSB3aGVlbCBldmVudHMgZ2VuZXJhdGVkIGJ5IHRoZSBicm93c2VyIHRvIHNpbXVsYXRlIGRlY2VsZXJhdGlvbi5cbiAqXG4gKi9cbmZ1bmN0aW9uIHdoZWVsKGVsZW1lbnQsIGV2ZW50KSB7XG5cbiAgLy8gU2luY2Ugd2UgaGF2ZSBhIG5ldyB3aGVlbCBldmVudCwgcmVzZXQgb3VyIHRpbWVyIHdhaXRpbmcgZm9yIHRoZSBsYXN0XG4gIC8vIHdoZWVsIGV2ZW50IHRvIHBhc3MuXG4gIGlmIChlbGVtZW50W2xhc3RXaGVlbFRpbWVvdXRTeW1ib2xdKSB7XG4gICAgY2xlYXJUaW1lb3V0KGVsZW1lbnRbbGFzdFdoZWVsVGltZW91dFN5bWJvbF0pO1xuICB9XG4gIGVsZW1lbnRbbGFzdFdoZWVsVGltZW91dFN5bWJvbF0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB3aGVlbFRpbWVkT3V0KGVsZW1lbnQpO1xuICB9LCBXSEVFTF9USU1FKTtcblxuICBjb25zdCBkZWx0YVggPSBldmVudC5kZWx0YVg7XG4gIGNvbnN0IGRlbHRhWSA9IGV2ZW50LmRlbHRhWTtcblxuICAvLyBTZWUgaWYgZWxlbWVudCBldmVudCByZXByZXNlbnRzIGFjY2VsZXJhdGlvbiBvciBkZWNlbGVyYXRpb24uXG4gIGNvbnN0IGFjY2VsZXJhdGlvbiA9IHNpZ24oZGVsdGFYKSAqIChkZWx0YVggLSBlbGVtZW50W2xhc3REZWx0YVhTeW1ib2xdKTtcbiAgZWxlbWVudFtsYXN0RGVsdGFYU3ltYm9sXSA9IGRlbHRhWDtcblxuICBpZiAoTWF0aC5hYnMoZGVsdGFYKSA8IE1hdGguYWJzKGRlbHRhWSkpIHtcbiAgICAvLyBNb3ZlIHdhcyBtb3N0bHkgdmVydGljYWwuIFRoZSB1c2VyIG1heSBiZSB0cnlpbmcgc2Nyb2xsIHdpdGggdGhlXG4gICAgLy8gdHJhY2twYWQvd2hlZWwuIFRvIGJlIG9uIHRoZSBzYWZlLCB3ZSBpZ25vcmUgc3VjaCBldmVudHMuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGVsZW1lbnRbcG9zdE5hdmlnYXRlRGVsYXlDb21wbGV0ZVN5bWJvbF0pIHtcbiAgICAvLyBJdCdzIHRvbyBzb29uIGFmdGVyIGEgbmF2aWdhdGlvbjsgaWdub3JlIHRoZSBldmVudC5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhY2NlbGVyYXRpb24gPiAwKSB7XG4gICAgLy8gVGhlIGV2ZW50cyBhcmUgbm90IChvciBhcmUgbm8gbG9uZ2VyKSBkZWNlbGVyYXRpbmcsIHNvIHdlIGNhbiBzdGFydFxuICAgIC8vIHBheWluZyBhdHRlbnRpb24gdG8gdGhlbSBhZ2Fpbi5cbiAgICBlbGVtZW50W2Fic29yYkRlY2VsZXJhdGlvblN5bWJvbF0gPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChlbGVtZW50W2Fic29yYkRlY2VsZXJhdGlvblN5bWJvbF0pIHtcbiAgICAvLyBUaGUgd2hlZWwgZXZlbnQgd2FzIGxpa2VseSBmYWtlZCB0byBzaW11bGF0ZSBkZWNlbGVyYXRpb247IGlnbm9yZSBpdC5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGVsZW1lbnRbd2hlZWxEaXN0YW5jZVN5bWJvbF0gKz0gZGVsdGFYO1xuXG4gIC8vIFVwZGF0ZSB0aGUgdHJhdmVsIGZyYWN0aW9uIG9mIHRoZSBlbGVtZW50IGJlaW5nIG5hdmlnYXRlZC5cbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICBsZXQgdHJhdmVsRnJhY3Rpb24gPSB3aWR0aCA+IDAgP1xuICAgIGVsZW1lbnRbd2hlZWxEaXN0YW5jZVN5bWJvbF0gLyB3aWR0aCA6XG4gICAgMDtcbiAgZWxlbWVudFtzeW1ib2xzLmRyYWdnaW5nXSA9IHRydWU7XG4gIHRyYXZlbEZyYWN0aW9uID0gc2lnbih0cmF2ZWxGcmFjdGlvbikgKiBNYXRoLm1pbihNYXRoLmFicyh0cmF2ZWxGcmFjdGlvbiksIDEpO1xuICBlbGVtZW50LnRyYXZlbEZyYWN0aW9uID0gdHJhdmVsRnJhY3Rpb247XG5cbiAgLy8gSWYgdGhlIHVzZXIgaGFzIGRyYWdnZWQgZW5vdWdoIHRvIHJlYWNoIHRoZSBwcmV2aW91cy9uZXh0IGl0ZW0sIHRoZW5cbiAgLy8gY29tcGxldGUgYSBuYXZpZ2F0aW9uIHRvIHRoYXQgaXRlbS5cbiAgaWYgKHRyYXZlbEZyYWN0aW9uID09PSAxKSB7XG4gICAgZWxlbWVudFtzeW1ib2xzLmRyYWdnaW5nXSA9IGZhbHNlO1xuICAgIGVsZW1lbnRbc3ltYm9scy5nb1JpZ2h0XSgpO1xuICAgIHBvc3ROYXZpZ2F0ZShlbGVtZW50KTtcbiAgfSBlbHNlIGlmICh0cmF2ZWxGcmFjdGlvbiA9PT0gLTEpIHtcbiAgICBlbGVtZW50W3N5bWJvbHMuZHJhZ2dpbmddID0gZmFsc2U7XG4gICAgZWxlbWVudFtzeW1ib2xzLmdvTGVmdF0oKTtcbiAgICBwb3N0TmF2aWdhdGUoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gQSBzdWZmaWNpZW50bHkgbG9uZyBwZXJpb2Qgb2YgdGltZSBoYXMgcGFzc2VkIHNpbmNlIHRoZSBsYXN0IHdoZWVsIGV2ZW50LlxuLy8gV2Ugc25hcCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBjbG9zZXN0IGl0ZW0sIHRoZW4gcmVzZXQgb3VyIHN0YXRlLlxuZnVuY3Rpb24gd2hlZWxUaW1lZE91dChlbGVtZW50KSB7XG5cbiAgLy8gU25hcCB0byB0aGUgY2xvc2VzdCBpdGVtLlxuICBlbGVtZW50W3N5bWJvbHMuZHJhZ2dpbmddID0gZmFsc2U7XG4gIGNvbnN0IHRyYXZlbEZyYWN0aW9uID0gZWxlbWVudC50cmF2ZWxGcmFjdGlvbjtcbiAgaWYgKHRyYXZlbEZyYWN0aW9uID49IDAuNSkge1xuICAgIGVsZW1lbnRbc3ltYm9scy5nb1JpZ2h0XSgpO1xuICB9IGVsc2UgaWYgKHRyYXZlbEZyYWN0aW9uIDw9IC0wLjUpIHtcbiAgICBlbGVtZW50W3N5bWJvbHMuZ29MZWZ0XSgpO1xuICB9XG5cbiAgLy8gVE9ETzogTGlzdGVuIGZvciB0aGUgdHJhbnNpdGlvbiB0byBjb21wbGV0ZSwgYW5kIHRoZW4gcmVzdG9yZVxuICAvLyBkcmFnZ2luZyB0byBmYWxzZSAob3IgdGhlIHByZXZpb3VzIHZhbHVlKS5cblxuICByZXNldFdoZWVsVHJhY2tpbmcoZWxlbWVudCk7XG59XG4iLCIvKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzeW1ib2wgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYXNzb2NpYXRpbmcgcHJpdmF0ZVxuICogZGF0YSB3aXRoIGFuIGVsZW1lbnQuXG4gKlxuICogTWl4aW5zIGFuZCBjb21wb25lbnQgY2xhc3NlcyBvZnRlbiB3YW50IHRvIGFzc29jaWF0ZSBwcml2YXRlIGRhdGEgd2l0aCBhblxuICogZWxlbWVudCBpbnN0YW5jZSwgYnV0IEphdmFTY3JpcHQgZG9lcyBub3QgaGF2ZSBkaXJlY3Qgc3VwcG9ydCBmb3IgdHJ1ZVxuICogcHJpdmF0ZSBwcm9wZXJ0aWVzLiBPbmUgYXBwcm9hY2ggaXMgdG8gdXNlIHRoZVxuICogW1N5bWJvbF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3ltYm9sKVxuICogZGF0YSB0eXBlIHRvIHNldCBhbmQgcmV0cmlldmUgZGF0YSBvbiBhbiBlbGVtZW50LlxuICpcbiAqIFVuZm9ydHVuYXRlbHksIHRoZSBTeW1ib2wgdHlwZSBpcyBub3QgYXZhaWxhYmxlIGluIEludGVybmV0IEV4cGxvcmVyIDExLiBUaGVcbiAqIGBjcmVhdGVTeW1ib2xgIGhlbHBlciBmdW5jdGlvbiBleGlzdHMgYXMgYSB3b3JrYXJvdW5kIGZvciBJRSAxMS4gUmF0aGVyIHRoYW5cbiAqIHJldHVybmluZyBhIHRydWUgU3ltYm9sLCBpdCBzaW1wbHkgcmV0dXJucyBhbiB1bmRlcnNjb3JlLXByZWZpeGVkIHN0cmluZy5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgICAgY29uc3QgZm9vU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdmb28nKTtcbiAqXG4gKiAgICAgY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICogICAgICAgZ2V0IGZvbygpIHtcbiAqICAgICAgICAgcmV0dXJuIHRoaXNbZm9vU3ltYm9sXTtcbiAqICAgICAgIH1cbiAqICAgICAgIHNldCBmb28odmFsdWUpIHtcbiAqICAgICAgICAgdGhpc1tmb29TeW1ib2xdID0gdmFsdWU7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIEluIElFIDExLCB0aGlzIHNhbXBsZSB3aWxsIFwiaGlkZVwiIGRhdGEgYmVoaW5kIGFuIGluc3RhbmNlIHByb3BlcnR5IHRoaXMuX2Zvby5cbiAqIFRoZSB1c2Ugb2YgdGhlIHVuZGVyc2NvcmUgaXMgbWVhbnQgdG8gcmVkdWNlIChub3QgZWxpbWluYXRlKSB0aGUgcG90ZW50aWFsXG4gKiBmb3IgbmFtZSBjb25mbGljdHMsIGFuZCBkaXNjb3VyYWdlIChub3QgcHJldmVudCkgZXh0ZXJuYWwgYWNjZXNzIHRvIHRoaXNcbiAqIGRhdGEuIEluIG1vZGVybiBicm93c2VycywgdGhlIGFib3ZlIGNvZGUgd2lsbCBlbGltaW5hdGUgdGhlIHBvdGVudGlhbCBvZlxuICogbmFtaW5nIGNvbmZsaWN0cywgYW5kIGJldHRlciBoaWRlIHRoZSBkYXRhIGJlaGluZCBhIHJlYWwgU3ltYm9sLlxuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVTeW1ib2xcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXNjcmlwdGlvbiAtIEEgc3RyaW5nIHRvIGlkZW50aWZ5IHRoZSBzeW1ib2wgd2hlbiBkZWJ1Z2dpbmdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nID9cbiAgICBTeW1ib2woZGVzY3JpcHRpb24pIDpcbiAgICBgXyR7ZGVzY3JpcHRpb259YDtcbn1cbiIsIi8qXG4gKiBNaWNyb3Rhc2sgaGVscGVyIGZvciBJRSAxMS5cbiAqXG4gKiBFeGVjdXRpbmcgYSBmdW5jdGlvbiBhcyBhIG1pY3JvdGFzayBpcyB0cml2aWFsIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydFxuICogcHJvbWlzZXMsIHdob3NlIHRoZW4oKSBjbGF1c2VzIHVzZSBtaWNyb3Rhc2sgdGltaW5nLiBJRSAxMSBkb2Vzbid0IHN1cHBvcnRcbiAqIHByb21pc2VzLCBidXQgZG9lcyBzdXBwb3J0IE11dGF0aW9uT2JzZXJ2ZXJzLCB3aGljaCBhcmUgYWxzbyBleGVjdXRlZCBhc1xuICogbWljcm90YXNrcy4gU28gdGhpcyBoZWxwZXIgdXNlcyBhbiBNdXRhdGlvbk9ic2VydmVyIHRvIGFjaGlldmUgbWljcm90YXNrXG4gKiB0aW1pbmcuXG4gKlxuICogU2VlIGh0dHBzOi8vamFrZWFyY2hpYmFsZC5jb20vMjAxNS90YXNrcy1taWNyb3Rhc2tzLXF1ZXVlcy1hbmQtc2NoZWR1bGVzL1xuICpcbiAqIEluc3BpcmVkIGJ5IFBvbHltZXIncyBhc3luYygpIGZ1bmN0aW9uLlxuICovXG5cblxuLy8gVGhlIHF1ZXVlIG9mIHBlbmRpbmcgY2FsbGJhY2tzIHRvIGJlIGV4ZWN1dGVkIGFzIG1pY3JvdGFza3MuXG5jb25zdCBjYWxsYmFja3MgPSBbXTtcblxuLy8gQ3JlYXRlIGFuIGVsZW1lbnQgdGhhdCB3ZSB3aWxsIG1vZGlmeSB0byBmb3JjZSBvYnNlcnZhYmxlIG11dGF0aW9ucy5cbmNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG5cbi8vIEEgbW9ub3RvbmljYWxseS1pbmNyZWFzaW5nIHZhbHVlLlxubGV0IGNvdW50ZXIgPSAwO1xuXG5cbi8qKlxuICogQWRkIGEgY2FsbGJhY2sgdG8gdGhlIG1pY3JvdGFzayBxdWV1ZS5cbiAqXG4gKiBUaGlzIHVzZXMgYSBNdXRhdGlvbk9ic2VydmVyIHNvIHRoYXQgaXQgd29ya3Mgb24gSUUgMTEuXG4gKlxuICogTk9URTogSUUgMTEgbWF5IGFjdHVhbGx5IHVzZSB0aW1lb3V0IHRpbWluZyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJzLiBUaGlzXG4gKiBuZWVkcyBtb3JlIGludmVzdGlnYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uIG1pY3JvdGFza1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWljcm90YXNrKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgLy8gRm9yY2UgYSBtdXRhdGlvbi5cbiAgZWxlbWVudC50ZXh0Q29udGVudCA9ICsrY291bnRlcjtcbn1cblxuXG4vLyBFeGVjdXRlIGFueSBwZW5kaW5nIGNhbGxiYWNrcy5cbmZ1bmN0aW9uIGV4ZWN1dGVDYWxsYmFja3MoKSB7XG4gIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzLnNoaWZ0KCk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG5cbi8vIENyZWF0ZSB0aGUgb2JzZXJ2ZXIuXG5jb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGV4ZWN1dGVDYWxsYmFja3MpO1xub2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gIGNoYXJhY3RlckRhdGE6IHRydWVcbn0pO1xuIiwiLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHJlbmRlcmluZyBhbiBhcnJheSBvZiBpdGVtcyBhcyBlbGVtZW50cy5cbiAqXG4gKiBUaGlzIGlzIG5vdCBhIG1peGluLCBidXQgYSBmdW5jdGlvbiBjb21wb25lbnRzIGNhbiB1c2UgaWYgdGhleSBuZWVkIHRvXG4gKiBnZW5lcmF0ZSBhIHNldCBvZiBlbGVtZW50cyBmb3IgdGhlIGl0ZW1zIGluIGFuIGFycmF5LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZXVzZSBleGlzdGluZyBlbGVtZW50cyBpZiBwb3NzaWJsZS4gRS5nLiwgaWYgaXQgaXMgY2FsbGVkXG4gKiB0byByZW5kZXIgYW4gYXJyYXkgb2YgNCBpdGVtcywgYW5kIGxhdGVyIGNhbGxlZCB0byByZW5kZXIgYW4gYXJyYXkgb2YgNVxuICogaXRlbXMsIGl0IGNhbiByZXVzZSB0aGUgZXhpc3RpbmcgNCBpdGVtcywgY3JlYXRpbmcganVzdCBvbmUgbmV3IGVsZW1lbnQuXG4gKiBOb3RlLCBob3dldmVyLCB0aGF0IHRoaXMgcmUtcmVuZGVyaW5nIGlzIG5vdCBhdXRvbWF0aWMuIElmLCBhZnRlciBjYWxsaW5nXG4gKiB0aGlzIGZ1bmN0aW9uLCB5b3UgbWFuaXB1bGF0ZSB0aGUgYXJyYXkgeW91IHVzZWQsIHlvdSBtdXN0IHN0aWxsIGNhbGwgdGhpc1xuICogZnVuY3Rpb24gYWdhaW4gdG8gcmUtcmVuZGVyIHRoZSBhcnJheS5cbiAqXG4gKiBUaGUgYHJlbmRlckl0ZW1gIHBhcmFtZXRlciB0YWtlcyBhIGZ1bmN0aW9uIG9mIHR3byBhcmd1bWVudHM6IGFuIGl0ZW0gdG9cbiAqIHRvIHJlbmRlciwgYW5kIGFuIGV4aXN0aW5nIGVsZW1lbnQgKGlmIG9uZSBleGlzdHMpIHdoaWNoIGNhbiBiZSByZXB1cnBvc2VkIHRvXG4gKiByZW5kZXIgdGhhdCBpdGVtLiBJZiB0aGUgbGF0dGVyIGFyZ3VtZW50IGlzIG51bGwsIHRoZSBgcmVuZGVySXRlbSgpYCBmdW5jdGlvblxuICogc2hvdWxkIGNyZWF0ZSBhIG5ldyBlbGVtZW50IGFuZCByZXR1cm4gaXQuIFRoZSBmdW5jdGlvbiBzaG91bGQgZG8gdGhlIHNhbWVcbiAqIGlmIHRoZSBzdXBwbGllZCBleGlzdGluZyBlbGVtZW50IGlzIG5vdCBzdWl0YWJsZSBmb3IgcmVuZGVyaW5nIHRoZSBnaXZlblxuICogaXRlbTsgdGhlIHJldHVybmVkIGVsZW1lbnQgd2lsbCBiZSB1c2VkIHRvIHJlcGxhY2UgdGhlIGV4aXN0aW5nIG9uZS4gSWYgdGhlXG4gKiBleGlzdGluZyBlbGVtZW50ICppcyogc3VpdGFibGUsIHRoZSBmdW5jdGlvbiBjYW4gc2ltcGx5IHVwZGF0ZSBpdCBhbmQgcmV0dXJuXG4gKiBpdCBhcyBpcy5cbiAqXG4gKiBFeGFtcGxlOiBUaGUgZm9sbG93aW5nIHdpbGwgcmVuZGVyIGFuIGFycmF5IG9mIHN0cmluZ3MgaW4gZGl2cyBhcyBjaGlsZHJlblxuICogb2YgdGhlIGBjb250YWluZXJgIGVsZW1lbnQ6XG4gKlxuICogICAgIGxldCBzdHJpbmdzID0gWydhJywgJ2InLCAnYycsIC4uLl07XG4gKiAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMucXVlcnlTZWxlY3RvciguLi4pO1xuICogICAgIHJlbmRlckFycmF5QXNFbGVtZW50cyhzdHJpbmdzLCBjb250YWluZXIsIChzdHJpbmcsIGVsZW1lbnQpID0+IHtcbiAqICAgICAgIGlmICghZWxlbWVudCkge1xuICogICAgICAgICAvLyBObyBlbGVtZW50IGV4aXN0cyB5ZXQsIHNvIGNyZWF0ZSBhIG5ldyBvbmUuXG4gKiAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAqICAgICAgIH1cbiAqICAgICAgIC8vIFNldC91cGRhdGUgdGhlIHRleHQgY29udGVudCBvZiB0aGUgZWxlbWVudC5cbiAqICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBzdHJpbmc7XG4gKiAgICAgICByZXR1cm4gZWxlbWVudDtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtcyAtIHRoZSBpdGVtcyB0byByZW5kZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIHRoZSBwYXJlbnQgdGhhdCB3aWxsIGhvbGQgdGhlIGVsZW1lbnRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJJdGVtIC0gcmV0dXJucyBhIG5ldyBlbGVtZW50IGZvciBhbiBpdGVtLCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcHVycG9zZXMgYW4gZXhpc3RpbmcgZWxlbWVudCBmb3IgYW4gaXRlbVxuICovXG5mdW5jdGlvbiByZW5kZXJBcnJheUFzRWxlbWVudHMoaXRlbXMsIGNvbnRhaW5lciwgcmVuZGVySXRlbSkge1xuICAvLyBDcmVhdGUgYSBuZXcgc2V0IG9mIGVsZW1lbnRzIGZvciB0aGUgY3VycmVudCBpdGVtcy5cbiAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBvbGRFbGVtZW50ID0gY29udGFpbmVyLmNoaWxkTm9kZXNbaW5kZXhdO1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSByZW5kZXJJdGVtKGl0ZW0sIG9sZEVsZW1lbnQpO1xuICAgIGlmIChuZXdFbGVtZW50KSB7XG4gICAgICBpZiAoIW9sZEVsZW1lbnQpIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChuZXdFbGVtZW50ICE9PSBvbGRFbGVtZW50KSB7XG4gICAgICAgIGNvbnRhaW5lci5yZXBsYWNlQ2hpbGQobmV3RWxlbWVudCwgb2xkRWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB0aGUgYXJyYXkgc2hyYW5rLCByZW1vdmUgdGhlIGV4dHJhIGVsZW1lbnRzIHdoaWNoIGFyZSBubyBsb25nZXIgbmVlZGVkLlxuICB3aGlsZSAoY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoID4gaXRlbXMubGVuZ3RoKSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5jaGlsZE5vZGVzW2l0ZW1zLmxlbmd0aF0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlckFycmF5QXNFbGVtZW50cztcbiIsImltcG9ydCBjcmVhdGVTeW1ib2wgZnJvbSAnLi9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IHRvZ2dsZUNsYXNzIGZyb20gJy4vdG9nZ2xlQ2xhc3MnO1xuXG5cbi8vIFN5bWJvbHMgZm9yIHByaXZhdGUgZGF0YSBtZW1iZXJzIG9uIGFuIGVsZW1lbnQuXG5jb25zdCBzYWZlVG9TZXRBdHRyaWJ1dGVzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdzYWZlVG9TZXRBdHRyaWJ1dGVzJyk7XG5jb25zdCBwZW5kaW5nQXR0cmlidXRlc1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncGVuZGluZ0F0dHJpYnV0ZXMnKTtcbmNvbnN0IHBlbmRpbmdDbGFzc2VzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdwZW5kaW5nQ2xhc3NlcycpO1xuXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgdXBkYXRpbmcgYXR0cmlidXRlcywgaW5jbHVkaW5nIHRoZSBgY2xhc3NgIGF0dHJpYnV0ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFueSBwZW5kaW5nIHVwZGF0ZXMgdG8gYXR0cmlidXRlcyBhbmQgY2xhc3Nlcy5cbiAgICpcbiAgICogVGhpcyB3cml0ZXMgYW55IGBzZXRBdHRyaWJ1dGVgIG9yIGB0b2dnbGVDbGFzc2AgdmFsdWVzIHRoYXQgd2VyZSBwZXJmb3JtZWRcbiAgICogYmVmb3JlIGFuIGVsZW1lbnQgd2FzIGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgYnkgbWl4aW5zL2NvbXBvbmVudHMgaW4gdGhlaXJcbiAgICogYGNvbm5lY3RlZENhbGxiYWNrYC4gSWYgbXVsaXRwbGUgbWl4aW5zL2NvbXBvbmVudHMgaW52b2tlIHRoaXMgZHVyaW5nIHRoZVxuICAgKiBzYW1lIGBjb25uZWN0ZWRDYWxsYmFja2AsIG9ubHkgdGhlIGZpcnN0IGNhbGwgd2lsbCBoYXZlIGFueSBlZmZlY3QuIFRoZVxuICAgKiBzdWJzZXF1ZW50IGNhbGxzIHdpbGwgYmUgaGFybWxlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBiZWluZyBhZGRlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAqL1xuICBjb25uZWN0ZWQoZWxlbWVudCkge1xuICAgIGVsZW1lbnRbc2FmZVRvU2V0QXR0cmlidXRlc1N5bWJvbF0gPSB0cnVlO1xuXG4gICAgLy8gU2V0IGFueSBwZW5kaW5nIGF0dHJpYnV0ZXMuXG4gICAgaWYgKGVsZW1lbnRbcGVuZGluZ0F0dHJpYnV0ZXNTeW1ib2xdKSB7XG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gZWxlbWVudFtwZW5kaW5nQXR0cmlidXRlc1N5bWJvbF0pIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50W3BlbmRpbmdBdHRyaWJ1dGVzU3ltYm9sXVthdHRyaWJ1dGVdO1xuICAgICAgICBzZXRBdHRyaWJ1dGVUb0VsZW1lbnQoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbGVtZW50W3BlbmRpbmdBdHRyaWJ1dGVzU3ltYm9sXSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2V0IGFueSBwZW5kaW5nIGNsYXNzZXMuXG4gICAgaWYgKGVsZW1lbnRbcGVuZGluZ0NsYXNzZXNTeW1ib2xdKSB7XG4gICAgICBmb3IgKGxldCBjbGFzc05hbWUgaW4gZWxlbWVudFtwZW5kaW5nQ2xhc3Nlc1N5bWJvbF0pIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50W3BlbmRpbmdDbGFzc2VzU3ltYm9sXVtjbGFzc05hbWVdO1xuICAgICAgICB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRbcGVuZGluZ0NsYXNzZXNTeW1ib2xdID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldC91bnNldCB0aGUgYXR0cmlidXRlIHdpdGggdGhlIGluZGljYXRlZCBuYW1lLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBleGlzdHMgcHJpbWFyaWx5IHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbiBlbGVtZW50IHdhbnRzIHRvXG4gICAqIHNldCBhIGRlZmF1bHQgcHJvcGVydHkgdmFsdWUgdGhhdCBzaG91bGQgYmUgcmVmbGVjdGVkIGFzIGFuIGF0dHJpYnV0ZS4gQW5cbiAgICogaW1wb3J0YW50IGxpbWl0YXRpb24gb2YgY3VzdG9tIGVsZW1lbnQgY29uc3R1cmN0b3JzIGlzIHRoYXQgdGhleSBjYW5ub3RcbiAgICogc2V0IGF0dHJpYnV0ZXMuIEEgY2FsbCB0byBgc2V0QXR0cmlidXRlYCBkdXJpbmcgdGhlIGNvbnN0cnVjdG9yIHdpbGxcbiAgICogYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVsZW1lbnQgaXMgY29ubmVjdGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSAtIFRoZSBuYW1lIG9mIHRoZSAqYXR0cmlidXRlKiAobm90IHByb3BlcnR5KSB0byBzZXQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQuIElmIG51bGwsIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZW1vdmVkLlxuICAgKi9cbiAgc2V0QXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAoZWxlbWVudFtzYWZlVG9TZXRBdHRyaWJ1dGVzU3ltYm9sXSkge1xuICAgICAgLy8gU2FmZSB0byBzZXQgYXR0cmlidXRlcyBpbW1lZGlhdGVseS5cbiAgICAgIHNldEF0dHJpYnV0ZVRvRWxlbWVudChlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVmZXIgc2V0dGluZyBhdHRyaWJ1dGVzIHVudGlsIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RlZC5cbiAgICAgIGlmICghZWxlbWVudFtwZW5kaW5nQXR0cmlidXRlc1N5bWJvbF0pIHtcbiAgICAgICAgZWxlbWVudFtwZW5kaW5nQXR0cmlidXRlc1N5bWJvbF0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRbcGVuZGluZ0F0dHJpYnV0ZXNTeW1ib2xdW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldC91bnNldCB0aGUgY2xhc3Mgd2l0aCB0aGUgaW5kaWNhdGVkIG5hbWUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGV4aXN0cyBwcmltYXJpbHkgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFuIGVsZW1lbnQgd2FudHMgdG9cbiAgICogc2V0IGEgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZSB0aGF0IHNob3VsZCBiZSByZWZsZWN0ZWQgYXMgYXMgY2xhc3MuIEFuXG4gICAqIGltcG9ydGFudCBsaW1pdGF0aW9uIG9mIGN1c3RvbSBlbGVtZW50IGNvbnN0dXJjdG9ycyBpcyB0aGF0IHRoZXkgY2Fubm90XG4gICAqIHNldCBhdHRyaWJ1dGVzLCBpbmNsdWRpbmcgdGhlIGBjbGFzc2AgYXR0cmlidXRlLiBBIGNhbGwgdG9cbiAgICogYHRvZ2dsZUNsYXNzYCBkdXJpbmcgdGhlIGNvbnN0cnVjdG9yIHdpbGwgYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVsZW1lbnRcbiAgICogaXMgY29ubmVjdGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjbGFzcyB0byBzZXQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZSAtIFRydWUgdG8gc2V0IHRoZSBjbGFzcywgZmFsc2UgdG8gcmVtb3ZlIGl0LlxuICAgKi9cbiAgdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCB2YWx1ZSkge1xuICAgIGlmIChlbGVtZW50W3NhZmVUb1NldEF0dHJpYnV0ZXNTeW1ib2xdKSB7XG4gICAgICAvLyBTYWZlIHRvIHNldCBjbGFzcyBpbW1lZGlhdGVseS5cbiAgICAgIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZlciBzZXR0aW5nIGNsYXNzIHVudGlsIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RlZC5cbiAgICAgIGlmICghZWxlbWVudFtwZW5kaW5nQ2xhc3Nlc1N5bWJvbF0pIHtcbiAgICAgICAgZWxlbWVudFtwZW5kaW5nQ2xhc3Nlc1N5bWJvbF0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRbcGVuZGluZ0NsYXNzZXNTeW1ib2xdW2NsYXNzTmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxufTtcblxuXG4vLyBSZWZsZWN0IHRoZSBhdHRyaWJ1dGUgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXG4vLyBJZiB0aGUgdmFsdWUgaXMgbnVsbCwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVUb0VsZW1lbnQoZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0ZXh0ID0gU3RyaW5nKHZhbHVlKTtcbiAgICAvLyBBdm9pZCByZWN1cnNpdmUgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIGNhbGxzLlxuICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSAhPT0gdGV4dCkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuL2NyZWF0ZVN5bWJvbCc7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIFN5bWJvbCBvYmplY3RzIGZvciBzdGFuZGFyZCBjb21wb25lbnQgcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAqXG4gKiBUaGVzZSBTeW1ib2wgb2JqZWN0cyBhcmUgdXNlZCB0byBhbGxvdyBtaXhpbnMgYW5kIGEgY29tcG9uZW50IHRvIGludGVybmFsbHlcbiAqIGNvbW11bmljYXRlLCB3aXRob3V0IGV4cG9zaW5nIHRoZXNlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlIGNvbXBvbmVudCdzXG4gKiBwdWJsaWMgQVBJLlxuICpcbiAqIFRvIHVzZSB0aGVzZSBTeW1ib2wgb2JqZWN0cyBpbiB5b3VyIG93biBjb21wb25lbnQsIGluY2x1ZGUgdGhpcyBtb2R1bGUgYW5kXG4gKiB0aGVuIGNyZWF0ZSBhIHByb3BlcnR5IG9yIG1ldGhvZCB3aG9zZSBrZXkgaXMgdGhlIGRlc2lyZWQgU3ltYm9sLlxuICpcbiAqICAgICBpbXBvcnQgJ1NpbmdsZVNlbGVjdGlvbk1peGluJyBmcm9tICdiYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TaW5nbGVTZWxlY3Rpb25NaXhpbic7XG4gKiAgICAgaW1wb3J0ICdzeW1ib2xzJyBmcm9tICdiYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zeW1ib2xzJztcbiAqXG4gKiAgICAgY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgU2luZ2xlU2VsZWN0aW9uTWl4aW4oSFRNTEVsZW1lbnQpIHtcbiAqICAgICAgIFtzeW1ib2xzLml0ZW1TZWxlY3RlZF0oaXRlbSwgc2VsZWN0ZWQpIHtcbiAqICAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGludm9rZWQgd2hlbmV2ZXIgYW4gaXRlbSBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkLlxuICogICAgICAgfVxuICogICAgIH1cbiAqXG4gKiBAbW9kdWxlIHN5bWJvbHNcbiAqL1xuY29uc3Qgc3ltYm9scyA9IHtcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGRlZmF1bHRzYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBzZXQgb3Igb3ZlcnJpZGUgZGVmYXVsdHMgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAgICogdG8gYSBuZXcgY29tcG9uZW50IGluc3RhbmNlLiBXaGVuIGltcGxlbWVudGluZyB0aGlzIHByb3BlcnR5LCB0YWtlIGNhcmUgdG9cbiAgICogZmlyc3QgYWNxdWlyZSBhbnkgZGVmYXVsdHMgZGVmaW5lZCBieSB0aGUgc3VwZXJjbGFzcy4gVGhlIHN0YW5kYXJkIGlkaW9tIGlzXG4gICAqIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqICAgICBnZXQgW3N5bWJvbHMuZGVmYXVsdHNdKCkge1xuICAgKiAgICAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgKiAgICAgICAvLyBTZXQgb3Igb3ZlcnJpZGUgZGVmYXVsdCB2YWx1ZXMgaGVyZVxuICAgKiAgICAgICBkZWZhdWx0cy5jdXN0b21Qcm9wZXJ0eSA9IGZhbHNlO1xuICAgKiAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEB2YXIge29iamVjdH0gZGVmYXVsdHNcbiAgICovXG4gIGRlZmF1bHRzOiBjcmVhdGVTeW1ib2woJ2RlZmF1bHRzJyksXG5cbiAgLyoqXG4gICAqIFN5bWJvbCBmb3IgdGhlIGBkcmFnZ2luZ2AgcHJvcGVydHkuXG4gICAqXG4gICAqIENvbXBvbmVudHMgbGlrZSBjYXJvdXNlbHMgb2Z0ZW4gZGVmaW5lIGFuaW1hdGVkIENTUyB0cmFuc2l0aW9ucyBmb3JcbiAgICogc2xpZGluZyBlZmZlY3RzLiBTdWNoIGEgdHJhbnNpdGlvbiBzaG91bGQgdXN1YWxseSAqbm90KiBiZSBhcHBsaWVkIHdoaWxlXG4gICAqIHRoZSB1c2VyIGlzIGRyYWdnaW5nLCBiZWNhdXNlIGEgQ1NTIGFuaW1hdGlvbiB3aWxsIGludHJvZHVjZSBhIGxhZyB0aGF0XG4gICAqIG1ha2VzIHRoZSBzd2lwZSBmZWVsIHNsdWdnaXNoLiBJbnN0ZWFkLCBhcyBsb25nIGFzIHRoZSB1c2VyIGlzIGRyYWdnaW5nXG4gICAqIHdpdGggdGhlaXIgZmluZ2VyIGRvd24sIHRoZSB0cmFuc2l0aW9uIHNob3VsZCBiZSBzdXBwcmVzc2VkLiBXaGVuIHRoZVxuICAgKiB1c2VyIHJlbGVhc2VzIHRoZWlyIGZpbmdlciwgdGhlIHRyYW5zaXRpb24gY2FuIGJlIHJlc3RvcmVkLCBhbGxvd2luZyB0aGVcbiAgICogYW5pbWF0aW9uIHRvIHNob3cgdGhlIGNhcm91c2VsIHNsaWRpbmcgaW50byBpdHMgZmluYWwgcG9zaXRpb24uXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufSB0cnVlIGlmIGEgZHJhZyBpcyBpbiBwcm9ncmVzcywgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgZHJhZ2dpbmc6IGNyZWF0ZVN5bWJvbCgnZHJhZ2dpbmcnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGdvRG93bmAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgZG93bi5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGdvRG93blxuICAgKi9cbiAgZ29Eb3duOiBjcmVhdGVTeW1ib2woJ2dvRG93bicpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgZ29FbmRgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIHRvIHRoZSBlbmQgKGUuZy4sXG4gICAqIG9mIGEgbGlzdCkuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBnb0VuZFxuICAgKi9cbiAgZ29FbmQ6IGNyZWF0ZVN5bWJvbCgnZ29FbmQnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGdvTGVmdGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgbGVmdC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGdvTGVmdFxuICAgKi9cbiAgZ29MZWZ0OiBjcmVhdGVTeW1ib2woJ2dvTGVmdCcpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgZ29SaWdodGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgcmlnaHQuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBnb1JpZ2h0XG4gICAqL1xuICBnb1JpZ2h0OiBjcmVhdGVTeW1ib2woJ2dvUmlnaHQnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGdvU3RhcnRgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGdvL25hdmlnYXRlIHRvIHRoZSBzdGFydFxuICAgKiAoZS5nLiwgb2YgYSBsaXN0KS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGdvU3RhcnRcbiAgICovXG4gIGdvU3RhcnQ6IGNyZWF0ZVN5bWJvbCgnZ29TdGFydCcpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgZ29VcGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gZ28vbmF2aWdhdGUgdXAuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBnb1VwXG4gICAqL1xuICBnb1VwOiBjcmVhdGVTeW1ib2woJ2dvVXAnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGl0ZW1BZGRlZGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gYSBuZXcgaXRlbSBpcyBhZGRlZCB0byBhIGxpc3QuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBpdGVtQWRkZWRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaXRlbSAtIHRoZSBpdGVtIGJlaW5nIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgICovXG4gIGl0ZW1BZGRlZDogY3JlYXRlU3ltYm9sKCdpdGVtQWRkZWQnKSxcblxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgaXRlbXNDaGFuZ2VkYCBtZXRob2QuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiB0aGUgdW5kZXJseWluZyBjb250ZW50cyBjaGFuZ2UuIEl0IGlzIGFsc29cbiAgICogaW52b2tlZCBvbiBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24g4oCTIHNpbmNlIHRoZSBpdGVtcyBoYXZlIFwiY2hhbmdlZFwiIGZyb21cbiAgICogYmVpbmcgbm90aGluZy5cbiAgICovXG4gIGl0ZW1zQ2hhbmdlZDogY3JlYXRlU3ltYm9sKCdpdGVtc0NoYW5nZWQnKSxcblxuICAvKipcbiAgICogU3ltYm9sIGZvciB0aGUgYGl0ZW1TZWxlY3RlZGAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gYW4gaXRlbSBiZWNvbWVzIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBpdGVtU2VsZWN0ZWRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaXRlbSAtIHRoZSBpdGVtIGJlaW5nIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZCAtIHRydWUgaWYgdGhlIGl0ZW0gaXMgc2VsZWN0ZWQsIGZhbHNlIGlmIG5vdFxuICAgKi9cbiAgaXRlbVNlbGVjdGVkOiBjcmVhdGVTeW1ib2woJ2l0ZW1TZWxlY3RlZCcpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBga2V5ZG93bmAgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gYW4gZWxlbWVudCByZWNlaXZlcyBhIGBrZXlkb3duYCBldmVudC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGtleWRvd25cbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIHRoZSBldmVudCBiZWluZyBwcm9jZXNzZWRcbiAgICovXG4gIGtleWRvd246IGNyZWF0ZVN5bWJvbCgna2V5ZG93bicpLFxuXG4gIC8qKlxuICAgKiBTeW1ib2wgZm9yIHRoZSBgdGVtcGxhdGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBUaGlzIHByb3BlcnR5IHJldHVybnMgYSBjb21wb25lbnQncyB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ3xIVE1MRWxlbWVudH1cbiAgICovXG4gIHRlbXBsYXRlOiBjcmVhdGVTeW1ib2woJ3RlbXBsYXRlJylcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN5bWJvbHM7XG4iLCIvKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3Igc3RhbmRhcmQgY2xhc3NMaXN0LnRvZ2dsZSgpIGJlaGF2aW9yIG9uIG9sZCBicm93c2VycyxcbiAqIG5hbWVseSBJRSAxMS5cbiAqXG4gKiBUaGUgc3RhbmRhcmRcbiAqIFtjbGFzc2xpc3RdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2NsYXNzTGlzdClcbiAqIG9iamVjdCBoYXMgYSBgdG9nZ2xlKClgIGZ1bmN0aW9uIHRoYXQgc3VwcG9ydHMgYSBzZWNvbmQgQm9vbGVhbiBwYXJhbWV0ZXJcbiAqIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3VjY2luY3RseSB0dXJuIGEgY2xhc3Mgb24gb3Igb2ZmLiBUaGlzIGZlYXR1cmUgaXMgb2Z0ZW5cbiAqIHVzZWZ1bCBpbiBkZXNpZ25pbmcgY3VzdG9tIGVsZW1lbnRzLCB3aGljaCBtYXkgd2FudCB0byBleHRlcm5hbGx5IHJlZmxlY3RcbiAqIGNvbXBvbmVudCBzdGF0ZSBpbiBhIENTUyBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBzdHlsaW5nIHB1cnBvc2VzLlxuICpcbiAqIFVuZm9ydHVuYXRlbHksIElFIDExIGRvZXMgbm90IHN1cHBvcnQgdGhlIEJvb2xlYW4gcGFyYW1ldGVyIHRvXG4gKiBgY2xhc3NMaXN0LnRvZ2dsZSgpYC4gVGhpcyBoZWxwZXIgZnVuY3Rpb24gYmVoYXZlcyBsaWtlIHRoZSBzdGFuZGFyZFxuICogYHRvZ2dsZSgpYCwgaW5jbHVkaW5nIHN1cHBvcnQgZm9yIHRoZSBCb29sZWFuIHBhcmFtZXRlciwgc28gdGhhdCBpdCBjYW4gYmVcbiAqIHVzZWQgZXZlbiBvbiBJRSAxMS5cbiAqXG4gKiBAZnVuY3Rpb24gdG9nZ2xlQ2xhc3NcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgLSBUaGUgY2xhc3MgdG8gYWRkL3JlbW92ZVxuICogQHBhcmFtIHtib29sZWFufSBbZm9yY2VdIC0gRm9yY2UgdGhlIGNsYXNzIHRvIGJlIGFkZGVkIChpZiB0cnVlKSBvciByZW1vdmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaWYgZmFsc2UpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgZm9yY2UpIHtcbiAgY29uc3QgY2xhc3NMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XG4gIGNvbnN0IGFkZENsYXNzID0gKHR5cGVvZiBmb3JjZSA9PT0gJ3VuZGVmaW5lZCcpID9cbiAgICAhY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkgOlxuICAgIGZvcmNlO1xuICBpZiAoYWRkQ2xhc3MpIHtcbiAgICBjbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICB9XG4gIHJldHVybiBhZGRDbGFzcztcbn1cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgdHJhbnNwaWxlZCB0byBjcmVhdGUgYW4gRVM1LWNvbXBhdGlibGUgZGlzdHJpYnV0aW9uIGluIHdoaWNoXG4gKiB0aGUgcGFja2FnZSdzIG1haW4gZmVhdHVyZShzKSBhcmUgYXZhaWxhYmxlIHZpYSB0aGUgd2luZG93LkJhc2ljIGdsb2JhbC5cbiAqIElmIHlvdSdyZSBhbHJlYWR5IHVzaW5nIEVTNiB5b3Vyc2VsZiwgaWdub3JlIHRoaXMgZmlsZSwgYW5kIGluc3RlYWQgaW1wb3J0XG4gKiB0aGUgc291cmNlIGZpbGUocykgeW91IHdhbnQgZnJvbSB0aGUgc3JjIGZvbGRlci5cbiAqL1xuXG5pbXBvcnQgQ3VycmVudEFuY2hvciBmcm9tICcuL3NyYy9DdXJyZW50QW5jaG9yJztcblxud2luZG93LkJhc2ljID0gd2luZG93LkJhc2ljIHx8IHt9O1xud2luZG93LkJhc2ljLkN1cnJlbnRBbmNob3IgPSBDdXJyZW50QW5jaG9yO1xuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IHNhZmVBdHRyaWJ1dGVzIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3NhZmVBdHRyaWJ1dGVzJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3N5bWJvbHMnO1xuaW1wb3J0IFdyYXBwZWRTdGFuZGFyZEVsZW1lbnQgZnJvbSAnLi4vLi4vYmFzaWMtd3JhcHBlZC1zdGFuZGFyZC1lbGVtZW50L3NyYy9XcmFwcGVkU3RhbmRhcmRFbGVtZW50JztcblxuXG4vLyBTeW1ib2xzIGZvciBwcml2YXRlIGRhdGEgbWVtYmVycyBvbiBhbiBlbGVtZW50LlxuY29uc3QgYXJlYUxpbmtTeW1ib2wgPSBjcmVhdGVTeW1ib2woJ2FyZWFMaW5rJyk7XG5cblxuLyoqXG4gKiBBbiBhbmNob3IgKGxpbmspIHRoYXQgaGlnaGxpZ2h0cyBpdHNlbGYgd2hlbiBpdHMgZGVzdGluYXRpb24gbWF0Y2hlcyB0aGVcbiAqIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogW0xpdmUgZGVtb10oaHR0cDovL2Jhc2ljd2ViY29tcG9uZW50cy5vcmcvYmFzaWMtd2ViLWNvbXBvbmVudHMvcGFja2FnZXMvYmFzaWMtY3VycmVudC1hbmNob3IvKVxuICpcbiAqIFN1Y2ggYSBsaW5rIGNvbW1vbmx5IGFwcGVhcnMgaW4gdG9vbGJhcnMsIHNpZGUgYmFycywgYW5kIG90aGVyIG5hdmlnYXRpb25cbiAqIGVsZW1lbnRzLiBJbiB0aGVzZSBzaXR1YXRpb25zLCB5b3UgZ2VuZXJhbGx5IHdhbnQgdGhlIHVzZXIgdG8gdW5kZXJzdGFuZCB3aGF0XG4gKiBwYWdlIG9yIGFyZWEgdGhlIHVzZXIgaXMgYWxyZWFkeSBvbi5cbiAqXG4gKiBXaGVuIHRoZSBsaW5rIGlzIGN1cnJlbnQg4oCUIHdoZW4gaXQgcG9pbnRzIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uIOKAlCB0aGVcbiAqIGxpbmsgd2lsbCBoYXZlIHRoZSBDU1MgYGN1cnJlbnRgIGNsYXNzIGFwcGxpZWQgdG8gaXQsIGFuZCBpdHMgYGN1cnJlbnRgXG4gKiBwcm9wZXJ0eSB3aWxsIGJlIHRydWUuXG4gKlxuICogTm90ZTogb25lIGxpbWl0YXRpb24gb2YgdGhpcyBjb21wb25lbnQgaXMgdGhhdCwgYnkgZGVmYXVsdCwgdGhlIGxpbmsgZG9lc1xuICogKm5vdCogc2hvdyB0aGUgc3RhbmRhcmQgbGluayBjb2xvciAodXN1YWxseSBibHVlKSBhbmQgdGV4dCBkZWNvcmF0aW9uXG4gKiAodW5kZXJsaW5lKS4gSG93ZXZlciwgaW4gbmF2aWdhdGlvbiBlbGVtZW50cyBsaWtlIHRvb2xiYXJzLCB5b3Ugb2Z0ZW4gd2lsbFxuICogd2FudCB0byBleHBsaWNpdGx5IHNwZWNpZmljIGxpbmsgY29sb3JzIGFueXdheSwgZS5nLiwgdG8gcmVmbGVjdCB5b3VyXG4gKiBhcHBsaWNhdGlvbidzIHZpc3VhbCBzdHlsZSBhbmQgYnJhbmQuXG4gKlxuICogQGV4dGVuZHMgV3JhcHBlZFN0YW5kYXJkRWxlbWVudFxuICovXG5jbGFzcyBDdXJyZW50QW5jaG9yIGV4dGVuZHMgV3JhcHBlZFN0YW5kYXJkRWxlbWVudC53cmFwKCdhJykge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBldmVudCA9PiB7XG4gICAgICByZWZyZXNoKHRoaXMpO1xuICAgIH0pO1xuXG4gICAgLy8gU3R1cGlkIEVkZ2UvSUUgXCJzdXBwb3J0XCIgcG9wc3RhdGUsIGJ1dCBkb24ndCBmaXJlIGl0IG9uIGhhc2hjaGFuZ2UuXG4gICAgLy8gU28gd2UgaGF2ZSB0byBsaXN0ZW4gZm9yIGhhc2hjaGFuZ2UgYXMgd2VsbCwgd2l0aCB0aGUgcmVzdWx0IHRoYXQgYVxuICAgIC8vIHN0YW5kYXJkcy1jb21wbGlhbnQgYnJvd3NlciBtYXkgZW5kIHVwIHJlZnJlc2hpbmcgdGhlIGxpbmsgdHdpY2UuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBldmVudCA9PiB7XG4gICAgICByZWZyZXNoKHRoaXMpO1xuICAgIH0pO1xuXG4gICAgLy8gU2V0IGRlZmF1bHRzLlxuICAgIGlmICh0eXBlb2YgdGhpcy5hcmVhTGluayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuYXJlYUxpbmsgPSB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLmFyZWFMaW5rO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBsaW5rIHBvaW50cyB0byBhbiBhcmVhIHdpdGhpbiBhIHNpdGUsIG5vdCBqdXN0IGEgc2luZ2xlIHBhZ2UuXG4gICAqXG4gICAqIElmIHRydWUsIHRoZSBtYXRjaGluZyBydWxlIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBsaW5rIGlzIGN1cnJlbnQgY2hhbmdlczpcbiAgICogYW4gYXJlYSBsaW5rIGlzIGNvbnNpZGVyZWQgdG8gYmUgY3VycmVudCBpZiB0aGUgbGluaydzIGRlc3RpbmF0aW9uIGZvcm1zIGFcbiAgICogcHJlZml4IG9mIHRoZSBjdXJyZW50IGxvY2F0aW9uIChpbnN0ZWFkIG9mIG1hdGNoaW5nIHRoZSBjb21wbGV0ZSBVUkwpLlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBhcmVhTGluaygpIHtcbiAgICByZXR1cm4gdGhpc1thcmVhTGlua1N5bWJvbF07XG4gIH1cbiAgc2V0IGFyZWFMaW5rKHZhbHVlKSB7XG4gICAgLy8gQ2FzdCBib29sZWFuIG9yIHN0cmluZyB2YWx1ZXMgdG8gYm9vbGVhbi5cbiAgICB0aGlzW2FyZWFMaW5rU3ltYm9sXSA9IChTdHJpbmcodmFsdWUpID09PSAndHJ1ZScpO1xuICAgIHJlZnJlc2godGhpcyk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2spIHsgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTsgfVxuICAgIHNhZmVBdHRyaWJ1dGVzLmNvbm5lY3RlZCh0aGlzKTtcbiAgICByZWZyZXNoKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIGxpbmsncyBkZXN0aW5hdGlvbiBtYXRjaGVzIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gICAqXG4gICAqIElmIHRoaXMgaXMgdHJ1ZSwgdGhlIGVsZW1lbnQgd2lsbCBoYXZlIGFuIGBjdXJyZW50YCBDU1MgY2xhc3MgYXBwbGllZCB0byBpdC5cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ2N1cnJlbnQnKTtcbiAgfVxuICBzZXQgY3VycmVudCh2YWx1ZSkge1xuICAgIHNhZmVBdHRyaWJ1dGVzLnRvZ2dsZUNsYXNzKHRoaXMsICdjdXJyZW50JywgdmFsdWUpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2N1cnJlbnQtY2hhbmdlZCcpKTtcbiAgfVxuXG4gIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgY29uc3QgZGVmYXVsdHMgPSBzdXBlcltzeW1ib2xzLmRlZmF1bHRzXSB8fCB7fTtcbiAgICBkZWZhdWx0cy5hcmVhTGluayA9IGZhbHNlO1xuICAgIHJldHVybiBkZWZhdWx0cztcbiAgfVxuXG4gIC8vIEF1Z21lbnQgaHJlZiBpbXBsZW1lbnRhdGlvbiBzbyB0aGF0IGNoYW5naW5nIGhyZWYgY2hlY2tzIHRoZSBhY3RpdmUgc3RhdHVzLlxuICBnZXQgaHJlZigpIHtcbiAgICByZXR1cm4gc3VwZXIuaHJlZjtcbiAgfVxuICBzZXQgaHJlZih2YWx1ZSkge1xuICAgIHN1cGVyLmhyZWYgPSB2YWx1ZTtcbiAgICByZWZyZXNoKHRoaXMpO1xuICB9XG5cbiAgZ2V0IFtzeW1ib2xzLnRlbXBsYXRlXSgpIHtcbiAgICAvLyBSZXNldCBzdHlsZXMgc28gdGhhdCBjb2xvciBjYW4gYmUgc3BlY2lmaWVkIGZyb20gdGhlIG91dHNpZGUgd2l0aG91dFxuICAgIC8vIGhhdmluZyB0byBkZWZpbmUgYSBDU1MgdmFyaWFibGUuXG4gICAgcmV0dXJuIGBcbiAgICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgfVxuXG4gICAgICAjaW5uZXIge1xuICAgICAgICBjb2xvcjogaW5oZXJpdDtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IGluaGVyaXQ7XG4gICAgICB9XG4gICAgICA8L3N0eWxlPlxuICAgICAgPGEgaWQ9XCJpbm5lclwiPjxzbG90Pjwvc2xvdD48L2E+YDtcbiAgfVxuXG59XG5cblxuLy8gVXBkYXRlIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgZWxlbWVudCBiYXNlZCBvbiB0aGUgY3VycmVudCBsb2NhdGlvbi5cbmZ1bmN0aW9uIHJlZnJlc2goZWxlbWVudCkge1xuICBjb25zdCB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgbGV0IG1hdGNoO1xuICBpZiAoZWxlbWVudC5hcmVhTGluaykge1xuICAgIC8vIE1hdGNoIHByZWZpeFxuICAgIGxldCBwcmVmaXggPSBlbGVtZW50LmhyZWY7XG4gICAgLy8gSWYgcHJlZml4IGRvZXNuJ3QgZW5kIGluIHNsYXNoLCBhZGQgYSBzbGFzaC5cbiAgICAvLyBXZSB3YW50IHRvIGF2b2lkIG1hdGNoaW5nIGluIHRoZSBtaWRkbGUgb2YgYSBmb2xkZXIgbmFtZS5cbiAgICBpZiAocHJlZml4Lmxlbmd0aCA8IHVybC5sZW5ndGggJiYgcHJlZml4LnN1YnN0cigtMSkgIT09ICcvJykge1xuICAgICAgcHJlZml4ICs9ICcvJztcbiAgICB9XG4gICAgbWF0Y2ggPSAodXJsLnN1YnN0cigwLCBwcmVmaXgubGVuZ3RoKSA9PT0gcHJlZml4KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBNYXRjaCB3aG9sZSBwYXRoXG4gICAgbWF0Y2ggPSAodXJsID09PSBlbGVtZW50LmhyZWYpO1xuICB9XG4gIGVsZW1lbnQuY3VycmVudCA9IG1hdGNoO1xufVxuXG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnYmFzaWMtY3VycmVudC1hbmNob3InLCBDdXJyZW50QW5jaG9yKTtcbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgdHJhbnNwaWxlZCB0byBjcmVhdGUgYW4gRVM1LWNvbXBhdGlibGUgZGlzdHJpYnV0aW9uIGluIHdoaWNoXG4gKiB0aGUgcGFja2FnZSdzIG1haW4gZmVhdHVyZShzKSBhcmUgYXZhaWxhYmxlIHZpYSB0aGUgd2luZG93LkJhc2ljIGdsb2JhbC5cbiAqIElmIHlvdSdyZSBhbHJlYWR5IHVzaW5nIEVTNiB5b3Vyc2VsZiwgaWdub3JlIHRoaXMgZmlsZSwgYW5kIGluc3RlYWQgaW1wb3J0XG4gKiB0aGUgc291cmNlIGZpbGUocykgeW91IHdhbnQgZnJvbSB0aGUgc3JjIGZvbGRlci5cbiAqL1xuXG5pbXBvcnQgRWxlbWVudEJhc2UgZnJvbSAnLi9zcmMvRWxlbWVudEJhc2UnO1xuXG53aW5kb3cuQmFzaWMgPSB3aW5kb3cuQmFzaWMgfHwge307XG53aW5kb3cuQmFzaWMuRWxlbWVudEJhc2UgPSBFbGVtZW50QmFzZTtcbiIsImltcG9ydCBBdHRyaWJ1dGVNYXJzaGFsbGluZ01peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0F0dHJpYnV0ZU1hcnNoYWxsaW5nTWl4aW4nO1xuaW1wb3J0IENvbXBvc2FibGVNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9Db21wb3NhYmxlTWl4aW4nO1xuaW1wb3J0IERpc3RyaWJ1dGVkQ2hpbGRyZW5NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9EaXN0cmlidXRlZENoaWxkcmVuTWl4aW4nO1xuaW1wb3J0IFNoYWRvd0VsZW1lbnRSZWZlcmVuY2VzTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2hhZG93RWxlbWVudFJlZmVyZW5jZXNNaXhpbic7XG5pbXBvcnQgU2hhZG93VGVtcGxhdGVNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TaGFkb3dUZW1wbGF0ZU1peGluJztcblxuXG4vKipcbiAqIEEgc2FtcGxlIGdlbmVyYWwtcHVycG9zZSBiYXNlIGNsYXNzIGZvciBkZWZpbmluZyBjdXN0b20gZWxlbWVudHMgdGhhdCBtaXhlc1xuICogaW4gc29tZSBjb21tb24gZmVhdHVyZXM6IHRlbXBsYXRlIHN0YW1waW5nIGludG8gYSBzaGFkb3cgcm9vdCwgc2hhZG93IGVsZW1lbnRcbiAqIHJlZmVyZW5jZXMsIG1hcnNoYWxsaW5nIGF0dHJpYnV0ZXMgdG8gcHJvcGVydGllcywgYW5kIHJldHJpZXZpbmcgdGhlIGNoaWxkcmVuXG4gKiBkaXN0cmlidXRlZCB0byBhIGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGJhc2UgY2xhc3MgaXMgbm90IHNwZWNpYWwgaW4gYW55IHdheSwgYW5kIGlzIGRlZmluZWQgb25seSBhcyBhXG4gKiBjb252ZW5pZW50IHNob3J0aGFuZCBmb3IgYXBwbHlpbmcgdGhlIG1peGlucyBsaXN0ZWQgYWJvdmUuIFlvdSBjYW4gdXNlIHRoaXNcbiAqIGNsYXNzIGFzIGEgYmFzZSBjbGFzcyBmb3IgeW91ciBvd24gZWxlbWVudHMsIG9yIGVhc2lseSBjcmVhdGUgeW91ciBvd24gYmFzZVxuICogY2xhc3MgYnkgYXBwbHlpbmcgdGhlIHNhbWUgc2V0IG9mIG1peGlucy5cbiAqXG4gKiBUaGUgRWxlbWVudEJhc2UgYmFzZSBjbGFzcyBkb2VzIG5vdCByZWdpc3RlciBpdHNlbGYgYXMgYSBjdXN0b20gZWxlbWVudCB3aXRoXG4gKiB0aGUgYnJvd3NlciwgYW5kIGhlbmNlIGNhbm5vdCBiZSBpbmRlcGVuZGVudGx5IGluc3RhbnRpYXRlZC5cbiAqXG4gKiBAbWl4ZXMgQXR0cmlidXRlTWFyc2hhbGxpbmdNaXhpblxuICogQG1peGVzIENvbXBvc2FibGVNaXhpblxuICogQG1peGVzIERpc3RyaWJ1dGVkQ2hpbGRyZW5NaXhpblxuICogQG1peGVzIFNoYWRvd0VsZW1lbnRSZWZlcmVuY2VzTWl4aW5cbiAqIEBtaXhlcyBTaGFkb3dUZW1wbGF0ZU1peGluXG4gKi9cbmNsYXNzIEVsZW1lbnRCYXNlIGV4dGVuZHMgQ29tcG9zYWJsZU1peGluKEhUTUxFbGVtZW50KS5jb21wb3NlKFxuICBTaGFkb3dUZW1wbGF0ZU1peGluLCAgICAgICAgICAvLyBiZWZvcmUgbm9kZSBmaW5kaW5nLCBzbyBzaGFkb3cgcm9vdCBpcyBwb3B1bGF0ZWRcbiAgU2hhZG93RWxlbWVudFJlZmVyZW5jZXNNaXhpbiwgLy8gYmVmb3JlIG1hcnNoYWxsaW5nLCBzbyBwcm9wZXJ0aWVzIGNhbiB1c2UgcmVmc1xuICBBdHRyaWJ1dGVNYXJzaGFsbGluZ01peGluLFxuICBEaXN0cmlidXRlZENoaWxkcmVuTWl4aW5cbikge31cblxuZXhwb3J0IGRlZmF1bHQgRWxlbWVudEJhc2U7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHRyYW5zcGlsZWQgdG8gY3JlYXRlIGFuIEVTNS1jb21wYXRpYmxlIGRpc3RyaWJ1dGlvbiBpbiB3aGljaFxuICogdGhlIHBhY2thZ2UncyBtYWluIGZlYXR1cmUocykgYXJlIGF2YWlsYWJsZSB2aWEgdGhlIHdpbmRvdy5CYXNpYyBnbG9iYWwuXG4gKiBJZiB5b3UncmUgYWxyZWFkeSB1c2luZyBFUzYgeW91cnNlbGYsIGlnbm9yZSB0aGlzIGZpbGUsIGFuZCBpbnN0ZWFkIGltcG9ydFxuICogdGhlIHNvdXJjZSBmaWxlKHMpIHlvdSB3YW50IGZyb20gdGhlIHNyYyBmb2xkZXIuXG4gKi9cblxuaW1wb3J0IEZhZGVPdmVyZmxvdyBmcm9tICcuL3NyYy9GYWRlT3ZlcmZsb3cnO1xuXG53aW5kb3cuQmFzaWMgPSB3aW5kb3cuQmFzaWMgfHwge307XG53aW5kb3cuQmFzaWMuRmFkZU92ZXJmbG93ID0gRmFkZU92ZXJmbG93O1xuIiwiaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IEVsZW1lbnRCYXNlIGZyb20gJy4uLy4uL2Jhc2ljLWVsZW1lbnQtYmFzZS9zcmMvRWxlbWVudEJhc2UnO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc3ltYm9scyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IGZhZGVDb2xvclN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgnZmFkZUNvbG9yJyk7XG5cblxuLyoqXG4gKiBGYWRlcyBvdXQgY29udGVudCB0aGF0IG92ZXJmbG93cyBzbyB0aGUgdXNlciBrbm93cyB0aGVyZSdzIG1vcmUuXG4gKlxuICogVGhpcyBjb21wb25lbnQgZG9lc24ndCBoYW5kbGUgaW50ZXJhY3Rpdml0eS5cbiAqXG4gKiBUaGUgY29tcG9uZW50IG5lZWRzIHRvIGtub3cgdGhlIGNvbG9yIGl0IHNob3VsZCBmYWRlIHRvLCB3aGljaCBpdCB0cmllcyB0b1xuICogaW5mZXIgZnJvbSB0aGUgYmFja2dyb3VuZCBjb2xvci4gSW4gc29tZSBzaXR1YXRpb25zLCB0aGlzIG1heSBub3Qgd29yaywgaW5cbiAqIHdoaWNoIGNhc2UgeW91IGNhbiBleHBsaWNpdGx5IHNldCB0aGUgZmFkZUNvbG9yIGF0dHJpYnV0ZS5cbiAqXG4gKiBUaGUgY29tcG9uZW50IGN1cnJlbnRseSBhbHdheXMgZGlzcGxheXMgdGhlIGZhZGUsIGV2ZW4gaWYgdGhlIGNvbXBvbmVudCdzXG4gKiBjb250ZW50IGlzIHNob3J0IGVub3VnaCB0byBmaXQgY29tcGxldGVseSBpbiB2aWV3LlxuICpcbiAqIEBleHRlbmRzIEVsZW1lbnRCYXNlXG4gKi9cbmNsYXNzIEZhZGVPdmVyZmxvdyBleHRlbmRzIEVsZW1lbnRCYXNlIHtcblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2spIHsgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTsgfVxuICAgIGlmICh0aGlzLmZhZGVDb2xvciA9PSBudWxsKSB7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBmYWRlLlxuICAgKlxuICAgKiBUaGUgZmFkZSBjb2xvciBzaG91bGQgbWF0Y2ggdGhlIGJhY2tncm91bmQgY29sb3IuIFRoZSBjb21wb25lbnQgZG9lcyBpdHNcbiAgICogYmVzdCB0byBpbmZlciB0aGUgYmFja2dyb3VuZCBjb2xvciwgYnV0IGluIHNvbWUgc2l0dWF0aW9ucywgdGhhdCBtYXkgbm90XG4gICAqIHdvcmsuIEluIHRob3NlIGNhc2VzLCB5b3UgY2FuIG1hbnVhbGx5IGlkZW50aWZ5IHRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgKiBUaGlzIHNob3VsZCBiZSBhIHNvbGlkIGNvbG9yLlxuICAgKlxuICAgKiBAYXR0cmlidXRlIGZhZGVDb2xvclxuICAgKiBAZGVmYXVsdCB3aGl0ZVxuICAgKi9cbiAgZ2V0IGZhZGVDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpc1tmYWRlQ29sb3JTeW1ib2xdO1xuICB9XG4gIHNldCBmYWRlQ29sb3IodmFsdWUpIHtcbiAgICB0aGlzW2ZhZGVDb2xvclN5bWJvbF0gPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNvbnN0IHJnYiA9IGV4dHJhY3RSZ2JWYWx1ZXModmFsdWUpO1xuICAgICAgaWYgKHJnYikge1xuICAgICAgICBjb25zdCBmYWRlQ29sb3JUcmFuc3BhcmVudCA9IGByZ2JhKCR7cmdiLnJ9LCR7cmdiLmd9LCR7cmdiLmJ9LDApYDtcbiAgICAgICAgY29uc3QgZ3JhZGllbnQgPSBgbGluZWFyLWdyYWRpZW50KCR7ZmFkZUNvbG9yVHJhbnNwYXJlbnR9IDAlLCAke3ZhbHVlfSAxMDAlKWA7XG4gICAgICAgIHRoaXMuJC5mYWRlLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGdyYWRpZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmZlciB0aGUgZmFkZSBjb2xvciBmcm9tIGJhY2tncm91bmQgY29sb3IuIElmIHlvdSBoYXZlIHByb2dyYW1tYXRpY2FsbHlcbiAgICogY2hhbmdlZCB0aGUgY29sb3IgYmVoaW5kIHRoZSBjb21wb25lbnQsIHlvdSBjYW4gaW52b2tlIHRoaXMgbWV0aG9kIHRvIGhhdmVcbiAgICogdGhlIGNvbXBvbmVudCB0cnkgdG8gcGljayB1cCB0aGUgbmV3IGJhY2tncm91bmQgY29sb3IuXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIC8vIFRPRE86IEF1dG9tYXRpY2FsbHkgaGlkZSB0aGUgZmFkZSBpZiBhbGwgdGhlIGNvbnRlbnQgY2FuIGJlIHNlZW4uXG4gICAgdGhpcy5mYWRlQ29sb3IgPSBmaW5kQmFja2dyb3VuZENvbG9yKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgc2hvdyB0aGUgZmFkZSB0byB0aGUgYmFja2dyb3VuZCBjb2xvci5cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGdldCBzaG93RmFkZSgpIHtcbiAgICByZXR1cm4gdGhpcy4kLmZhZGUuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG4gIHNldCBzaG93RmFkZSh2YWx1ZSkge1xuICAgIHRoaXMuJC5mYWRlLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/ICcnIDogJ25vbmUnO1xuICB9XG5cbiAgZ2V0IFtzeW1ib2xzLnRlbXBsYXRlXSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgfVxuXG4gICAgICAjZmFkZSB7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgaGVpZ2h0OiAzZW07XG4gICAgICAgIG1heC1oZWlnaHQ6IDUwJTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7IC8qIExldHMgdXNlciBpbnRlcmFjdCB3aXRoIGNvbnRlbnQgdGhyb3VnaCB0aGUgZmFkZS4gKi9cbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG5cbiAgICAgIDxkaXYgaWQ9XCJmYWRlXCI+PC9kaXY+XG4gICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgYDtcbiAgfVxuXG59XG5cblxuLy8gUmV0dXJuIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBnaXZlbiBlbGVtZW50LiBJZiB0aGUgY29sb3IgaXNcbi8vIFwidHJhbnNwYXJlbnRcIiAodGhlIGRlZmF1bHQgaW4gTW96aWxsYSBhbmQgSUUpIG9yIFwicmdiYSgwLCAwLCAwLCAwKVwiICh0aGVcbi8vIGRlZmF1bHQgdHJhbnNwYXJlbnQgdmFsdWUgaW4gQmxpbmsgYW5kIFdlYmtpdCksIHdhbGsgdXAgdGhlIHBhcmVudCBjaGFpblxuLy8gdW50aWwgYSBub24tdHJhbnNwYXJlbnQgY29sb3IgaXMgZm91bmQuXG5mdW5jdGlvbiBmaW5kQmFja2dyb3VuZENvbG9yKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudC5zdHlsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgaGFzIG5vIGJhY2tncm91bmQsIGFzc3VtZSB3aGl0ZS5cbiAgICByZXR1cm4gJ3JnYigyNTUsMjU1LDI1NSknO1xuICB9XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuYmFja2dyb3VuZENvbG9yO1xuICBpZiAoYmFja2dyb3VuZENvbG9yID09PSAndHJhbnNwYXJlbnQnIHx8IGJhY2tncm91bmRDb2xvciA9PT0gJ3JnYmEoMCwgMCwgMCwgMCknKSB7XG4gICAgcmV0dXJuIGZpbmRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudC5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFja2dyb3VuZENvbG9yO1xuICB9XG59XG5cblxuLy8gUmV0dXJuIHRoZSBpbmRpdmlkdWFsIFJHQiB2YWx1ZXMgZnJvbSBhIENTUyBjb2xvciBzdHJpbmcuXG5mdW5jdGlvbiBleHRyYWN0UmdiVmFsdWVzKHJnYlN0cmluZykge1xuICBjb25zdCByZ2JSZWdleCA9IC9yZ2JhP1xcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccypbXFxkXFwuXStcXHMqKT9cXCkvO1xuICBjb25zdCBtYXRjaCA9IHJnYlJlZ2V4LmV4ZWMocmdiU3RyaW5nKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHBhcnNlSW50KG1hdGNoWzFdKSxcbiAgICAgIGc6IHBhcnNlSW50KG1hdGNoWzJdKSxcbiAgICAgIGI6IHBhcnNlSW50KG1hdGNoWzNdKVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2Jhc2ljLWZhZGUtb3ZlcmZsb3cnLCBGYWRlT3ZlcmZsb3cpO1xuZXhwb3J0IGRlZmF1bHQgRmFkZU92ZXJmbG93O1xuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyB0cmFuc3BpbGVkIHRvIGNyZWF0ZSBhbiBFUzUtY29tcGF0aWJsZSBkaXN0cmlidXRpb24gaW4gd2hpY2hcbiAqIHRoZSBwYWNrYWdlJ3MgbWFpbiBmZWF0dXJlKHMpIGFyZSBhdmFpbGFibGUgdmlhIHRoZSB3aW5kb3cuQmFzaWMgZ2xvYmFsLlxuICogSWYgeW91J3JlIGFscmVhZHkgdXNpbmcgRVM2IHlvdXJzZWxmLCBpZ25vcmUgdGhpcyBmaWxlLCBhbmQgaW5zdGVhZCBpbXBvcnRcbiAqIHRoZSBzb3VyY2UgZmlsZShzKSB5b3Ugd2FudCBmcm9tIHRoZSBzcmMgZm9sZGVyLlxuICovXG5cbmltcG9ydCBMaXN0Qm94IGZyb20gJy4vc3JjL0xpc3RCb3gnO1xuXG53aW5kb3cuQmFzaWMgPSB3aW5kb3cuQmFzaWMgfHwge307XG53aW5kb3cuQmFzaWMuTGlzdEJveCA9IExpc3RCb3g7XG4iLCJpbXBvcnQgRWxlbWVudEJhc2UgZnJvbSAnLi4vLi4vYmFzaWMtZWxlbWVudC1iYXNlL3NyYy9FbGVtZW50QmFzZSc7XG5pbXBvcnQgRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9EaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluJztcbmltcG9ydCBDbGlja1NlbGVjdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0NsaWNrU2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IENvbnRlbnRJdGVtc01peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0NvbnRlbnRJdGVtc01peGluJztcbmltcG9ydCBEaXJlY3Rpb25TZWxlY3Rpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9EaXJlY3Rpb25TZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgR2VuZXJpY01peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0dlbmVyaWNNaXhpbic7XG5pbXBvcnQgS2V5Ym9hcmRNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9LZXlib2FyZE1peGluJztcbmltcG9ydCBLZXlib2FyZERpcmVjdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0tleWJvYXJkRGlyZWN0aW9uTWl4aW4nO1xuaW1wb3J0IEtleWJvYXJkUGFnZWRTZWxlY3Rpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9LZXlib2FyZFBhZ2VkU2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IEtleWJvYXJkUHJlZml4U2VsZWN0aW9uTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvS2V5Ym9hcmRQcmVmaXhTZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgU2VsZWN0ZWRJdGVtVGV4dFZhbHVlTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2VsZWN0ZWRJdGVtVGV4dFZhbHVlTWl4aW4nO1xuaW1wb3J0IFNlbGVjdGlvbkFyaWFBY3RpdmVNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TZWxlY3Rpb25BcmlhQWN0aXZlTWl4aW4nO1xuaW1wb3J0IFNlbGVjdGlvbkhpZ2hsaWdodE1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NlbGVjdGlvbkhpZ2hsaWdodE1peGluJztcbmltcG9ydCBTZWxlY3Rpb25JblZpZXdNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TZWxlY3Rpb25JblZpZXdNaXhpbic7XG5pbXBvcnQgU2luZ2xlU2VsZWN0aW9uTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2luZ2xlU2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc3ltYm9scyc7XG5cblxuLyoqXG4gKiBBIHNpbmdsZS1zZWxlY3Rpb24gbGlzdCBib3ggdGhhdCBzdXBwb3J0cyBzZWxlY3Rpb24gaGlnaGxpZ2h0aW5nICh1c2luZyB0aGVcbiAqIHN5c3RlbSBoaWdobGlnaHQgY29sb3IpIGFuZCBrZXlib2FyZCBuYXZpZ2F0aW9uLlxuICpcbiAqIFtMaXZlIGRlbW9dKGh0dHA6Ly9iYXNpY3dlYmNvbXBvbmVudHMub3JnL2Jhc2ljLXdlYi1jb21wb25lbnRzL3BhY2thZ2VzL2Jhc2ljLWxpc3QtYm94LylcbiAqXG4gKiBUaGUgdXNlciBjYW4gc2VsZWN0IGFuIGl0ZW0gd2l0aCB0aGUgbW91c2UvdG91Y2ggb3Iga2V5Ym9hcmQ6IFVwL0Rvd24sIFBhZ2VcbiAqIFVwL0Rvd24sIEhvbWUvRW5kLlxuICpcbiAqIExpa2Ugb3RoZXIgQmFzaWMgV2ViIENvbXBvbmVudHMsIHRoaXMgY2FuIGhhbmRsZSBkaXN0cmlidXRlZCBjb250ZW50OiB5b3UgY2FuXG4gKiBpbmNsdWRlIGEgY29udGVudCBlbGVtZW50IGluc2lkZSBhIGJhc2ljLWxpc3QtYm94LCBhbmQgdGhlIGxpc3Qgd2lsbCBuYXZpZ2F0ZVxuICogdGhyb3VnaCB0aGUgZGlzdHJpYnV0ZWQgY29udGVudC5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBpbmNsdWRlcyBiYXNpYyBBUklBIHN1cHBvcnQgdG8gcHJvdmlkZSBhIHJlYXNvbmFibGUgZGVmYXVsdFxuICogZXhwZXJpZW5jZSwgZS5nLiwgZm9yIHNjcmVlbiByZWFkZXJzLiBUaGUgbGlzdCBjb21wb25lbnQgaXRzZWxmIHdpbGwgYmVcbiAqIGFzc2lnbmVkIGFuIGFwcHJvcHJpYXRlIEFSSUEgcm9sZSAoZGVmYXVsdCBpcyBcImxpc3Rib3hcIikuIFRoZSBJRCBvZiB0aGVcbiAqIHNlbGVjdGVkIGl0ZW0gd2lsbCBiZSByZWZsZWN0ZWQgaW4gYW4gXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiBhdHRyaWJ1dGVcbiAqIGFwcGxpZWQgdG8gdGhlIGxpc3QuIFRvIHN1cHBvcnQgdGhpcyBmZWF0dXJlLCBhbGwgaXRlbXMgaW4gdGhlIGxpc3QgbmVlZFxuICogdW5pcXVlIElEcy4gSWYgYW4gaXRlbSBkb2VzIG5vdCBoYXZlIGFuIElELCBiYXNpYy1saXN0LWJveCB3aWxsIGF1dG9tYXRpY2FsbHlcbiAqIGFzc2lnbiBhIGRlZmF1bHQgSUQuXG4gKlxuICogVGhlIGtleWJvYXJkIGludGVyYWN0aW9uIG1vZGVsIGdlbmVyYWxseSBmb2xsb3dzIHRoYXQgb2YgTWljcm9zb2Z0IFdpbmRvd3MnXG4gKiBsaXN0IGJveGVzIGluc3RlYWQgb2YgdGhvc2UgaW4gT1MgWDpcbiAqXG4gKiAqIFRoZSBQYWdlIFVwL0Rvd24gYW5kIEhvbWUvRW5kIGtleXMgYWN0dWFsbHkgbW92ZSB0aGUgc2VsZWN0aW9uLCByYXRoZXIgdGhhblxuICogICBqdXN0IHNjcm9sbGluZyB0aGUgbGlzdC4gVGhlIGZvcm1lciBiZWhhdmlvciBzZWVtcyBtb3JlIGdlbmVyYWxseSB1c2VmdWxcbiAqICAgZm9yIGtleWJvYXJkIHVzZXJzLlxuICpcbiAqICogUHJlc3NpbmcgUGFnZSBVcC9Eb3duIHdpbGwgbW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSB0b3Btb3N0L2JvdHRvbW1vc3RcbiAqICAgdmlzaWJsZSBpdGVtIGlmIHRoZSBzZWxlY3Rpb24gaXMgbm90IGFscmVhZHkgdGhlcmUuIFRoZXJlYWZ0ZXIsIHRoZSBrZXlcbiAqICAgd2lsbCBtb3ZlIHRoZSBzZWxlY3Rpb24gdXAvZG93biBieSBhIHBhZ2UsIGFuZCAocGVyIHRoZSBhYm92ZSBwb2ludCkgbWFrZVxuICogICB0aGUgc2VsZWN0ZWQgaXRlbSB2aXNpYmxlLlxuICpcbiAqIFByb2dyYW1tYXRpY2FsbHkgc2VsZWN0aW5nIGFuIGl0ZW0gKGJ5IHNldHRpbmcgdGhlIHNlbGVjdGVkIHByb3BlcnR5KSBzY3JvbGxzXG4gKiB0aGUgaXRlbSBpbnRvIHZpZXcuXG4gKlxuICogVGhlIHVzZXIgY2FuIGFsc28gc2VsZWN0IGFuIGl0ZW0gYnkgdHlwaW5nIHRoZSBiZWdpbm5pbmcgb2YgYW4gaXRlbSdzIHRleHQuXG4gKlxuICogQGV4dGVuZHMgRWxlbWVudEJhc2VcbiAqIEBtaXhlcyBDbGlja1NlbGVjdGlvbk1peGluXG4gKiBAbWl4ZXMgQ29udGVudEl0ZW1zTWl4aW5cbiAqIEBtaXhlcyBEaXJlY3Rpb25TZWxlY3Rpb25NaXhpblxuICogQG1peGVzIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW5cbiAqIEBtaXhlcyBHZW5lcmljTWl4aW5cbiAqIEBtaXhlcyBLZXlib2FyZE1peGluXG4gKiBAbWl4ZXMgS2V5Ym9hcmREaXJlY3Rpb25NaXhpblxuICogQG1peGVzIEtleWJvYXJkUGFnZWRTZWxlY3Rpb25NaXhpblxuICogQG1peGVzIEtleWJvYXJkUHJlZml4U2VsZWN0aW9uTWl4aW5cbiAqIEBtaXhpcyBTZWxlY3RlZEl0ZW1UZXh0VmFsdWVNaXhpblxuICogQG1peGVzIFNlbGVjdGlvbkFyaWFBY3RpdmVNaXhpblxuICogQG1peGVzIFNlbGVjdGlvbkhpZ2hsaWdodE1peGluXG4gKiBAbWl4ZXMgU2VsZWN0aW9uSW5WaWV3TWl4aW5cbiAqIEBtaXhlcyBTaW5nbGVTZWxlY3Rpb25NaXhpblxuICovXG5jbGFzcyBMaXN0Qm94IGV4dGVuZHMgRWxlbWVudEJhc2UuY29tcG9zZShcbiAgQ2xpY2tTZWxlY3Rpb25NaXhpbixcbiAgQ29udGVudEl0ZW1zTWl4aW4sXG4gIERpcmVjdGlvblNlbGVjdGlvbk1peGluLFxuICBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluLFxuICBHZW5lcmljTWl4aW4sXG4gIEtleWJvYXJkTWl4aW4sXG4gIEtleWJvYXJkRGlyZWN0aW9uTWl4aW4sXG4gIEtleWJvYXJkUGFnZWRTZWxlY3Rpb25NaXhpbixcbiAgS2V5Ym9hcmRQcmVmaXhTZWxlY3Rpb25NaXhpbixcbiAgU2VsZWN0ZWRJdGVtVGV4dFZhbHVlTWl4aW4sXG4gIFNlbGVjdGlvbkFyaWFBY3RpdmVNaXhpbixcbiAgU2VsZWN0aW9uSGlnaGxpZ2h0TWl4aW4sXG4gIFNlbGVjdGlvbkluVmlld01peGluLFxuICBTaW5nbGVTZWxlY3Rpb25NaXhpblxuKSB7XG5cbiAgZ2V0IFtzeW1ib2xzLmRlZmF1bHRzXSgpIHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHN1cGVyW3N5bWJvbHMuZGVmYXVsdHNdIHx8IHt9O1xuICAgIGRlZmF1bHRzLm5hdmlnYXRpb25BeGlzID0gJ3ZlcnRpY2FsJztcbiAgICByZXR1cm4gZGVmYXVsdHM7XG4gIH1cblxuICBnZXQgc2Nyb2xsVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLiQuaXRlbXNDb250YWluZXI7XG4gIH1cblxuICBnZXQgW3N5bWJvbHMudGVtcGxhdGVdKCkge1xuICAgIGNvbnN0IGJhc2VUZW1wbGF0ZSA9IHN1cGVyW3N5bWJvbHMudGVtcGxhdGVdIHx8ICcnO1xuICAgIHJldHVybiBgXG4gICAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICBbdGFyZ2V0PVwiY2hpbGRcIl0ge1xuICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIC13ZWJraXQtZmxleDogMTtcbiAgICAgICAgZmxleDogMTtcbiAgICAgIH1cblxuICAgICAgI2l0ZW1zQ29udGFpbmVyIHtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAxO1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XG4gICAgICAgIG92ZXJmbG93LXk6IHNjcm9sbDsgLyogZm9yIG1vbWVudHVtIHNjcm9sbGluZyAqL1xuICAgICAgfVxuXG4gICAgICAvKiBHZW5lcmljTWl4aW4gYXBwZWFyYW5jZSAqL1xuICAgICAgOmhvc3QoW2dlbmVyaWM9XCJcIl0pIHtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgZ3JheTtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgY3Vyc29yOiBkZWZhdWx0O1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZ2VuZXJpYz1cIlwiXSkgI2l0ZW1zQ29udGFpbmVyIDo6c2xvdHRlZCgqKSB7XG4gICAgICAgIGN1cnNvcjogZGVmYXVsdDtcbiAgICAgICAgcGFkZGluZzogMC4yNWVtO1xuICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgfVxuICAgICAgPC9zdHlsZT5cblxuICAgICAgPGRpdiBpZD1cIml0ZW1zQ29udGFpbmVyXCIgcm9sZT1cIm5vbmVcIj5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgICAgPC9kaXY+XG4gICAgICAke2Jhc2VUZW1wbGF0ZX1cbiAgICBgO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gdGhlIGxpc3QncyB2YWx1ZSBwcm9wZXJ0eSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgTGlzdEJveFxuICAgKiBAZXZlbnQgdmFsdWUtY2hhbmdlZFxuICAgKi9cbn1cblxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2Jhc2ljLWxpc3QtYm94JywgTGlzdEJveCk7XG5leHBvcnQgZGVmYXVsdCBMaXN0Qm94O1xuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyB0cmFuc3BpbGVkIHRvIGNyZWF0ZSBhbiBFUzUtY29tcGF0aWJsZSBkaXN0cmlidXRpb24gaW4gd2hpY2hcbiAqIHRoZSBwYWNrYWdlJ3MgbWFpbiBmZWF0dXJlKHMpIGFyZSBhdmFpbGFibGUgdmlhIHRoZSB3aW5kb3cuQmFzaWMgZ2xvYmFsLlxuICogSWYgeW91J3JlIGFscmVhZHkgdXNpbmcgRVM2IHlvdXJzZWxmLCBpZ25vcmUgdGhpcyBmaWxlLCBhbmQgaW5zdGVhZCBpbXBvcnRcbiAqIHRoZSBzb3VyY2UgZmlsZShzKSB5b3Ugd2FudCBmcm9tIHRoZSBzcmMgZm9sZGVyLlxuICovXG5cbmltcG9ydCBNb2RlcyBmcm9tICcuL3NyYy9Nb2Rlcyc7XG5cbndpbmRvdy5CYXNpYyA9IHdpbmRvdy5CYXNpYyB8fCB7fTtcbndpbmRvdy5CYXNpYy5Nb2RlcyA9IE1vZGVzO1xuIiwiaW1wb3J0IEVsZW1lbnRCYXNlIGZyb20gJy4uLy4uL2Jhc2ljLWVsZW1lbnQtYmFzZS9zcmMvRWxlbWVudEJhc2UnO1xuaW1wb3J0IERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbic7XG5pbXBvcnQgQ29udGVudEl0ZW1zTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQ29udGVudEl0ZW1zTWl4aW4nO1xuaW1wb3J0IFNpbmdsZVNlbGVjdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NpbmdsZVNlbGVjdGlvbk1peGluJztcbmltcG9ydCBzeW1ib2xzIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL3N5bWJvbHMnO1xuXG5jb25zdCBiYXNlID0gRWxlbWVudEJhc2UuY29tcG9zZShcbiAgQ29udGVudEl0ZW1zTWl4aW4sXG4gIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4sXG4gIFNpbmdsZVNlbGVjdGlvbk1peGluXG4pO1xuXG5cbi8qKlxuICogU2hvd3MgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudCBhdCBhIHRpbWUuIFRoaXMgY2FuIGJlIHVzZWZ1bCwgZm9yIGV4YW1wbGUsXG4gKiBpZiBhIGdpdmVuIFVJIGVsZW1lbnQgaGFzIG11bHRpcGxlIG1vZGVzIHRoYXQgcHJlc2VudCBzdWJzdGFudGlhbGx5IGRpZmZlcmVudFxuICogZWxlbWVudHMuXG4gKlxuICogVGhlIHRyYW5zaXRpb24gYmV0d2VlbiBjaGlsZCBlbGVtZW50cyBpcyBpbnN0YW50ZW5vdXMuIElmIHlvdSdkIGxpa2UgdGhlXG4gKiB0cmFuc2l0aW9uIHRvIGJlIGFjY29tcGFuaWVkIGJ5IHZpc2libGUgYW5pbWF0ZWQgZWZmZWN0cywgc2VlXG4gKiBbYmFzaWMtYW5pbWF0aW9uLXN0YWdlXSguLi9iYXNpYy1hbmltYXRpb24tc3RhZ2UpLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGRvZXNuJ3QgcHJvdmlkZSBhbnkgVUkgZm9yIGNoYW5naW5nIHdoaWNoIG1vZGUgaXMgc2hvd24uXG4gKlxuICogQGV4dGVuZHMgRWxlbWVudEJhc2VcbiAqIEBtaXhlcyBDb250ZW50SXRlbXNNaXhpblxuICogQG1peGVzIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW5cbiAqIEBtaXhlcyBTaW5nbGVTZWxlY3Rpb25NaXhpblxuICovXG5jbGFzcyBNb2RlcyBleHRlbmRzIGJhc2Uge1xuXG4gIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgY29uc3QgZGVmYXVsdHMgPSBzdXBlcltzeW1ib2xzLmRlZmF1bHRzXSB8fCB7fTtcbiAgICBkZWZhdWx0cy5zZWxlY3Rpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9XG5cbiAgW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCkge1xuICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1TZWxlY3RlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIHNlbGVjdGVkKTsgfVxuICAgIGl0ZW0uc3R5bGUuZGlzcGxheSA9IHNlbGVjdGVkID8gJycgOiAnbm9uZSc7XG4gICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgIXNlbGVjdGVkKTtcbiAgfVxuXG4gIGdldCBbc3ltYm9scy50ZW1wbGF0ZV0oKSB7XG4gICAgcmV0dXJuIGA8c2xvdD48L3Nsb3Q+YDtcbiAgfVxuXG59XG5cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdiYXNpYy1tb2RlcycsIE1vZGVzKTtcbmV4cG9ydCBkZWZhdWx0IE1vZGVzO1xuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyB0cmFuc3BpbGVkIHRvIGNyZWF0ZSBhbiBFUzUtY29tcGF0aWJsZSBkaXN0cmlidXRpb24gaW4gd2hpY2hcbiAqIHRoZSBwYWNrYWdlJ3MgbWFpbiBmZWF0dXJlKHMpIGFyZSBhdmFpbGFibGUgdmlhIHRoZSB3aW5kb3cuQmFzaWMgZ2xvYmFsLlxuICogSWYgeW91J3JlIGFscmVhZHkgdXNpbmcgRVM2IHlvdXJzZWxmLCBpZ25vcmUgdGhpcyBmaWxlLCBhbmQgaW5zdGVhZCBpbXBvcnRcbiAqIHRoZSBzb3VyY2UgZmlsZShzKSB5b3Ugd2FudCBmcm9tIHRoZSBzcmMgZm9sZGVyLlxuICovXG5cbmltcG9ydCBTbGlkZXNob3dXaXRoQ29udHJvbHMgZnJvbSAnLi9zcmMvU2xpZGVzaG93V2l0aENvbnRyb2xzJztcblxud2luZG93LkJhc2ljID0gd2luZG93LkJhc2ljIHx8IHt9O1xud2luZG93LkJhc2ljLlNsaWRlc2hvd1dpdGhDb250cm9scyA9IFNsaWRlc2hvd1dpdGhDb250cm9scztcbiIsImltcG9ydCBTbGlkZXNob3cgZnJvbSAnLi4vLi4vYmFzaWMtc2xpZGVzaG93L3NyYy9TbGlkZXNob3cnO1xuaW1wb3J0IFBsYXlDb250cm9sc01peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1BsYXlDb250cm9sc01peGluJztcblxuLyoqXG4gKiBBbiBleHRlbnNpb24gb2ZcbiAqIFtiYXNpYy1zbGlkZXNob3ddKC4uL2Jhc2ljLXNsaWRlc2hvdykgdGhhdCBhZGRzIHBsYXkgY29udHJvbHNcbiAqIHZpYSBbUGxheUNvbnRyb2xzTWl4aW5dKC4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvZG9jcy9QbGF5Q29udHJvbHNNaXhpbi5tZCkuXG4gKlxuICogW0xpdmUgZGVtb10oaHR0cDovL2Jhc2ljd2ViY29tcG9uZW50cy5vcmcvYmFzaWMtd2ViLWNvbXBvbmVudHMvcGFja2FnZXMvYmFzaWMtc2xpZGVzaG93LXdpdGgtY29udHJvbHMvKVxuICpcbiAqIEBleHRlbmRzIFNsaWRlc2hvd1xuICogQG1peGVzIFBsYXlDb250cm9sc01peGluXG4gKi9cbmNsYXNzIFNsaWRlc2hvd1dpdGhDb250cm9scyBleHRlbmRzIFBsYXlDb250cm9sc01peGluKFNsaWRlc2hvdykge31cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnYmFzaWMtc2xpZGVzaG93LXdpdGgtY29udHJvbHMnLCBTbGlkZXNob3dXaXRoQ29udHJvbHMpO1xuXG5leHBvcnQgZGVmYXVsdCBTbGlkZXNob3dXaXRoQ29udHJvbHM7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHRyYW5zcGlsZWQgdG8gY3JlYXRlIGFuIEVTNS1jb21wYXRpYmxlIGRpc3RyaWJ1dGlvbiBpbiB3aGljaFxuICogdGhlIHBhY2thZ2UncyBtYWluIGZlYXR1cmUocykgYXJlIGF2YWlsYWJsZSB2aWEgdGhlIHdpbmRvdy5CYXNpYyBnbG9iYWwuXG4gKiBJZiB5b3UncmUgYWxyZWFkeSB1c2luZyBFUzYgeW91cnNlbGYsIGlnbm9yZSB0aGlzIGZpbGUsIGFuZCBpbnN0ZWFkIGltcG9ydFxuICogdGhlIHNvdXJjZSBmaWxlKHMpIHlvdSB3YW50IGZyb20gdGhlIHNyYyBmb2xkZXIuXG4gKi9cblxuaW1wb3J0IFNsaWRlc2hvdyBmcm9tICcuL3NyYy9TbGlkZXNob3cnO1xuXG53aW5kb3cuQmFzaWMgPSB3aW5kb3cuQmFzaWMgfHwge307XG53aW5kb3cuQmFzaWMuU2xpZGVzaG93ID0gU2xpZGVzaG93O1xuIiwiaW1wb3J0IEVsZW1lbnRCYXNlIGZyb20gJy4uLy4uL2Jhc2ljLWVsZW1lbnQtYmFzZS9zcmMvRWxlbWVudEJhc2UnO1xuaW1wb3J0IENvbnRlbnRJdGVtc01peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0NvbnRlbnRJdGVtc01peGluJztcbmltcG9ydCBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0Rpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4nO1xuaW1wb3J0IEZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9GcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IFNlbGVjdGlvbkFuaW1hdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NlbGVjdGlvbkFuaW1hdGlvbk1peGluJztcbmltcG9ydCBTZWxlY3Rpb25BcmlhQWN0aXZlTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluJztcbmltcG9ydCBTaW5nbGVTZWxlY3Rpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TaW5nbGVTZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zeW1ib2xzJztcbmltcG9ydCBUaW1lclNlbGVjdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1RpbWVyU2VsZWN0aW9uTWl4aW4nO1xuXG5cbmNvbnN0IGJhc2UgPSBFbGVtZW50QmFzZS5jb21wb3NlKFxuICBDb250ZW50SXRlbXNNaXhpbixcbiAgRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpbixcbiAgRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluLFxuICBTZWxlY3Rpb25BbmltYXRpb25NaXhpbixcbiAgU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluLFxuICBTaW5nbGVTZWxlY3Rpb25NaXhpbixcbiAgVGltZXJTZWxlY3Rpb25NaXhpblxuKTtcblxuXG4vKipcbiAqIFNsaWRlc2hvdyB3aXRoIGFuaW1hdGVkIHRyYW5zaXRpb25zLlxuICpcbiAqIFtMaXZlIGRlbW9dKGh0dHA6Ly9iYXNpY3dlYmNvbXBvbmVudHMub3JnL2Jhc2ljLXdlYi1jb21wb25lbnRzL3BhY2thZ2VzL2Jhc2ljLXNsaWRlc2hvdy8pXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgc2xpZGVzaG93IHdpbGwgaW1tZWRpYXRlbHkgYmVnaW4gcGxheWluZyB3aGVuIGl0IGlzIGNvbm5lY3RlZFxuICogdG8gdGhlIGRvY3VtZW50LCBhZHZhbmNlIGV2ZXJ5IDMwMDAgbXMgKDMgc2Vjb25kcyksIGFuZCB1c2UgYSBzaW1wbGVcbiAqIGNyb3NzZmFkZSBlZmZlY3QuIEZvciBhIHZhcmlhdGlvbiB3aXRoIHBsYXkgY29udHJvbHMsIHNlZVxuICogW2Jhc2ljLXNsaWRlc2hvdy13aXRoLWNvbnRyb2xzXSguLi9iYXNpYy1zbGlkZXNob3ctd2l0aC1jb250cm9scykuXG4gKlxuICogVGhpcyBjb21wb25lbnQgY2FuIGJlIHVzZWQgb24gaXRzIG93bi4gVG8gaW5jb3Jwb3JhdGUgc2xpZGVzaG93IGJlaGF2aW9yIGludG9cbiAqIGEgY29tcG9uZW50IG9mIHlvdXIgb3duLCBhcHBseSB0aGVcbiAqIFtUaW1lclNlbGVjdGlvbk1peGluXSguLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL2RvY3MvVGltZXJTZWxlY3Rpb25NaXhpbi5tZCkuXG4gKlxuICogQGV4dGVuZHMgRWxlbWVudEJhc2VcbiAqIEBtaXhlcyBDb250ZW50SXRlbXNNaXhpblxuICogQG1peGVzIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW5cbiAqIEBtaXhlcyBGcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW5cbiAqIEBtaXhlcyBTZWxlY3Rpb25BbmltYXRpb25NaXhpblxuICogQG1peGVzIFNlbGVjdGlvbkFyaWFBY3RpdmVNaXhpblxuICogQG1peGVzIFNpbmdsZVNlbGVjdGlvbk1peGluXG4gKiBAbWl4ZXMgVGltZXJTZWxlY3Rpb25NaXhpblxuICovXG5jbGFzcyBTbGlkZXNob3cgZXh0ZW5kcyBiYXNlIHtcblxuICBnZXQgW3N5bWJvbHMuZGVmYXVsdHNdKCkge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gc3VwZXJbc3ltYm9scy5kZWZhdWx0c10gfHwge307XG4gICAgZGVmYXVsdHMucGxheWluZyA9IHRydWU7XG4gICAgZGVmYXVsdHMuc2VsZWN0aW9uQW5pbWF0aW9uRHVyYXRpb24gPSA1MDA7XG4gICAgZGVmYXVsdHMuc2VsZWN0aW9uQW5pbWF0aW9uRWZmZWN0ID0gJ2Nyb3NzZmFkZSc7XG4gICAgZGVmYXVsdHMuc2VsZWN0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIGRlZmF1bHRzLnNlbGVjdGlvblRpbWVyRHVyYXRpb24gPSAzMDAwO1xuICAgIGRlZmF1bHRzLnNlbGVjdGlvbldyYXBzID0gdHJ1ZTtcbiAgICByZXR1cm4gZGVmYXVsdHM7XG4gIH1cblxuICBnZXQgW3N5bWJvbHMudGVtcGxhdGVdKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICAjY29udGFpbmVyIDo6c2xvdHRlZCgqKSB7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG5cbiAgICAgIDxkaXYgaWQ9XCJjb250YWluZXJcIiByb2xlPVwibm9uZVwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICB9XG5cbn1cblxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2Jhc2ljLXNsaWRlc2hvdycsIFNsaWRlc2hvdyk7XG5leHBvcnQgZGVmYXVsdCBTbGlkZXNob3c7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHRyYW5zcGlsZWQgdG8gY3JlYXRlIGFuIEVTNS1jb21wYXRpYmxlIGRpc3RyaWJ1dGlvbiBpbiB3aGljaFxuICogdGhlIHBhY2thZ2UncyBtYWluIGZlYXR1cmUocykgYXJlIGF2YWlsYWJsZSB2aWEgdGhlIHdpbmRvdy5CYXNpYyBnbG9iYWwuXG4gKiBJZiB5b3UncmUgYWxyZWFkeSB1c2luZyBFUzYgeW91cnNlbGYsIGlnbm9yZSB0aGlzIGZpbGUsIGFuZCBpbnN0ZWFkIGltcG9ydFxuICogdGhlIHNvdXJjZSBmaWxlKHMpIHlvdSB3YW50IGZyb20gdGhlIHNyYyBmb2xkZXIuXG4gKi9cblxuaW1wb3J0IFNsaWRpbmdDYXJvdXNlbCBmcm9tICcuL3NyYy9TbGlkaW5nQ2Fyb3VzZWwnO1xuXG53aW5kb3cuQmFzaWMgPSB3aW5kb3cuQmFzaWMgfHwge307XG53aW5kb3cuQmFzaWMuU2xpZGluZ0Nhcm91c2VsID0gU2xpZGluZ0Nhcm91c2VsO1xuIiwiaW1wb3J0IEhvcml6b250YWxOYXZpZ2F0aW9uTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvSG9yaXpvbnRhbE5hdmlnYXRpb25NaXhpbic7XG5pbXBvcnQgU2xpZGluZ1ZpZXdwb3J0IGZyb20gJy4uLy4uL2Jhc2ljLXNsaWRpbmctdmlld3BvcnQvc3JjL1NsaWRpbmdWaWV3cG9ydCc7XG5cblxuLyoqXG4gKiBMZXRzIHRoZSB1c2VyIG5hdmlnYXRlIGxhdGVyYWxseSB0aHJvdWdoIGEgc2VxdWVuY2Ugb2YgY2hpbGQgZWxlbWVudHNcbiAqIHVzaW5nIGEgc2ltcGxlIENTUyB0cmFuc2l0aW9uIGVmZmVjdCB0byBzaG93IGhvcml6b250YWwgbW92ZW1lbnQuXG4gKlxuICogW0xpdmUgZGVtb10oaHR0cDovL2Jhc2ljd2ViY29tcG9uZW50cy5vcmcvYmFzaWMtd2ViLWNvbXBvbmVudHMvcGFja2FnZXMvYmFzaWMtc2xpZGluZy1jYXJvdXNlbC8pXG4gKlxuICogYmFzaWMtc2xpZGluZy1jYXJvdXNlbCBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgY2Fyb3VzZWwgdXNlciBpbnRlcmZhY2VcbiAqIHBhdHRlcm4sIGNvbW1vbmx5IHVzZWQgZm9yIG5hdmlnYXRpbmcgYmV0d2VlbiBpbWFnZXMsIHBhZ2VzLCBhbmQgb3RoZXJcbiAqIGVsZW1lbnRzLiBUaGlzIHBhdHRlcm4gcHJlc2VudHMgdGhlIHVzZXIgd2l0aCBhIGxpbmVhciBzZXF1ZW5jZSBvZiBlbGVtZW50cyxcbiAqIG9ubHkgb25lIG9mIHdoaWNoIGlzIHNob3duIGF0IGEgdGltZS4gVGhlIHVzZXIgY2FuIG5hdmlnYXRlIHRvIHRoZVxuICogbmV4dC9wcmV2aW91cyBlbGVtZW50IHdpdGggYSB2YXJpZXR5IG9mIGlucHV0IG1ldGhvZHMuXG4gKlxuICogYmFzaWMtc2xpZGluZy1jYXJvdXNlbCBpcyBhIHNpbXBsZXIgdmFyaWF0aW9uIG9mIHRoZSBtb3JlIHNvcGhpc3RpY2F0ZWRcbiAqIFtiYXNpYy1jYXJvdXNlbF0oLi4vYmFzaWMtY2Fyb3VzZWwpIGNvbXBvbmVudC4gVGhlIGxhdHRlciBpbmNsdWRlcyBzdXBwb3J0XG4gKiBmb3Igd3JhcHBpbmcgKGdvaW5nIGZvcndhcmQgZnJvbSB0aGUgbGFzdCBpdGVtIHRvIHRoZSBmaXJzdCwgYW5kIHZpY2UgdmVyc2EpLFxuICogYW5kIG1vcmUgY29tcGxleCB2aXN1YWwgdHJhbnNpdGlvbnMuIFRob3NlIHRyYW5zaXRpb25zIGVudGFpbCB1c2Ugb2YgdGhlIFdlYlxuICogQW5pbWF0aW9uIEFQSSwgd2hpY2ggcmVxdWlyZXMgYSBwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gSGVuY2UsIHRoZVxuICogc2ltcGxlciBiYXNpYy1zbGlkaW5nLWNhcm91c2VsIG1heSBiZSBhIG1vcmUgYXBwcm9wcmlhdGUgY2hvaWNlIGlmIGZhY3RvcnNcbiAqIHN1Y2ggYXMgZG93bmxvYWQgc2l6ZSBhcmUgY3JpdGljYWwuXG4gKlxuICogQmV5b25kIHRob3NlIGRpZmZlcmVuY2VzLCBiYXNpYy1zbGlkaW5nLWNhcm91c2VsIG9mZmVycyB0aGUgc2FtZSBBUEksIHVzYWdlXG4gKiByZWNvbW1lbmRhdGlvbnMsIGFuZCBzdXBwb3J0IGZvciBrZXlib2FyZC90b3VjaC9tb3VzZSBhbmQgYXNzaXN0aXZlIGRldmljZXMuXG4gKiBTZWUgdGhhdCBjb21wb25lbnQgZm9yIG1vcmUgZGV0YWlscyBvbiB1c2UuXG4gKlxuICogQGV4dGVuZHMgU2xpZGluZ1ZpZXdwb3J0XG4gKiBAbWl4ZXMgSG9yaXpvbnRhbE5hdmlnYXRpb25NaXhpblxuICovXG5jbGFzcyBTbGlkaW5nQ2Fyb3VzZWwgZXh0ZW5kcyBTbGlkaW5nVmlld3BvcnQuY29tcG9zZShcbiAgSG9yaXpvbnRhbE5hdmlnYXRpb25NaXhpblxuKSB7fVxuXG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnYmFzaWMtc2xpZGluZy1jYXJvdXNlbCcsIFNsaWRpbmdDYXJvdXNlbCk7XG5leHBvcnQgZGVmYXVsdCBTbGlkaW5nQ2Fyb3VzZWw7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHRyYW5zcGlsZWQgdG8gY3JlYXRlIGFuIEVTNS1jb21wYXRpYmxlIGRpc3RyaWJ1dGlvbiBpbiB3aGljaFxuICogdGhlIHBhY2thZ2UncyBtYWluIGZlYXR1cmUocykgYXJlIGF2YWlsYWJsZSB2aWEgdGhlIHdpbmRvdy5CYXNpYyBnbG9iYWwuXG4gKiBJZiB5b3UncmUgYWxyZWFkeSB1c2luZyBFUzYgeW91cnNlbGYsIGlnbm9yZSB0aGlzIGZpbGUsIGFuZCBpbnN0ZWFkIGltcG9ydFxuICogdGhlIHNvdXJjZSBmaWxlKHMpIHlvdSB3YW50IGZyb20gdGhlIHNyYyBmb2xkZXIuXG4gKi9cblxuaW1wb3J0IFNsaWRpbmdWaWV3cG9ydCBmcm9tICcuL3NyYy9TbGlkaW5nVmlld3BvcnQnO1xuXG53aW5kb3cuQmFzaWMgPSB3aW5kb3cuQmFzaWMgfHwge307XG53aW5kb3cuQmFzaWMuU2xpZGluZ1ZpZXdwb3J0ID0gU2xpZGluZ1ZpZXdwb3J0O1xuIiwiaW1wb3J0IENvbnRlbnRJdGVtc01peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0NvbnRlbnRJdGVtc01peGluJztcbmltcG9ydCBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0Rpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4nO1xuaW1wb3J0IEVsZW1lbnRCYXNlIGZyb20gJy4uLy4uL2Jhc2ljLWVsZW1lbnQtYmFzZS9zcmMvRWxlbWVudEJhc2UnO1xuaW1wb3J0IEZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9GcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4nO1xuaW1wb3J0IFNlbGVjdGlvbkFyaWFBY3RpdmVNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TZWxlY3Rpb25BcmlhQWN0aXZlTWl4aW4nO1xuaW1wb3J0IFNpbmdsZVNlbGVjdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL1NpbmdsZVNlbGVjdGlvbk1peGluJztcbmltcG9ydCBTcHJlYWRJdGVtcyBmcm9tICcuLi8uLi9iYXNpYy1zcHJlYWQtaXRlbXMvc3JjL1NwcmVhZEl0ZW1zJzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5pbXBvcnQgc3ltYm9scyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zeW1ib2xzJztcblxuXG5jb25zdCBiYXNlID0gRWxlbWVudEJhc2UuY29tcG9zZShcbiAgQ29udGVudEl0ZW1zTWl4aW4sXG4gIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4sXG4gIEZyYWN0aW9uYWxTZWxlY3Rpb25NaXhpbixcbiAgU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluLFxuICBTaW5nbGVTZWxlY3Rpb25NaXhpblxuKTtcblxuXG4vKipcbiAqIFByZXNlbnRzIGxpc3QgaXRlbXMgaW4gYSB2aWV3cG9ydCBzdWNoIHRoYXQgb25seSBhIHNpbmdsZSBpdGVtIGlzIHZpc2libGUgYXRcbiAqIGEgdGltZS5cbiAqXG4gKiBOYXZpZ2F0aW5nIGJldHdlZW4gaXRlbXMgd2lsbCBiZSByZXByZXNlbnRlZCB3aXRoIGEgaG9yaXpvbnRhbCB2aXN1YWxcbiAqIHNsaWRpbmcgZWZmZWN0LiBGb3IgbW9yZSBjb21wbGV4IHZpc3VhbCBlZmZlY3RzLCBzZWVcbiAqIFtiYXNpYy1hbmltYXRpb24tc3RhZ2VdKC4uL2Jhc2ljLWFuaW1hdGlvbi1zdGFnZSksIHdoaWNoIHRha2VzIGFkdmFudGFnZSBvZlxuICogdGhlIFdlYiBBbmltYXRpb25zIEFQSS5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBoYW5kbGVzIHRoZSByZW5kZXJpbmcgcmVzcG9uc2liaWxpdGllcyBmb3IgdGhlIGJhc2ljLWNhcm91c2VsXG4gKiBjb21wb25lbnQuXG4gKlxuICogVGhpcyBjb21wb25lbnQgY3VycmVudGx5IHJlcXVpcmVzIHRoYXQgeW91IGV4cGxpY2l0bHkgYXBwbHkgYSBzaXplIHRvIGl0LlxuICpcbiAqIEBleHRlbmRzIEVsZW1lbnRCYXNlXG4gKiBAbWl4ZXMgQ29udGVudEl0ZW1zTWl4aW5cbiAqIEBtaXhlcyBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluXG4gKiBAbWl4ZXMgRnJhY3Rpb25hbFNlbGVjdGlvbk1peGluXG4gKiBAbWl4ZXMgU2VsZWN0aW9uQXJpYUFjdGl2ZU1peGluXG4gKiBAbWl4ZXMgU2luZ2xlU2VsZWN0aW9uTWl4aW5cbiAqL1xuY2xhc3MgU2xpZGluZ1ZpZXdwb3J0IGV4dGVuZHMgYmFzZSB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzW3N5bWJvbHMuZHJhZ2dpbmddID0gZmFsc2U7XG4gIH1cblxuICBnZXQgW3N5bWJvbHMuZGVmYXVsdHNdKCkge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gc3VwZXJbc3ltYm9scy5kZWZhdWx0c10gfHwge307XG4gICAgZGVmYXVsdHMuc2VsZWN0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIHJldHVybiBkZWZhdWx0cztcbiAgfVxuXG4gIC8qXG4gICAqIER1cmluZyBkcmFncywgZG9uJ3Qgc2hvdyBDU1MgdHJhbnNpdGlvbnMuXG4gICAqL1xuICBnZXQgW3N5bWJvbHMuZHJhZ2dpbmddKCkge1xuICAgIHJldHVybiAhdGhpcy5zaG93VHJhbnNpdGlvbjtcbiAgfVxuICBzZXQgW3N5bWJvbHMuZHJhZ2dpbmddKHZhbHVlKSB7XG4gICAgaWYgKHN5bWJvbHMuZHJhZ2dpbmcgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXJbc3ltYm9scy5kcmFnZ2luZ10gPSB2YWx1ZTsgfVxuICAgIHRoaXMucmVmbGVjdENsYXNzKCdzaG93VHJhbnNpdGlvbicsICF2YWx1ZSk7XG4gIH1cblxuICBnZXQgc2VsZWN0ZWRGcmFjdGlvbigpIHtcbiAgICByZXR1cm4gc3VwZXIuc2VsZWN0ZWRGcmFjdGlvbjtcbiAgfVxuICBzZXQgc2VsZWN0ZWRGcmFjdGlvbih2YWx1ZSkge1xuICAgIGlmICgnc2VsZWN0ZWRGcmFjdGlvbicgaW4gYmFzZS5wcm90b3R5cGUpIHsgc3VwZXIuc2VsZWN0ZWRGcmFjdGlvbiA9IHZhbHVlOyB9XG4gICAgcmVuZGVyKHRoaXMpO1xuICB9XG5cbiAgZ2V0IHNlbGVjdGVkSXRlbSgpIHtcbiAgICByZXR1cm4gc3VwZXIuc2VsZWN0ZWRJdGVtO1xuICB9XG4gIHNldCBzZWxlY3RlZEl0ZW0oaXRlbSkge1xuICAgIGlmICgnc2VsZWN0ZWRJdGVtJyBpbiBiYXNlLnByb3RvdHlwZSkgeyBzdXBlci5zZWxlY3RlZEl0ZW0gPSBpdGVtOyB9XG4gICAgcmVuZGVyKHRoaXMpO1xuICB9XG5cbiAgZ2V0IFtzeW1ib2xzLnRlbXBsYXRlXSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICAjc2xpZGluZ0NvbnRhaW5lciB7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAvKlxuICAgICAgICAgU2V0IHdpZHRoIGZvciBJRS9FZGdlLiBJdCdzIG5vdCBjbGVhciB3aHkgdGhleSBuZWVkIHRoaXMsIGFuZCB0aGUgb3RoZXJcbiAgICAgICAgIGJyb3dzZXJzIGRvbid0LlxuICAgICAgICAgKi9cbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XG4gICAgICB9XG5cbiAgICAgIDpob3N0KC5zaG93VHJhbnNpdGlvbikgI3NsaWRpbmdDb250YWluZXIge1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQ7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0O1xuICAgICAgfVxuICAgICAgPC9zdHlsZT5cblxuICAgICAgPGJhc2ljLXNwcmVhZC1pdGVtcyBpZD1cInNsaWRpbmdDb250YWluZXJcIiByb2xlPVwibm9uZVwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICA8L2Jhc2ljLXNwcmVhZC1pdGVtcz5cbiAgICBgO1xuICB9XG5cbn1cblxuXG5cbmZ1bmN0aW9uIHJlbmRlcihlbGVtZW50KSB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJTZWxlY3Rpb24uYmluZChlbGVtZW50KSk7XG59XG5cbi8vIE5vdGU6IEluIHRoaXMgcm91dGluZSwgXCJ0aGlzXCIgaXMgYm91bmQgdG8gYW4gZWxlbWVudCBpbnN0YW5jZS5cbmZ1bmN0aW9uIHJlbmRlclNlbGVjdGlvbigpIHtcbiAgaWYgKCF0aGlzLnNlbGVjdGVkSXRlbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzZWxlY3Rpb24gPSBGcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4uaGVscGVycy5lbGVtZW50U2VsZWN0aW9uKHRoaXMpO1xuICBjb25zdCBpdGVtQ291bnQgPSB0aGlzLml0ZW1zID8gdGhpcy5pdGVtcy5sZW5ndGggOiAwO1xuICBjb25zdCBkYW1wZWQgPSBGcmFjdGlvbmFsU2VsZWN0aW9uTWl4aW4uaGVscGVycy5kYW1wZWRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpdGVtQ291bnQpO1xuICAvLyBVc2UgYSBwZXJjZW50YWdlIHNvIHRoZSB0cmFuc2Zvcm0gd2lsbCBzdGlsbCB3b3JrIGlmIHNjcmVlbiBzaXplIGNoYW5nZXNcbiAgLy8gKGUuZy4sIGlmIGRldmljZSBvcmllbnRhdGlvbiBjaGFuZ2VzKS5cbiAgY29uc3QgbGVmdCA9IC1kYW1wZWQgKiAxMDA7XG4gIGNvbnN0IHRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKCcgKyBsZWZ0ICsgJyUpJztcbiAgdGhpcy4kLnNsaWRpbmdDb250YWluZXIuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICB0aGlzLiQuc2xpZGluZ0NvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG59XG5cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdiYXNpYy1zbGlkaW5nLXZpZXdwb3J0JywgU2xpZGluZ1ZpZXdwb3J0KTtcbmV4cG9ydCBkZWZhdWx0IFNsaWRpbmdWaWV3cG9ydDtcbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgdHJhbnNwaWxlZCB0byBjcmVhdGUgYW4gRVM1LWNvbXBhdGlibGUgZGlzdHJpYnV0aW9uIGluIHdoaWNoXG4gKiB0aGUgcGFja2FnZSdzIG1haW4gZmVhdHVyZShzKSBhcmUgYXZhaWxhYmxlIHZpYSB0aGUgd2luZG93LkJhc2ljIGdsb2JhbC5cbiAqIElmIHlvdSdyZSBhbHJlYWR5IHVzaW5nIEVTNiB5b3Vyc2VsZiwgaWdub3JlIHRoaXMgZmlsZSwgYW5kIGluc3RlYWQgaW1wb3J0XG4gKiB0aGUgc291cmNlIGZpbGUocykgeW91IHdhbnQgZnJvbSB0aGUgc3JjIGZvbGRlci5cbiAqL1xuXG5pbXBvcnQgU3ByZWFkSXRlbXMgZnJvbSAnLi9zcmMvU3ByZWFkSXRlbXMnO1xuXG53aW5kb3cuQmFzaWMgPSB3aW5kb3cuQmFzaWMgfHwge307XG53aW5kb3cuQmFzaWMuU3ByZWFkSXRlbXMgPSBTcHJlYWRJdGVtcztcbiIsImltcG9ydCBFbGVtZW50QmFzZSBmcm9tICcuLi8uLi9iYXNpYy1lbGVtZW50LWJhc2Uvc3JjL0VsZW1lbnRCYXNlJztcbmltcG9ydCBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0Rpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4nO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc3ltYm9scyc7XG5cblxuLyoqXG4gKiBTcHJlYWRzIG91dCBhIHNldCBvZiBpdGVtcyBob3Jpem9udGFsbHkgc28gdGhleSB0YWtlIGVxdWFsIHNwYWNlLlxuICpcbiAqIFtMaXZlIGRlbW9dKGh0dHA6Ly9iYXNpY3dlYmNvbXBvbmVudHMub3JnL2Jhc2ljLXdlYi1jb21wb25lbnRzL3BhY2thZ2VzL2Jhc2ljLXNwcmVhZC1pdGVtcy8pXG4gKlxuICogVGhpcyBjb21wb25lbnQgaXMgdXNlZCwgZm9yIGV4YW1wbGUsIGJ5IHRoZSBiYXNpYy1zbGlkaW5nLXZpZXdwb3J0IGNvbXBvbmVudFxuICogdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gb2YgZGlmZmVyZW50IHNpemUgd2lsbCB0YWtlIHVwIHRoZSBzYW1lIGFtb3VudCBvZlxuICogaG9yaXpvbnRhbCBzcGFjZS5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBjdXJyZW50bHkgcmVxdWlyZXMgYW4gZXhwbGljaXQgc2l6ZSBieSBhcHBsaWVkIHRvIGl0LlxuICpcbiAqIEBleHRlbmRzIEVsZW1lbnRCYXNlXG4gKiBAbWl4ZXMgRGlzdHJpYnV0ZWRDaGlsZHJlbkNvbnRlbnRNaXhpblxuICovXG5jbGFzcyBTcHJlYWRJdGVtcyBleHRlbmRzIEVsZW1lbnRCYXNlLmNvbXBvc2UoXG4gIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW5cbikge1xuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykgeyBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpOyB9XG4gICAgLy8gSEFDS1xuICAgIHRoaXNbc3ltYm9scy5pdGVtc0NoYW5nZWRdKCk7XG4gIH1cblxuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuXG4gIC8vIFRPRE86IFNob3VsZCBhbHNvIGhhbmRsZSBjb250ZW50Q2hhbmdlZCgpLCBidXQgbmVlZCB0byByYXRpb25hbGl6ZSB3aXRoXG4gIC8vIGludm9jYXRpb24gb2YgW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSBpbiBjb25uZWN0ZWRDYWxsYmFjay5cbiAgW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpIHtcbiAgICBpZiAoc3VwZXJbc3ltYm9scy5pdGVtc0NoYW5nZWRdKSB7IHN1cGVyW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSgpOyB9XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGNvdW50ID0gaXRlbXMubGVuZ3RoO1xuICAgIHRoaXMuJC5zcHJlYWRDb250YWluZXIuc3R5bGUud2lkdGggPSAoY291bnQgKiAxMDApICsgJyUnO1xuICAgIGNvbnN0IGl0ZW1XaWR0aCA9ICgxMDAgLyBjb3VudCkgKyBcIiVcIjtcbiAgICBbXS5mb3JFYWNoLmNhbGwoaXRlbXMsIGl0ZW0gPT4ge1xuICAgICAgaXRlbS5zdHlsZS53aWR0aCA9IGl0ZW1XaWR0aDtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBbc3ltYm9scy50ZW1wbGF0ZV0oKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICB9XG5cbiAgICAgICNzcHJlYWRDb250YWluZXIge1xuICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICAjc3ByZWFkQ29udGFpbmVyIDo6c2xvdHRlZCgqKSB7XG4gICAgICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG4gICAgICAgIG9iamVjdC1maXQ6IHZhcigtLWJhc2ljLWl0ZW0tb2JqZWN0LWZpdCwgY29udGFpbik7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgLXdlYmtpdC11c2VyLWRyYWc6IG5vbmU7XG4gICAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICB9XG4gICAgICA8L3N0eWxlPlxuXG4gICAgICA8ZGl2IGlkPVwic3ByZWFkQ29udGFpbmVyXCIgcm9sZT1cIm5vbmVcIj5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgfVxuXG59XG5cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdiYXNpYy1zcHJlYWQtaXRlbXMnLCBTcHJlYWRJdGVtcyk7XG5leHBvcnQgZGVmYXVsdCBTcHJlYWRJdGVtcztcbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgdHJhbnNwaWxlZCB0byBjcmVhdGUgYW4gRVM1LWNvbXBhdGlibGUgZGlzdHJpYnV0aW9uIGluIHdoaWNoXG4gKiB0aGUgcGFja2FnZSdzIG1haW4gZmVhdHVyZShzKSBhcmUgYXZhaWxhYmxlIHZpYSB0aGUgd2luZG93LkJhc2ljIGdsb2JhbC5cbiAqIElmIHlvdSdyZSBhbHJlYWR5IHVzaW5nIEVTNiB5b3Vyc2VsZiwgaWdub3JlIHRoaXMgZmlsZSwgYW5kIGluc3RlYWQgaW1wb3J0XG4gKiB0aGUgc291cmNlIGZpbGUocykgeW91IHdhbnQgZnJvbSB0aGUgc3JjIGZvbGRlci5cbiAqL1xuXG5pbXBvcnQgVGFiU3RyaXAgZnJvbSAnLi9zcmMvVGFiU3RyaXAnO1xuaW1wb3J0IFRhYlN0cmlwTWl4aW4gZnJvbSAnLi9zcmMvVGFiU3RyaXBNaXhpbic7XG5cbndpbmRvdy5CYXNpYyA9IHdpbmRvdy5CYXNpYyB8fCB7fTtcbndpbmRvdy5CYXNpYy5UYWJTdHJpcCA9IFRhYlN0cmlwO1xud2luZG93LkJhc2ljLlRhYlN0cmlwTWl4aW4gPSBUYWJTdHJpcE1peGluO1xuIiwiLy8gaW1wb3J0IENsaWNrU2VsZWN0aW9uTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQ2xpY2tTZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgQ29udGVudEl0ZW1zTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvQ29udGVudEl0ZW1zTWl4aW4nO1xuaW1wb3J0IGNyZWF0ZVN5bWJvbCBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9jcmVhdGVTeW1ib2wnO1xuaW1wb3J0IERpcmVjdGlvblNlbGVjdGlvbk1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0RpcmVjdGlvblNlbGVjdGlvbk1peGluJztcbmltcG9ydCBEaXN0cmlidXRlZENoaWxkcmVuQ29udGVudE1peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0Rpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4nO1xuaW1wb3J0IEVsZW1lbnRCYXNlIGZyb20gJy4uLy4uL2Jhc2ljLWVsZW1lbnQtYmFzZS9zcmMvRWxlbWVudEJhc2UnO1xuaW1wb3J0IEdlbmVyaWNNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9HZW5lcmljTWl4aW4nO1xuaW1wb3J0IEtleWJvYXJkRGlyZWN0aW9uTWl4aW4gZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvS2V5Ym9hcmREaXJlY3Rpb25NaXhpbic7XG5pbXBvcnQgS2V5Ym9hcmRNaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9LZXlib2FyZE1peGluJztcbmltcG9ydCByZW5kZXJBcnJheUFzRWxlbWVudHMgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvcmVuZGVyQXJyYXlBc0VsZW1lbnRzJztcbmltcG9ydCBTaW5nbGVTZWxlY3Rpb25NaXhpbiBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9TaW5nbGVTZWxlY3Rpb25NaXhpbic7XG5pbXBvcnQgc3ltYm9scyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zeW1ib2xzJztcbmltcG9ydCB0b2dnbGVDbGFzcyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy90b2dnbGVDbGFzcyc7XG5cblxuLy8gU3ltYm9scyBmb3IgcHJpdmF0ZSBkYXRhIG1lbWJlcnMgb24gYW4gZWxlbWVudC5cbmNvbnN0IHBhbmVsc1N5bWJvbCA9IGNyZWF0ZVN5bWJvbCgncGFuZWxzJyk7XG5jb25zdCBzcHJlYWRUYWJzU3ltYm9sID0gY3JlYXRlU3ltYm9sKCdzcHJlYWRUYWJzJyk7XG5jb25zdCB0YWJQb3NpdGlvblN5bWJvbCA9IGNyZWF0ZVN5bWJvbCgndGFiUG9zaXRpb24nKTtcblxuXG4vKipcbiAqIEEgc2V0IG9mIHBhZ2VzIHdpdGggYSB0YWIgc3RyaXAgZ292ZXJuaW5nIHdoaWNoIHBhZ2UgaXMgc2hvd24uXG4gKlxuICogVGhpcyBzdG9jayBjb21iaW5hdGlvbiBhcHBsaWVzIHRoZSBbVGFiU3RyaXBNaXhpbl0oLi4vYmFzaWMtdGFiLXN0cmlwLykgdG8gYVxuICogW2Jhc2ljLW1vZGVzXSguLi9iYXNpYy1tb2Rlcy8pIGVsZW1lbnQuIElmIHlvdSdkIGxpa2UgdG8gY3JlYXRlIHNvbWV0aGluZ1xuICogbW9yZSBjb21wbGV4IHRoYW4gdGhpcyBhcnJhbmdlbWVudCwgeW91IGNhbiB1c2UgZWl0aGVyIG9mIHRob3NlIGVsZW1lbnRzIG9uXG4gKiBpdHMgb3duLlxuICpcbiAqIFNpbmNlIHRoaXMgY29tcG9uZW50IHVzZXMgYFRhYlN0cmlwTWl4aW5gLCBpdCBvYnRhaW5zIHRoZSBuYW1lcyBvZiB0aGVcbiAqIGluZGl2aWR1YWwgdGFicyBmcm9tIGEgY2hpbGQncyBgYXJpYS1sYWJlbGAgcHJvcGVydHkuIEV4YW1wbGU6XG4gKlxuICogICAgIDxiYXNpYy10YWJzPlxuICogICAgICAgPGRpdiBhcmlhLWxhYmVsPVwiT25lXCI+UGFnZSBvbmU8L2Rpdj5cbiAqICAgICAgIDxkaXYgYXJpYS1sYWJlbD1cIlR3b1wiPlBhZ2UgdHdvPC9kaXY+XG4gKiAgICAgICA8ZGl2IGFyaWEtbGFiZWw9XCJUaHJlZVwiPlBhZ2UgdGhyZWU8L2Rpdj5cbiAqICAgICA8L2Jhc2ljLXRhYnM+XG4gKlxuICogQGV4dGVuZHMgRWxlbWVudEJhc2VcbiAqIEBtaXhlcyBDbGlja1NlbGVjdGlvbk1peGluXG4gKiBAbWl4ZXMgQ29udGVudEl0ZW1zTWl4aW5cbiAqIEBtaXhlcyBEaXJlY3Rpb25TZWxlY3Rpb25NaXhpblxuICogQG1peGVzIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW5cbiAqIEBtaXhlcyBHZW5lcmljTWl4aW5cbiAqIEBtaXhlcyBLZXlib2FyZE1peGluXG4gKiBAbWl4ZXMgS2V5Ym9hcmREaXJlY3Rpb25NaXhpblxuICogQG1peGVzIFNpbmdsZVNlbGVjdGlvbk1peGluXG4gKi9cbmNsYXNzIFRhYlN0cmlwIGV4dGVuZHMgRWxlbWVudEJhc2UuY29tcG9zZShcbiAgLy8gQ2xpY2tTZWxlY3Rpb25NaXhpbixcbiAgRGlyZWN0aW9uU2VsZWN0aW9uTWl4aW4sXG4gIEdlbmVyaWNNaXhpbixcbiAgS2V5Ym9hcmRNaXhpbixcbiAgS2V5Ym9hcmREaXJlY3Rpb25NaXhpbixcbiAgQ29udGVudEl0ZW1zTWl4aW4sXG4gIERpc3RyaWJ1dGVkQ2hpbGRyZW5Db250ZW50TWl4aW4sXG4gIFNpbmdsZVNlbGVjdGlvbk1peGluXG4pIHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLy8gSGFuZGxlIGNsaWNrcy9FbnRlciBvbiB0YWIgYnV0dG9ucy5cbiAgICAvLyBUT0RPOiBSYXRpb25hbGl6ZSB3aXRoIENsaWNrU2VsZWN0aW9uP1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB0YWIgPSBldmVudC5wYXRoWzBdO1xuICAgICAgY29uc3QgaW5kZXggPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMuaXRlbXMsIHRhYik7XG4gICAgICBpZiAoaW5kZXggPj0gMCAmJiB0aGlzLnNlbGVjdGVkSW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgICAvLyBOb3RlOiBXZSBkb24ndCBjYWxsIHByZXZlbnREZWZhdWx0IGhlcmUuIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGZvclxuICAgICAgICAvLyBtb3VzZWRvd24gaW5jbHVkZXMgc2V0dGluZyBrZXlib2FyZCBmb2N1cyBpZiB0aGUgZWxlbWVudCBkb2Vzbid0XG4gICAgICAgIC8vIGFscmVhZHkgaGF2ZSB0aGUgZm9jdXMsIGFuZCB3ZSB3YW50IHRvIHByZXNlcnZlIHRoYXQgYmVoYXZpb3IuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2V0IGRlZmF1bHRzLlxuICAgIGlmICh0eXBlb2YgdGhpcy50YWJQb3NpdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMudGFiUG9zaXRpb24gPSB0aGlzW3N5bWJvbHMuZGVmYXVsdHNdLnRhYlBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGdldCBbc3ltYm9scy5kZWZhdWx0c10oKSB7XG4gICAgY29uc3QgZGVmYXVsdHMgPSBzdXBlcltzeW1ib2xzLmRlZmF1bHRzXSB8fCB7fTtcbiAgICBkZWZhdWx0cy50YWJpbmRleCA9IG51bGw7XG4gICAgZGVmYXVsdHMudGFiUG9zaXRpb24gPSAndG9wJztcbiAgICByZXR1cm4gZGVmYXVsdHM7XG4gIH1cblxuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuJC50YWJzLmNoaWxkcmVuO1xuICB9XG5cbiAgW3N5bWJvbHMuaXRlbVNlbGVjdGVkXShpdGVtLCBzZWxlY3RlZCkge1xuICAgIGlmIChzdXBlcltzeW1ib2xzLml0ZW1TZWxlY3RlZF0pIHsgc3VwZXJbc3ltYm9scy5pdGVtU2VsZWN0ZWRdKGl0ZW0sIHNlbGVjdGVkKTsgfVxuICAgIGFwcGx5U2VsZWN0aW9uVG9UYWIoaXRlbSwgc2VsZWN0ZWQpO1xuICB9XG5cbiAgW3N5bWJvbHMua2V5ZG93bl0oZXZlbnQpIHtcbiAgICBjb25zdCBoYW5kbGVkID0gc3VwZXJbc3ltYm9scy5rZXlkb3duXSAmJiBzdXBlcltzeW1ib2xzLmtleWRvd25dKGV2ZW50KTtcbiAgICBpZiAoaGFuZGxlZCAmJiB0aGlzLnNlbGVjdGVkSXRlbSkge1xuICAgICAgLy8gSWYgdGhlIGV2ZW50IHJlc3VsdGVkIGluIGEgY2hhbmdlIG9mIHNlbGVjdGlvbiwgbW92ZSB0aGUgZm9jdXMgdG8gdGhlXG4gICAgICAvLyBuZXdseS1zZWxlY3RlZCB0YWIuXG4gICAgICB0aGlzLnNlbGVjdGVkSXRlbS5mb2N1cygpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlZDtcbiAgfVxuXG4gIGdldCBwYW5lbHMoKSB7XG4gICAgcmV0dXJuIHRoaXNbcGFuZWxzU3ltYm9sXTtcbiAgfVxuICBzZXQgcGFuZWxzKHBhbmVscykge1xuICAgIHRoaXNbcGFuZWxzU3ltYm9sXSA9IHBhbmVscztcblxuICAgIC8vIENyZWF0ZSBvbmUgdGFiIGZvciBlYWNoIHBhbmVsLlxuICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXg7XG4gICAgY29uc3Qgc2VsZWN0ZWRQYW5lbCA9IHBhbmVsc1tzZWxlY3RlZEluZGV4XTtcbiAgICByZW5kZXJBcnJheUFzRWxlbWVudHMocGFuZWxzLCB0aGlzLiQudGFicywgKHBhbmVsLCB0YWIpID0+IHtcbiAgICAgIGlmICghdGFiKSB7XG4gICAgICAgIHRhYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICB0YWIuY2xhc3NMaXN0LmFkZCgndGFiJyk7XG4gICAgICAgIHRhYi5jbGFzc0xpc3QuYWRkKCdzdHlsZS1zY29wZScpO1xuICAgICAgICB0YWIuY2xhc3NMaXN0LmFkZCgnYmFzaWMtdGFiLXN0cmlwJyk7XG4gICAgICAgIHRhYi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndGFiJyk7XG4gICAgICAgIHRhYi5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgICB9XG4gICAgICB0YWIuaWQgPSBwYW5lbC5pZCArICdfdGFiJztcbiAgICAgIHRhYi50ZXh0Q29udGVudCA9IHBhbmVsLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuXG4gICAgICAvLyBQb2ludCB0YWIgYW5kIHBhbmVsIGF0IGVhY2ggb3RoZXIuXG4gICAgICB0YWIuc2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJywgcGFuZWwuaWQpO1xuICAgICAgcGFuZWwuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknLCB0YWIuaWQpO1xuXG4gICAgICBhcHBseVNlbGVjdGlvblRvVGFiKHRhYiwgcGFuZWwgPT09IHNlbGVjdGVkUGFuZWwpO1xuXG4gICAgICByZXR1cm4gdGFiO1xuICAgIH0pO1xuXG4gICAgdGhpc1tzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKTtcbiAgfVxuXG4gIGdldCBzcHJlYWRUYWJzKCkge1xuICAgIHJldHVybiB0aGlzW3NwcmVhZFRhYnNTeW1ib2xdO1xuICB9XG4gIHNldCBzcHJlYWRUYWJzKHZhbHVlKSB7XG4gICAgdGhpc1tzcHJlYWRUYWJzU3ltYm9sXSA9IHZhbHVlO1xuICAgIHRvZ2dsZUNsYXNzKHRoaXMsICdzcHJlYWQnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSB0YWIgc3RyaXAgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQncyBjaGlsZHJlbi4gVmFsaWRcbiAgICogdmFsdWVzIGFyZSBcInRvcFwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBhbmQgXCJib3R0b21cIi5cbiAgICpcbiAgICogQGRlZmF1bHQgXCJ0b3BcIlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHRhYlBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzW3RhYlBvc2l0aW9uU3ltYm9sXTtcbiAgfVxuICBzZXQgdGFiUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICB0aGlzW3RhYlBvc2l0aW9uU3ltYm9sXSA9IHBvc2l0aW9uO1xuICAgIHRoaXMucmVmbGVjdEF0dHJpYnV0ZSgndGFiLXBvc2l0aW9uJywgcG9zaXRpb24pO1xuICAgIHRoaXMubmF2aWdhdGlvbkF4aXMgPSAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykgP1xuICAgICAgJ2hvcml6b250YWwnIDpcbiAgICAgICd2ZXJ0aWNhbCc7XG4gIH1cblxuICBnZXQgW3N5bWJvbHMudGVtcGxhdGVdKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEF2b2lkIGhhdmluZyB0YWIgY29udGFpbmVyIHN0cmV0Y2ggYWNyb3NzLiBVc2VyIHdvbid0IGJlIGFibGUgdG8gc2VlXG4gICAgICAgICAqIGl0LCBidXQgc2luY2UgaXQgaGFuZGxlcyB0aGUga2V5Ym9hcmQsIGluIE1vYmlsZSBTYWZhcmkgYSB0YXAgb24gdGhlXG4gICAgICAgICAqIGNvbnRhaW5lciBiYWNrZ3JvdW5kIHdpbGwgY2F1c2UgdGhlIHJlZ2lvbiB0byBmbGFzaC4gQWxpZ25pbmcgdGhlXG4gICAgICAgICAqIHJlZ2lvbiBjb2xsYXBzZXMgaXQgZG93biB0byBob2xkIGl0cyBjb250ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgICN0YWJzIHtcbiAgICAgICAgICAvKiBGb3IgSUUgYnVnIChjbGlja2luZyB0YWIgcHJvZHVjZXMgZ2FwIGJldHdlZW4gdGFiIGFuZCBwYWdlKS4gKi9cbiAgICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgICAgICAtd2Via2l0LWZsZXg6IDE7XG4gICAgICAgICAgZmxleDogMTtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIFRyeSB0byBvYnRhaW4gZmFzdC10YXAgYmVoYXZpb3Igb24gYWxsIHRhYnMuXG4gICAgICAgICAgICogU2VlIGh0dHBzOi8vd2Via2l0Lm9yZy9ibG9nLzU2MTAvbW9yZS1yZXNwb25zaXZlLXRhcHBpbmctb24taW9zLy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdCg6bm90KC5zcHJlYWQpKSAjdGFicyB7XG4gICAgICAgICAgLXdlYmtpdC1hbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xuICAgICAgICAgIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICAudGFiIHtcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xuICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cblxuICAgICAgICA6aG9zdChbZ2VuZXJpYz1cIlwiXSkgLnRhYiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcbiAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgcGFkZGluZzogMC41ZW0gMC43NWVtO1xuICAgICAgICAgIHRyYW5zaXRpb246IGJvcmRlci1jb2xvciAwLjI1cztcbiAgICAgICAgfVxuXG4gICAgICAgIDpob3N0KFtnZW5lcmljPVwiXCJdKSAudGFiLnNlbGVjdGVkIHtcbiAgICAgICAgICBib3JkZXItY29sb3I6ICNjY2M7XG4gICAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIDpob3N0KFtnZW5lcmljPVwiXCJdKSAudGFiOmhvdmVyIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogTGVmdC9yaWdodCBwb3NpdGlvbnMgKi9cbiAgICAgICAgOmhvc3QoW3RhYi1wb3NpdGlvbj1cImxlZnRcIl0pICN0YWJzLFxuICAgICAgICA6aG9zdChbdGFiLXBvc2l0aW9uPVwicmlnaHRcIl0pICN0YWJzIHtcbiAgICAgICAgICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFNwcmVhZCB2YXJpYW50ICovXG4gICAgICAgIDpob3N0KC5zcHJlYWQpICN0YWJzIHtcbiAgICAgICAgICAtd2Via2l0LWFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgICAgICB9XG4gICAgICAgIDpob3N0KC5zcHJlYWQpIC50YWIge1xuICAgICAgICAgIC13ZWJraXQtZmxleDogMTtcbiAgICAgICAgICBmbGV4OiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogR2VuZXJpYyBzdHlsZSwgdG9wL2JvdHRvbSBwb3NpdGlvbnMgKi9cbiAgICAgICAgOmhvc3QoW2dlbmVyaWM9XCJcIl1bdGFiLXBvc2l0aW9uPVwidG9wXCJdKSAudGFiOm5vdCg6bGFzdC1jaGlsZCksXG4gICAgICAgIDpob3N0KFtnZW5lcmljPVwiXCJdW3RhYi1wb3NpdGlvbj1cImJvdHRvbVwiXSkgLnRhYjpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDAuMmVtO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogR2VuZXJpYyBzdHlsZSwgdG9wIHBvc2l0aW9uICovXG4gICAgICAgIDpob3N0KFtnZW5lcmljPVwiXCJdW3RhYi1wb3NpdGlvbj1cInRvcFwiXSkgLnRhYiB7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogMC4yNWVtIDAuMjVlbSAwIDA7XG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogLTFweDtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdChbZ2VuZXJpYz1cIlwiXVt0YWItcG9zaXRpb249XCJ0b3BcIl0pIC50YWIuc2VsZWN0ZWQge1xuICAgICAgICAgIGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLyogR2VuZXJpYyBzdHlsZSwgYm90dG9tIHBvc2l0aW9uICovXG4gICAgICAgIDpob3N0KFtnZW5lcmljPVwiXCJdW3RhYi1wb3NpdGlvbj1cImJvdHRvbVwiXSkgLnRhYiB7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogMCAwIDAuMjVlbSAwLjI1ZW07XG4gICAgICAgICAgbWFyZ2luLXRvcDogLTFweDtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdChbZ2VuZXJpYz1cIlwiXVt0YWItcG9zaXRpb249XCJib3R0b21cIl0pIC50YWIuc2VsZWN0ZWQge1xuICAgICAgICAgIGJvcmRlci10b3AtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLyogR2VuZXJpYyBzdHlsZSwgbGVmdC9yaWdodCBwb3NpdGlvbnMgKi9cbiAgICAgICAgOmhvc3QoW2dlbmVyaWM9XCJcIl1bdGFiLXBvc2l0aW9uPVwibGVmdFwiXSkgLnRhYjpub3QoOmxhc3QtY2hpbGQpLFxuICAgICAgICA6aG9zdChbZ2VuZXJpYz1cIlwiXVt0YWItcG9zaXRpb249XCJyaWdodFwiXSkgLnRhYjpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwLjJlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIEdlbmVyaWMgc3R5bGUsIGxlZnQgcG9zaXRpb24gKi9cbiAgICAgICAgOmhvc3QoW2dlbmVyaWM9XCJcIl1bdGFiLXBvc2l0aW9uPVwibGVmdFwiXSkgLnRhYiB7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogMC4yNWVtIDAgMCAwLjI1ZW07XG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiAtMXB4O1xuICAgICAgICB9XG4gICAgICAgIDpob3N0KFtnZW5lcmljPVwiXCJdW3RhYi1wb3NpdGlvbj1cImxlZnRcIl0pIC50YWIuc2VsZWN0ZWQge1xuICAgICAgICAgIGJvcmRlci1yaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBHZW5lcmljIHN0eWxlLCByaWdodCBwb3NpdGlvbiAqL1xuICAgICAgICA6aG9zdChbZ2VuZXJpYz1cIlwiXVt0YWItcG9zaXRpb249XCJyaWdodFwiXSkgLnRhYiB7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogMCAwLjI1ZW0gMC4yNWVtIDA7XG4gICAgICAgICAgbWFyZ2luLWxlZnQ6IC0xcHg7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QoW2dlbmVyaWM9XCJcIl1bdGFiLXBvc2l0aW9uPVwicmlnaHRcIl0pIC50YWIuc2VsZWN0ZWQge1xuICAgICAgICAgIGJvcmRlci1sZWZ0LWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cbiAgICAgIDxkaXYgaWQ9XCJ0YWJzXCIgcm9sZT1cInRhYmxpc3RcIj48L2Rpdj5cbiAgICBgO1xuICB9XG59XG5cblxuZnVuY3Rpb24gYXBwbHlTZWxlY3Rpb25Ub1RhYih0YWIsIHNlbGVjdGVkKSB7XG4gIHRhYi5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG59XG5cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdiYXNpYy10YWItc3RyaXAnLCBUYWJTdHJpcCk7XG5leHBvcnQgZGVmYXVsdCBUYWJTdHJpcDtcbiIsImltcG9ydCBUYWJTdHJpcCBmcm9tICcuL1RhYlN0cmlwJzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5pbXBvcnQgc3ltYm9scyBmcm9tICcuLi8uLi9iYXNpYy1jb21wb25lbnQtbWl4aW5zL3NyYy9zeW1ib2xzJztcblxuXG4vLyBVc2VkIHRvIGFzc2lnbiB1bmlxdWUgSURzIHRvIHRhYnMgZm9yIEFSSUEgcHVycG9zZXMuXG5sZXQgaWRDb3VudCA9IDA7XG5cblxuLyogRXhwb3J0ZWQgZnVuY3Rpb24gZXh0ZW5kcyBhIGJhc2UgY2xhc3Mgd2l0aCBUYWJTdHJpcC4gKi9cbmV4cG9ydCBkZWZhdWx0IChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIEEgdGVtcGxhdGUgbWl4aW4gd2hpY2ggYWRkcyBzdHJpcCBvZiB0YWJzIGZvciBzZWxlY3Rpbmcgb25lIG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBjaGlsZHJlbi5cbiAgICpcbiAgICogVGhlIGNvbXBvbmVudCBjcmVhdGVzIGEgdGFiIHRvIHJlcHJlc2VudCBlYWNoIG9mIGl0cyBsaWdodCBET00gY2hpbGRyZW4uXG4gICAqIFRoZSB0YWIgbmFtZSBpcyBvYnRhaW5lZCBieSBleGFtaW5pbmcgdGhlIGNoaWxkcmVuIGZvciBhbiBgYXJpYS1sYWJlbGBcbiAgICogcHJvcGVydHkuXG4gICAqXG4gICAqIFVzZSB0YWJzIHdoZW4geW91IHdhbnQgdG8gcHJvdmlkZSBhIGxhcmdlIHNldCBvZiBvcHRpb25zIG9yIGVsZW1lbnRzIHRoYW5cbiAgICogY2FuIGNvbWZvcnRhYmx5IGZpdCBpbmxpbmUsIHRoZSBvcHRpb25zIGNhbiBiZSBjb2hlcmVudGx5IGdyb3VwZWQgaW50byBwYWdlcyxcbiAgICogYW5kIHlvdSB3YW50IHRvIGF2b2lkIG1ha2luZyB0aGUgdXNlciBuYXZpZ2F0ZSB0byBhIHNlcGFyYXRlIHBhZ2UuIFRhYnMgd29ya1xuICAgKiBiZXN0IGlmIHlvdSBvbmx5IGhhdmUgYSBzbWFsbCBoYW5kZnVsIG9mIHBhZ2VzLCBzYXkgMuKAkzcuXG4gICAqXG4gICAqIFRoZSBiYXNpYy10YWItc3RyaXAgY29tcG9uZW50IGRvZXMgbm90IGRlZmluZSBob3cgYSBzZWxlY3RlZCBjaGlsZCBpc1xuICAgKiByZXByZXNlbnRlZC4gSWYgeW91J3JlIGxvb2tpbmcgZm9yIHRoZSBzdGFuZGFyZCBiZWhhdmlvciBvZiBqdXN0IHNob3dpbmcgb25seVxuICAgKiB0aGUgc2VsZWN0ZWQgY2hpbGQsIHlvdSBjYW4gdXNlIHRoaXMgY29tcG9uZW50IGluIGNvbWJpbmF0aW9uIHdpdGggdGhlXG4gICAqIHNlcGFyYXRlIFtiYXNpYy1tb2Rlc10oLi4vYmFzaWMtbW9kZXMvKSBjb21wb25lbnQuIEEgdHlwaWNhbCBhcnJhbmdlbWVudDpcbiAgICpcbiAgICogICAgIDxiYXNpYy10YWItc3RyaXA+XG4gICAqICAgICAgIDxiYXNpYy1tb2RlcyBhcmlhLWxhYmVsPVwiUGFuZWxzXCI+XG4gICAqICAgICAgICAgPGRpdiBhcmlhLWxhYmVsPVwiT25lXCI+UGFnZSBvbmU8L2Rpdj5cbiAgICogICAgICAgICA8ZGl2IGFyaWEtbGFiZWw9XCJUd29cIj5QYWdlIHR3bzwvZGl2PlxuICAgKiAgICAgICAgIDxkaXYgYXJpYS1sYWJlbD1cIlRocmVlXCI+UGFnZSB0aHJlZTwvZGl2PlxuICAgKiAgICAgICA8L2Jhc2ljLW1vZGVzPlxuICAgKiAgICAgPC9iYXNpYy10YWItc3RyaXA+XG4gICAqXG4gICAqIFRoZSBhYm92ZSBjb21iaW5hdGlvbiBpcyBzbyBjb21tb24gaXQgaXMgcHJvdmlkZWQgYXMgYSBzaW5nbGUgY29tcG9uZW50LFxuICAgKiBbYmFzaWMtdGFic10oLi4vYmFzaWMtdGFicy8pLlxuICAgKlxuICAgKiBUaGUgdXNlciBjYW4gc2VsZWN0IGEgdGFiIHdpdGggdGhlIG1vdXNlIG9yIHRvdWNoLCBhcyB3ZWxsIGFzIGJ5IHRocm91Z2ggdGhlXG4gICAqIGtleWJvYXJkLiBFYWNoIHRhYiBhcHBlYXJzIGFzIGEgc2VwYXJhdGUgYnV0dG9uIGluIHRoZSB0YWIgb3JkZXIuXG4gICAqIEFkZGl0aW9uYWxseSwgaWYgdGhlIGZvY3VzIGlzIGN1cnJlbnRseSBvbiBhIHRhYiwgdGhlIHVzZXIgY2FuIHF1aWNrbHlcbiAgICogbmF2aWdhdGUgYmV0d2VlbiB0YWJzIHdpdGggdGhlIGxlZnQvcmlnaHQgYXJyb3cga2V5cyAob3IsIGlmIHRoZSB0YWJzIGFyZVxuICAgKiBpbiB2ZXJ0aWNhbCBwb3NpdGlvbiwgdGhlIHVwL2Rvd24gYXJyb3cga2V5cykuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSB0YWJzIGFyZSBzaG93biBncm91cGVkIHRvIHRoZSBsZWZ0LCB3aGVyZSBlYWNoIHRhYiBpcyBvbmx5XG4gICAqIGFzIGJpZyBhcyBuZWNlc3NhcnkuIFlvdSBjYW4gYXBwbHkgdGhlIGBzcHJlYWRgIENTUyBjbGFzcyB0byBhXG4gICAqIGJhc2ljLXRhYi1zdHJpcCBlbGVtZW50IGZvciBhIHZhcmlhbnQgYXBwZWFyYW5jZSBpbiB3aGljaCB0aGUgYXZhaWxhYmxlIHdpZHRoXG4gICAqIG9mIHRoZSBlbGVtZW50IGlzIGRpdmlkZWQgdXAgZXF1YWxseSBhbW9uZyB0YWJzLlxuICAgKlxuICAgKiBUaGUgR2VuZXJpY01peGluIGRlZmF1bHQgc3R5bGluZyBvZiB0aGUgdGFiIHN0cmlwIHdpbGwgcHJlc2VudCB0aGUgY2xhc3NpY1xuICAgKiBza2V1bW9ycGhpYyBsb29rIG9mIHJvdW5kZWQgdGFicyBhdHRhY2hlZCB0byBhIHN1cmZhY2UuIFlvdSBjYW4gcmVtb3ZlIHRoaXNcbiAgICogc3R5bGluZyBieSBzZXR0aW5nIHRoZSBgR2VuZXJpY01peGluYCBwcm9wZXJ0eS9hdHRyaWJ1dGUgdG8gZmFsc2UuXG4gICAqL1xuICBjbGFzcyBUYWJTdHJpcCBleHRlbmRzIGJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy4kLnRhYlN0cmlwLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVkLWl0ZW0tY2hhbmdlZCcsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IGV2ZW50LnRhcmdldC5zZWxlY3RlZEluZGV4O1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ICE9PSBzZWxlY3RlZEluZGV4KSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0IFtzeW1ib2xzLmRlZmF1bHRzXSgpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRzID0gc3VwZXJbc3ltYm9scy5kZWZhdWx0c10gfHwge307XG4gICAgICBkZWZhdWx0cy50YWJQb3NpdGlvbiA9ICd0b3AnO1xuICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIGdldCBnZW5lcmljKCkge1xuICAgICAgcmV0dXJuIHN1cGVyLmdlbmVyaWM7XG4gICAgfVxuICAgIHNldCBnZW5lcmljKHZhbHVlKSB7XG4gICAgICBpZiAoJ2dlbmVyaWMnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLmdlbmVyaWMgPSB2YWx1ZTsgfVxuICAgICAgdGhpcy4kLnRhYlN0cmlwLmdlbmVyaWMgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBbc3ltYm9scy5pdGVtc0NoYW5nZWRdKCkge1xuICAgICAgaWYgKHN1cGVyW3N5bWJvbHMuaXRlbXNDaGFuZ2VkXSkgeyBzdXBlcltzeW1ib2xzLml0ZW1zQ2hhbmdlZF0oKTsgfVxuXG4gICAgICBjb25zdCBiYXNlSWQgPSB0aGlzLmlkID9cbiAgICAgICAgXCJfXCIgKyB0aGlzLmlkICsgXCJQYW5lbFwiIDpcbiAgICAgICAgXCJfcGFuZWxcIjtcblxuICAgICAgLy8gQ29uZmlybSB0aGF0IGl0ZW1zIGhhdmUgYXQgbGVhc3QgYSBkZWZhdWx0IHJvbGUgYW5kIElEIGZvciBBUklBIHB1cnBvc2VzLlxuICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAvLyBpZiAoIWl0ZW0uZ2V0QXR0cmlidXRlKCdyb2xlJykpIHtcbiAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgncm9sZScsICd0YWJwYW5lbCcpO1xuICAgICAgICAvLyB9XG4gICAgICAgIGlmICghaXRlbS5pZCkge1xuICAgICAgICAgIGl0ZW0uaWQgPSBiYXNlSWQgKyBpZENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBQb2ludCB0aGUgdGFiIHN0cmlwIGF0IHRoZSBwYW5lbHMuXG4gICAgICB0aGlzLiQudGFiU3RyaXAucGFuZWxzID0gdGhpcy5pdGVtcztcbiAgICAgIHRoaXMuJC50YWJTdHJpcC5zZWxlY3RlZEluZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4O1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnNlbGVjdGVkSW5kZXg7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEluZGV4KHZhbHVlKSB7XG4gICAgICBpZiAoJ3NlbGVjdGVkSW5kZXgnIGluIGJhc2UucHJvdG90eXBlKSB7IHN1cGVyLnNlbGVjdGVkSW5kZXggPSB2YWx1ZTsgfVxuICAgICAgaWYgKHRoaXMuJC50YWJTdHJpcC5zZWxlY3RlZEluZGV4ICE9PSB2YWx1ZSkge1xuICAgICAgICB0aGlzLiQudGFiU3RyaXAuc2VsZWN0ZWRJbmRleCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzcHJlYWRUYWJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJC50YWJTdHJpcC5zcHJlYWRUYWJzO1xuICAgIH1cbiAgICBzZXQgc3ByZWFkVGFicyh2YWx1ZSkge1xuICAgICAgdGhpcy4kLnRhYlN0cmlwLnNwcmVhZFRhYnMgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgdGFiUG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy4kLnRhYlN0cmlwLnRhYlBvc2l0aW9uO1xuICAgIH1cbiAgICBzZXQgdGFiUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgIHRoaXMuJC50YWJTdHJpcC50YWJQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgdGhpcy5yZWZsZWN0QXR0cmlidXRlKCd0YWItcG9zaXRpb24nLCBwb3NpdGlvbik7XG5cbiAgICAgIC8vIFBoeXNpY2FsbHkgcmVvcmRlciB0aGUgdGFicyBhbmQgcGFnZXMgdG8gcmVmbGVjdCB0aGUgZGVzaXJlZCBhcnJhbmdlbWVudC5cbiAgICAgIC8vIFdlIGNvdWxkIGNoYW5nZSB0aGUgdmlzdWFsIGFwcGVhcmFuY2UgYnkgcmV2ZXJzaW5nIHRoZSBvcmRlciBvZiB0aGUgZmxleFxuICAgICAgLy8gYm94LCBidXQgdGhlbiB0aGUgdmlzdWFsIG9yZGVyIHdvdWxkbid0IHJlZmxlY3QgdGhlIGRvY3VtZW50IG9yZGVyLCB3aGljaFxuICAgICAgLy8gZGV0ZXJtaW5lcyBmb2N1cyBvcmRlci4gVGhhdCB3b3VsZCBzdXJwcmlzZSBhIHVzZXIgdHJ5aW5nIHRvIHRhYiB0aHJvdWdoXG4gICAgICAvLyB0aGUgY29udHJvbHMuXG4gICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnbGVmdCcpID9cbiAgICAgICAgdGhpcy4kLnRhYlN0cmlwIDpcbiAgICAgICAgdGhpcy4kLnBhZ2VzO1xuICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnbGVmdCcpID9cbiAgICAgICAgdGhpcy4kLnBhZ2VzIDpcbiAgICAgICAgdGhpcy4kLnRhYlN0cmlwO1xuICAgICAgaWYgKGZpcnN0RWxlbWVudC5uZXh0U2libGluZyAhPT0gbGFzdEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5zaGFkb3dSb290Lmluc2VydEJlZm9yZShmaXJzdEVsZW1lbnQsIGxhc3RFbGVtZW50KTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGdldCBbc3ltYm9scy50ZW1wbGF0ZV0oKSB7XG4gICAgICBjb25zdCBiYXNlVGVtcGxhdGUgPSBzdXBlcltzeW1ib2xzLnRlbXBsYXRlXSB8fCAnJztcbiAgICAgIHJldHVybiBgXG4gICAgICAgIDxzdHlsZT5cbiAgICAgICAgOmhvc3Qge1xuICAgICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgfVxuXG4gICAgICAgICNwYWdlcyB7XG4gICAgICAgICAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgLXdlYmtpdC1mbGV4OiAxO1xuICAgICAgICAgIGZsZXg6IDE7XG4gICAgICAgICAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIH1cblxuICAgICAgICAjcGFnZXMgOjpzbG90dGVkKCopIHtcbiAgICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAtd2Via2l0LWZsZXg6IDE7XG4gICAgICAgICAgZmxleDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIExlZnQvcmlnaHQgcG9zaXRpb25zICovXG4gICAgICAgIDpob3N0KFt0YWItcG9zaXRpb249XCJsZWZ0XCJdKSxcbiAgICAgICAgOmhvc3QoW3RhYi1wb3NpdGlvbj1cInJpZ2h0XCJdKSB7XG4gICAgICAgICAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogcm93O1xuICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBHZW5lcmljIHN0eWxlICovXG4gICAgICAgIDpob3N0KFtnZW5lcmljPVwiXCJdKSAjcGFnZXMge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xuICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgfVxuICAgICAgICA8L3N0eWxlPlxuXG4gICAgICAgIDxiYXNpYy10YWItc3RyaXAgaWQ9XCJ0YWJTdHJpcFwiIHJvbGU9XCJ0YWJsaXN0XCI+PC9iYXNpYy10YWItc3RyaXA+XG4gICAgICAgIDxkaXYgaWQ9XCJwYWdlc1wiPlxuICAgICAgICAgICR7YmFzZVRlbXBsYXRlfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIGA7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gVGFiU3RyaXA7XG59O1xuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyB0cmFuc3BpbGVkIHRvIGNyZWF0ZSBhbiBFUzUtY29tcGF0aWJsZSBkaXN0cmlidXRpb24gaW4gd2hpY2hcbiAqIHRoZSBwYWNrYWdlJ3MgbWFpbiBmZWF0dXJlKHMpIGFyZSBhdmFpbGFibGUgdmlhIHRoZSB3aW5kb3cuQmFzaWMgZ2xvYmFsLlxuICogSWYgeW91J3JlIGFscmVhZHkgdXNpbmcgRVM2IHlvdXJzZWxmLCBpZ25vcmUgdGhpcyBmaWxlLCBhbmQgaW5zdGVhZCBpbXBvcnRcbiAqIHRoZSBzb3VyY2UgZmlsZShzKSB5b3Ugd2FudCBmcm9tIHRoZSBzcmMgZm9sZGVyLlxuICovXG5cbmltcG9ydCBUYWJzIGZyb20gJy4vc3JjL1RhYnMnO1xuXG53aW5kb3cuQmFzaWMgPSB3aW5kb3cuQmFzaWMgfHwge307XG53aW5kb3cuQmFzaWMuVGFicyA9IFRhYnM7XG4iLCJpbXBvcnQgR2VuZXJpY01peGluIGZyb20gJy4uLy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvc3JjL0dlbmVyaWNNaXhpbic7XG5pbXBvcnQgTW9kZXMgZnJvbSAnLi4vLi4vYmFzaWMtbW9kZXMvc3JjL01vZGVzJztcbmltcG9ydCBUYWJTdHJpcE1peGluIGZyb20gJy4uLy4uL2Jhc2ljLXRhYi1zdHJpcC9zcmMvVGFiU3RyaXBNaXhpbic7XG5cblxuY29uc3QgYmFzZSA9IE1vZGVzLmNvbXBvc2UoXG4gIEdlbmVyaWNNaXhpbixcbiAgVGFiU3RyaXBNaXhpblxuKTtcblxuXG4vKipcbiAqIEEgc2V0IG9mIHBhZ2VzIHdpdGggYSB0YWIgc3RyaXAgZ292ZXJuaW5nIHdoaWNoIHBhZ2UgaXMgc2hvd24uXG4gKlxuICogVGhpcyBzdG9jayBjb21iaW5hdGlvbiBhcHBsaWVzIHRoZSBbVGFiU3RyaXBNaXhpbl0oLi4vYmFzaWMtdGFiLXN0cmlwLykgdG8gYVxuICogW2Jhc2ljLW1vZGVzXSguLi9iYXNpYy1tb2Rlcy8pIGVsZW1lbnQuIElmIHlvdSdkIGxpa2UgdG8gY3JlYXRlIHNvbWV0aGluZ1xuICogbW9yZSBjb21wbGV4IHRoYW4gdGhpcyBhcnJhbmdlbWVudCwgeW91IGNhbiB1c2UgZWl0aGVyIG9mIHRob3NlIGVsZW1lbnRzIG9uXG4gKiBpdHMgb3duLlxuICpcbiAqIFNpbmNlIHRoaXMgY29tcG9uZW50IHVzZXMgYFRhYlN0cmlwTWl4aW5gLCBpdCBvYnRhaW5zIHRoZSBuYW1lcyBvZiB0aGVcbiAqIGluZGl2aWR1YWwgdGFicyBmcm9tIGEgY2hpbGQncyBgYXJpYS1sYWJlbGAgcHJvcGVydHkuIEV4YW1wbGU6XG4gKlxuICogICAgIDxiYXNpYy10YWJzPlxuICogICAgICAgPGRpdiBhcmlhLWxhYmVsPVwiT25lXCI+UGFnZSBvbmU8L2Rpdj5cbiAqICAgICAgIDxkaXYgYXJpYS1sYWJlbD1cIlR3b1wiPlBhZ2UgdHdvPC9kaXY+XG4gKiAgICAgICA8ZGl2IGFyaWEtbGFiZWw9XCJUaHJlZVwiPlBhZ2UgdGhyZWU8L2Rpdj5cbiAqICAgICA8L2Jhc2ljLXRhYnM+XG4gKlxuICogQGV4dGVuZHMgTW9kZXNcbiAqIEBtaXhlcyBHZW5lcmljTWl4aW5cbiAqL1xuY2xhc3MgVGFicyBleHRlbmRzIGJhc2Uge31cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdiYXNpYy10YWJzJywgVGFicyk7XG5leHBvcnQgZGVmYXVsdCBUYWJzO1xuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyB0cmFuc3BpbGVkIHRvIGNyZWF0ZSBhbiBFUzUtY29tcGF0aWJsZSBkaXN0cmlidXRpb24gb2YgYWxsXG4gKiBjb21wb25lbnRzIGluIHRoZSBwcm9qZWN0LiBJZiB5b3UncmUgYWxyZWFkeSB1c2luZyBFUzYgeW91cnNlbGYsIGlnbm9yZSB0aGlzXG4gKiBmaWxlLCBhbmQgaW5zdGVhZCBpbXBvcnQgdGhlIHNvdXJjZSBmaWxlKHMpIHlvdSB3YW50IGZyb20gdGhlIHNwZWNpZmljXG4gKiBwYWNrYWdlIHlvdSB3YW50LlxuICovXG5cbi8vIEltcG9ydCBhbGwgdGhlIGdsb2JhbHMgZnJvbSBlYWNoIHBhY2thZ2UuXG4vLyBXZSB0ZWxsIGpzaGludCB0byBpZ25vcmUgdGhlIGZhY3QgdGhhdCB3ZSdyZSBub3QgYWN0dWFsbHkgdXNpbmcgdGhlbSBoZXJlLlxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuXG5pbXBvcnQgKiBhcyBhbmltYXRpb25TdGFnZSBmcm9tICcuLi9iYXNpYy1hbmltYXRpb24tc3RhZ2UvZ2xvYmFscyc7XG5pbXBvcnQgKiBhcyBhdXRvc2l6ZVRleHRhcmVhIGZyb20gJy4uL2Jhc2ljLWF1dG9zaXplLXRleHRhcmVhL2dsb2JhbHMnO1xuaW1wb3J0ICogYXMgY2Fyb3VzZWwgZnJvbSAnLi4vYmFzaWMtY2Fyb3VzZWwvZ2xvYmFscyc7XG5pbXBvcnQgKiBhcyBjb2xsYXBzaWJsZVBhbmVsIGZyb20gJy4uL2Jhc2ljLWNvbGxhcHNpYmxlLXBhbmVsL2dsb2JhbHMnO1xuaW1wb3J0ICogYXMgY29tcG9uZW50TWl4aW5zIGZyb20gJy4uL2Jhc2ljLWNvbXBvbmVudC1taXhpbnMvZ2xvYmFscyc7XG5pbXBvcnQgKiBhcyBjdXJyZW50QW5jaG9yIGZyb20gJy4uL2Jhc2ljLWN1cnJlbnQtYW5jaG9yL2dsb2JhbHMnO1xuaW1wb3J0ICogYXMgZWxlbWVudEJhc2UgZnJvbSAnLi4vYmFzaWMtZWxlbWVudC1iYXNlL2dsb2JhbHMnO1xuaW1wb3J0ICogYXMgZmFkZU92ZXJmbG93IGZyb20gJy4uL2Jhc2ljLWZhZGUtb3ZlcmZsb3cvZ2xvYmFscyc7XG5pbXBvcnQgKiBhcyBsaXN0Qm94IGZyb20gJy4uL2Jhc2ljLWxpc3QtYm94L2dsb2JhbHMnO1xuaW1wb3J0ICogYXMgbW9kZXMgZnJvbSAnLi4vYmFzaWMtbW9kZXMvZ2xvYmFscyc7XG5pbXBvcnQgKiBhcyBzbGlkZXNob3cgZnJvbSAnLi4vYmFzaWMtc2xpZGVzaG93L2dsb2JhbHMnO1xuaW1wb3J0ICogYXMgc2xpZGVzaG93V2l0aENvbnRyb2xzIGZyb20gJy4uL2Jhc2ljLXNsaWRlc2hvdy13aXRoLWNvbnRyb2xzL2dsb2JhbHMnO1xuaW1wb3J0ICogYXMgc2xpZGluZ0Nhcm91c2VsIGZyb20gJy4uL2Jhc2ljLXNsaWRpbmctY2Fyb3VzZWwvZ2xvYmFscyc7XG5pbXBvcnQgKiBhcyBzbGlkaW5nVmlld3BvcnQgZnJvbSAnLi4vYmFzaWMtc2xpZGluZy12aWV3cG9ydC9nbG9iYWxzJztcbmltcG9ydCAqIGFzIHNwcmVhZEl0ZW1zIGZyb20gJy4uL2Jhc2ljLXNwcmVhZC1pdGVtcy9nbG9iYWxzJztcbmltcG9ydCAqIGFzIHRhYnMgZnJvbSAnLi4vYmFzaWMtdGFicy9nbG9iYWxzJztcbmltcG9ydCAqIGFzIHRhYlN0cmlwIGZyb20gJy4uL2Jhc2ljLXRhYi1zdHJpcC9nbG9iYWxzJztcbmltcG9ydCAqIGFzIHdlYkNvbXBvbmVudHMgZnJvbSAnLi4vYmFzaWMtd2ViLWNvbXBvbmVudHMvZ2xvYmFscyc7XG5pbXBvcnQgKiBhcyB3cmFwcGVkU3RhbmRhcmRFbGVtZW50IGZyb20gJy4uL2Jhc2ljLXdyYXBwZWQtc3RhbmRhcmQtZWxlbWVudC9nbG9iYWxzJztcblxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgdHJhbnNwaWxlZCB0byBjcmVhdGUgYW4gRVM1LWNvbXBhdGlibGUgZGlzdHJpYnV0aW9uIGluIHdoaWNoXG4gKiB0aGUgcGFja2FnZSdzIG1haW4gZmVhdHVyZShzKSBhcmUgYXZhaWxhYmxlIHZpYSB0aGUgd2luZG93LkJhc2ljIGdsb2JhbC5cbiAqIElmIHlvdSdyZSBhbHJlYWR5IHVzaW5nIEVTNiB5b3Vyc2VsZiwgaWdub3JlIHRoaXMgZmlsZSwgYW5kIGluc3RlYWQgaW1wb3J0XG4gKiB0aGUgc291cmNlIGZpbGUocykgeW91IHdhbnQgZnJvbSB0aGUgc3JjIGZvbGRlci5cbiAqL1xuXG5pbXBvcnQgV3JhcHBlZFN0YW5kYXJkRWxlbWVudCBmcm9tICcuL3NyYy9XcmFwcGVkU3RhbmRhcmRFbGVtZW50Jztcblxud2luZG93LkJhc2ljID0gd2luZG93LkJhc2ljIHx8IHt9O1xud2luZG93LkJhc2ljLldyYXBwZWRTdGFuZGFyZEVsZW1lbnQgPSBXcmFwcGVkU3RhbmRhcmRFbGVtZW50O1xuIiwiaW1wb3J0IEVsZW1lbnRCYXNlIGZyb20gJy4uLy4uL2Jhc2ljLWVsZW1lbnQtYmFzZS9zcmMvRWxlbWVudEJhc2UnO1xuaW1wb3J0IHN5bWJvbHMgZnJvbSAnLi4vLi4vYmFzaWMtY29tcG9uZW50LW1peGlucy9zcmMvc3ltYm9scyc7XG5cblxuLypcbiAqIEEgc2V0IG9mIGV2ZW50cyB3aGljaCwgaWYgZmlyZWQgYnkgdGhlIGlubmVyIHN0YW5kYXJkIGVsZW1lbnQsIHNob3VsZCBiZVxuICogcmUtcmFpc2VkIGJ5IHRoZSBjdXN0b20gZWxlbWVudC4gKFdlIG9ubHkgbmVlZCB0byBkbyB0aGF0IHVuZGVyIG5hdGl2ZVxuICogU2hhZG93IERPTSwgbm90IHRoZSBwb2x5ZmlsbC4pXG4gKlxuICogVGhlc2UgYXJlIGV2ZW50cyB3aGljaCBhcmUgc3BlYydlZCB0byBOT1QgZ2V0IHJldGFyZ2V0dGVkIGFjcm9zcyBhIFNoYWRvdyBET01cbiAqIGJvdW5kYXJ5LCBvcmdhbml6ZWQgYnkgd2hpY2ggZWxlbWVudChzKSByYWlzZSB0aGUgZXZlbnRzLiBUbyBwcm9wZXJseVxuICogc2ltdWxhdGUgdGhlc2UsIHdlIHdpbGwgbmVlZCB0byBsaXN0ZW4gZm9yIHRoZSByZWFsIGV2ZW50cywgdGhlbiByZS1yYWlzZSBhXG4gKiBzaW11bGF0aW9uIG9mIHRoZSBvcmlnaW5hbCBldmVudC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NoYWRvdy1kb20vI2gtZXZlbnRzLXRoYXQtYXJlLW5vdC1sZWFrZWQtaW50by1hbmNlc3Rvci10cmVlcy5cbiAqXG4gKiBJdCBhcHBlYXJzIHRoYXQgd2UgZG8gKm5vdCogbmVlZCB0byByZS1yYWlzZSB0aGUgbm9uLWJ1YmJsaW5nIFwiZm9jdXNcIiBhbmRcbiAqIFwiYmx1clwiIGV2ZW50cy4gVGhlc2UgYXBwZWFyIHRvIGJlIGF1dG9tYXRpY2FsbHkgcmUtcmFpc2VkIGFzIGV4cGVjdGVkIC0tIGJ1dFxuICogaXQncyBub3QgY2xlYXIgd2h5IHRoYXQgaGFwcGVucy5cbiAqXG4gKiBUaGUgbGlzdCBiZWxvdyBpcyByZWFzb25hYmx5IGNvbXBsZXRlLiBJdCBvbWl0cyBlbGVtZW50cyB0aGF0IGNhbm5vdCBiZVxuICogd3JhcHBlZCAoc2VlIGNsYXNzIG5vdGVzIGFib3ZlKS4gQWxzbywgd2UgaGF2ZW4ndCBhY3R1YWxseSB0cmllZCB3cmFwcGluZ1xuICogZXZlcnkgZWxlbWVudCBpbiB0aGlzIGxpc3Q7IHNvbWUgb2YgdGhlIG1vcmUgb2JzY3VyZSBvbmVzIG1pZ2h0IG5vdCBhY3R1YWxseVxuICogd29yayBhcyBleHBlY3RlZCwgYnV0IGl0IHdhcyBlYXNpZXIgdG8gaW5jbHVkZSB0aGVtIGZvciBjb21wbGV0ZW5lc3MgdGhhblxuICogdG8gYWN0dWFsbHkgdmVyaWZ5IHdoZXRoZXIgb3Igbm90IHRoZSBlbGVtZW50IGNhbiBiZSB3cmFwcGVkLlxuICovXG5jb25zdCByZXJhaXNlRXZlbnRzID0ge1xuICBhZGRyZXNzOiBbJ3Njcm9sbCddLFxuICBibG9ja3F1b3RlOiBbJ3Njcm9sbCddLFxuICBjYXB0aW9uOiBbJ3Njcm9sbCddLFxuICBjZW50ZXI6IFsnc2Nyb2xsJ10sXG4gIGRkOiBbJ3Njcm9sbCddLFxuICBkaXI6IFsnc2Nyb2xsJ10sXG4gIGRpdjogWydzY3JvbGwnXSxcbiAgZGw6IFsnc2Nyb2xsJ10sXG4gIGR0OiBbJ3Njcm9sbCddLFxuICBmaWVsZHNldDogWydzY3JvbGwnXSxcbiAgZm9ybTogWydyZXNldCcsICdzY3JvbGwnXSxcbiAgZnJhbWU6IFsnbG9hZCddLFxuICBoMTogWydzY3JvbGwnXSxcbiAgaDI6IFsnc2Nyb2xsJ10sXG4gIGgzOiBbJ3Njcm9sbCddLFxuICBoNDogWydzY3JvbGwnXSxcbiAgaDU6IFsnc2Nyb2xsJ10sXG4gIGg2OiBbJ3Njcm9sbCddLFxuICBpZnJhbWU6IFsnbG9hZCddLFxuICBpbWc6IFsnYWJvcnQnLCAnZXJyb3InLCAnbG9hZCddLFxuICBpbnB1dDogWydhYm9ydCcsICdjaGFuZ2UnLCAnZXJyb3InLCAnc2VsZWN0JywgJ2xvYWQnXSxcbiAga2V5Z2VuOiBbJ3Jlc2V0JywgJ3NlbGVjdCddLFxuICBsaTogWydzY3JvbGwnXSxcbiAgbGluazogWydsb2FkJ10sXG4gIG1lbnU6IFsnc2Nyb2xsJ10sXG4gIG9iamVjdDogWydlcnJvcicsICdzY3JvbGwnXSxcbiAgb2w6IFsnc2Nyb2xsJ10sXG4gIHA6IFsnc2Nyb2xsJ10sXG4gIHNjcmlwdDogWydlcnJvcicsICdsb2FkJ10sXG4gIHNlbGVjdDogWydjaGFuZ2UnLCAnc2Nyb2xsJ10sXG4gIHRib2R5OiBbJ3Njcm9sbCddLFxuICB0Zm9vdDogWydzY3JvbGwnXSxcbiAgdGhlYWQ6IFsnc2Nyb2xsJ10sXG4gIHRleHRhcmVhOiBbJ2NoYW5nZScsICdzZWxlY3QnLCAnc2Nyb2xsJ11cbn07XG5cblxuLy8gS2VlcCB0cmFjayBvZiB3aGljaCByZS1yYWlzZWQgZXZlbnRzIHNob3VsZCBidWJibGUuXG5jb25zdCBldmVudEJ1YmJsZXMgPSB7XG4gIGFib3J0OiB0cnVlLFxuICBjaGFuZ2U6IHRydWUsXG4gIHJlc2V0OiB0cnVlXG59O1xuXG5cbi8vIEVsZW1lbnRzIHdoaWNoIGFyZSBkaXNwbGF5OiBibG9jayBieSBkZWZhdWx0LlxuLy8gU291cmNlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0Jsb2NrLWxldmVsX2VsZW1lbnRzXG5jb25zdCBibG9ja0VsZW1lbnRzID0gW1xuICAnYWRkcmVzcycsXG4gICdhcnRpY2xlJyxcbiAgJ2FzaWRlJyxcbiAgJ2Jsb2NrcXVvdGUnLFxuICAnY2FudmFzJyxcbiAgJ2RkJyxcbiAgJ2RpdicsXG4gICdkbCcsXG4gICdmaWVsZHNldCcsXG4gICdmaWdjYXB0aW9uJyxcbiAgJ2ZpZ3VyZScsXG4gICdmb290ZXInLFxuICAnZm9ybScsXG4gICdoMScsXG4gICdoMicsXG4gICdoMycsXG4gICdoNCcsXG4gICdoNScsXG4gICdoNicsXG4gICdoZWFkZXInLFxuICAnaGdyb3VwJyxcbiAgJ2hyJyxcbiAgJ2xpJyxcbiAgJ21haW4nLFxuICAnbmF2JyxcbiAgJ25vc2NyaXB0JyxcbiAgJ29sJyxcbiAgJ291dHB1dCcsXG4gICdwJyxcbiAgJ3ByZScsXG4gICdzZWN0aW9uJyxcbiAgJ3RhYmxlJyxcbiAgJ3Rmb290JyxcbiAgJ3VsJyxcbiAgJ3ZpZGVvJ1xuXTtcblxuXG4vKipcbiAqIFdyYXBzIGEgc3RhbmRhcmQgSFRNTCBlbGVtZW50IHNvIHRoYXQgdGhlIHN0YW5kYXJkIGJlaGF2aW9yIGNhbiB0aGVuIGJlXG4gKiBleHRlbmRlZC5cbiAqXG4gKiBbTGl2ZSBkZW1vXShodHRwOi8vYmFzaWN3ZWJjb21wb25lbnRzLm9yZy9iYXNpYy13ZWItY29tcG9uZW50cy9wYWNrYWdlcy9iYXNpYy13cmFwcGVkLXN0YW5kYXJkLWVsZW1lbnQvKVxuICpcbiAqIFNlZSBhbHNvIFtiYXNpYy1hdXRvc2l6ZS10ZXh0YXJlYV0oLi4vYmFzaWMtYXV0b3NpemUtdGV4dGFyZWEpIGFuZFxuICogW2Jhc2ljLWN1cnJlbnQtYW5jaG9yXSguLi9iYXNpYy1jdXJyZW50LWFuY2hvcikuIFRoZSBmb3JtZXIgdXNlc1xuICogV3JhcHBlZFN0YW5kYXJkRWxlbWVudCB0byB3cmFwIGEgc3RhbmRhcmQgYDx0ZXh0YXJlYT5gIGFuZCBgPGE+YCxcbiAqIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBUaGUgQ3VzdG9tIEVsZW1lbnRzIHNwZWMgZG9lcyBub3QgY3VycmVudGx5IChhcyBvZiBNYXJjaCAyMDE2KSBhbGxvdyB5b3UgdG9cbiAqIGV4dGVuZCB0aGUgYmVoYXZpb3Igb2YgYSBzdGFuZGFyZCBIVE1MIGVsZW1lbnQgbGlrZSBgPGE+YCBvciBgPGJ1dHRvbj5gLlxuICogQXMgYSBwYXJ0aWFsIHdvcmthcm91bmQsIHRoZSBXcmFwcGVkU3RhbmRhcmRFbGVtZW50IGNsYXNzIGNhbiBjcmVhdGUgYSBjbGFzc1xuICogZm9yIHlvdSB0aGF0IHdyYXBzIGFuIGluc3RhbmNlIG9mIGEgc3RhbmRhcmQgSFRNTCBlbGVtZW50LiBGb3IgZXhhbXBsZSwgdGhlXG4gKiBjb2RlIGJlbG93IGNyZWF0ZXMgYSBjbGFzcyB0aGF0IHdpbGwgd3JhcCBhbiBpbnN0YW5jZSBvZiBhIHN0YW5kYXJkIGA8YT5gXG4gKiBlbGVtZW50OlxuICpcbiAqICAgICBjbGFzcyBXcmFwcGVkQSBleHRlbmRzIFdyYXBwZWRTdGFuZGFyZEVsZW1lbnQud3JhcCgnYScpIHtcbiAqICAgICAgIGN1c3RvbU1ldGhvZCgpIHsgLi4uIH1cbiAqICAgICB9XG4gKiAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCd3cmFwcGVkLWEnLCBXcmFwcGVkQSk7XG4gKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIHJlc3VsdGluZyBjbGFzcyB3aWxsIGxvb2sgdG8gdGhlIHVzZXIgbGlrZSBhbiBpbnN0YW5jZSBvZlxuICogdGhlIHN0YW5kYXJkIGVsZW1lbnQgY2xhc3MgaXQgd3JhcHMuIFRoZSByZXN1bHRpbmcgY2xhc3Mgd2lsbCAqbm90KiBiZSBhblxuICogYGluc3RhbmNlb2ZgIHRoZSBzdGFuZGFyZCBjbGFzcyAoaGVyZSwgSFRNTEFuY2hvckVsZW1lbnQpLiBBbm90aGVyIGxpbWl0YXRpb25cbiAqIGlzIHRoYXQgdGhlIHJlc3VsdGluZyBgPHdyYXBwZWQtYT5gIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgcGljayB1cCBDU1Mgc3R5bGVzXG4gKiBmb3Igc3RhbmRhcmQgYDxhPmAgZWxlbWVudHMuIEhvd2V2ZXIsIHRoZSByZXN1bHRpbmcgY2xhc3MgKmNhbiogYmUgZXh0ZW5kZWQuXG4gKiBFLmcuLCBpbnN0YW5jZXMgb2YgdGhlIGFib3ZlIGNsYXNzIGhhdmUgYSBgY3VzdG9tTWV0aG9kKClgIGF2YWlsYWJsZSB0byB0aGVtLlxuICpcbiAqIEFueSBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIG9yaWdpbmFsIHN0YW5kYXJkIGVsZW1lbnQgd2lsbCBiZSBleHBvc2VkIG9uXG4gKiB0aGUgcmVzdWx0aW5nIHdyYXBwZXIgY2xhc3MsIGFuZCBjYWxscyB0byBnZXQgb3Igc2V0IHRob3NlIHByb3BlcnRpZXMgd2lsbCBiZVxuICogZGVsZWdhdGVkIHRvIHRoZSB3cmFwcGVkIGVsZW1lbnQgaW5zdGFuY2UuIENvbnRpbnVpbmcgdGhlIGFib3ZlIGV4YW1wbGU6XG4gKlxuICogICAgIGxldCB3cmFwcGVkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnd3JhcHBlZC1hJyk7XG4gKiAgICAgd3JhcHBlZC5ocmVmID0gJ2h0dHA6Ly9leGFtcGxlLmNvbS8nO1xuICogICAgIHdyYXBwZWQudGV4dENvbnRlbnQgPSAnQ2xpY2sgaGVyZSc7XG4gKlxuICogSGVyZSwgdGhlIGNyZWF0ZWQgY3VzdG9tIGA8d3JhcHBlZC1hPmAgZWxlbWVudCB3aWxsIGNvbnRhaW4gaW5zaWRlIGl0c1xuICogc2hhZG93IHRyZWUgYW4gaW5zdGFuY2Ugb2YgYSBzdGFuZGFyZCBgPGE+YCBlbGVtZW50LiBUaGUgY2FsbCB0byBzZXQgdGhlXG4gKiB3cmFwcGVyJ3MgYGhyZWZgIHByb3BlcnR5IHdpbGwgdWx0aW1hdGVseSBzZXQgdGhlIGBocmVmYCBvbiB0aGUgaW5uZXIgbGluay5cbiAqIE1vcmVvdmVyLCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBgPHdyYXBwZWQtYT5gIGVsZW1lbnQgd2lsbCBhcHBlYXIgaW5zaWRlXG4gKiB0aGUgaW5uZXIgbGluay4gVGhlIHJlc3VsdCBvZiBhbGwgdGhpcyBpcyB0aGF0IHRoZSB1c2VyIHdpbGwgc2VlIHdoYXQgKmxvb2tzKlxuICogbGlrZSBhIG5vcm1hbCBsaW5rLCBqdXN0IGFzIGlmIHlvdSBoYWQgd3JpdHRlblxuICogYDxhIGhyZWY9XCJodHRwOi8vZXhhbXBsZS5jb20vXCI+Q2xpY2sgaGVyZTwvYT5gLiBIb3dldmVyLCB0aGUgYWN0dWFsIGVsZW1lbnRcbiAqIHdpbGwgYmUgYW4gaW5zdGFuY2Ugb2YgeW91ciBjdXN0b20gY2xhc3MsIHdpdGggd2hhdGV2ZXIgYmVoYXZpb3IgeW91J3ZlXG4gKiBkZWZpbmVkIGZvciBpdC5cbiAqXG4gKiBXcmFwcGVkIGVsZW1lbnRzIHNob3VsZCByYWlzZSB0aGUgc2FtZSBldmVudHMgYXMgdGhlIG9yaWdpbmFsIHN0YW5kYXJkXG4gKiBlbGVtZW50cy4gRS5nLiwgaWYgeW91IHdyYXAgYW4gYDxpbWc+YCBlbGVtZW50LCB0aGUgd3JhcHBlZCByZXN1bHQgd2lsbCByYWlzZVxuICogdGhlIHN0YW5kYXJkIGBsb2FkYCBldmVudCBhcyBleHBlY3RlZC5cbiAqXG4gKiBTb21lIGVsZW1lbnRzLCBzdWNoIGFzIGA8Ym9keT5gLCBgPGh0bWw+YCwgYW5kIGA8c3R5bGU+YCBjYW5ub3QgYmUgd3JhcHBlZFxuICogYW5kIHN0aWxsIGFjaGlldmUgdGhlaXIgc3RhbmRhcmQgYmVoYXZpb3IuXG4gKlxuICogQGV4dGVuZHMgRWxlbWVudEJhc2VcbiAqL1xuY2xhc3MgV3JhcHBlZFN0YW5kYXJkRWxlbWVudCBleHRlbmRzIEVsZW1lbnRCYXNlIHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLy8gTGlzdGVuIGZvciBhbnkgZXZlbnRzIHJhaXNlZCBieSB0aGUgaW5uZXIgZWxlbWVudCB3aGljaCB3aWxsIG5vdFxuICAgIC8vIGF1dG9tYXRpY2FsbHkgYmUgcmV0YXJnZXR0ZWQgYWNyb3NzIHRoZSBTaGFkb3cgRE9NIGJvdW5kYXJ5LCBhbmQgcmUtcmFpc2VcbiAgICAvLyB0aG9zZSBldmVudHMgd2hlbiB0aGV5IGhhcHBlbi5cbiAgICAvL1xuICAgIC8vIE5vdGU6IEl0J3MgdW5jbGVhciB3aHkgd2UgbmVlZCB0byBkbyB0aGlzIGluIHRoZSBTaGFkb3cgRE9NIHBvbHlmaWxsLlxuICAgIC8vIEluIHRoZW9yeSwgZXZlbnRzIGluIHRoZSBsaWdodCBET00gc2hvdWxkIGJ1YmJsZSBhcyBub3JtYWwuIEJ1dCB0aGlzXG4gICAgLy8gY29kZSBhcHBlYXJzIHRvIGJlIHJlcXVpcmVkIGluIHRoZSBwb2x5ZmlsbCBjYXNlIGFzIHdlbGwuXG4gICAgY29uc3QgZXZlbnROYW1lcyA9IHJlcmFpc2VFdmVudHNbdGhpcy5leHRlbmRzXSB8fCBbXTtcbiAgICBldmVudE5hbWVzLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgIHRoaXMuaW5uZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KGV2ZW50TmFtZSwge1xuICAgICAgICAgIGJ1YmJsZXM6IGV2ZW50QnViYmxlc1tldmVudE5hbWVdIHx8IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBkZXNjcmlwdGlvbiBmb3IgdGhlIHVzZXIgb2YgdGhlIGVsZW1lbnQncyBwdXJwb3NlIG9uIHRoZSBwYWdlLiBTZXR0aW5nXG4gICAqIHRoaXMgYXBwbGllcyB0aGUgbGFiZWwgdG8gdGhlIGlubmVyIGVsZW1lbnQsIGVuc3VyaW5nIHRoYXQgc2NyZWVuIHJlYWRlcnNcbiAgICogYW5kIG90aGVyIGFzc2lzdGl2ZSB0ZWNobm9sb2dpZXMgd2lsbCBwcm92aWRlIGEgbWVhbmluZ2Z1bCBkZXNjcmlwdGlvbiB0b1xuICAgKiB0aGUgdXNlci5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBhcmlhTGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5uZXIuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gIH1cbiAgc2V0IGFyaWFMYWJlbChsYWJlbCkge1xuICAgIC8vIFByb3BhZ2F0ZSB0aGUgQVJJQSBsYWJlbCB0byB0aGUgaW5uZXIgdGV4dGFyZWEuXG4gICAgdGhpcy5pbm5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgaW5uZXIgc3RhbmRhcmQgSFRNTCBlbGVtZW50LlxuICAgKlxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBnZXQgaW5uZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuJC5pbm5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgY29waWVkIGludG8gdGhlIHNoYWRvdyB0cmVlIG9mIG5ldyBpbnN0YW5jZXMgb2YgdGhpcyBlbGVtZW50LlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IGlzIGEgdGVtcGxhdGUgdGhhdCBpbmNsdWRlcyBhbiBpbnN0YW5jZVxuICAgKiB0aGUgc3RhbmRhcmQgZWxlbWVudCBiZWluZyB3cmFwcGVkLCB3aXRoIGEgYDxzbG90PmAgZWxlbWVudCBpbnNpZGUgdGhhdFxuICAgKiB0byBwaWNrIHVwIHRoZSBlbGVtZW50J3MgbGlnaHQgRE9NIGNvbnRlbnQuIEZvciBleGFtcGxlLCBpZiB5b3Ugd3JhcCBhblxuICAgKiBgPGE+YCBlbGVtZW50LCB0aGVuIHRoZSBkZWZhdWx0IHRlbXBsYXRlIHdpbGwgbG9vayBsaWtlOlxuICAgKlxuICAgKiAgICAgPHRlbXBsYXRlPlxuICAgKiAgICAgICA8c3R5bGU+XG4gICAqICAgICAgIDpob3N0IHtcbiAgICogICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAqICAgICAgIH1cbiAgICogICAgICAgPC9zdHlsZT5cbiAgICogICAgICAgPGEgaWQ9XCJpbm5lclwiPlxuICAgKiAgICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICogICAgICAgPC9hPlxuICAgKiAgICAgPC90ZW1wbGF0ZT5cbiAgICpcbiAgICogVGhlIGBkaXNwbGF5YCBzdHlsaW5nIGFwcGxpZWQgdG8gdGhlIGhvc3Qgd2lsbCBiZSBgYmxvY2tgIGZvciBlbGVtZW50cyB0aGF0XG4gICAqIGFyZSBibG9jayBlbGVtZW50cyBieSBkZWZhdWx0LCBhbmQgYGlubGluZS1ibG9ja2AgKG5vdCBgaW5saW5lYCkgZm9yIG90aGVyXG4gICAqIGVsZW1lbnRzLlxuICAgKlxuICAgKiBJZiB5b3UnZCBsaWtlIHRoZSB0ZW1wbGF0ZSB0byBpbmNsdWRlIG90aGVyIGVsZW1lbnRzLCB0aGVuIG92ZXJyaWRlIHRoaXNcbiAgICogcHJvcGVydHkgYW5kIHJldHVybiBhIHRlbXBsYXRlIG9mIHlvdXIgb3duLiBUaGUgdGVtcGxhdGUgc2hvdWxkIGluY2x1ZGUgYW5cbiAgICogaW5zdGFuY2Ugb2YgdGhlIHN0YW5kYXJkIEhUTUwgZWxlbWVudCB5b3UgYXJlIHdyYXBwaW5nLCBhbmQgdGhlIElEIG9mIHRoYXRcbiAgICogZWxlbWVudCBzaG91bGQgYmUgXCJpbm5lclwiLlxuICAgKlxuICAgKiBAdHlwZSB7KHN0cmluZ3xIVE1MVGVtcGxhdGVFbGVtZW50KX1cbiAgICovXG4gIGdldCBbc3ltYm9scy50ZW1wbGF0ZV0oKSB7XG4gICAgY29uc3QgZGlzcGxheSA9IGJsb2NrRWxlbWVudHMuaW5kZXhPZih0aGlzLmV4dGVuZHMpID49IDAgP1xuICAgICAgJ2Jsb2NrJyA6XG4gICAgICAnaW5saW5lLWJsb2NrJztcbiAgICByZXR1cm4gYDxzdHlsZT46aG9zdCB7IGRpc3BsYXk6ICR7ZGlzcGxheX19PC9zdHlsZT48JHt0aGlzLmV4dGVuZHN9IGlkPVwiaW5uZXJcIj48c2xvdD48L3Nsb3Q+PC8ke3RoaXMuZXh0ZW5kc31gO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbGFzcyB0aGF0IHdyYXBzIGEgc3RhbmRhcmQgSFRNTCBlbGVtZW50LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIHJlc3VsdGluZyBjbGFzcyBpcyBhIHN1YmNsYXNzIG9mIFdyYXBwZWRTdGFuZGFyZEVsZW1lbnQsIG5vdFxuICAgKiB0aGUgc3RhbmRhcmQgY2xhc3MgYmVpbmcgd3JhcHBlZC4gRS5nLiwgaWYgeW91IGNhbGxcbiAgICogYFdyYXBwZWRTdGFuZGFyZEVsZW1lbnQud3JhcCgnYScpYCwgeW91IHdpbGwgZ2V0IGEgY2xhc3Mgd2hvc2Ugc2hhZG93IHRyZWVcbiAgICogd2lsbCBpbmNsdWRlIGFuIGFuY2hvciBlbGVtZW50LCBidXQgdGhlIGNsYXNzIHdpbGwgKm5vdCogaW5oZXJpdCBmcm9tXG4gICAqIEhUTUxBbmNob3JFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXh0ZW5kc1RhZyAtIHRoZSBzdGFuZGFyZCBIVE1MIGVsZW1lbnQgdGFnIHRvIGV4dGVuZFxuICAgKi9cbiAgc3RhdGljIHdyYXAoZXh0ZW5kc1RhZykge1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBuZXcgY2xhc3MuXG4gICAgY2xhc3MgV3JhcHBlZCBleHRlbmRzIFdyYXBwZWRTdGFuZGFyZEVsZW1lbnQge31cblxuICAgIC8vIEluZGljYXRlIHdoaWNoIHRhZyBpdCB3cmFwcy5cbiAgICBXcmFwcGVkLnByb3RvdHlwZS5leHRlbmRzID0gZXh0ZW5kc1RhZztcblxuICAgIC8vIENyZWF0ZSBnZXR0ZXIvc2V0dGVycyB0aGF0IGRlbGVnYXRlIHRvIHRoZSB3cmFwcGVkIGVsZW1lbnQuXG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZXh0ZW5kc1RhZyk7XG4gICAgY29uc3QgZXh0ZW5kc1Byb3RvdHlwZSA9IGVsZW1lbnQuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXh0ZW5kc1Byb3RvdHlwZSk7XG4gICAgbmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZXh0ZW5kc1Byb3RvdHlwZSwgbmFtZSk7XG4gICAgICAgIGNvbnN0IGRlbGVnYXRlID0gY3JlYXRlUHJvcGVydHlEZWxlZ2F0ZShuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWQucHJvdG90eXBlLCBuYW1lLCBkZWxlZ2F0ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gV3JhcHBlZDtcbiAgfVxuXG59XG5cblxuZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlEZWxlZ2F0ZShuYW1lLCBkZXNjcmlwdG9yKSB7XG4gIGNvbnN0IGRlbGVnYXRlID0ge1xuICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICB9O1xuICBpZiAoZGVzY3JpcHRvci5nZXQpIHtcbiAgICBkZWxlZ2F0ZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmlubmVyW25hbWVdO1xuICAgIH07XG4gIH1cbiAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgZGVsZWdhdGUuc2V0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMuaW5uZXJbbmFtZV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG4gIGlmIChkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgZGVsZWdhdGUud3JpdGFibGUgPSBkZXNjcmlwdG9yLndyaXRhYmxlO1xuICB9XG4gIHJldHVybiBkZWxlZ2F0ZTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkU3RhbmRhcmRFbGVtZW50O1xuIl19"}