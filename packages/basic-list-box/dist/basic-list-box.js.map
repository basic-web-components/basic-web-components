{"version":3,"sources":["node_modules/browser-pack/_prelude.js","packages/basic-component-mixins/src/AttributeMarshallingMixin.js","packages/basic-component-mixins/src/ClickSelectionMixin.js","packages/basic-component-mixins/src/ComposableMixin.js","packages/basic-component-mixins/src/ContentItemsMixin.js","packages/basic-component-mixins/src/DirectionSelectionMixin.js","packages/basic-component-mixins/src/DistributedChildrenContentMixin.js","packages/basic-component-mixins/src/DistributedChildrenMixin.js","packages/basic-component-mixins/src/GenericMixin.js","packages/basic-component-mixins/src/KeyboardDirectionMixin.js","packages/basic-component-mixins/src/KeyboardMixin.js","packages/basic-component-mixins/src/KeyboardPagedSelectionMixin.js","packages/basic-component-mixins/src/KeyboardPrefixSelectionMixin.js","packages/basic-component-mixins/src/SelectedItemTextValueMixin.js","packages/basic-component-mixins/src/SelectionAriaActiveMixin.js","packages/basic-component-mixins/src/SelectionHighlightMixin.js","packages/basic-component-mixins/src/SelectionInViewMixin.js","packages/basic-component-mixins/src/ShadowElementReferencesMixin.js","packages/basic-component-mixins/src/ShadowTemplateMixin.js","packages/basic-component-mixins/src/SingleSelectionMixin.js","packages/basic-component-mixins/src/createSymbol.js","packages/basic-component-mixins/src/microtask.js","packages/basic-component-mixins/src/safeAttributes.js","packages/basic-component-mixins/src/symbols.js","packages/basic-component-mixins/src/toggleClass.js","packages/basic-element-base/src/ElementBase.js","packages/basic-list-box/globals.js","packages/basic-list-box/src/ListBox.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","attributeToPropertyName","attributeName","propertyName","attributeToPropertyNames","hypenRegEx","replace","match","toUpperCase","attributesForClass","classFn","HTMLElement","Object","baseClass","getPrototypeOf","prototype","constructor","baseAttributes","propertyNames","getOwnPropertyNames","setterNames","filter","getOwnPropertyDescriptor","set","attributes","map","setterName","propertyNameToAttribute","diff","attribute","indexOf","concat","propertyNamesToAttributes","uppercaseRegEx","toLowerCase","_safeAttributes","base","AttributeMarshalling","_base","_classCallCheck","this","_possibleConstructorReturn","__proto__","apply","arguments","_inherits","_createClass","key","value","oldValue","newValue","_get","_safeAttributes2","default","connected","setAttribute","className","toggleClass","get","indexOfContainingItem","element","target","items","itemCount","item","contains","_symbols","ClickSelection","_this","addEventListener","event","_symbols2","handlingUserInteraction","path","index","selectedIndex","stopPropagation","_set","composeClass","mixin","Subclass","_base2","copyOwnProperties","NON_MIXABLE_OBJECT_PROPERTIES","source","ignorePropertyNames","undefined","forEach","name","descriptor","defineProperty","Composable","_len","mixins","Array","_key","reduce","filterAuxiliaryElements","auxiliaryTags","localName","_createSymbol","_toggleClass","itemsSymbol","_createSymbol2","itemInitializedSymbol","ContentItems","itemsChanged","itemAdded","itemSelected","selected","_toggleClass2","_this2","dispatchEvent","CustomEvent","content","DirectionSelection","goDown","selectNext","goEnd","selectLast","goLeft","selectPrevious","goRight","goStart","selectFirst","goUp","selectedFraction","_microtask","DistributedChildrenContent","shadowRoot","slots","querySelectorAll","slot","contentChanged","_microtask2","distributedChildren","console","warn","expandContentElements","nodes","includeTextNodes","_ref","expanded","node","isSlot","HTMLSlotElement","assignedNodes","flatten","Text","flattened","_toConsumableArray","DistributedChildren","children","childNodes","strings","distributedChildNodes","child","textContent","join","genericSymbol","Generic","generic","defaults","parsed","String","removeAttribute","navigationAxisSymbol","KeyboardDirection","navigationAxis","keydown","handled","axis","horizontal","vertical","keyCode","metaKey","altKey","Keyboard","preventDefault","getAttribute","tabindex","getIndexOfItemAtY","y","downward","start","end","step","scrollTarget","topOfClientArea","offsetTop","clientTop","itemIndex","itemTop","found","itemBottom","offsetHeight","itemStyle","getComputedStyle","itemPaddingTop","parseFloat","paddingTop","itemPaddingBottom","paddingBottom","contentTop","contentBottom","clientHeight","scrollOnePage","edge","scrollTop","indexOfItemAtEdge","newIndex","delta","KeyboardPagedSelection","pageUp","pageDown","getIndexOfItemWithTextPrefix","prefix","itemTextContents","getItemTextContents","prefixLength","itemTextContent","substr","itemTextContentsSymbol","text","alt","handleBackspace","typedPrefixSymbol","selectItemWithTextPrefix","setPrefixTimeout","handlePlainCharacter","char","resetPrefixTimeout","prefixTimeoutSymbol","clearTimeout","resetTypedPrefix","setTimeout","PREFIX_TIMEOUT_DURATION","KeyboardPrefixSelection","resetPrefix","ctrlKey","which","fromCharCode","SelectedItemTextValue","selectedItem","currentIndex","idCount","SelectionAriaActive","role","id","baseId","itemId","SelectionHighlight","template","baseTemplate","SelectionInView","scrollItemIntoView","elementTop","elementBottom","scrollBottom","ShadowElementReferences","$","nodesWithIds","createTemplateWithInnerHTML","innerHTML","document","createElement","div","appendChild","shimTemplateStyles","tag","window","WebComponents","ShadowCSS","shimStyling","ShadowTemplate","ShadowDOMPolyfill","root","attachShadow","mode","clone","importNode","selectIndex","count","boundedIndex","selectionWraps","Math","max","min","previousIndex","trackSelectedItem","previousSelectedItem","indexInCurrentItems","previousSelectedIndex","newSelectedIndex","selectionRequired","updatePossibleNavigations","canSelectNext","canSelectPrevious","canSelectNextSymbol","canSelectPreviousSymbol","selectionRequiredSymbol","selectionWrapsSymbol","externalSelectedIndexSymbol","externalSelectedItemSymbol","internalSelectedIndexSymbol","internalSelectedItemSymbol","SingleSelection","previousCanSelectNext","previousCanSelectPrevious","hasItems","detail","createSymbol","description","Symbol","microtask","callback","callbacks","push","counter","executeCallbacks","shift","createTextNode","observer","MutationObserver","observe","characterData","setAttributeToElement","safeToSetAttributesSymbol","pendingAttributesSymbol","pendingClassesSymbol","_value","_toggleClass3","symbols","dragging","force","classList","addClass","add","remove","_AttributeMarshallingMixin","_ComposableMixin","_DistributedChildrenMixin","_ShadowElementReferencesMixin","_ShadowTemplateMixin","ElementBase","_ComposableMixin2","compose","_ShadowTemplateMixin2","_ShadowElementReferencesMixin2","_AttributeMarshallingMixin2","_DistributedChildrenMixin2","_ListBox","Basic","ListBox","_ListBox2","_ElementBase","_DistributedChildrenContentMixin","_ClickSelectionMixin","_ContentItemsMixin","_DirectionSelectionMixin","_GenericMixin","_KeyboardMixin","_KeyboardDirectionMixin","_KeyboardPagedSelectionMixin","_KeyboardPrefixSelectionMixin","_SelectedItemTextValueMixin","_SelectionAriaActiveMixin","_SelectionHighlightMixin","_SelectionInViewMixin","_SingleSelectionMixin","itemsContainer","_ElementBase2","_ClickSelectionMixin2","_ContentItemsMixin2","_DirectionSelectionMixin2","_DistributedChildrenContentMixin2","_GenericMixin2","_KeyboardMixin2","_KeyboardDirectionMixin2","_KeyboardPagedSelectionMixin2","_KeyboardPrefixSelectionMixin2","_SelectedItemTextValueMixin2","_SelectionAriaActiveMixin2","_SelectionHighlightMixin2","_SelectionInViewMixin2","_SingleSelectionMixin2","customElements","define"],"mappings":"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","file":"basic-list-box.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import safeAttributes from './safeAttributes';\n\n\n// Memoized maps of attribute to property names and vice versa.\nconst attributeToPropertyNames = {};\nconst propertyNamesToAttributes = {};\n\n\n/* Exported function extends a base class with AttributeMarshalling. */\nexport default (base) => {\n\n  /**\n   * Mixin which marshalls attributes to properties and vice versa.\n   *\n   * If your component exposes a setter for a property, it's generally a good\n   * idea to let devs using your component be able to set that property in HTML\n   * via an element attribute. You can code that yourself by writing an\n   * `attributeChangedCallback`, or you can use this mixin to get a degree of\n   * automatic support.\n   *\n   * This mixin implements an `attributeChangedCallback` that will attempt to\n   * convert a change in an element attribute into a call to the corresponding\n   * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n   * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n   * respects that convention, automatically mapping the hyphenated attribute\n   * name to the corresponding camelCase property name.\n   *\n   * Example: You define a component using this mixin:\n   *\n   *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n   *       get fooBar() { return this._fooBar; }\n   *       set fooBar(value) { this._fooBar = value; }\n   *     }\n   *     customElements.define('my-element', MyElement);\n   *\n   * If someone then instantiates your component in HTML:\n   *\n   *     <my-element foo-bar=\"Hello\"></my-element>\n   *\n   * Then, after the element has been upgraded, the `fooBar` setter will\n   * automatically be invoked with the initial value \"Hello\".\n   *\n   * For the time being, this mixin only supports string-valued properties.\n   * If you'd like to convert string attributes to other types (numbers,\n   * booleans), you need to implement `attributeChangedCallback` yourself.\n   */\n  class AttributeMarshalling extends base {\n\n    /*\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n      const propertyName = attributeToPropertyName(attributeName);\n      // If the attribute name corresponds to a property name, set the property.\n      // Ignore standard HTMLElement properties handled by the DOM.\n      if (propertyName in this && !(propertyName in HTMLElement.prototype)) {\n        this[propertyName] = newValue;\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    static get observedAttributes() {\n      return attributesForClass(this);\n    }\n\n    /**\n     * Set/unset the attribute with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as an attribute. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes. A call to `reflectAttribute` during the constructor will\n     * be deferred until the element is connected to the document.\n     *\n     * @param {string} attribute - The name of the *attribute* (not property) to set.\n     * @param {object} value - The value to set. If null, the attribute will be removed.\n     */\n    reflectAttribute(attribute, value) {\n      return safeAttributes.setAttribute(this, attribute, value);\n    }\n\n    /**\n     * Set/unset the class with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as as class. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes, including the `class` attribute. A call to\n     * `reflectClass` during the constructor will be deferred until the element\n     * is connected to the document.\n     *\n     * @param {string} className - The name of the class to set.\n     * @param {object} value - True to set the class, false to remove it.\n     */\n    reflectClass(className, value) {\n      return safeAttributes.toggleClass(this, className, value);\n    }\n\n  }\n\n  return AttributeMarshalling;\n};\n\n\n// Convert hyphenated foo-bar attribute name to camel case fooBar property name.\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hypenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hypenRegEx,\n        match => match[1].toUpperCase());\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\nfunction attributesForClass(classFn) {\n\n  // We treat the element base classes as if they have no attributes, since we\n  // don't want to receive attributeChangedCallback for them.\n  if (classFn === HTMLElement || classFn === Object) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n  const baseAttributes = attributesForClass(baseClass);\n\n  // Get attributes for this class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter(propertyName =>\n    typeof Object.getOwnPropertyDescriptor(\n        classFn.prototype, propertyName).set === 'function');\n  const attributes = setterNames.map(setterName =>\n      propertyNameToAttribute(setterName));\n\n  // Merge.\n  const diff = attributes.filter(attribute =>\n      baseAttributes.indexOf(attribute) < 0);\n  return baseAttributes.concat(diff);\n}\n\n// Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, '-$1').toLowerCase();\n  }\n  return attribute;\n}\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with ClickSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps a click (actually, a mousedown) to a selection.\n   *\n   * This simple mixin is useful in list box-like elements, where a click on a\n   * list item implicitly selects it.\n   *\n   * This mixin expects the component to provide an `items` property. You can\n   * provide that property yourself, or use\n   * [ContentItemsMixin](ContentItemsMixin.md). This mixin also expects the\n   * component to define a `selectedIndex` property. You can provide that\n   * yourself, or use [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class ClickSelection extends base {\n\n    constructor() {\n      super();\n      /*\n       * REVIEW: Which event should we listen to here?\n       *\n       * The standard use for this mixin is in list boxes. List boxes don't\n       * appear to be consistent with regard to whether they select on mousedown\n       * or click/mouseup.\n       */\n      this.addEventListener('mousedown', event => {\n        this[symbols.handlingUserInteraction] = true;\n        // HACK: If the item is a button, the event seems to be raised in\n        // phase 2 (AT_TARGET), but the target is the component, not item.\n        // Need to invesigate.\n        const target = event.target === this ?\n          event.path[0] :\n          event.target;\n        const index = indexOfContainingItem(this, target);\n        if (index >= 0) {\n          this.selectedIndex = index;\n          // Note: We don't call preventDefault here. The default behavior for\n          // mousedown includes setting keyboard focus if the element doesn't\n          // already have the focus, and we want to preserve that behavior.\n          event.stopPropagation();\n        }\n        this[symbols.handlingUserInteraction] = false;\n      });\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n    }\n\n  }\n\n  return ClickSelection;\n};\n\n\n/*\n * Return index of the element items that either is or contains the indicated\n * target. Return -1 if not found.\n */\nfunction indexOfContainingItem(element, target) {\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n  for (let i = 0; i < itemCount; i++) {\n    let item = items[i];\n    if (item === target || item.contains(target)) {\n      return i;\n    }\n  }\n  return -1;\n}\n","/* Exported function extends a base class with Composable. */\nexport default (base) => {\n\n  /**\n   * Mixin to make a class more easily composable with other mixins.\n   *\n   * This mixin contributes a `compose` method that applies a set of mixin\n   * functions and returns the resulting new class. This sugar can make the\n   * application of many mixins at once easier to read.\n   */\n  class Composable extends base {\n\n    /**\n     * Apply a set of mixin functions or mixin objects to the present class and\n     * return the new class.\n     *\n     * Instead of writing:\n     *\n     *     let MyClass = Mixin1(Mixin2(Mixin3(Mixin4(Mixin5(BaseClass)))));\n     *\n     * You can write:\n     *\n     *     let MyClass = ComposableMixin(BaseClass).compose(\n     *       Mixin1,\n     *       Mixin2,\n     *       Mixin3,\n     *       Mixin4,\n     *       Mixin5\n     *     );\n     *\n     * This function can also take mixin objects. A mixin object is just a\n     * shorthand for a mixin function that creates a new subclass with the given\n     * members. The mixin object's members are *not* copied directly onto the\n     * prototype of the base class, as with traditional mixins.\n     *\n     * In addition to providing syntactic sugar, this mixin can be used to\n     * define a class in ES5, which lacks ES6's `class` keyword.\n     *\n     * @param {...mixins} mixins - A set of mixin functions or objects to apply.\n     */\n    static compose(...mixins) {\n      // We create a new subclass for each mixin in turn. The result becomes\n      // the base class extended by any subsequent mixins. It turns out that\n      // we can use Array.reduce() to concisely express this, using the current\n      // object as the seed for reduce().\n      return mixins.reduce(composeClass, this);\n    }\n\n  }\n\n  return Composable;\n};\n\n\n// Properties defined by Object that we don't want to mixin.\nconst NON_MIXABLE_OBJECT_PROPERTIES = [\n  'constructor'\n];\n\n/*\n * Apply the mixin to the given base class to return a new class.\n * The mixin can either be a function that returns the modified class, or a\n * plain object whose members will be copied to the new class' prototype.\n */\nfunction composeClass(base, mixin) {\n  if (typeof mixin === 'function') {\n    // Mixin function\n    return mixin(base);\n  } else {\n    // Mixin object\n    class Subclass extends base {}\n    copyOwnProperties(mixin, Subclass.prototype, NON_MIXABLE_OBJECT_PROPERTIES);\n    return Subclass;\n  }\n}\n\n\n/*\n * Copy the given properties/methods to the target.\n * Return the updated target.\n */\nfunction copyOwnProperties(source, target, ignorePropertyNames = []) {\n  Object.getOwnPropertyNames(source).forEach(name => {\n    if (ignorePropertyNames.indexOf(name) < 0) {\n      const descriptor = Object.getOwnPropertyDescriptor(source, name);\n      Object.defineProperty(target, name, descriptor);\n    }\n  });\n  return target;\n}\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemsSymbol = createSymbol('items');\nconst itemInitializedSymbol = createSymbol('itemInitialized');\n\n\n/* Exported function extends a base class with ContentItems. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps content semantics (elements) to list item semantics.\n   *\n   * Items differ from element contents in several ways:\n   *\n   * * They are often referenced via index.\n   * * They may have a selection state.\n   * * It's common to do work to initialize the appearance or state of a new\n   *   item.\n   * * Auxiliary invisible child elements are filtered out and not counted as\n   *   items. Auxiliary elements include link, script, style, and template\n   *   elements. This filtering ensures that those auxiliary elements can be\n   *   used in markup inside of a list without being treated as list items.\n   *\n   * This mixin expects a component to provide a `content` property returning a\n   * raw set of elements. You can provide that yourself, or use\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md).\n   *\n   * The most commonly referenced property defined by this mixin is the `items`\n   * property. To avoid having to do work each time that property is requested,\n   * this mixin supports an optimized mode. If you invoke the `contentChanged`\n   * method when the set of items changes, the mixin concludes that you'll take\n   * care of notifying it of future changes, and turns on the optimization. With\n   * that on, the mixin saves a reference to the computed set of items, and will\n   * return that immediately on subsequent calls to the `items` property. If you\n   * use this mixin in conjunction with\n   * [DistributedChildrenContentMixin](DistributedChildrenContentMixin.md), the\n   * `contentChanged` method will be invoked for you when the element's children\n   * change, turning on the optimization automatically.\n   */\n  class ContentItems extends base {\n\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n\n      // Since we got the contentChanged call, we'll assume we'll be notified if\n      // the set of items changes later. We turn on memoization of the items\n      // property by setting our internal property to null (instead of\n      // undefined).\n      this[itemsSymbol] = null;\n\n      this[symbols.itemsChanged]();\n    }\n\n    /**\n     * This method is invoked whenever a new item is added to the list.\n     *\n     * The default implementation of this method does nothing. You can override\n     * this to perform per-item initialization.\n     *\n     * @param {HTMLElement} item - The item that was added.\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n    }\n\n    /**\n     * The selection state for a single item has changed.\n     *\n     * Invoke this method to signal that the selected state of the indicated item\n     * has changed. By default, this applies a `selected` CSS class if the item\n     * is selected, and removed it if not selected.\n     *\n     * @param {HTMLElement} item - The item whose selection state has changed.\n     * @param {boolean} selected - True if the item is selected, false if not.\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      toggleClass(item, 'selected', selected);\n    }\n\n    /**\n     * The current set of items in the list. See the top-level documentation for\n     * mixin for a description of how items differ from plain content.\n     *\n     * @type {HTMLElement[]}\n     */\n    get items() {\n      let items;\n      if (this[itemsSymbol] == null) {\n        items = filterAuxiliaryElements(this.content);\n        // Note: test for *equality* with null; don't treat undefined as a match.\n        if (this[itemsSymbol] === null) {\n          // Memoize the set of items.\n          this[itemsSymbol] = items;\n        }\n      } else {\n        // Return the memoized items.\n        items = this[itemsSymbol];\n      }\n      return items;\n    }\n\n    /**\n     * This method is invoked when the underlying contents change. It is also\n     * invoked on component initialization – since the items have \"changed\" from\n     * being nothing.\n     */\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // Perform per-item initialization.\n      Array.prototype.forEach.call(this.items, item => {\n        if (!item[itemInitializedSymbol]) {\n          this[symbols.itemAdded](item);\n          item[itemInitializedSymbol] = true;\n        }\n      });\n\n      if (this[symbols.handlingUserInteraction]) {\n        this.dispatchEvent(new CustomEvent('items-changed'));\n      }\n    }\n\n    /**\n     * Fires when the items in the list change.\n     *\n     * @memberof ContentItems\n     * @event items-changed\n     */\n  }\n\n  return ContentItems;\n};\n\n\n// Return the given elements, filtering out auxiliary elements that aren't\n// typically visible. Items which are not elements are returned as is.\nfunction filterAuxiliaryElements(items) {\n  const auxiliaryTags = [\n    'link',\n    'script',\n    'style',\n    'template'\n  ];\n  return [].filter.call(items, function(item) {\n    return !item.localName || auxiliaryTags.indexOf(item.localName) < 0;\n  });\n}\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with DirectionSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps direction semantics (goLeft, goRight, etc.) to selection\n   * semantics (selectPrevious, selectNext, etc.).\n   *\n   * This mixin can be used in conjunction with\n   * [KeyboardDirectionMixin](KeyboardDirectionMixin.md) (which maps keyboard\n   * events to directions) and a mixin that handles selection like\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class DirectionSelection extends base {\n\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { super[symbols.goDown](); }\n      return this.selectNext();\n    }\n\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { super[symbols.goEnd](); }\n      return this.selectLast();\n    }\n\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { super[symbols.goLeft](); }\n      return this.selectPrevious();\n    }\n\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { super[symbols.goRight](); }\n      return this.selectNext();\n    }\n\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { super[symbols.goStart](); }\n      return this.selectFirst();\n    }\n\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { super[symbols.goUp](); }\n      return this.selectPrevious();\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    get selectedFraction() {\n      return super.selectedFraction;\n    }\n    set selectedFraction(value) {\n      if ('selectedFraction' in base.prototype) { super.selectedFraction = value; }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectFirst() {\n      if (super.selectFirst) { return super.selectFirst(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectLast() {\n      if (super.selectLast) { return super.selectLast(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectNext() {\n      if (super.selectNext) { return super.selectNext(); }\n    }\n\n    // Default implementation. This will typically be handled by other mixins.\n    selectPrevious() {\n      if (super.selectPrevious) { return super.selectPrevious(); }\n    }\n\n    // Map drag travel fraction to selection fraction.\n    get travelFraction() {\n      return super.travelFraction;\n    }\n    set travelFraction(value) {\n      if ('travelFraction' in base.prototype) { super.travelFraction = value; }\n      this.selectedFraction = value;\n    }\n\n  }\n\n  return DirectionSelection;\n};\n","import microtask from './microtask';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/* Exported function extends a base class with DistributedChildrenContent. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines a component's content as its children, expanding any\n   * nodes distributed to the component's slots.\n   *\n   * This also provides notification of changes to a component's content. It\n   * will invoke a `contentChanged` method when the component is first\n   * instantiated, and whenever its distributed children change. This is an\n   * easy way to satisfy the Gold Standard checklist item for monitoring\n   * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n   *\n   * Example:\n   *\n   * ```\n   * let base = DistributedChildrenContentMixin(DistributedChildrenMixin(HTMLElement));\n   * class CountingElement extends base {\n   *\n   *   constructor() {\n   *     super();\n   *     let root = this.attachShadow({ mode: 'open' });\n   *     root.innerHTML = `<slot></slot>`;\n   *   }\n   *\n   *   contentChanged() {\n   *     // Count the component's children, both initially and when changed.\n   *     this.count = this.distributedChildren.length;\n   *   }\n   *\n   * }\n   * ```\n   *\n   * Note that content change detection depends upon the element having at least\n   * one `slot` element in its shadow subtree.\n   *\n   * This mixin is intended for use with the\n   * [DistributedChildrenMixin](DistributedChildrenMixin.md). See that mixin for\n   * a discussion of how that works. This DistributedChildrenContentMixin\n   * provides an easy way of defining the \"content\" of a component as the\n   * component's distributed children. That in turn lets mixins like\n   * [ContentItemsMixin](ContentItemsMixin.md) manipulate the children as list\n   * items.\n   */\n  class DistributedChildrenContent extends base {\n\n    constructor() {\n      super();\n\n      if (this.shadowRoot) {\n        // Listen to changes on all slots.\n        const slots = this.shadowRoot.querySelectorAll('slot');\n        slots.forEach(slot => slot.addEventListener('slotchange', event => {\n          this.contentChanged();\n        }));\n      }\n\n      // Make an initial call to contentChanged() so that the component can do\n      // initialization that it normally does when content changes.\n      //\n      // This will invoke contentChanged() handlers in other mixins. In order\n      // that those mixins have a chance to complete their own initialization,\n      // we add the contentChanged() call to the microtask queue.\n      microtask(() => this.contentChanged());\n    }\n\n    /**\n     * Invoked when the contents of the component (including distributed\n     * children) have changed.\n     *\n     * This method is also invoked when a component is first instantiated; the\n     * contents have essentially \"changed\" from being nothing. This allows the\n     * component to perform initial processing of its children.\n     */\n    contentChanged() {\n      if (super.contentChanged) { super.contentChanged(); }\n      if (this[symbols.handlingUserInteraction]) {\n        const event = new CustomEvent('content-changed');\n        this.dispatchEvent(event);\n      }\n    }\n\n    /**\n     * The content of this component, defined to be the flattened array of\n     * children distributed to the component.\n     *\n     * @type {HTMLElement[]}\n     */\n    get content() {\n      const distributedChildren = this.distributedChildren;\n      if (typeof distributedChildren === 'undefined') {\n        console.warn(`DistributedChildrenContentMixin expects the component to define a \"distributedChildren\" property.`);\n      }\n      return distributedChildren;\n    }\n    set content(value) {\n      if ('content' in base.prototype) { super.content = value; }\n      // TODO: Set the children to the given value (which should be an array of\n      // elements)?\n    }\n\n    /**\n     * This event is raised when the component's contents (including distributed\n     * children) have changed.\n     *\n     * @memberof DistributedChildrenContent\n     * @event content-changed\n     */\n  }\n\n  return DistributedChildrenContent;\n};\n","/* Exported function extends a base class with DistributedChildren. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines helpers for accessing a component's distributed\n   * children as a flattened array or string.\n   *\n   * The standard DOM API provides several ways of accessing child content:\n   * `children`, `childNodes`, and `textContent`. None of these functions are\n   * Shadow DOM aware. This mixin defines variations of those functions that\n   * *are* Shadow DOM aware.\n   *\n   * Example: you create a component `<count-children>` that displays a number\n   * equal to the number of children placed inside that component. If someone\n   * instantiates your component like:\n   *\n   *     <count-children>\n   *       <div></div>\n   *       <div></div>\n   *       <div></div>\n   *     </count-children>\n   *\n   * Then the component should show \"3\", because there are three children. To\n   * calculate the number of children, the component can just calculate\n   * `this.children.length`. However, suppose someone instantiates your\n   * component inside one of their own components, and puts a `<slot>` element\n   * inside your component:\n   *\n   *     <count-children>\n   *       <slot></slot>\n   *     </count-children>\n   *\n   * If your component only looks at `this.children`, it will always see exactly\n   * one child — the `<slot>` element. But the user looking at the page will\n   * *see* any nodes distributed to that slot. To match what the user sees, your\n   * component should expand any `<slot>` elements it contains.\n   *\n   * That is the problem this mixin solves. After applying this mixin, your\n   * component code has access to `this.distributedChildren`, whose `length`\n   * will return the total number of all children distributed to your component\n   * in the composed tree.\n   *\n   * Note: The latest Custom Elements API design calls for a new function,\n   * `getAssignedNodes` that takes an optional `deep` parameter, that will solve\n   * this problem at the API level.\n   */\n  class DistributedChildren extends base {\n\n    /**\n     * An in-order collection of distributed children, expanding any slot\n     * elements. Like the standard children property, this skips text nodes.\n     *\n     * @type {HTMLElement[]}\n     */\n    get distributedChildren() {\n      return expandContentElements(this.children, false);\n    }\n\n    /**\n     * An in-order collection of distributed child nodes, expanding any slot\n     * elements. Like the standard childNodes property, this includes text\n     * nodes.\n     *\n     * @type {Node[]}\n     */\n    get distributedChildNodes() {\n      return expandContentElements(this.childNodes, true);\n    }\n\n    /**\n     * The concatenated text content of all distributed child nodes, expanding\n     * any slot elements.\n     *\n     * @type {string}\n     */\n    get distributedTextContent() {\n      const strings = this.distributedChildNodes.map(function(child) {\n        return child.textContent;\n      });\n      return strings.join('');\n    }\n\n  }\n\n  return DistributedChildren;\n};\n\n\n/*\n * Given a array of nodes, return a new array with any content elements expanded\n * to the nodes distributed to that content element. This rule is applied\n * recursively.\n *\n * If includeTextNodes is true, text nodes will be included, as in the\n * standard childNodes property; by default, this skips text nodes, like the\n * standard children property.\n */\nfunction expandContentElements(nodes, includeTextNodes) {\n  const expanded = Array.prototype.map.call(nodes, node => {\n    // We want to see if the node is an instanceof HTMLSlotELement, but\n    // that class won't exist if the browser that doesn't support native\n    // Shadow DOM and if the Shadow DOM polyfill hasn't been loaded. Instead,\n    // we do a simplistic check to see if the tag name is \"slot\".\n    const isSlot = typeof HTMLSlotElement !== 'undefined' ?\n      node instanceof HTMLSlotElement :\n      node.localName === 'slot';\n    if (isSlot) {\n      // Use the nodes assigned to this node instead.\n      const assignedNodes = node.assignedNodes({ flatten: true });\n      return assignedNodes ?\n        expandContentElements(assignedNodes, includeTextNodes) :\n        [];\n    } else if (node instanceof HTMLElement) {\n      // Plain element; use as is.\n      return [node];\n    } else if (node instanceof Text && includeTextNodes) {\n      // Text node.\n      return [node];\n    } else {\n      // Comment, processing instruction, etc.; skip.\n      return [];\n    }\n  });\n  const flattened = [].concat(...expanded);\n  return flattened;\n}\n","import createSymbol from './createSymbol';\nimport safeAttributes from './safeAttributes';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst genericSymbol = createSymbol('generic');\n\n\n/* Exported function extends a base class with Generic. */\nexport default (base) => {\n\n  /**\n   * Mixin which allows a component to support a \"generic\" style: a minimalist\n   * style that can easily be removed to reset its visual appearance to a\n   * baseline state.\n   *\n   * By default, a component should provide a minimal visual presentation that\n   * allows the component to function. However, the more styling the component\n   * provides by default, the harder it becomes to get the component to fit in\n   * in other settings. Each CSS rule has to be overridden. Worse, new CSS rules\n   * added to the default style won't be overridden by default, making it hard\n   * to know whether a new version of a component will still look okay.\n   *\n   * As a compromise, the mixin defines a `generic` attribute. This attribute is\n   * normally set by default, and styles can be written that apply only when the\n   * generic attribute is set. This allows the construction of CSS rules that\n   * will only apply to generic components like:\n   *\n   *     :host([generic=\"\"]) {\n   *       ... generic appearance defined here ...\n   *     }\n   *\n   * This makes it easy to remove all default styling — set the `GenericMixin`\n   * attribute to false, and all default styling will be removed.\n   */\n  class Generic extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.generic === 'undefined') {\n        this.generic = this[symbols.defaults].generic;\n      }\n    }\n\n    // This mixin doesn't actually respond to attribute changes, but relies\n    // on separately-defined behavior (e.g., in AttributeMarshallingMixin) for that.\n    // Still, we need define a baseline attributeChangedCallback that does\n    // nothing, in case this mixin gets used on its own.\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(name, oldValue, newValue); }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      safeAttributes.connected(this);\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.generic = true;\n      return defaults;\n    }\n\n    /**\n     * True if the component would like to receive generic styling.\n     *\n     * This property is true by default — set it to false to turn off all\n     * generic styles. This makes it easier to apply custom styling; you won't\n     * have to explicitly override styling you don't want.\n     *\n     * @type Boolean\n     * @default true\n     */\n    get generic() {\n      return this[genericSymbol];\n    }\n    set generic(value) {\n      const parsed = typeof value === 'string' ?\n        String(value) !== 'false' :\n        value;\n      this[genericSymbol] = parsed;\n\n      if ('generic' in base.prototype) { super.generic = value; }\n\n      // We roll our own attribute setting so that an explicitly false value\n      // shows up as GenericMixin=\"false\".\n      if (parsed === false) {\n        // Explicitly use false string.\n        safeAttributes.setAttribute(this, 'generic', 'false');\n      } else if (parsed == null) {\n        // Explicitly remove attribute. (Always safe to do this.)\n        this.removeAttribute('generic');\n      } else {\n        // Use the empty string to get attribute to appear with no value.\n        safeAttributes.setAttribute(this, 'generic', '');\n      }\n    }\n\n  }\n\n  return Generic;\n};\n\n\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst navigationAxisSymbol = createSymbol('navigationAxis');\n\n\n/* Exported function extends a base class with KeyboardDirection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps direction keys (Left, Right, etc.) to direction semantics\n   * (go left, go right, etc.).\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   *\n   * This mixin calls methods such as `goLeft` and `goRight`. You can define\n   * what that means by implementing those methods yourself. If you want to use\n   * direction keys to navigate a selection, use this mixin with\n   * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n   */\n  class KeyboardDirection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.navigationAxis === 'undefined') {\n        this.navigationAxis = this[symbols.defaults].navigationAxis;\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.navigationAxis = 'both';\n      return defaults;\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate down.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { return super[symbols.goDown](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the end (e.g., of a list).\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { return super[symbols.goEnd](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the start (e.g., of a\n     * list). The default implementation of this method does nothing.\n     */\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { return super[symbols.goStart](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate up.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { return super[symbols.goUp](); }\n    }\n\n    /**\n     * Indicates the direction of permitted navigation with the keyboard.\n     *\n     * Accepted values are \"horizontal\", \"vertical\", or \"both\" (the default).\n     * If this property is \"horizontal\", the Up Arrow and Down Arrow keys will\n     * be ignored. Conversely, if this is \"vertical\", the Left Arrow and Right\n     * Arrow keys will be ignored.\n     *\n     * @type {string}\n     */\n    get navigationAxis() {\n      return this[navigationAxisSymbol];\n    }\n    set navigationAxis(value) {\n      this[navigationAxisSymbol] = value;\n      if ('navigationAxis' in base.prototype) { super.navigationAxis = value; }\n    }\n\n    [symbols.keydown](event) {\n      let handled;\n\n      const axis = this.navigationAxis;\n      const horizontal = (axis === 'horizontal' || axis === 'both');\n      const vertical = (axis === 'vertical' || axis === 'both');\n\n      // Ignore Left/Right keys when metaKey or altKey modifier is also pressed,\n      // as the user may be trying to navigate back or forward in the browser.\n      switch (event.keyCode) {\n        case 35: // End\n          handled = this[symbols.goEnd]();\n          break;\n        case 36: // Home\n          handled = this[symbols.goStart]();\n          break;\n        case 37: // Left\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goLeft]();\n          }\n          break;\n        case 38: // Up\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goStart]() : this[symbols.goUp]();\n          }\n          break;\n        case 39: // Right\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goRight]();\n          }\n          break;\n        case 40: // Down\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goEnd]() : this[symbols.goDown]();\n          }\n          break;\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n  }\n\n  return KeyboardDirection;\n};\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with Keyboard. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages the keydown handling for a component.\n   *\n   * This mixin handles several keyboard-related features.\n   *\n   * First, it wires up a single keydown event handler that can be shared by\n   * multiple mixins on a component. The event handler will invoke a `keydown`\n   * method with the event object, and any mixin along the prototype chain that\n   * wants to handle that method can do so.\n   *\n   * If a mixin wants to indicate that keyboard event has been handled, and that\n   * other mixins should *not* handle it, the mixin's `keydown` handler should\n   * return a value of true. The convention that seems to work well is that a\n   * mixin should see if it wants to handle the event and, if not, then ask the\n   * superclass to see if it wants to handle the event. This has the effect of\n   * giving the mixin that was applied last the first chance at handling a\n   * keyboard event.\n   *\n   * Example:\n   *\n   *     [symbols.keydown](event) {\n   *       let handled;\n   *       switch (event.keyCode) {\n   *         // Handle the keys you want, setting handled = true if appropriate.\n   *       }\n   *       // Prefer mixin result if it's defined, otherwise use base result.\n   *       return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n   *     }\n   *\n   * A second feature provided by this mixin is that it implicitly makes the\n   * component a tab stop if it isn't already, by setting `tabIndex` to 0. This\n   * has the effect of adding the component to the tab order in document order.\n   */\n  class Keyboard extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('keydown', event => {\n        this[symbols.handlingUserInteraction] = true;\n        const handled = this[symbols.keydown](event);\n        if (handled) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n        this[symbols.handlingUserInteraction] = false;\n      });\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (this.getAttribute('tabindex') == null && this[symbols.defaults].tabindex !== null) {\n        this.setAttribute('tabindex', this[symbols.defaults].tabindex);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      // The default tab index is 0 (document order).\n      defaults.tabindex = 0;\n      return defaults;\n    }\n\n    /**\n     * Handle the indicated keyboard event.\n     *\n     * The default implementation of this method does nothing. This will\n     * typically be handled by other mixins.\n     *\n     * @param {KeyboardEvent} event - the keyboard event\n     * @return {boolean} true if the event was handled\n     */\n    [symbols.keydown](event) {\n      if (super[symbols.keydown]) { return super[symbols.keydown](event); }\n    }\n\n  }\n\n  return Keyboard;\n};\n","import symbols from './symbols';\n\n\n/* Exported function extends a base class with KeyboardPagedSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which maps page keys (Page Up, Page Down) into operations that move\n   * the selection by one page.\n   *\n   * The keyboard interaction model generally follows that of Microsoft Windows'\n   * list boxes instead of those in OS X:\n   *\n   * * The Page Up/Down and Home/End keys actually change the selection, rather\n   *   than just scrolling. The former behavior seems more generally useful for\n   *   keyboard users.\n   *\n   * * Pressing Page Up/Down will change the selection to the topmost/bottommost\n   *   visible item if the selection is not already there. Thereafter, the key\n   *   will move the selection up/down by a page, and (per the above point) make\n   *   the selected item visible.\n   *\n   * To ensure the selected item is in view following use of Page Up/Down, use\n   * the related [SelectionInViewMixin](SelectionInViewMixin.md).\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   */\n  class KeyboardPagedSelection extends base {\n\n    [symbols.keydown](event) {\n      let handled;\n      switch (event.keyCode) {\n        case 33: // Page Up\n          handled = this.pageUp();\n          break;\n        case 34: // Page Down\n          handled = this.pageDown();\n          break;\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    /**\n     * Scroll down one page.\n     */\n    pageDown() {\n      if (super.pageDown) { super.pageDown(); }\n      return scrollOnePage(this, true);\n    }\n\n    /**\n     * Scroll up one page.\n     */\n    pageUp() {\n      if (super.pageUp) { super.pageUp(); }\n      return scrollOnePage(this, false);\n    }\n\n    /**\n     * The element that should be scrolled with the Page Up/Down keys.\n     * Default is the current element.\n     *\n     * @type {HTMLElement}\n     */\n    get scrollTarget() {\n      // Prefer base result.\n      return 'scrollTarget' in base.prototype ? super.scrollTarget : this;\n    }\n    set scrollTarget(element) {\n      if ('scrollTarget' in base.prototype) { super.scrollTarget = element; }\n    }\n  }\n\n  return KeyboardPagedSelection;\n};\n\n\n// Return the item whose content spans the given y position (relative to the\n// top of the list's scrolling client area), or null if not found.\n//\n// If downward is true, move down the list of items to find the first item\n// found at the given y position; if downward is false, move up the list of\n// items to find the last item at that position.\nfunction getIndexOfItemAtY(element, y, downward) {\n  const items = element.items;\n  const start = downward ? 0 : items.length - 1;\n  const end = downward ? items.length : 0;\n  const step = downward ? 1 : -1;\n  const scrollTarget = element.scrollTarget;\n  const topOfClientArea = scrollTarget.offsetTop + scrollTarget.clientTop;\n\n  // Find the item spanning the indicated y coordinate.\n  let item;\n  let itemIndex = start;\n  let itemTop;\n  let found = false;\n  while (itemIndex !== end) {\n    item = items[itemIndex];\n    itemTop = item.offsetTop - topOfClientArea;\n    const itemBottom = itemTop + item.offsetHeight;\n    if (itemTop <= y && itemBottom >= y) {\n      // Item spans the indicated y coordinate.\n      found = true;\n      break;\n    }\n    itemIndex += step;\n  }\n\n  if (!found) {\n    return null;\n  }\n\n  // We may have found an item whose padding spans the given y coordinate,\n  // but whose content is actually above/below that point.\n  // TODO: If the item has a border, then padding should be included in\n  // considering a hit.\n  const itemStyle = getComputedStyle(item);\n  const itemPaddingTop = parseFloat(itemStyle.paddingTop);\n  const itemPaddingBottom = parseFloat(itemStyle.paddingBottom);\n  const contentTop = itemTop + item.clientTop + itemPaddingTop;\n  const contentBottom = contentTop + item.clientHeight - itemPaddingTop - itemPaddingBottom;\n  if (downward && contentTop <= y || !downward && contentBottom >= y) {\n    // The indicated coordinate hits the actual item content.\n    return itemIndex;\n  }\n  else {\n    // The indicated coordinate falls within the item's padding. Back up to\n    // the item below/above the item we found and return that.\n    return itemIndex - step;\n  }\n}\n\n// Move by one page downward (if downward is true), or upward (if false).\n// Return true if we ended up changing the selection, false if not.\n// TODO: Better support for horizontal lists.\nfunction scrollOnePage(element, downward) {\n\n  // Determine the item visible just at the edge of direction we're heading.\n  // We'll select that item if it's not already selected.\n  const scrollTarget = element.scrollTarget;\n  const edge = scrollTarget.scrollTop + (downward ? scrollTarget.clientHeight : 0);\n  const indexOfItemAtEdge = getIndexOfItemAtY(element, edge, downward);\n\n  const selectedIndex = element.selectedIndex;\n  let newIndex;\n  if (indexOfItemAtEdge && selectedIndex === indexOfItemAtEdge) {\n    // The item at the edge was already selected, so scroll in the indicated\n    // direction by one page. Leave the new item at that edge selected.\n    const delta = (downward ? 1 : -1) * scrollTarget.clientHeight;\n    newIndex = getIndexOfItemAtY(element, edge + delta, downward);\n  }\n  else {\n    // The item at the edge wasn't selected yet. Instead of scrolling, we'll\n    // just select that item. That is, the first attempt to page up/down\n    // usually just moves the selection to the edge in that direction.\n    newIndex = indexOfItemAtEdge;\n  }\n\n  if (!newIndex) {\n    // We can't find an item in the direction we want to travel. Select the\n    // last item (if moving downward) or first item (if moving upward).\n    newIndex = (downward ? element.items.length - 1 : 0);\n  }\n\n  if (newIndex !== selectedIndex) {\n    element.selectedIndex = newIndex;\n    return true; // We handled the page up/down ourselves.\n  }\n  else {\n    return false; // We didn't do anything.\n  }\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemTextContentsSymbol = createSymbol('itemTextContents');\nconst typedPrefixSymbol = createSymbol('typedPrefix');\nconst prefixTimeoutSymbol = createSymbol('prefixTimeout');\n\n\n/* Exported function extends a base class with KeyboardPrefixSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin that handles list box-style prefix typing, in which the user can type\n   * a string to select the first item that begins with that string.\n   *\n   * Example: suppose a component using this mixin has the following items:\n   *\n   *     <sample-list-component>\n   *       <div>Apple</div>\n   *       <div>Apricot</div>\n   *       <div>Banana</div>\n   *       <div>Blackberry</div>\n   *       <div>Blueberry</div>\n   *       <div>Cantaloupe</div>\n   *       <div>Cherry</div>\n   *       <div>Lemon</div>\n   *       <div>Lime</div>\n   *     </sample-list-component>\n   *\n   * If this component receives the focus, and the user presses the \"b\" or \"B\"\n   * key, the \"Banana\" item will be selected, because it's the first item that\n   * matches the prefix \"b\". (Matching is case-insensitive.) If the user now\n   * presses the \"l\" or \"L\" key quickly, the prefix to match becomes \"bl\", so\n   * \"Blackberry\" will be selected.\n   *\n   * The prefix typing feature has a one second timeout — the prefix to match\n   * will be reset after a second has passed since the user last typed a key.\n   * If, in the above example, the user waits a second between typing \"b\" and\n   * \"l\", the prefix will become \"l\", so \"Lemon\" would be selected.\n   *\n   * This mixin expects the component to invoke a `keydown` method when a key is\n   * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n   * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n   *\n   * This mixin also expects the component to provide an `items` property. The\n   * `textContent` of those items will be used for purposes of prefix matching.\n   */\n  class KeyboardPrefixSelection extends base {\n\n    // TODO: If the set of items is changed, reset the prefix.\n    // [symbols.itemsChanged]() {\n    //   this[itemTextContentsSymbol] = null;\n    //   resetTypedPrefix(this);\n    // }\n\n    // TODO: If the selection is changed by some other means (e.g., arrow keys)\n    // other than prefix typing, then that act should reset the prefix.\n\n    [symbols.keydown](event) {\n      let handled;\n      let resetPrefix = true;\n\n      switch (event.keyCode) {\n        case 8: // Backspace\n          handleBackspace(this);\n          handled = true;\n          resetPrefix = false;\n          break;\n        case 27: // Escape\n          handled = true;\n          break;\n        default:\n          if (!event.ctrlKey && !event.metaKey && !event.altKey &&\n              event.which !== 32 /* Space */) {\n            handlePlainCharacter(this, String.fromCharCode(event.which));\n          }\n          resetPrefix = false;\n      }\n\n      if (resetPrefix) {\n        resetTypedPrefix(this);\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    /**\n     * Select the first item whose text content begins with the given prefix.\n     *\n     * @param prefix [String] The prefix string to search for\n     */\n    selectItemWithTextPrefix(prefix) {\n      if (super.selectItemWithTextPrefix) { super.selectItemWithTextPrefix(prefix); }\n      if (prefix == null || prefix.length === 0) {\n        return;\n      }\n      const index = getIndexOfItemWithTextPrefix(this, prefix);\n      if (index >= 0) {\n        this.selectedIndex = index;\n      }\n    }\n\n  }\n\n  return KeyboardPrefixSelection;\n};\n\n\n// Time in milliseconds after which the user is considered to have stopped\n// typing.\nconst PREFIX_TIMEOUT_DURATION = 1000;\n\n\n// Return the index of the first item with the given prefix, else -1.\nfunction getIndexOfItemWithTextPrefix(element, prefix) {\n  const itemTextContents = getItemTextContents(element);\n  const prefixLength = prefix.length;\n  for (let i = 0; i < itemTextContents.length; i++) {\n    const itemTextContent = itemTextContents[i];\n    if (itemTextContent.substr(0, prefixLength) === prefix) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n// Return an array of the text content (in lowercase) of all items.\n// Cache these results.\nfunction getItemTextContents(element) {\n  if (!element[itemTextContentsSymbol]) {\n    const items = element.items;\n    element[itemTextContentsSymbol] = items.map(child => {\n      const text = child.textContent || child.alt;\n      return text.toLowerCase();\n    });\n  }\n  return element[itemTextContentsSymbol];\n}\n\nfunction handleBackspace(element) {\n  const length = element[typedPrefixSymbol] ? element[typedPrefixSymbol].length : 0;\n  if (length > 0) {\n    element[typedPrefixSymbol] = element[typedPrefixSymbol].substr(0, length - 1);\n  }\n  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n  setPrefixTimeout(element);\n}\n\nfunction handlePlainCharacter(element, char) {\n  const prefix = element[typedPrefixSymbol] || '';\n  element[typedPrefixSymbol] = prefix + char.toLowerCase();\n  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n  setPrefixTimeout(element);\n}\n\nfunction resetPrefixTimeout(element) {\n  if (element[prefixTimeoutSymbol]) {\n    clearTimeout(element[prefixTimeoutSymbol]);\n    element[prefixTimeoutSymbol] = false;\n  }\n}\n\nfunction resetTypedPrefix(element) {\n  element[typedPrefixSymbol] = '';\n  resetPrefixTimeout(element);\n}\n\nfunction setPrefixTimeout(element) {\n  resetPrefixTimeout(element);\n  element[prefixTimeoutSymbol] = setTimeout(() => {\n    resetTypedPrefix(element);\n  }, PREFIX_TIMEOUT_DURATION);\n}\n","import symbols from '../../basic-component-mixins/src/symbols';\n\n\n/* Exported function extends a base class with SelectedItemTextValue. */\nexport default (base) => {\n\n  /**\n   * Mixin which defines a `value` property that reflects the text content of a\n   * selected item.\n   *\n   * This mixin exists for list-like components that want to provide a more\n   * convenient way to get/set the selected item using text.\n   *\n   * This mixin expects a component to provide an `items` array of all elements\n   * in the list. A standard way to do that with is\n   * [ContentItemsMixin](ContentItemsMixin.md). This also expects the definition\n   * of `selectedIndex` and `selectedItem` properties, which can be obtained\n   * from [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class SelectedItemTextValue extends base {\n\n    /**\n     * The text content of the selected item.\n     *\n     * Setting this value to a string will attempt to select the first list item\n     * whose text content match that string. Setting this to a string not matching\n     * any list item will result in no selection.\n     *\n     * @type {string}\n     */\n    get value() {\n      return this.selectedItem == null || this.selectedItem.textContent == null ?\n        '' :\n        this.selectedItem.textContent;\n    }\n    set value(text) {\n\n      const currentIndex = this.selectedIndex;\n      let newIndex = -1; // Assume we won't find the text.\n\n      // Find the item with the indicated text.\n      const items = this.items;\n      for (let i = 0, length = items.length; i < length; i++) {\n        if (items[i].textContent === text) {\n          newIndex = i;\n          break;\n        }\n      }\n\n      if (newIndex !== currentIndex) {\n        this.selectedIndex = newIndex;\n        if (this[symbols.handlingUserInteraction]) {\n          const event = new CustomEvent('value-changed');\n          this.dispatchEvent(event);\n        }\n      }\n    }\n  }\n\n  return SelectedItemTextValue;\n};\n","import symbols from './symbols';\n\n\n// Used to assign unique IDs to item elements without IDs.\nlet idCount = 0;\n\n\n/* Exported function extends a base class with SelectionAriaActive. */\nexport default (base) => {\n\n  /**\n   * Mixin which treats the selected item in a list as the active item in ARIA\n   * accessibility terms.\n   *\n   * Handling ARIA selection state properly is actually quite complex:\n   *\n   * * The items in the list need to be indicated as possible items via an ARIA\n   *   `role` attribute value such as \"option\".\n   * * The selected item need to be marked as selected by setting the item's\n   *   `aria-selected` attribute to true *and* the other items need be marked as\n   *   *not* selected by setting `aria-selected` to false.\n   * * The outermost element with the keyboard focus needs to have attributes\n   *   set on it so that the selection is knowable at the list level via the\n   *   `aria-activedescendant` attribute.\n   * * Use of `aria-activedescendant` in turn requires that all items in the\n   *   list have ID attributes assigned to them.\n   *\n   * This mixin tries to address all of the above requirements. To that end,\n   * this mixin will assign generated IDs to any item that doesn't already have\n   * an ID.\n   *\n   * ARIA relies on elements to provide `role` attributes. This mixin will apply\n   * a default role of \"listbox\" on the outer list if it doesn't already have an\n   * explicit role. Similarly, this mixin will apply a default role of \"option\"\n   * to any list item that does not already have a role specified.\n   *\n   * This mixin expects a set of members that manage the state of the selection:\n   * `[symbols.itemSelected]`, `itemAdded`, and `selectedIndex`. You can\n   * supply these yourself, or do so via\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class SelectionAriaActive extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      // Set default ARIA role.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'listbox';\n      return defaults;\n    }\n\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n\n      if (!item.getAttribute('role')) {\n        // Assign a default ARIA role.\n        item.setAttribute('role', 'option');\n      }\n\n      // Ensure each item has an ID so we can set aria-activedescendant on the\n      // overall list whenever the selection changes.\n      //\n      // The ID will take the form of a base ID plus a unique integer. The base\n      // ID will be incorporate the component's own ID. E.g., if a component has\n      // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n      // the compnent has no ID itself, its items will get IDs that look like\n      // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n      // them from manually-assigned IDs, and to minimize the potential for ID\n      // conflicts.\n      if (!item.id) {\n        const baseId = this.id ?\n            \"_\" + this.id + \"Option\" :\n            \"_option\";\n        item.id = baseId + idCount++;\n      }\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      item.setAttribute('aria-selected', selected);\n      const itemId = item.id;\n      if (itemId && selected) {\n        this.setAttribute('aria-activedescendant', itemId);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item == null) {\n        // Selection was removed.\n        this.removeAttribute('aria-activedescendant');\n      }\n    }\n\n  }\n\n  return SelectionAriaActive;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with SelectionHighlight. */\nexport default (base) => {\n\n  /**\n   * Template mixin which applies standard highlight colors to a selected item.\n   *\n   * This mixin highlights textual items (e.g., in a list) in a standard way by\n   * using the CSS `highlight` and `highlighttext` color values. These values\n   * respect operating system defaults and user preferences, and hence are good\n   * default values for highlight colors.\n   *\n   * This mixin expects a `selected` class to be applied to selected items. You\n   * can use [ContentItemsMixin](ContentItemsMixin.md) for that purpose.\n   */\n  class SelectionHighlight extends base {\n\n    get [symbols.template]() {\n      const baseTemplate = super[symbols.template] || '';\n      return `\n        <style>\n          :host([generic=\"\"]) ::slotted(.selected) {\n            background-color: highlight;\n            color: highlighttext;\n          }\n        </style>\n        ${baseTemplate}\n      `;\n    }\n\n  }\n\n  return SelectionHighlight;\n};\n","/* Exported function extends a base class with SelectionInView. */\nexport default (base) => {\n\n  /**\n   * Mixin which scrolls a container to ensure that a newly-selected item is\n   * visible to the user.\n   *\n   * When the selected item in a list-like component changes, it's easier for\n   * the to confirm that the selection has changed to an appropriate item if the\n   * user can actually see that item.\n   *\n   * This mixin expects a `selectedItem` property to be set when the selection\n   * changes. You can supply that yourself, or use\n   * [SingleSelectionMixin](SingleSelectionMixin.md).\n   */\n  class SelectionInView extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      const selectedItem = this.selectedItem;\n      if (selectedItem) {\n        this.scrollItemIntoView(selectedItem);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item) {\n        // Keep the selected item in view.\n        this.scrollItemIntoView(item);\n      }\n    }\n\n    /**\n     * Scroll the given element completely into view, minimizing the degree of\n     * scrolling performed.\n     *\n     * Blink has a `scrollIntoViewIfNeeded()` function that does something\n     * similar, but unfortunately it's non-standard, and in any event often ends\n     * up scrolling more than is absolutely necessary.\n     *\n     * @param {HTMLElement} item - the item to scroll into view.\n     */\n    scrollItemIntoView(item) {\n      if (super.scrollItemIntoView) { super.scrollItemIntoView(); }\n      // Get the relative position of the item with respect to the top of the\n      // list's scrollable canvas. An item at the top of the list will have a\n      // elementTop of 0.\n\n      const scrollTarget = this.scrollTarget;\n      const elementTop = item.offsetTop - scrollTarget.offsetTop - scrollTarget.clientTop;\n      const elementBottom = elementTop + item.offsetHeight;\n      // Determine the bottom of the scrollable canvas.\n      const scrollBottom = scrollTarget.scrollTop + scrollTarget.clientHeight;\n      if (elementBottom > scrollBottom) {\n        // Scroll up until item is entirely visible.\n        scrollTarget.scrollTop += elementBottom - scrollBottom;\n      }\n      else if (elementTop < scrollTarget.scrollTop) {\n        // Scroll down until item is entirely visible.\n        scrollTarget.scrollTop = elementTop;\n      }\n    }\n\n    /**\n     * The element that should be scrolled to bring an item into view.\n     *\n     * The default value of this property is the element itself.\n     *\n     * @type {HTMLElement}\n     */\n    get scrollTarget() {\n      // Prefer base result.\n      return 'scrollTarget' in base.prototype ? super.scrollTarget : this;\n    }\n    set scrollTarget(element) {\n      if ('scrollTarget' in base.prototype) { super.scrollTarget = element; }\n    }\n\n  }\n\n  return SelectionInView;\n};\n","/* Exported function extends a base class with ShadowElementReferences. */\nexport default (base) => {\n\n  /**\n   * Mixin to create references to elements in a component's Shadow DOM subtree.\n   *\n   * This adds a member on the component called `this.$` that can be used to\n   * reference shadow elements with IDs. E.g., if component's shadow contains an\n   * element `<button id=\"foo\">`, then this mixin will create a member\n   * `this.$.foo` that points to that button.\n   *\n   * Such references simplify a component's access to its own elements. In\n   * exchange, this mixin trades off a one-time cost of querying all elements in\n   * the shadow tree instead of paying an ongoing cost to query for an element\n   * each time the component wants to inspect or manipulate it.\n   *\n   * This mixin expects the component to define a Shadow DOM subtree. You can\n   * create that tree yourself, or make use of\n   * [ShadowTemplateMixin](ShadowTemplateMixin.md).\n   *\n   * This mixin is inspired by Polymer's [automatic\n   * node finding](https://www.polymer-project.org/1.0/docs/devguide/local-dom.html#node-finding)\n   * feature.\n   */\n  class ShadowElementReferences extends base {\n\n    constructor() {\n      super();\n      if (this.shadowRoot) {\n        // Look for elements in the shadow subtree that have id attributes.\n        // An alternatively implementation of this mixin would be to just define\n        // a this.$ getter that lazily does this search the first time someone\n        // tries to access this.$. That might introduce some complexity – if the\n        // the tree changed after it was first populated, the result of\n        // searching for a node might be somewhat unpredictable.\n        this.$ = {};\n        const nodesWithIds = this.shadowRoot.querySelectorAll('[id]');\n        [].forEach.call(nodesWithIds, node => {\n          const id = node.getAttribute('id');\n          this.$[id] = node;\n        });\n      }\n    }\n\n    /**\n     * The collection of references to the elements with IDs in a component's\n     * Shadow DOM subtree.\n     *\n     * @type {object}\n     * @member $\n     */\n  }\n\n  return ShadowElementReferences;\n};\n","import symbols from '../src/symbols';\n\n\n/* Exported function extends a base class with ShadowTemplate. */\nexport default (base) => {\n\n  /**\n   * Mixin for stamping a template into a Shadow DOM subtree upon component\n   * instantiation.\n   *\n   * To use this mixin, define a `template` property as a string or HTML\n   * `<template>` element:\n   *\n   *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n   *       get [symbols.template]() {\n   *         return `Hello, <em>world</em>.`;\n   *       }\n   *     }\n   *\n   * When your component class is instantiated, a shadow root will be created on\n   * the instance, and the contents of the template will be cloned into the\n   * shadow root. If your component does not define a `template` property, this\n   * mixin has no effect.\n   *\n   * For the time being, this extension retains support for Shadow DOM v0. That\n   * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n   * implement Shadow DOM v1.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n      let template = this[symbols.template];\n      // TODO: Save the processed template with the component's class prototype\n      // so it doesn't need to be processed with every instantiation.\n      if (template) {\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          template = createTemplateWithInnerHTML(template);\n        }\n\n        if (window.ShadowDOMPolyfill) {\n          shimTemplateStyles(template, this.localName);\n        }\n\n        const root = this.attachShadow({ mode: 'open' });\n        const clone = document.importNode(template.content, true);\n        root.appendChild(clone);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n};\n\n\n// Convert a plain string of HTML into a real template element.\nfunction createTemplateWithInnerHTML(innerHTML) {\n  const template = document.createElement('template');\n  // REVIEW: Is there an easier way to do this?\n  // We'd like to just set innerHTML on the template content, but since it's\n  // a DocumentFragment, that doesn't work.\n  const div = document.createElement('div');\n  div.innerHTML = innerHTML;\n  while (div.childNodes.length > 0) {\n    template.content.appendChild(div.childNodes[0]);\n  }\n  return template;\n}\n\n// Invoke basic style shimming with ShadowCSS.\nfunction shimTemplateStyles(template, tag) {\n  window.WebComponents.ShadowCSS.shimStyling(template.content, tag);\n}\n","import createSymbol from './createSymbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = createSymbol('canSelectNext');\nconst canSelectPreviousSymbol = createSymbol('canSelectPrevious');\nconst selectionRequiredSymbol = createSymbol('selectionRequired');\nconst selectionWrapsSymbol = createSymbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = createSymbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = createSymbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = createSymbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = createSymbol('internalSelectedItem');\n\n\n/* Exported function extends a base class with SingleSelection. */\nexport default (base) => {\n\n  /**\n   * Mixin which manages single-selection semantics for items in a list.\n   *\n   * This mixin expects a component to provide an `items` Array or NodeList of\n   * all elements in the list. A standard way to do that with is the\n   * [ContentItemsMixin](ContentItemsMixin.md), which takes a component's\n   * content (typically its distributed children) as the set of list items; see\n   * that mixin for details.\n   *\n   * This mixin tracks a single selected item in the list, and provides means to\n   * get and set that state by item position (`selectedIndex`) or item identity\n   * (`selectedItem`). The selection can be moved in the list via the methods\n   * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n   *\n   * This mixin does not produce any user-visible effects to represent\n   * selection. Other mixins, such as\n   * [SelectionAriaActiveMixin](SelectionAriaActiveMixin.md),\n   * [SelectionHighlightMixin](SelectionHighlightMixin.md) and\n   * [SelectionInViewMixin](SelectionInViewMixin.md), modify the selected item\n   * in common ways to let the user know a given item is selected or not\n   * selected.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const previousCanSelectNext = this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (canSelectNext !== previousCanSelectNext && this[symbols.handlingUserInteraction]) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const previousCanSelectPrevious = this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (canSelectPrevious !== previousCanSelectPrevious && this[symbols.handlingUserInteraction]) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedIndex = this[internalSelectedIndexSymbol];\n      let item;\n      if (index !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && index >= 0 && index < items.length)) {\n          index = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = index;\n        item = hasItems && index >= 0 ? items[index] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (index !== previousSelectedIndex) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = index;\n\n        if (this[symbols.handlingUserInteraction]) {\n          const event = new CustomEvent('selected-index-changed', {\n            detail: {\n              selectedIndex: index,\n              value: index // for Polymer binding. TODO: Verify still necessary\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (item !== previousSelectedItem) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        if (this[symbols.handlingUserInteraction]) {\n          const event = new CustomEvent('selected-item-changed', {\n            detail: {\n              selectedItem: item,\n              value: item // for Polymer binding\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      this[selectionRequiredSymbol] = selectionRequired;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      trackSelectedItem(this);\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(value) {\n      this[selectionWrapsSymbol] = String(value) === 'true';\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Select the last item in the list.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the selectedItem property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     * @param {HTMLElement} detail.previousItem The previously selected item.\n     */\n\n    /**\n     * Fires when the selectedIndex property changes.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n  }\n\n  return SingleSelection;\n};\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n  const count = element.items.length;\n\n  const boundedIndex = (element.selectionWraps) ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n","/*\n * Microtask helper for IE 11.\n *\n * Executing a function as a microtask is trivial in browsers that support\n * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n * promises, but does support MutationObservers, which are also executed as\n * microtasks. So this helper uses an MutationObserver to achieve microtask\n * timing.\n *\n * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * Inspired by Polymer's async() function.\n */\n\n\n// The queue of pending callbacks to be executed as microtasks.\nconst callbacks = [];\n\n// Create an element that we will modify to force observable mutations.\nconst element = document.createTextNode('');\n\n// A monotonically-increasing value.\nlet counter = 0;\n\n\n/**\n * Add a callback to the microtask queue.\n *\n * This uses a MutationObserver so that it works on IE 11.\n *\n * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n * needs more investigation.\n *\n * @function microtask\n * @param {function} callback\n */\nexport default function microtask(callback) {\n  callbacks.push(callback);\n  // Force a mutation.\n  element.textContent = ++counter;\n}\n\n\n// Execute any pending callbacks.\nfunction executeCallbacks() {\n  while (callbacks.length > 0) {\n    const callback = callbacks.shift();\n    callback();\n  }\n}\n\n\n// Create the observer.\nconst observer = new MutationObserver(executeCallbacks);\nobserver.observe(element, {\n  characterData: true\n});\n","import createSymbol from './createSymbol';\nimport toggleClass from './toggleClass';\n\n\n// Symbols for private data members on an element.\nconst safeToSetAttributesSymbol = createSymbol('safeToSetAttributes');\nconst pendingAttributesSymbol = createSymbol('pendingAttributes');\nconst pendingClassesSymbol = createSymbol('pendingClasses');\n\n\n/**\n * Helper functions for updating attributes, including the `class` attribute.\n */\nexport default {\n\n  /**\n   * Perform any pending updates to attributes and classes.\n   *\n   * This writes any `setAttribute` or `toggleClass` values that were performed\n   * before an element was attached to the document for the first time.\n   *\n   * This method should be called by mixins/components in their\n   * `connectedCallback`. If mulitple mixins/components invoke this during the\n   * same `connectedCallback`, only the first call will have any effect. The\n   * subsequent calls will be harmless.\n   *\n   * @param {HTMLElement} element - The element being added to the document.\n   */\n  connected(element) {\n    element[safeToSetAttributesSymbol] = true;\n\n    // Set any pending attributes.\n    if (element[pendingAttributesSymbol]) {\n      for (let attribute in element[pendingAttributesSymbol]) {\n        const value = element[pendingAttributesSymbol][attribute];\n        setAttributeToElement(element, attribute, value);\n      }\n      element[pendingAttributesSymbol] = null;\n    }\n\n    // Set any pending classes.\n    if (element[pendingClassesSymbol]) {\n      for (let className in element[pendingClassesSymbol]) {\n        const value = element[pendingClassesSymbol][className];\n        toggleClass(element, className, value);\n      }\n      element[pendingClassesSymbol] = null;\n    }\n  },\n\n  /**\n   * Set/unset the attribute with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as an attribute. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes. A call to `setAttribute` during the constructor will\n   * be deferred until the element is connected to the document.\n   *\n   * @param {string} attribute - The name of the *attribute* (not property) to set.\n   * @param {object} value - The value to set. If null, the attribute will be removed.\n   */\n  setAttribute(element, attribute, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set attributes immediately.\n      setAttributeToElement(element, attribute, value);\n    } else {\n      // Defer setting attributes until the first time we're connected.\n      if (!element[pendingAttributesSymbol]) {\n        element[pendingAttributesSymbol] = {};\n      }\n      element[pendingAttributesSymbol][attribute] = value;\n    }\n  },\n\n  /**\n   * Set/unset the class with the indicated name.\n   *\n   * This method exists primarily to handle the case where an element wants to\n   * set a default property value that should be reflected as as class. An\n   * important limitation of custom element consturctors is that they cannot\n   * set attributes, including the `class` attribute. A call to\n   * `toggleClass` during the constructor will be deferred until the element\n   * is connected to the document.\n   *\n   * @param {string} className - The name of the class to set.\n   * @param {object} value - True to set the class, false to remove it.\n   */\n  toggleClass(element, className, value) {\n    if (element[safeToSetAttributesSymbol]) {\n      // Safe to set class immediately.\n      toggleClass(element, className, value);\n    } else {\n      // Defer setting class until the first time we're connected.\n      if (!element[pendingClassesSymbol]) {\n        element[pendingClassesSymbol] = {};\n      }\n      element[pendingClassesSymbol][className] = value;\n    }\n  }\n\n};\n\n\n// Reflect the attribute to the given element.\n// If the value is null, remove the attribute.\nfunction setAttributeToElement(element, attributeName, value) {\n  if (value === null || typeof value === 'undefined') {\n    element.removeAttribute(attributeName);\n  } else {\n    const text = String(value);\n    // Avoid recursive attributeChangedCallback calls.\n    if (element.getAttribute(attributeName) !== text) {\n      element.setAttribute(attributeName, value);\n    }\n  }\n}\n","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'basic-component-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'basic-component-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `dragging` property.\n   *\n   * Components like carousels often define animated CSS transitions for\n   * sliding effects. Such a transition should usually *not* be applied while\n   * the user is dragging, because a CSS animation will introduce a lag that\n   * makes the swipe feel sluggish. Instead, as long as the user is dragging\n   * with their finger down, the transition should be suppressed. When the\n   * user releases their finger, the transition can be restored, allowing the\n   * animation to show the carousel sliding into its final position.\n   *\n   * @type {boolean} true if a drag is in progress, false if not.\n   */\n  dragging: createSymbol('dragging'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: createSymbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: createSymbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: createSymbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: createSymbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: createSymbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: createSymbol('goUp'),\n\n  /**\n   * Symbol for the `handlingUserInteraction` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. This property can be used\n   * to manage events as follows.\n   *\n   * First, UI event listeners should set this property to `true` at the start\n   * of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.handlingUserInteraction] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.handlingUserInteraction] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.handlingUserInteraction]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   */\n  handlingUserInteraction: createSymbol('handlingUserInteraction'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: createSymbol('keydown'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLElement}\n   */\n  template: createSymbol('template')\n};\n\nexport default symbols;\n","/**\n * Helper function for standard classList.toggle() behavior on old browsers,\n * namely IE 11.\n *\n * The standard\n * [classlist](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList)\n * object has a `toggle()` function that supports a second Boolean parameter\n * that can be used to succinctly turn a class on or off. This feature is often\n * useful in designing custom elements, which may want to externally reflect\n * component state in a CSS class that can be used for styling purposes.\n *\n * Unfortunately, IE 11 does not support the Boolean parameter to\n * `classList.toggle()`. This helper function behaves like the standard\n * `toggle()`, including support for the Boolean parameter, so that it can be\n * used even on IE 11.\n *\n * @function toggleClass\n * @param {HTMLElement} element - The element to modify\n * @param {string} className - The class to add/remove\n * @param {boolean} [force] - Force the class to be added (if true) or removed\n *                            (if false)\n */\nexport default function toggleClass(element, className, force) {\n  const classList = element.classList;\n  const addClass = (typeof force === 'undefined') ?\n    !classList.contains(className) :\n    force;\n  if (addClass) {\n    classList.add(className);\n  } else {\n    classList.remove(className);\n  }\n  return addClass;\n}\n","import AttributeMarshallingMixin from '../../basic-component-mixins/src/AttributeMarshallingMixin';\nimport ComposableMixin from '../../basic-component-mixins/src/ComposableMixin';\nimport DistributedChildrenMixin from '../../basic-component-mixins/src/DistributedChildrenMixin';\nimport ShadowElementReferencesMixin from '../../basic-component-mixins/src/ShadowElementReferencesMixin';\nimport ShadowTemplateMixin from '../../basic-component-mixins/src/ShadowTemplateMixin';\n\n\n/**\n * A sample general-purpose base class for defining custom elements that mixes\n * in some common features: template stamping into a shadow root, shadow element\n * references, marshalling attributes to properties, and retrieving the children\n * distributed to a component.\n *\n * This base class is not special in any way, and is defined only as a\n * convenient shorthand for applying the mixins listed above. You can use this\n * class as a base class for your own elements, or easily create your own base\n * class by applying the same set of mixins.\n *\n * The ElementBase base class does not register itself as a custom element with\n * the browser, and hence cannot be independently instantiated.\n *\n * @mixes AttributeMarshallingMixin\n * @mixes ComposableMixin\n * @mixes DistributedChildrenMixin\n * @mixes ShadowElementReferencesMixin\n * @mixes ShadowTemplateMixin\n */\nclass ElementBase extends ComposableMixin(HTMLElement).compose(\n  ShadowTemplateMixin,          // before node finding, so shadow root is populated\n  ShadowElementReferencesMixin, // before marshalling, so properties can use refs\n  AttributeMarshallingMixin,\n  DistributedChildrenMixin\n) {}\n\nexport default ElementBase;\n","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport ListBox from './src/ListBox';\n\nwindow.Basic = window.Basic || {};\nwindow.Basic.ListBox = ListBox;\n","import ElementBase from '../../basic-element-base/src/ElementBase';\nimport DistributedChildrenContentMixin from '../../basic-component-mixins/src/DistributedChildrenContentMixin';\nimport ClickSelectionMixin from '../../basic-component-mixins/src/ClickSelectionMixin';\nimport ContentItemsMixin from '../../basic-component-mixins/src/ContentItemsMixin';\nimport DirectionSelectionMixin from '../../basic-component-mixins/src/DirectionSelectionMixin';\nimport GenericMixin from '../../basic-component-mixins/src/GenericMixin';\nimport KeyboardMixin from '../../basic-component-mixins/src/KeyboardMixin';\nimport KeyboardDirectionMixin from '../../basic-component-mixins/src/KeyboardDirectionMixin';\nimport KeyboardPagedSelectionMixin from '../../basic-component-mixins/src/KeyboardPagedSelectionMixin';\nimport KeyboardPrefixSelectionMixin from '../../basic-component-mixins/src/KeyboardPrefixSelectionMixin';\nimport SelectedItemTextValueMixin from '../../basic-component-mixins/src/SelectedItemTextValueMixin';\nimport SelectionAriaActiveMixin from '../../basic-component-mixins/src/SelectionAriaActiveMixin';\nimport SelectionHighlightMixin from '../../basic-component-mixins/src/SelectionHighlightMixin';\nimport SelectionInViewMixin from '../../basic-component-mixins/src/SelectionInViewMixin';\nimport SingleSelectionMixin from '../../basic-component-mixins/src/SingleSelectionMixin';\nimport symbols from '../../basic-component-mixins/src/symbols';\n\n\n/**\n * A single-selection list box that supports selection highlighting (using the\n * system highlight color) and keyboard navigation.\n *\n * [Live demo](http://basicwebcomponents.org/basic-web-components/packages/basic-list-box/)\n *\n * The user can select an item with the mouse/touch or keyboard: Up/Down, Page\n * Up/Down, Home/End.\n *\n * Like other Basic Web Components, this can handle distributed content: you can\n * include a content element inside a basic-list-box, and the list will navigate\n * through the distributed content.\n *\n * This component includes basic ARIA support to provide a reasonable default\n * experience, e.g., for screen readers. The list component itself will be\n * assigned an appropriate ARIA role (default is \"listbox\"). The ID of the\n * selected item will be reflected in an \"aria-activedescendant\" attribute\n * applied to the list. To support this feature, all items in the list need\n * unique IDs. If an item does not have an ID, basic-list-box will automatically\n * assign a default ID.\n *\n * The keyboard interaction model generally follows that of Microsoft Windows'\n * list boxes instead of those in OS X:\n *\n * * The Page Up/Down and Home/End keys actually move the selection, rather than\n *   just scrolling the list. The former behavior seems more generally useful\n *   for keyboard users.\n *\n * * Pressing Page Up/Down will move the selection to the topmost/bottommost\n *   visible item if the selection is not already there. Thereafter, the key\n *   will move the selection up/down by a page, and (per the above point) make\n *   the selected item visible.\n *\n * Programmatically selecting an item (by setting the selected property) scrolls\n * the item into view.\n *\n * The user can also select an item by typing the beginning of an item's text.\n *\n * @extends ElementBase\n * @mixes ClickSelectionMixin\n * @mixes ContentItemsMixin\n * @mixes DirectionSelectionMixin\n * @mixes DistributedChildrenContentMixin\n * @mixes GenericMixin\n * @mixes KeyboardMixin\n * @mixes KeyboardDirectionMixin\n * @mixes KeyboardPagedSelectionMixin\n * @mixes KeyboardPrefixSelectionMixin\n * @mixis SelectedItemTextValueMixin\n * @mixes SelectionAriaActiveMixin\n * @mixes SelectionHighlightMixin\n * @mixes SelectionInViewMixin\n * @mixes SingleSelectionMixin\n */\nclass ListBox extends ElementBase.compose(\n  ClickSelectionMixin,\n  ContentItemsMixin,\n  DirectionSelectionMixin,\n  DistributedChildrenContentMixin,\n  GenericMixin,\n  KeyboardMixin,\n  KeyboardDirectionMixin,\n  KeyboardPagedSelectionMixin,\n  KeyboardPrefixSelectionMixin,\n  SelectedItemTextValueMixin,\n  SelectionAriaActiveMixin,\n  SelectionHighlightMixin,\n  SelectionInViewMixin,\n  SingleSelectionMixin\n) {\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.navigationAxis = 'vertical';\n    return defaults;\n  }\n\n  get scrollTarget() {\n    return this.$.itemsContainer;\n  }\n\n  get [symbols.template]() {\n    const baseTemplate = super[symbols.template] || '';\n    return `\n      <style>\n      :host {\n        display: -webkit-flex;\n        display: flex;\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n      }\n\n      [target=\"child\"] {\n        display: -webkit-flex;\n        display: flex;\n        -webkit-flex: 1;\n        flex: 1;\n      }\n\n      #itemsContainer {\n        -webkit-flex: 1;\n        flex: 1;\n        -webkit-overflow-scrolling: touch;\n        overflow-y: scroll; /* for momentum scrolling */\n      }\n\n      /* GenericMixin appearance */\n      :host([generic=\"\"]) {\n        border: 1px solid gray;\n        box-sizing: border-box;\n        cursor: default;\n      }\n\n      :host([generic=\"\"]) #itemsContainer ::slotted(*) {\n        cursor: default;\n        padding: 0.25em;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n      </style>\n\n      <div id=\"itemsContainer\" role=\"none\">\n        <slot></slot>\n      </div>\n      ${baseTemplate}\n    `;\n  }\n\n  /**\n   * Fires when the list's value property changes.\n   *\n   * @memberof ListBox\n   * @event value-changed\n   */\n}\n\n\ncustomElements.define('basic-list-box', ListBox);\nexport default ListBox;\n"]}